<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - /usr/include/pulse/def.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">usr/include/pulse</a> - def.h<span style="font-size: 80%;"> (source / <a href="def.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-24</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef foodefhfoo</a>
<span class="lineNum">       2 </span>            : #define foodefhfoo
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /***
<span class="lineNum">       5 </span>            :   This file is part of PulseAudio.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :   Copyright 2004-2006 Lennart Poettering
<span class="lineNum">       8 </span>            :   Copyright 2006 Pierre Ossman &lt;ossman@cendio.se&gt; for Cendio AB
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            :   PulseAudio is free software; you can redistribute it and/or modify
<span class="lineNum">      11 </span>            :   it under the terms of the GNU Lesser General Public License as
<span class="lineNum">      12 </span>            :   published by the Free Software Foundation; either version 2.1 of the
<span class="lineNum">      13 </span>            :   License, or (at your option) any later version.
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            :   PulseAudio is distributed in the hope that it will be useful, but
<span class="lineNum">      16 </span>            :   WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      17 </span>            :   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
<span class="lineNum">      18 </span>            :   Lesser General Public License for more details.
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            :   You should have received a copy of the GNU Lesser General Public
<span class="lineNum">      21 </span>            :   License along with PulseAudio; if not, write to the Free Software
<span class="lineNum">      22 </span>            :   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
<span class="lineNum">      23 </span>            :   USA.
<span class="lineNum">      24 </span>            : ***/
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &lt;inttypes.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;pulse/cdecl.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;pulse/sample.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;pulse/version.h&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : /** \file
<span class="lineNum">      35 </span>            :  * Global definitions */
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : PA_C_DECL_BEGIN
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /** The state of a connection context */
<span class="lineNum">      40 </span>            : typedef enum pa_context_state {
<span class="lineNum">      41 </span>            :     PA_CONTEXT_UNCONNECTED,    /**&lt; The context hasn't been connected yet */
<span class="lineNum">      42 </span>            :     PA_CONTEXT_CONNECTING,     /**&lt; A connection is being established */
<span class="lineNum">      43 </span>            :     PA_CONTEXT_AUTHORIZING,    /**&lt; The client is authorizing itself to the daemon */
<span class="lineNum">      44 </span>            :     PA_CONTEXT_SETTING_NAME,   /**&lt; The client is passing its application name to the daemon */
<span class="lineNum">      45 </span>            :     PA_CONTEXT_READY,          /**&lt; The connection is established, the context is ready to execute operations */
<span class="lineNum">      46 </span>            :     PA_CONTEXT_FAILED,         /**&lt; The connection failed or was disconnected */
<span class="lineNum">      47 </span>            :     PA_CONTEXT_TERMINATED      /**&lt; The connection was terminated cleanly */
<span class="lineNum">      48 </span>            : } pa_context_state_t;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /** Return non-zero if the passed state is one of the connected states. \since 0.9.11 */
<span class="lineNum">      51 </span>            : static inline int PA_CONTEXT_IS_GOOD(pa_context_state_t x) {
<span class="lineNum">      52 </span>            :     return
<span class="lineNum">      53 </span>            :         x == PA_CONTEXT_CONNECTING ||
<span class="lineNum">      54 </span>            :         x == PA_CONTEXT_AUTHORIZING ||
<span class="lineNum">      55 </span><span class="lineCov">          1 :         x == PA_CONTEXT_SETTING_NAME ||</span>
<span class="lineNum">      56 </span>            :         x == PA_CONTEXT_READY;
<span class="lineNum">      57 </span>            : }
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /** \cond fulldocs */
<span class="lineNum">      60 </span>            : #define PA_CONTEXT_UNCONNECTED PA_CONTEXT_UNCONNECTED
<span class="lineNum">      61 </span>            : #define PA_CONTEXT_CONNECTING PA_CONTEXT_CONNECTING
<span class="lineNum">      62 </span>            : #define PA_CONTEXT_AUTHORIZING PA_CONTEXT_AUTHORIZING
<span class="lineNum">      63 </span>            : #define PA_CONTEXT_SETTING_NAME PA_CONTEXT_SETTING_NAME
<span class="lineNum">      64 </span>            : #define PA_CONTEXT_READY PA_CONTEXT_READY
<span class="lineNum">      65 </span>            : #define PA_CONTEXT_FAILED PA_CONTEXT_FAILED
<span class="lineNum">      66 </span>            : #define PA_CONTEXT_IS_GOOD PA_CONTEXT_IS_GOOD
<span class="lineNum">      67 </span>            : /** \endcond */
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : /** The state of a stream */
<span class="lineNum">      70 </span>            : typedef enum pa_stream_state {
<span class="lineNum">      71 </span>            :     PA_STREAM_UNCONNECTED,  /**&lt; The stream is not yet connected to any sink or source */
<span class="lineNum">      72 </span>            :     PA_STREAM_CREATING,     /**&lt; The stream is being created */
<span class="lineNum">      73 </span>            :     PA_STREAM_READY,        /**&lt; The stream is established, you may pass audio data to it now */
<span class="lineNum">      74 </span>            :     PA_STREAM_FAILED,       /**&lt; An error occurred that made the stream invalid */
<span class="lineNum">      75 </span>            :     PA_STREAM_TERMINATED    /**&lt; The stream has been terminated cleanly */
<span class="lineNum">      76 </span>            : } pa_stream_state_t;
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /** Return non-zero if the passed state is one of the connected states. \since 0.9.11 */
<span class="lineNum">      79 </span>            : static inline int PA_STREAM_IS_GOOD(pa_stream_state_t x) {
<span class="lineNum">      80 </span>            :     return
<span class="lineNum">      81 </span><span class="lineCov">          1 :         x == PA_STREAM_CREATING ||</span>
<span class="lineNum">      82 </span>            :         x == PA_STREAM_READY;
<span class="lineNum">      83 </span>            : }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : /** \cond fulldocs */
<span class="lineNum">      86 </span>            : #define PA_STREAM_UNCONNECTED PA_STREAM_UNCONNECTED
<span class="lineNum">      87 </span>            : #define PA_STREAM_CREATING PA_STREAM_CREATING
<span class="lineNum">      88 </span>            : #define PA_STREAM_READY PA_STREAM_READY
<span class="lineNum">      89 </span>            : #define PA_STREAM_FAILED PA_STREAM_FAILED
<span class="lineNum">      90 </span>            : #define PA_STREAM_TERMINATED PA_STREAM_TERMINATED
<span class="lineNum">      91 </span>            : #define PA_STREAM_IS_GOOD PA_STREAM_IS_GOOD
<span class="lineNum">      92 </span>            : /** \endcond */
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : /** The state of an operation */
<span class="lineNum">      95 </span>            : typedef enum pa_operation_state {
<span class="lineNum">      96 </span>            :     PA_OPERATION_RUNNING,      /**&lt; The operation is still running */
<span class="lineNum">      97 </span>            :     PA_OPERATION_DONE,         /**&lt; The operation has been completed */
<span class="lineNum">      98 </span>            :     PA_OPERATION_CANCELLED     /**&lt; The operation has been cancelled. Before 0.9.18 this was called PA_OPERATION_CANCELED. That name is still available for compatibility. */
<span class="lineNum">      99 </span>            : } pa_operation_state_t;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /** \cond fulldocs */
<span class="lineNum">     102 </span>            : #define PA_OPERATION_RUNNING PA_OPERATION_RUNNING
<span class="lineNum">     103 </span>            : #define PA_OPERATION_DONE PA_OPERATION_DONE
<span class="lineNum">     104 </span>            : #define PA_OPERATION_CANCELED PA_OPERATION_CANCELLED
<span class="lineNum">     105 </span>            : #define PA_OPERATION_CANCELLED PA_OPERATION_CANCELLED
<span class="lineNum">     106 </span>            : /** \endcond */
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : /** An invalid index */
<span class="lineNum">     109 </span>            : #define PA_INVALID_INDEX ((uint32_t) -1)
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : /** Some special flags for contexts. */
<span class="lineNum">     112 </span>            : typedef enum pa_context_flags {
<span class="lineNum">     113 </span>            :     PA_CONTEXT_NOFLAGS = 0x0000U,
<span class="lineNum">     114 </span>            :     /**&lt; Flag to pass when no specific options are needed (used to avoid casting)  \since 0.9.19 */
<span class="lineNum">     115 </span>            :     PA_CONTEXT_NOAUTOSPAWN = 0x0001U,
<span class="lineNum">     116 </span>            :     /**&lt; Disabled autospawning of the PulseAudio daemon if required */
<span class="lineNum">     117 </span>            :     PA_CONTEXT_NOFAIL = 0x0002U
<span class="lineNum">     118 </span>            :     /**&lt; Don't fail if the daemon is not available when pa_context_connect() is called, instead enter PA_CONTEXT_CONNECTING state and wait for the daemon to appear.  \since 0.9.15 */
<span class="lineNum">     119 </span>            : } pa_context_flags_t;
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : /** \cond fulldocs */
<span class="lineNum">     122 </span>            : /* Allow clients to check with #ifdef for those flags */
<span class="lineNum">     123 </span>            : #define PA_CONTEXT_NOAUTOSPAWN PA_CONTEXT_NOAUTOSPAWN
<span class="lineNum">     124 </span>            : #define PA_CONTEXT_NOFAIL PA_CONTEXT_NOFAIL
<span class="lineNum">     125 </span>            : /** \endcond */
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : /** The direction of a pa_stream object */
<span class="lineNum">     128 </span>            : typedef enum pa_stream_direction {
<span class="lineNum">     129 </span>            :     PA_STREAM_NODIRECTION,   /**&lt; Invalid direction */
<span class="lineNum">     130 </span>            :     PA_STREAM_PLAYBACK,      /**&lt; Playback stream */
<span class="lineNum">     131 </span>            :     PA_STREAM_RECORD,        /**&lt; Record stream */
<span class="lineNum">     132 </span>            :     PA_STREAM_UPLOAD         /**&lt; Sample upload stream */
<span class="lineNum">     133 </span>            : } pa_stream_direction_t;
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /** \cond fulldocs */
<span class="lineNum">     136 </span>            : #define PA_STREAM_NODIRECTION PA_STREAM_NODIRECTION
<span class="lineNum">     137 </span>            : #define PA_STREAM_PLAYBACK PA_STREAM_PLAYBACK
<span class="lineNum">     138 </span>            : #define PA_STREAM_RECORD PA_STREAM_RECORD
<span class="lineNum">     139 </span>            : #define PA_STREAM_UPLOAD PA_STREAM_UPLOAD
<span class="lineNum">     140 </span>            : /** \endcond */
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : /** Some special flags for stream connections. */
<span class="lineNum">     143 </span>            : typedef enum pa_stream_flags {
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :     PA_STREAM_NOFLAGS = 0x0000U,
<span class="lineNum">     146 </span>            :     /**&lt; Flag to pass when no specific options are needed (used to avoid casting)  \since 0.9.19 */
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     PA_STREAM_START_CORKED = 0x0001U,
<span class="lineNum">     149 </span>            :     /**&lt; Create the stream corked, requiring an explicit
<span class="lineNum">     150 </span>            :      * pa_stream_cork() call to uncork it. */
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     PA_STREAM_INTERPOLATE_TIMING = 0x0002U,
<span class="lineNum">     153 </span>            :     /**&lt; Interpolate the latency for this stream. When enabled,
<span class="lineNum">     154 </span>            :      * pa_stream_get_latency() and pa_stream_get_time() will try to
<span class="lineNum">     155 </span>            :      * estimate the current record/playback time based on the local
<span class="lineNum">     156 </span>            :      * time that passed since the last timing info update.  Using this
<span class="lineNum">     157 </span>            :      * option has the advantage of not requiring a whole roundtrip
<span class="lineNum">     158 </span>            :      * when the current playback/recording time is needed. Consider
<span class="lineNum">     159 </span>            :      * using this option when requesting latency information
<span class="lineNum">     160 </span>            :      * frequently. This is especially useful on long latency network
<span class="lineNum">     161 </span>            :      * connections. It makes a lot of sense to combine this option
<span class="lineNum">     162 </span>            :      * with PA_STREAM_AUTO_TIMING_UPDATE. */
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     PA_STREAM_NOT_MONOTONIC = 0x0004U,
<span class="lineNum">     165 </span>            :     /**&lt; Don't force the time to increase monotonically. If this
<span class="lineNum">     166 </span>            :      * option is enabled, pa_stream_get_time() will not necessarily
<span class="lineNum">     167 </span>            :      * return always monotonically increasing time values on each
<span class="lineNum">     168 </span>            :      * call. This may confuse applications which cannot deal with time
<span class="lineNum">     169 </span>            :      * going 'backwards', but has the advantage that bad transport
<span class="lineNum">     170 </span>            :      * latency estimations that caused the time to to jump ahead can
<span class="lineNum">     171 </span>            :      * be corrected quickly, without the need to wait. (Please note
<span class="lineNum">     172 </span>            :      * that this flag was named PA_STREAM_NOT_MONOTONOUS in releases
<span class="lineNum">     173 </span>            :      * prior to 0.9.11. The old name is still defined too, for
<span class="lineNum">     174 </span>            :      * compatibility reasons. */
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :     PA_STREAM_AUTO_TIMING_UPDATE = 0x0008U,
<span class="lineNum">     177 </span>            :     /**&lt; If set timing update requests are issued periodically
<span class="lineNum">     178 </span>            :      * automatically. Combined with PA_STREAM_INTERPOLATE_TIMING you
<span class="lineNum">     179 </span>            :      * will be able to query the current time and latency with
<span class="lineNum">     180 </span>            :      * pa_stream_get_time() and pa_stream_get_latency() at all times
<span class="lineNum">     181 </span>            :      * without a packet round trip.*/
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :     PA_STREAM_NO_REMAP_CHANNELS = 0x0010U,
<span class="lineNum">     184 </span>            :     /**&lt; Don't remap channels by their name, instead map them simply
<span class="lineNum">     185 </span>            :      * by their index. Implies PA_STREAM_NO_REMIX_CHANNELS. Only
<span class="lineNum">     186 </span>            :      * supported when the server is at least PA 0.9.8. It is ignored
<span class="lineNum">     187 </span>            :      * on older servers.\since 0.9.8 */
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :     PA_STREAM_NO_REMIX_CHANNELS = 0x0020U,
<span class="lineNum">     190 </span>            :     /**&lt; When remapping channels by name, don't upmix or downmix them
<span class="lineNum">     191 </span>            :      * to related channels. Copy them into matching channels of the
<span class="lineNum">     192 </span>            :      * device 1:1. Only supported when the server is at least PA
<span class="lineNum">     193 </span>            :      * 0.9.8. It is ignored on older servers. \since 0.9.8 */
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :     PA_STREAM_FIX_FORMAT = 0x0040U,
<span class="lineNum">     196 </span>            :     /**&lt; Use the sample format of the sink/device this stream is being
<span class="lineNum">     197 </span>            :      * connected to, and possibly ignore the format the sample spec
<span class="lineNum">     198 </span>            :      * contains -- but you still have to pass a valid value in it as a
<span class="lineNum">     199 </span>            :      * hint to PulseAudio what would suit your stream best. If this is
<span class="lineNum">     200 </span>            :      * used you should query the used sample format after creating the
<span class="lineNum">     201 </span>            :      * stream by using pa_stream_get_sample_spec(). Also, if you
<span class="lineNum">     202 </span>            :      * specified manual buffer metrics it is recommended to update
<span class="lineNum">     203 </span>            :      * them with pa_stream_set_buffer_attr() to compensate for the
<span class="lineNum">     204 </span>            :      * changed frame sizes. Only supported when the server is at least
<span class="lineNum">     205 </span>            :      * PA 0.9.8. It is ignored on older servers. \since 0.9.8 */
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :     PA_STREAM_FIX_RATE = 0x0080U,
<span class="lineNum">     208 </span>            :     /**&lt; Use the sample rate of the sink, and possibly ignore the rate
<span class="lineNum">     209 </span>            :      * the sample spec contains. Usage similar to
<span class="lineNum">     210 </span>            :      * PA_STREAM_FIX_FORMAT.Only supported when the server is at least
<span class="lineNum">     211 </span>            :      * PA 0.9.8. It is ignored on older servers. \since 0.9.8 */
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :     PA_STREAM_FIX_CHANNELS = 0x0100,
<span class="lineNum">     214 </span>            :     /**&lt; Use the number of channels and the channel map of the sink,
<span class="lineNum">     215 </span>            :      * and possibly ignore the number of channels and the map the
<span class="lineNum">     216 </span>            :      * sample spec and the passed channel map contains. Usage similar
<span class="lineNum">     217 </span>            :      * to PA_STREAM_FIX_FORMAT. Only supported when the server is at
<span class="lineNum">     218 </span>            :      * least PA 0.9.8. It is ignored on older servers. \since 0.9.8 */
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     PA_STREAM_DONT_MOVE = 0x0200U,
<span class="lineNum">     221 </span>            :     /**&lt; Don't allow moving of this stream to another
<span class="lineNum">     222 </span>            :      * sink/device. Useful if you use any of the PA_STREAM_FIX_ flags
<span class="lineNum">     223 </span>            :      * and want to make sure that resampling never takes place --
<span class="lineNum">     224 </span>            :      * which might happen if the stream is moved to another
<span class="lineNum">     225 </span>            :      * sink/source with a different sample spec/channel map. Only
<span class="lineNum">     226 </span>            :      * supported when the server is at least PA 0.9.8. It is ignored
<span class="lineNum">     227 </span>            :      * on older servers. \since 0.9.8 */
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     PA_STREAM_VARIABLE_RATE = 0x0400U,
<span class="lineNum">     230 </span>            :     /**&lt; Allow dynamic changing of the sampling rate during playback
<span class="lineNum">     231 </span>            :      * with pa_stream_update_sample_rate(). Only supported when the
<span class="lineNum">     232 </span>            :      * server is at least PA 0.9.8. It is ignored on older
<span class="lineNum">     233 </span>            :      * servers. \since 0.9.8 */
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :     PA_STREAM_PEAK_DETECT = 0x0800U,
<span class="lineNum">     236 </span>            :     /**&lt; Find peaks instead of resampling. \since 0.9.11 */
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :     PA_STREAM_START_MUTED = 0x1000U,
<span class="lineNum">     239 </span>            :     /**&lt; Create in muted state. If neither PA_STREAM_START_UNMUTED nor
<span class="lineNum">     240 </span>            :      * PA_STREAM_START_MUTED it is left to the server to decide
<span class="lineNum">     241 </span>            :      * whether to create the stream in muted or in unmuted
<span class="lineNum">     242 </span>            :      * state. \since 0.9.11 */
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :     PA_STREAM_ADJUST_LATENCY = 0x2000U,
<span class="lineNum">     245 </span>            :     /**&lt; Try to adjust the latency of the sink/source based on the
<span class="lineNum">     246 </span>            :      * requested buffer metrics and adjust buffer metrics
<span class="lineNum">     247 </span>            :      * accordingly. Also see pa_buffer_attr. This option may not be
<span class="lineNum">     248 </span>            :      * specified at the same time as PA_STREAM_EARLY_REQUESTS. \since
<span class="lineNum">     249 </span>            :      * 0.9.11 */
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :     PA_STREAM_EARLY_REQUESTS = 0x4000U,
<span class="lineNum">     252 </span>            :     /**&lt; Enable compatibility mode for legacy clients that rely on a
<span class="lineNum">     253 </span>            :      * &quot;classic&quot; hardware device fragment-style playback model. If
<span class="lineNum">     254 </span>            :      * this option is set, the minreq value of the buffer metrics gets
<span class="lineNum">     255 </span>            :      * a new meaning: instead of just specifying that no requests
<span class="lineNum">     256 </span>            :      * asking for less new data than this value will be made to the
<span class="lineNum">     257 </span>            :      * client it will also guarantee that requests are generated as
<span class="lineNum">     258 </span>            :      * early as this limit is reached. This flag should only be set in
<span class="lineNum">     259 </span>            :      * very few situations where compatibility with a fragment-based
<span class="lineNum">     260 </span>            :      * playback model needs to be kept and the client applications
<span class="lineNum">     261 </span>            :      * cannot deal with data requests that are delayed to the latest
<span class="lineNum">     262 </span>            :      * moment possible. (Usually these are programs that use usleep()
<span class="lineNum">     263 </span>            :      * or a similar call in their playback loops instead of sleeping
<span class="lineNum">     264 </span>            :      * on the device itself.) Also see pa_buffer_attr. This option may
<span class="lineNum">     265 </span>            :      * not be specified at the same time as
<span class="lineNum">     266 </span>            :      * PA_STREAM_ADJUST_LATENCY. \since 0.9.12 */
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :     PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND = 0x8000U,
<span class="lineNum">     269 </span>            :     /**&lt; If set this stream won't be taken into account when we it is
<span class="lineNum">     270 </span>            :      * checked whether the device this stream is connected to should
<span class="lineNum">     271 </span>            :      * auto-suspend. \since 0.9.15 */
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :     PA_STREAM_START_UNMUTED = 0x10000U,
<span class="lineNum">     274 </span>            :     /**&lt; Create in unmuted state. If neither PA_STREAM_START_UNMUTED
<span class="lineNum">     275 </span>            :      * nor PA_STREAM_START_MUTED it is left to the server to decide
<span class="lineNum">     276 </span>            :      * whether to create the stream in muted or in unmuted
<span class="lineNum">     277 </span>            :      * state. \since 0.9.15 */
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :     PA_STREAM_FAIL_ON_SUSPEND = 0x20000U
<span class="lineNum">     280 </span>            :     /**&lt; If the sink/source this stream is connected to is suspended
<span class="lineNum">     281 </span>            :      * during the creation of this stream, cause it to fail. If the
<span class="lineNum">     282 </span>            :      * sink/source is being suspended during creation of this stream,
<span class="lineNum">     283 </span>            :      * make sure this stream is terminated. \since 0.9.15 */
<span class="lineNum">     284 </span>            : } pa_stream_flags_t;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : /** \cond fulldocs */
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : /* English is an evil language */
<span class="lineNum">     289 </span>            : #define PA_STREAM_NOT_MONOTONOUS PA_STREAM_NOT_MONOTONIC
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* Allow clients to check with #ifdef for those flags */
<span class="lineNum">     292 </span>            : #define PA_STREAM_START_CORKED PA_STREAM_START_CORKED
<span class="lineNum">     293 </span>            : #define PA_STREAM_INTERPOLATE_TIMING PA_STREAM_INTERPOLATE_TIMING
<span class="lineNum">     294 </span>            : #define PA_STREAM_NOT_MONOTONIC PA_STREAM_NOT_MONOTONIC
<span class="lineNum">     295 </span>            : #define PA_STREAM_AUTO_TIMING_UPDATE PA_STREAM_AUTO_TIMING_UPDATE
<span class="lineNum">     296 </span>            : #define PA_STREAM_NO_REMAP_CHANNELS PA_STREAM_NO_REMAP_CHANNELS
<span class="lineNum">     297 </span>            : #define PA_STREAM_NO_REMIX_CHANNELS PA_STREAM_NO_REMIX_CHANNELS
<span class="lineNum">     298 </span>            : #define PA_STREAM_FIX_FORMAT PA_STREAM_FIX_FORMAT
<span class="lineNum">     299 </span>            : #define PA_STREAM_FIX_RATE PA_STREAM_FIX_RATE
<span class="lineNum">     300 </span>            : #define PA_STREAM_FIX_CHANNELS PA_STREAM_FIX_CHANNELS
<span class="lineNum">     301 </span>            : #define PA_STREAM_DONT_MOVE PA_STREAM_DONT_MOVE
<span class="lineNum">     302 </span>            : #define PA_STREAM_VARIABLE_RATE PA_STREAM_VARIABLE_RATE
<span class="lineNum">     303 </span>            : #define PA_STREAM_PEAK_DETECT PA_STREAM_PEAK_DETECT
<span class="lineNum">     304 </span>            : #define PA_STREAM_START_MUTED PA_STREAM_START_MUTED
<span class="lineNum">     305 </span>            : #define PA_STREAM_ADJUST_LATENCY PA_STREAM_ADJUST_LATENCY
<span class="lineNum">     306 </span>            : #define PA_STREAM_EARLY_REQUESTS PA_STREAM_EARLY_REQUESTS
<span class="lineNum">     307 </span>            : #define PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND
<span class="lineNum">     308 </span>            : #define PA_STREAM_START_UNMUTED PA_STREAM_START_UNMUTED
<span class="lineNum">     309 </span>            : #define PA_STREAM_FAIL_ON_SUSPEND PA_STREAM_FAIL_ON_SUSPEND
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : /** \endcond */
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : /** Playback and record buffer metrics */
<span class="lineNum">     314 </span>            : typedef struct pa_buffer_attr {
<span class="lineNum">     315 </span>            :     uint32_t maxlength;
<span class="lineNum">     316 </span>            :     /**&lt; Maximum length of the buffer. Setting this to (uint32_t) -1
<span class="lineNum">     317 </span>            :      * will initialize this to the maximum value supported by server,
<span class="lineNum">     318 </span>            :      * which is recommended. */
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :     uint32_t tlength;
<span class="lineNum">     321 </span>            :     /**&lt; Playback only: target length of the buffer. The server tries
<span class="lineNum">     322 </span>            :      * to assure that at least tlength bytes are always available in
<span class="lineNum">     323 </span>            :      * the per-stream server-side playback buffer. It is recommended
<span class="lineNum">     324 </span>            :      * to set this to (uint32_t) -1, which will initialize this to a
<span class="lineNum">     325 </span>            :      * value that is deemed sensible by the server. However, this
<span class="lineNum">     326 </span>            :      * value will default to something like 2s, i.e. for applications
<span class="lineNum">     327 </span>            :      * that have specific latency requirements this value should be
<span class="lineNum">     328 </span>            :      * set to the maximum latency that the application can deal
<span class="lineNum">     329 </span>            :      * with. When PA_STREAM_ADJUST_LATENCY is not set this value will
<span class="lineNum">     330 </span>            :      * influence only the per-stream playback buffer size. When
<span class="lineNum">     331 </span>            :      * PA_STREAM_ADJUST_LATENCY is set the overall latency of the sink
<span class="lineNum">     332 </span>            :      * plus the playback buffer size is configured to this value. Set
<span class="lineNum">     333 </span>            :      * PA_STREAM_ADJUST_LATENCY if you are interested in adjusting the
<span class="lineNum">     334 </span>            :      * overall latency. Don't set it if you are interested in
<span class="lineNum">     335 </span>            :      * configuring the server-side per-stream playback buffer
<span class="lineNum">     336 </span>            :      * size. */
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     uint32_t prebuf;
<span class="lineNum">     339 </span>            :     /**&lt; Playback only: pre-buffering. The server does not start with
<span class="lineNum">     340 </span>            :      * playback before at least prebuf bytes are available in the
<span class="lineNum">     341 </span>            :      * buffer. It is recommended to set this to (uint32_t) -1, which
<span class="lineNum">     342 </span>            :      * will initialize this to the same value as tlength, whatever
<span class="lineNum">     343 </span>            :      * that may be. Initialize to 0 to enable manual start/stop
<span class="lineNum">     344 </span>            :      * control of the stream. This means that playback will not stop
<span class="lineNum">     345 </span>            :      * on underrun and playback will not start automatically. Instead
<span class="lineNum">     346 </span>            :      * pa_stream_corked() needs to be called explicitly. If you set
<span class="lineNum">     347 </span>            :      * this value to 0 you should also set PA_STREAM_START_CORKED. */
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     uint32_t minreq;
<span class="lineNum">     350 </span>            :     /**&lt; Playback only: minimum request. The server does not request
<span class="lineNum">     351 </span>            :      * less than minreq bytes from the client, instead waits until the
<span class="lineNum">     352 </span>            :      * buffer is free enough to request more bytes at once. It is
<span class="lineNum">     353 </span>            :      * recommended to set this to (uint32_t) -1, which will initialize
<span class="lineNum">     354 </span>            :      * this to a value that is deemed sensible by the server. This
<span class="lineNum">     355 </span>            :      * should be set to a value that gives PulseAudio enough time to
<span class="lineNum">     356 </span>            :      * move the data from the per-stream playback buffer into the
<span class="lineNum">     357 </span>            :      * hardware playback buffer. */
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :     uint32_t fragsize;
<span class="lineNum">     360 </span>            :     /**&lt; Recording only: fragment size. The server sends data in
<span class="lineNum">     361 </span>            :      * blocks of fragsize bytes size. Large values diminish
<span class="lineNum">     362 </span>            :      * interactivity with other operations on the connection context
<span class="lineNum">     363 </span>            :      * but decrease control overhead. It is recommended to set this to
<span class="lineNum">     364 </span>            :      * (uint32_t) -1, which will initialize this to a value that is
<span class="lineNum">     365 </span>            :      * deemed sensible by the server. However, this value will default
<span class="lineNum">     366 </span>            :      * to something like 2s, i.e. for applications that have specific
<span class="lineNum">     367 </span>            :      * latency requirements this value should be set to the maximum
<span class="lineNum">     368 </span>            :      * latency that the application can deal with. If
<span class="lineNum">     369 </span>            :      * PA_STREAM_ADJUST_LATENCY is set the overall source latency will
<span class="lineNum">     370 </span>            :      * be adjusted according to this value. If it is not set the
<span class="lineNum">     371 </span>            :      * source latency is left unmodified. */
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : } pa_buffer_attr;
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : /** Error values as used by pa_context_errno(). Use pa_strerror() to convert these values to human readable strings */
<span class="lineNum">     376 </span>            : enum {
<span class="lineNum">     377 </span>            :     PA_OK = 0,                     /**&lt; No error */
<span class="lineNum">     378 </span>            :     PA_ERR_ACCESS,                 /**&lt; Access failure */
<span class="lineNum">     379 </span>            :     PA_ERR_COMMAND,                /**&lt; Unknown command */
<span class="lineNum">     380 </span>            :     PA_ERR_INVALID,                /**&lt; Invalid argument */
<span class="lineNum">     381 </span>            :     PA_ERR_EXIST,                  /**&lt; Entity exists */
<span class="lineNum">     382 </span>            :     PA_ERR_NOENTITY,               /**&lt; No such entity */
<span class="lineNum">     383 </span>            :     PA_ERR_CONNECTIONREFUSED,      /**&lt; Connection refused */
<span class="lineNum">     384 </span>            :     PA_ERR_PROTOCOL,               /**&lt; Protocol error */
<span class="lineNum">     385 </span>            :     PA_ERR_TIMEOUT,                /**&lt; Timeout */
<span class="lineNum">     386 </span>            :     PA_ERR_AUTHKEY,                /**&lt; No authorization key */
<span class="lineNum">     387 </span>            :     PA_ERR_INTERNAL,               /**&lt; Internal error */
<span class="lineNum">     388 </span>            :     PA_ERR_CONNECTIONTERMINATED,   /**&lt; Connection terminated */
<span class="lineNum">     389 </span>            :     PA_ERR_KILLED,                 /**&lt; Entity killed */
<span class="lineNum">     390 </span>            :     PA_ERR_INVALIDSERVER,          /**&lt; Invalid server */
<span class="lineNum">     391 </span>            :     PA_ERR_MODINITFAILED,          /**&lt; Module initialization failed */
<span class="lineNum">     392 </span>            :     PA_ERR_BADSTATE,               /**&lt; Bad state */
<span class="lineNum">     393 </span>            :     PA_ERR_NODATA,                 /**&lt; No data */
<span class="lineNum">     394 </span>            :     PA_ERR_VERSION,                /**&lt; Incompatible protocol version */
<span class="lineNum">     395 </span>            :     PA_ERR_TOOLARGE,               /**&lt; Data too large */
<span class="lineNum">     396 </span>            :     PA_ERR_NOTSUPPORTED,           /**&lt; Operation not supported \since 0.9.5 */
<span class="lineNum">     397 </span>            :     PA_ERR_UNKNOWN,                /**&lt; The error code was unknown to the client */
<span class="lineNum">     398 </span>            :     PA_ERR_NOEXTENSION,            /**&lt; Extension does not exist. \since 0.9.12 */
<span class="lineNum">     399 </span>            :     PA_ERR_OBSOLETE,               /**&lt; Obsolete functionality. \since 0.9.15 */
<span class="lineNum">     400 </span>            :     PA_ERR_NOTIMPLEMENTED,         /**&lt; Missing implementation. \since 0.9.15 */
<span class="lineNum">     401 </span>            :     PA_ERR_FORKED,                 /**&lt; The caller forked without calling execve() and tried to reuse the context. \since 0.9.15 */
<span class="lineNum">     402 </span>            :     PA_ERR_IO,                     /**&lt; An IO error happened. \since 0.9.16 */
<span class="lineNum">     403 </span>            :     PA_ERR_BUSY,                   /**&lt; Device or resource busy. \since 0.9.17 */
<span class="lineNum">     404 </span>            :     PA_ERR_MAX                     /**&lt; Not really an error but the first invalid error code */
<span class="lineNum">     405 </span>            : };
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            : /** \cond fulldocs */
<span class="lineNum">     408 </span>            : #define PA_OK PA_OK
<span class="lineNum">     409 </span>            : #define PA_ERR_ACCESS PA_ERR_ACCESS
<span class="lineNum">     410 </span>            : #define PA_ERR_COMMAND PA_ERR_COMMAND
<span class="lineNum">     411 </span>            : #define PA_ERR_INVALID PA_ERR_INVALID
<span class="lineNum">     412 </span>            : #define PA_ERR_EXIST PA_ERR_EXIST
<span class="lineNum">     413 </span>            : #define PA_ERR_NOENTITY PA_ERR_NOENTITY
<span class="lineNum">     414 </span>            : #define PA_ERR_CONNECTIONREFUSED PA_ERR_CONNECTIONREFUSED
<span class="lineNum">     415 </span>            : #define PA_ERR_PROTOCOL PA_ERR_PROTOCOL
<span class="lineNum">     416 </span>            : #define PA_ERR_TIMEOUT PA_ERR_TIMEOUT
<span class="lineNum">     417 </span>            : #define PA_ERR_AUTHKEY PA_ERR_AUTHKEY
<span class="lineNum">     418 </span>            : #define PA_ERR_INTERNAL PA_ERR_INTERNAL
<span class="lineNum">     419 </span>            : #define PA_ERR_CONNECTIONTERMINATED PA_ERR_CONNECTIONTERMINATED
<span class="lineNum">     420 </span>            : #define PA_ERR_KILLED PA_ERR_KILLED
<span class="lineNum">     421 </span>            : #define PA_ERR_INVALIDSERVER PA_ERR_INVALIDSERVER
<span class="lineNum">     422 </span>            : #define PA_ERR_MODINITFAILED PA_ERR_MODINITFAILED
<span class="lineNum">     423 </span>            : #define PA_ERR_BADSTATE PA_ERR_BADSTATE
<span class="lineNum">     424 </span>            : #define PA_ERR_NODATA PA_ERR_NODATA
<span class="lineNum">     425 </span>            : #define PA_ERR_VERSION PA_ERR_VERSION
<span class="lineNum">     426 </span>            : #define PA_ERR_TOOLARGE PA_ERR_TOOLARGE
<span class="lineNum">     427 </span>            : #define PA_ERR_NOTSUPPORTED PA_ERR_NOTSUPPORTED
<span class="lineNum">     428 </span>            : #define PA_ERR_UNKNOWN PA_ERR_UNKNOWN
<span class="lineNum">     429 </span>            : #define PA_ERR_NOEXTENSION PA_ERR_NOEXTENSION
<span class="lineNum">     430 </span>            : #define PA_ERR_OBSOLETE PA_ERR_OBSOLETE
<span class="lineNum">     431 </span>            : #define PA_ERR_NOTIMPLEMENTED PA_ERR_NOTIMPLEMENTED
<span class="lineNum">     432 </span>            : #define PA_ERR_FORKED PA_ERR_FORKED
<span class="lineNum">     433 </span>            : #define PA_ERR_MAX PA_ERR_MAX
<span class="lineNum">     434 </span>            : /** \endcond */
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : /** Subscription event mask, as used by pa_context_subscribe() */
<span class="lineNum">     437 </span>            : typedef enum pa_subscription_mask {
<span class="lineNum">     438 </span>            :     PA_SUBSCRIPTION_MASK_NULL = 0x0000U,
<span class="lineNum">     439 </span>            :     /**&lt; No events */
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :     PA_SUBSCRIPTION_MASK_SINK = 0x0001U,
<span class="lineNum">     442 </span>            :     /**&lt; Sink events */
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :     PA_SUBSCRIPTION_MASK_SOURCE = 0x0002U,
<span class="lineNum">     445 </span>            :     /**&lt; Source events */
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :     PA_SUBSCRIPTION_MASK_SINK_INPUT = 0x0004U,
<span class="lineNum">     448 </span>            :     /**&lt; Sink input events */
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :     PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT = 0x0008U,
<span class="lineNum">     451 </span>            :     /**&lt; Source output events */
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :     PA_SUBSCRIPTION_MASK_MODULE = 0x0010U,
<span class="lineNum">     454 </span>            :     /**&lt; Module events */
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :     PA_SUBSCRIPTION_MASK_CLIENT = 0x0020U,
<span class="lineNum">     457 </span>            :     /**&lt; Client events */
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     PA_SUBSCRIPTION_MASK_SAMPLE_CACHE = 0x0040U,
<span class="lineNum">     460 </span>            :     /**&lt; Sample cache events */
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :     PA_SUBSCRIPTION_MASK_SERVER = 0x0080U,
<span class="lineNum">     463 </span>            :     /**&lt; Other global server changes. */
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /** \cond fulldocs */
<span class="lineNum">     466 </span>            :     PA_SUBSCRIPTION_MASK_AUTOLOAD = 0x0100U,
<span class="lineNum">     467 </span>            :     /**&lt; \deprecated Autoload table events. */
<span class="lineNum">     468 </span>            : /** \endcond */
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :     PA_SUBSCRIPTION_MASK_CARD = 0x0200U,
<span class="lineNum">     471 </span>            :     /**&lt; Card events. \since 0.9.15 */
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :     PA_SUBSCRIPTION_MASK_ALL = 0x02ffU
<span class="lineNum">     474 </span>            :     /**&lt; Catch all events */
<span class="lineNum">     475 </span>            : } pa_subscription_mask_t;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            : /** Subscription event types, as used by pa_context_subscribe() */
<span class="lineNum">     478 </span>            : typedef enum pa_subscription_event_type {
<span class="lineNum">     479 </span>            :     PA_SUBSCRIPTION_EVENT_SINK = 0x0000U,
<span class="lineNum">     480 </span>            :     /**&lt; Event type: Sink */
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     PA_SUBSCRIPTION_EVENT_SOURCE = 0x0001U,
<span class="lineNum">     483 </span>            :     /**&lt; Event type: Source */
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :     PA_SUBSCRIPTION_EVENT_SINK_INPUT = 0x0002U,
<span class="lineNum">     486 </span>            :     /**&lt; Event type: Sink input */
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :     PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT = 0x0003U,
<span class="lineNum">     489 </span>            :     /**&lt; Event type: Source output */
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :     PA_SUBSCRIPTION_EVENT_MODULE = 0x0004U,
<span class="lineNum">     492 </span>            :     /**&lt; Event type: Module */
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :     PA_SUBSCRIPTION_EVENT_CLIENT = 0x0005U,
<span class="lineNum">     495 </span>            :     /**&lt; Event type: Client */
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :     PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE = 0x0006U,
<span class="lineNum">     498 </span>            :     /**&lt; Event type: Sample cache item */
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :     PA_SUBSCRIPTION_EVENT_SERVER = 0x0007U,
<span class="lineNum">     501 </span>            :     /**&lt; Event type: Global server change, only occurring with PA_SUBSCRIPTION_EVENT_CHANGE. */
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : /** \cond fulldocs */
<span class="lineNum">     504 </span>            :     PA_SUBSCRIPTION_EVENT_AUTOLOAD = 0x0008U,
<span class="lineNum">     505 </span>            :     /**&lt; \deprecated Event type: Autoload table changes. */
<span class="lineNum">     506 </span>            : /** \endcond */
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :     PA_SUBSCRIPTION_EVENT_CARD = 0x0009U,
<span class="lineNum">     509 </span>            :     /**&lt; Event type: Card \since 0.9.15 */
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :     PA_SUBSCRIPTION_EVENT_FACILITY_MASK = 0x000FU,
<span class="lineNum">     512 </span>            :     /**&lt; A mask to extract the event type from an event value */
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     PA_SUBSCRIPTION_EVENT_NEW = 0x0000U,
<span class="lineNum">     515 </span>            :     /**&lt; A new object was created */
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :     PA_SUBSCRIPTION_EVENT_CHANGE = 0x0010U,
<span class="lineNum">     518 </span>            :     /**&lt; A property of the object was modified */
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :     PA_SUBSCRIPTION_EVENT_REMOVE = 0x0020U,
<span class="lineNum">     521 </span>            :     /**&lt; An object was removed */
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :     PA_SUBSCRIPTION_EVENT_TYPE_MASK = 0x0030U
<span class="lineNum">     524 </span>            :     /**&lt; A mask to extract the event operation from an event value */
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : } pa_subscription_event_type_t;
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : /** Return one if an event type t matches an event mask bitfield */
<span class="lineNum">     529 </span>            : #define pa_subscription_match_flags(m, t) (!!((m) &amp; (1 &lt;&lt; ((t) &amp; PA_SUBSCRIPTION_EVENT_FACILITY_MASK))))
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : /** \cond fulldocs */
<span class="lineNum">     532 </span>            : #define PA_SUBSCRIPTION_MASK_NULL PA_SUBSCRIPTION_MASK_NULL
<span class="lineNum">     533 </span>            : #define PA_SUBSCRIPTION_MASK_SINK PA_SUBSCRIPTION_MASK_SINK
<span class="lineNum">     534 </span>            : #define PA_SUBSCRIPTION_MASK_SOURCE PA_SUBSCRIPTION_MASK_SOURCE
<span class="lineNum">     535 </span>            : #define PA_SUBSCRIPTION_MASK_SINK_INPUT PA_SUBSCRIPTION_MASK_SINK_INPUT
<span class="lineNum">     536 </span>            : #define PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT
<span class="lineNum">     537 </span>            : #define PA_SUBSCRIPTION_MASK_MODULE PA_SUBSCRIPTION_MASK_MODULE
<span class="lineNum">     538 </span>            : #define PA_SUBSCRIPTION_MASK_CLIENT PA_SUBSCRIPTION_MASK_CLIENT
<span class="lineNum">     539 </span>            : #define PA_SUBSCRIPTION_MASK_SAMPLE_CACHE PA_SUBSCRIPTION_MASK_SAMPLE_CACHE
<span class="lineNum">     540 </span>            : #define PA_SUBSCRIPTION_MASK_SERVER PA_SUBSCRIPTION_MASK_SERVER
<span class="lineNum">     541 </span>            : #define PA_SUBSCRIPTION_MASK_AUTOLOAD PA_SUBSCRIPTION_MASK_AUTOLOAD
<span class="lineNum">     542 </span>            : #define PA_SUBSCRIPTION_MASK_CARD PA_SUBSCRIPTION_MASK_CARD
<span class="lineNum">     543 </span>            : #define PA_SUBSCRIPTION_MASK_ALL PA_SUBSCRIPTION_MASK_ALL
<span class="lineNum">     544 </span>            : #define PA_SUBSCRIPTION_EVENT_SINK PA_SUBSCRIPTION_EVENT_SINK
<span class="lineNum">     545 </span>            : #define PA_SUBSCRIPTION_EVENT_SOURCE PA_SUBSCRIPTION_EVENT_SOURCE
<span class="lineNum">     546 </span>            : #define PA_SUBSCRIPTION_EVENT_SINK_INPUT PA_SUBSCRIPTION_EVENT_SINK_INPUT
<span class="lineNum">     547 </span>            : #define PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT
<span class="lineNum">     548 </span>            : #define PA_SUBSCRIPTION_EVENT_MODULE PA_SUBSCRIPTION_EVENT_MODULE
<span class="lineNum">     549 </span>            : #define PA_SUBSCRIPTION_EVENT_CLIENT PA_SUBSCRIPTION_EVENT_CLIENT
<span class="lineNum">     550 </span>            : #define PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE
<span class="lineNum">     551 </span>            : #define PA_SUBSCRIPTION_EVENT_SERVER PA_SUBSCRIPTION_EVENT_SERVER
<span class="lineNum">     552 </span>            : #define PA_SUBSCRIPTION_EVENT_AUTOLOAD PA_SUBSCRIPTION_EVENT_AUTOLOAD
<span class="lineNum">     553 </span>            : #define PA_SUBSCRIPTION_EVENT_CARD PA_SUBSCRIPTION_EVENT_CARD
<span class="lineNum">     554 </span>            : #define PA_SUBSCRIPTION_EVENT_FACILITY_MASK PA_SUBSCRIPTION_EVENT_FACILITY_MASK
<span class="lineNum">     555 </span>            : #define PA_SUBSCRIPTION_EVENT_NEW PA_SUBSCRIPTION_EVENT_NEW
<span class="lineNum">     556 </span>            : #define PA_SUBSCRIPTION_EVENT_CHANGE PA_SUBSCRIPTION_EVENT_CHANGE
<span class="lineNum">     557 </span>            : #define PA_SUBSCRIPTION_EVENT_REMOVE PA_SUBSCRIPTION_EVENT_REMOVE
<span class="lineNum">     558 </span>            : #define PA_SUBSCRIPTION_EVENT_TYPE_MASK PA_SUBSCRIPTION_EVENT_TYPE_MASK
<span class="lineNum">     559 </span>            : /** \endcond */
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : /** A structure for all kinds of timing information of a stream. See
<span class="lineNum">     562 </span>            :  * pa_stream_update_timing_info() and pa_stream_get_timing_info(). The
<span class="lineNum">     563 </span>            :  * total output latency a sample that is written with
<span class="lineNum">     564 </span>            :  * pa_stream_write() takes to be played may be estimated by
<span class="lineNum">     565 </span>            :  * sink_usec+buffer_usec+transport_usec. (where buffer_usec is defined
<span class="lineNum">     566 </span>            :  * as pa_bytes_to_usec(write_index-read_index)) The output buffer
<span class="lineNum">     567 </span>            :  * which buffer_usec relates to may be manipulated freely (with
<span class="lineNum">     568 </span>            :  * pa_stream_write()'s seek argument, pa_stream_flush() and friends),
<span class="lineNum">     569 </span>            :  * the buffers sink_usec and source_usec relate to are first-in
<span class="lineNum">     570 </span>            :  * first-out (FIFO) buffers which cannot be flushed or manipulated in
<span class="lineNum">     571 </span>            :  * any way. The total input latency a sample that is recorded takes to
<span class="lineNum">     572 </span>            :  * be delivered to the application is:
<span class="lineNum">     573 </span>            :  * source_usec+buffer_usec+transport_usec-sink_usec. (Take care of
<span class="lineNum">     574 </span>            :  * sign issues!) When connected to a monitor source sink_usec contains
<span class="lineNum">     575 </span>            :  * the latency of the owning sink. The two latency estimations
<span class="lineNum">     576 </span>            :  * described here are implemented in pa_stream_get_latency(). Please
<span class="lineNum">     577 </span>            :  * note that this structure can be extended as part of evolutionary
<span class="lineNum">     578 </span>            :  * API updates at any time in any new release.*/
<span class="lineNum">     579 </span>            : typedef struct pa_timing_info {
<span class="lineNum">     580 </span>            :     struct timeval timestamp;
<span class="lineNum">     581 </span>            :     /**&lt; The time when this timing info structure was current */
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :     int synchronized_clocks;
<span class="lineNum">     584 </span>            :     /**&lt; Non-zero if the local and the remote machine have
<span class="lineNum">     585 </span>            :      * synchronized clocks. If synchronized clocks are detected
<span class="lineNum">     586 </span>            :      * transport_usec becomes much more reliable. However, the code
<span class="lineNum">     587 </span>            :      * that detects synchronized clocks is very limited and unreliable
<span class="lineNum">     588 </span>            :      * itself. */
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :     pa_usec_t sink_usec;
<span class="lineNum">     591 </span>            :     /**&lt; Time in usecs a sample takes to be played on the sink. For
<span class="lineNum">     592 </span>            :      * playback streams and record streams connected to a monitor
<span class="lineNum">     593 </span>            :      * source. */
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :     pa_usec_t source_usec;
<span class="lineNum">     596 </span>            :     /**&lt; Time in usecs a sample takes from being recorded to being
<span class="lineNum">     597 </span>            :      * delivered to the application. Only for record streams. */
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :     pa_usec_t transport_usec;
<span class="lineNum">     600 </span>            :     /**&lt; Estimated time in usecs a sample takes to be transferred
<span class="lineNum">     601 </span>            :      * to/from the daemon. For both playback and record streams. */
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     int playing;
<span class="lineNum">     604 </span>            :     /**&lt; Non-zero when the stream is currently not underrun and data
<span class="lineNum">     605 </span>            :      * is being passed on to the device. Only for playback
<span class="lineNum">     606 </span>            :      * streams. This field does not say whether the data is actually
<span class="lineNum">     607 </span>            :      * already being played. To determine this check whether
<span class="lineNum">     608 </span>            :      * since_underrun (converted to usec) is larger than sink_usec.*/
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            :     int write_index_corrupt;
<span class="lineNum">     611 </span>            :     /**&lt; Non-zero if write_index is not up-to-date because a local
<span class="lineNum">     612 </span>            :      * write command that corrupted it has been issued in the time
<span class="lineNum">     613 </span>            :      * since this latency info was current . Only write commands with
<span class="lineNum">     614 </span>            :      * SEEK_RELATIVE_ON_READ and SEEK_RELATIVE_END can corrupt
<span class="lineNum">     615 </span>            :      * write_index. */
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :     int64_t write_index;
<span class="lineNum">     618 </span>            :     /**&lt; Current write index into the playback buffer in bytes. Think
<span class="lineNum">     619 </span>            :      * twice before using this for seeking purposes: it might be out
<span class="lineNum">     620 </span>            :      * of date a the time you want to use it. Consider using
<span class="lineNum">     621 </span>            :      * PA_SEEK_RELATIVE instead. */
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :     int read_index_corrupt;
<span class="lineNum">     624 </span>            :     /**&lt; Non-zero if read_index is not up-to-date because a local
<span class="lineNum">     625 </span>            :      * pause or flush request that corrupted it has been issued in the
<span class="lineNum">     626 </span>            :      * time since this latency info was current. */
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :     int64_t read_index;
<span class="lineNum">     629 </span>            :     /**&lt; Current read index into the playback buffer in bytes. Think
<span class="lineNum">     630 </span>            :      * twice before using this for seeking purposes: it might be out
<span class="lineNum">     631 </span>            :      * of date a the time you want to use it. Consider using
<span class="lineNum">     632 </span>            :      * PA_SEEK_RELATIVE_ON_READ instead. */
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :     pa_usec_t configured_sink_usec;
<span class="lineNum">     635 </span>            :     /**&lt; The configured latency for the sink. \since 0.9.11 */
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :     pa_usec_t configured_source_usec;
<span class="lineNum">     638 </span>            :     /**&lt; The configured latency for the source. \since 0.9.11 */
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :     int64_t since_underrun;
<span class="lineNum">     641 </span>            :     /**&lt; Bytes that were handed to the sink since the last underrun
<span class="lineNum">     642 </span>            :      * happened, or since playback started again after the last
<span class="lineNum">     643 </span>            :      * underrun. playing will tell you which case it is. \since
<span class="lineNum">     644 </span>            :      * 0.9.11 */
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : } pa_timing_info;
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : /** A structure for the spawn api. This may be used to integrate auto
<span class="lineNum">     649 </span>            :  * spawned daemons into your application. For more information see
<span class="lineNum">     650 </span>            :  * pa_context_connect(). When spawning a new child process the
<span class="lineNum">     651 </span>            :  * waitpid() is used on the child's PID. The spawn routine will not
<span class="lineNum">     652 </span>            :  * block or ignore SIGCHLD signals, since this cannot be done in a
<span class="lineNum">     653 </span>            :  * thread compatible way. You might have to do this in
<span class="lineNum">     654 </span>            :  * prefork/postfork. */
<span class="lineNum">     655 </span>            : typedef struct pa_spawn_api {
<span class="lineNum">     656 </span>            :     void (*prefork)(void);
<span class="lineNum">     657 </span>            :     /**&lt; Is called just before the fork in the parent process. May be
<span class="lineNum">     658 </span>            :      * NULL. */
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :     void (*postfork)(void);
<span class="lineNum">     661 </span>            :     /**&lt; Is called immediately after the fork in the parent
<span class="lineNum">     662 </span>            :      * process. May be NULL.*/
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     void (*atfork)(void);
<span class="lineNum">     665 </span>            :     /**&lt; Is called immediately after the fork in the child
<span class="lineNum">     666 </span>            :      * process. May be NULL. It is not safe to close all file
<span class="lineNum">     667 </span>            :      * descriptors in this function unconditionally, since a UNIX
<span class="lineNum">     668 </span>            :      * socket (created using socketpair()) is passed to the new
<span class="lineNum">     669 </span>            :      * process. */
<span class="lineNum">     670 </span>            : } pa_spawn_api;
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : /** Seek type for pa_stream_write(). */
<span class="lineNum">     673 </span>            : typedef enum pa_seek_mode {
<span class="lineNum">     674 </span>            :     PA_SEEK_RELATIVE = 0,
<span class="lineNum">     675 </span>            :     /**&lt; Seek relatively to the write index */
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :     PA_SEEK_ABSOLUTE = 1,
<span class="lineNum">     678 </span>            :     /**&lt; Seek relatively to the start of the buffer queue */
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :     PA_SEEK_RELATIVE_ON_READ = 2,
<span class="lineNum">     681 </span>            :     /**&lt; Seek relatively to the read index.  */
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :     PA_SEEK_RELATIVE_END = 3
<span class="lineNum">     684 </span>            :     /**&lt; Seek relatively to the current end of the buffer queue. */
<span class="lineNum">     685 </span>            : } pa_seek_mode_t;
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : /** \cond fulldocs */
<span class="lineNum">     688 </span>            : #define PA_SEEK_RELATIVE PA_SEEK_RELATIVE
<span class="lineNum">     689 </span>            : #define PA_SEEK_ABSOLUTE PA_SEEK_ABSOLUTE
<span class="lineNum">     690 </span>            : #define PA_SEEK_RELATIVE_ON_READ PA_SEEK_RELATIVE_ON_READ
<span class="lineNum">     691 </span>            : #define PA_SEEK_RELATIVE_END PA_SEEK_RELATIVE_END
<span class="lineNum">     692 </span>            : /** \endcond */
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : /** Special sink flags. */
<span class="lineNum">     695 </span>            : typedef enum pa_sink_flags {
<span class="lineNum">     696 </span>            :     PA_SINK_NOFLAGS = 0x0000U,
<span class="lineNum">     697 </span>            :     /**&lt; Flag to pass when no specific options are needed (used to avoid casting)  \since 0.9.19 */
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :     PA_SINK_HW_VOLUME_CTRL = 0x0001U,
<span class="lineNum">     700 </span>            :     /**&lt; Supports hardware volume control */
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :     PA_SINK_LATENCY = 0x0002U,
<span class="lineNum">     703 </span>            :     /**&lt; Supports latency querying */
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :     PA_SINK_HARDWARE = 0x0004U,
<span class="lineNum">     706 </span>            :     /**&lt; Is a hardware sink of some kind, in contrast to
<span class="lineNum">     707 </span>            :      * &quot;virtual&quot;/software sinks \since 0.9.3 */
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :     PA_SINK_NETWORK = 0x0008U,
<span class="lineNum">     710 </span>            :     /**&lt; Is a networked sink of some kind. \since 0.9.7 */
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :     PA_SINK_HW_MUTE_CTRL = 0x0010U,
<span class="lineNum">     713 </span>            :     /**&lt; Supports hardware mute control \since 0.9.11 */
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     PA_SINK_DECIBEL_VOLUME = 0x0020U,
<span class="lineNum">     716 </span>            :     /**&lt; Volume can be translated to dB with pa_sw_volume_to_dB()
<span class="lineNum">     717 </span>            :      * \since 0.9.11 */
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :     PA_SINK_FLAT_VOLUME = 0x0040U,
<span class="lineNum">     720 </span>            :     /**&lt; This sink is in flat volume mode, i.e. always the maximum of
<span class="lineNum">     721 </span>            :      * the volume of all connected inputs. \since 0.9.15 */
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :     PA_SINK_DYNAMIC_LATENCY = 0x0080U
<span class="lineNum">     724 </span>            :     /**&lt; The latency can be adjusted dynamically depending on the
<span class="lineNum">     725 </span>            :      * needs of the connected streams. \since 0.9.15 */
<span class="lineNum">     726 </span>            : } pa_sink_flags_t;
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            : /** \cond fulldocs */
<span class="lineNum">     729 </span>            : #define PA_SINK_HW_VOLUME_CTRL PA_SINK_HW_VOLUME_CTRL
<span class="lineNum">     730 </span>            : #define PA_SINK_LATENCY PA_SINK_LATENCY
<span class="lineNum">     731 </span>            : #define PA_SINK_HARDWARE PA_SINK_HARDWARE
<span class="lineNum">     732 </span>            : #define PA_SINK_NETWORK PA_SINK_NETWORK
<span class="lineNum">     733 </span>            : #define PA_SINK_HW_MUTE_CTRL PA_SINK_HW_MUTE_CTRL
<span class="lineNum">     734 </span>            : #define PA_SINK_DECIBEL_VOLUME PA_SINK_DECIBEL_VOLUME
<span class="lineNum">     735 </span>            : #define PA_SINK_FLAT_VOLUME PA_SINK_FLAT_VOLUME
<span class="lineNum">     736 </span>            : #define PA_SINK_DYNAMIC_LATENCY PA_SINK_DYNAMIC_LATENCY
<span class="lineNum">     737 </span>            : /** \endcond */
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : /** Sink state. \since 0.9.15 */
<span class="lineNum">     740 </span>            : typedef enum pa_sink_state { /* enum serialized in u8 */
<span class="lineNum">     741 </span>            :     PA_SINK_INVALID_STATE = -1,
<span class="lineNum">     742 </span>            :     /**&lt; This state is used when the server does not support sink state introspection \since 0.9.15 */
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :     PA_SINK_RUNNING = 0,
<span class="lineNum">     745 </span>            :     /**&lt; Running, sink is playing and used by at least one non-corked sink-input \since 0.9.15 */
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :     PA_SINK_IDLE = 1,
<span class="lineNum">     748 </span>            :     /**&lt; When idle, the sink is playing but there is no non-corked sink-input attached to it \since 0.9.15 */
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            :     PA_SINK_SUSPENDED = 2,
<span class="lineNum">     751 </span>            :     /**&lt; When suspended, actual sink access can be closed, for instance \since 0.9.15 */
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : /** \cond fulldocs */
<span class="lineNum">     754 </span>            :     /* PRIVATE: Server-side values -- DO NOT USE THIS ON THE CLIENT
<span class="lineNum">     755 </span>            :      * SIDE! These values are *not* considered part of the official PA
<span class="lineNum">     756 </span>            :      * API/ABI. If you use them your application might break when PA
<span class="lineNum">     757 </span>            :      * is upgraded. Also, please note that these values are not useful
<span class="lineNum">     758 </span>            :      * on the client side anyway. */
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :     PA_SINK_INIT = -2,
<span class="lineNum">     761 </span>            :     /**&lt; Initialization state */
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :     PA_SINK_UNLINKED = -3
<span class="lineNum">     764 </span>            :     /**&lt; The state when the sink is getting unregistered and removed from client access */
<span class="lineNum">     765 </span>            : /** \endcond */
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : } pa_sink_state_t;
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : /** Returns non-zero if sink is playing: running or idle. \since 0.9.15 */
<span class="lineNum">     770 </span>            : static inline int PA_SINK_IS_OPENED(pa_sink_state_t x) {
<span class="lineNum">     771 </span>            :     return x == PA_SINK_RUNNING || x == PA_SINK_IDLE;
<span class="lineNum">     772 </span>            : }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : /** \cond fulldocs */
<span class="lineNum">     775 </span>            : #define PA_SINK_INVALID_STATE PA_SINK_INVALID_STATE
<span class="lineNum">     776 </span>            : #define PA_SINK_RUNNING PA_SINK_RUNNING
<span class="lineNum">     777 </span>            : #define PA_SINK_IDLE PA_SINK_IDLE
<span class="lineNum">     778 </span>            : #define PA_SINK_SUSPENDED PA_SINK_SUSPENDED
<span class="lineNum">     779 </span>            : #define PA_SINK_INIT PA_SINK_INIT
<span class="lineNum">     780 </span>            : #define PA_SINK_UNLINKED PA_SINK_UNLINKED
<span class="lineNum">     781 </span>            : #define PA_SINK_IS_OPENED PA_SINK_IS_OPENED
<span class="lineNum">     782 </span>            : /** \endcond */
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : /** Special source flags.  */
<span class="lineNum">     785 </span>            : typedef enum pa_source_flags {
<span class="lineNum">     786 </span>            :     PA_SOURCE_NOFLAGS = 0x0000U,
<span class="lineNum">     787 </span>            :     /**&lt; Flag to pass when no specific options are needed (used to avoid casting)  \since 0.9.19 */
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :     PA_SOURCE_HW_VOLUME_CTRL = 0x0001U,
<span class="lineNum">     790 </span>            :     /**&lt; Supports hardware volume control */
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :     PA_SOURCE_LATENCY = 0x0002U,
<span class="lineNum">     793 </span>            :     /**&lt; Supports latency querying */
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :     PA_SOURCE_HARDWARE = 0x0004U,
<span class="lineNum">     796 </span>            :     /**&lt; Is a hardware source of some kind, in contrast to
<span class="lineNum">     797 </span>            :      * &quot;virtual&quot;/software source \since 0.9.3 */
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :     PA_SOURCE_NETWORK = 0x0008U,
<span class="lineNum">     800 </span>            :     /**&lt; Is a networked source of some kind. \since 0.9.7 */
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :     PA_SOURCE_HW_MUTE_CTRL = 0x0010U,
<span class="lineNum">     803 </span>            :     /**&lt; Supports hardware mute control \since 0.9.11 */
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :     PA_SOURCE_DECIBEL_VOLUME = 0x0020U,
<span class="lineNum">     806 </span>            :     /**&lt; Volume can be translated to dB with pa_sw_volume_to_dB()
<span class="lineNum">     807 </span>            :      * \since 0.9.11 */
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     PA_SOURCE_DYNAMIC_LATENCY = 0x0040U
<span class="lineNum">     810 </span>            :     /**&lt; The latency can be adjusted dynamically depending on the
<span class="lineNum">     811 </span>            :      * needs of the connected streams. \since 0.9.15 */
<span class="lineNum">     812 </span>            : } pa_source_flags_t;
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : /** \cond fulldocs */
<span class="lineNum">     815 </span>            : #define PA_SOURCE_HW_VOLUME_CTRL PA_SOURCE_HW_VOLUME_CTRL
<span class="lineNum">     816 </span>            : #define PA_SOURCE_LATENCY PA_SOURCE_LATENCY
<span class="lineNum">     817 </span>            : #define PA_SOURCE_HARDWARE PA_SOURCE_HARDWARE
<span class="lineNum">     818 </span>            : #define PA_SOURCE_NETWORK PA_SOURCE_NETWORK
<span class="lineNum">     819 </span>            : #define PA_SOURCE_HW_MUTE_CTRL PA_SOURCE_HW_MUTE_CTRL
<span class="lineNum">     820 </span>            : #define PA_SOURCE_DECIBEL_VOLUME PA_SOURCE_DECIBEL_VOLUME
<span class="lineNum">     821 </span>            : #define PA_SOURCE_DYNAMIC_LATENCY PA_SOURCE_DYNAMIC_LATENCY
<span class="lineNum">     822 </span>            : /** \endcond */
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : /** Source state. \since 0.9.15 */
<span class="lineNum">     825 </span>            : typedef enum pa_source_state {
<span class="lineNum">     826 </span>            :     PA_SOURCE_INVALID_STATE = -1,
<span class="lineNum">     827 </span>            :     /**&lt; This state is used when the server does not support source state introspection \since 0.9.15 */
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :     PA_SOURCE_RUNNING = 0,
<span class="lineNum">     830 </span>            :     /**&lt; Running, source is recording and used by at least one non-corked source-output \since 0.9.15 */
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     PA_SOURCE_IDLE = 1,
<span class="lineNum">     833 </span>            :     /**&lt; When idle, the source is still recording but there is no non-corked source-output \since 0.9.15 */
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :     PA_SOURCE_SUSPENDED = 2,
<span class="lineNum">     836 </span>            :     /**&lt; When suspended, actual source access can be closed, for instance \since 0.9.15 */
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : /** \cond fulldocs */
<span class="lineNum">     839 </span>            :     /* PRIVATE: Server-side values -- DO NOT USE THIS ON THE CLIENT
<span class="lineNum">     840 </span>            :      * SIDE! These values are *not* considered part of the official PA
<span class="lineNum">     841 </span>            :      * API/ABI. If you use them your application might break when PA
<span class="lineNum">     842 </span>            :      * is upgraded. Also, please note that these values are not useful
<span class="lineNum">     843 </span>            :      * on the client side anyway. */
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :     PA_SOURCE_INIT = -2,
<span class="lineNum">     846 </span>            :     /**&lt; Initialization state */
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     PA_SOURCE_UNLINKED = -3
<span class="lineNum">     849 </span>            :     /**&lt; The state when the source is getting unregistered and removed from client access */
<span class="lineNum">     850 </span>            : /** \endcond */
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            : } pa_source_state_t;
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : /** Returns non-zero if source is recording: running or idle. \since 0.9.15 */
<span class="lineNum">     855 </span>            : static inline int PA_SOURCE_IS_OPENED(pa_source_state_t x) {
<span class="lineNum">     856 </span>            :     return x == PA_SOURCE_RUNNING || x == PA_SOURCE_IDLE;
<span class="lineNum">     857 </span>            : }
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            : /** \cond fulldocs */
<span class="lineNum">     860 </span>            : #define PA_SOURCE_INVALID_STATE PA_SOURCE_INVALID_STATE
<span class="lineNum">     861 </span>            : #define PA_SOURCE_RUNNING PA_SOURCE_RUNNING
<span class="lineNum">     862 </span>            : #define PA_SOURCE_IDLE PA_SOURCE_IDLE
<span class="lineNum">     863 </span>            : #define PA_SOURCE_SUSPENDED PA_SOURCE_SUSPENDED
<span class="lineNum">     864 </span>            : #define PA_SOURCE_INIT PA_SOURCE_INIT
<span class="lineNum">     865 </span>            : #define PA_SOURCE_UNLINKED PA_SOURCE_UNLINKED
<span class="lineNum">     866 </span>            : #define PA_SOURCE_IS_OPENED PA_SOURCE_IS_OPENED
<span class="lineNum">     867 </span>            : /** \endcond */
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            : /** A generic free() like callback prototype */
<span class="lineNum">     870 </span>            : typedef void (*pa_free_cb_t)(void *p);
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            : /** A stream policy/meta event requesting that an application should
<span class="lineNum">     873 </span>            :  * cork a specific stream. See pa_stream_event_cb_t for more
<span class="lineNum">     874 </span>            :  * information, \since 0.9.15 */
<span class="lineNum">     875 </span>            : #define PA_STREAM_EVENT_REQUEST_CORK &quot;request-cork&quot;
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : /** A stream policy/meta event requesting that an application should
<span class="lineNum">     878 </span>            :  * cork a specific stream. See pa_stream_event_cb_t for more
<span class="lineNum">     879 </span>            :  * information, \since 0.9.15 */
<span class="lineNum">     880 </span>            : #define PA_STREAM_EVENT_REQUEST_UNCORK &quot;request-uncork&quot;
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : PA_C_DECL_END
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
