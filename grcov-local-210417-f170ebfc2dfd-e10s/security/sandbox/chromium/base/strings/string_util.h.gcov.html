<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/sandbox/chromium/base/strings/string_util.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">security/sandbox/chromium/base/strings</a> - string_util.h<span style="font-size: 80%;"> (source / <a href="string_util.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright 2013 The Chromium Authors. All rights reserved.</a>
<span class="lineNum">       2 </span>            : // Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       3 </span>            : // found in the LICENSE file.
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : // This file defines utility functions for working with strings.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef BASE_STRINGS_STRING_UTIL_H_
<span class="lineNum">       8 </span>            : #define BASE_STRINGS_STRING_UTIL_H_
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      11 </span>            : #include &lt;stdarg.h&gt;   // va_list
<span class="lineNum">      12 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &lt;string&gt;
<span class="lineNum">      16 </span>            : #include &lt;vector&gt;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;base/base_export.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;base/compiler_specific.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;base/strings/string16.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;base/strings/string_piece.h&quot;  // For implicit conversions.
<span class="lineNum">      22 </span>            : #include &quot;build/build_config.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : namespace base {
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : // C standard-library functions that aren't cross-platform are provided as
<span class="lineNum">      27 </span>            : // &quot;base::...&quot;, and their prototypes are listed below. These functions are
<span class="lineNum">      28 </span>            : // then implemented as inline calls to the platform-specific equivalents in the
<span class="lineNum">      29 </span>            : // platform-specific headers.
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : // Wrapper for vsnprintf that always null-terminates and always returns the
<span class="lineNum">      32 </span>            : // number of characters that would be in an untruncated formatted
<span class="lineNum">      33 </span>            : // string, even when truncation occurs.
<span class="lineNum">      34 </span>            : int vsnprintf(char* buffer, size_t size, const char* format, va_list arguments)
<span class="lineNum">      35 </span>            :     PRINTF_FORMAT(3, 0);
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : // Some of these implementations need to be inlined.
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // We separate the declaration from the implementation of this inline
<span class="lineNum">      40 </span>            : // function just so the PRINTF_FORMAT works.
<span class="lineNum">      41 </span>            : inline int snprintf(char* buffer,
<span class="lineNum">      42 </span>            :                     size_t size,
<a name="43"><span class="lineNum">      43 </span>            :                     _Printf_format_string_ const char* format,</a>
<span class="lineNum">      44 </span>            :                     ...) PRINTF_FORMAT(3, 4);
<span class="lineNum">      45 </span><span class="lineNoCov">          0 : inline int snprintf(char* buffer,</span>
<span class="lineNum">      46 </span>            :                     size_t size,
<span class="lineNum">      47 </span>            :                     _Printf_format_string_ const char* format,
<span class="lineNum">      48 </span>            :                     ...) {
<span class="lineNum">      49 </span>            :   va_list arguments;
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   va_start(arguments, format);</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   int result = vsnprintf(buffer, size, format, arguments);</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   va_end(arguments);</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">      54 </span>            : }
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : // BSD-style safe and consistent string copy functions.
<span class="lineNum">      57 </span>            : // Copies |src| to |dst|, where |dst_size| is the total allocated size of |dst|.
<span class="lineNum">      58 </span>            : // Copies at most |dst_size|-1 characters, and always NULL terminates |dst|, as
<span class="lineNum">      59 </span>            : // long as |dst_size| is not 0.  Returns the length of |src| in characters.
<span class="lineNum">      60 </span>            : // If the return value is &gt;= dst_size, then the output was truncated.
<span class="lineNum">      61 </span>            : // NOTE: All sizes are in number of characters, NOT in bytes.
<span class="lineNum">      62 </span>            : BASE_EXPORT size_t strlcpy(char* dst, const char* src, size_t dst_size);
<span class="lineNum">      63 </span>            : BASE_EXPORT size_t wcslcpy(wchar_t* dst, const wchar_t* src, size_t dst_size);
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : // Scan a wprintf format string to determine whether it's portable across a
<span class="lineNum">      66 </span>            : // variety of systems.  This function only checks that the conversion
<span class="lineNum">      67 </span>            : // specifiers used by the format string are supported and have the same meaning
<span class="lineNum">      68 </span>            : // on a variety of systems.  It doesn't check for other errors that might occur
<span class="lineNum">      69 </span>            : // within a format string.
<span class="lineNum">      70 </span>            : //
<span class="lineNum">      71 </span>            : // Nonportable conversion specifiers for wprintf are:
<span class="lineNum">      72 </span>            : //  - 's' and 'c' without an 'l' length modifier.  %s and %c operate on char
<span class="lineNum">      73 </span>            : //     data on all systems except Windows, which treat them as wchar_t data.
<span class="lineNum">      74 </span>            : //     Use %ls and %lc for wchar_t data instead.
<span class="lineNum">      75 </span>            : //  - 'S' and 'C', which operate on wchar_t data on all systems except Windows,
<span class="lineNum">      76 </span>            : //     which treat them as char data.  Use %ls and %lc for wchar_t data
<span class="lineNum">      77 </span>            : //     instead.
<span class="lineNum">      78 </span>            : //  - 'F', which is not identified by Windows wprintf documentation.
<span class="lineNum">      79 </span>            : //  - 'D', 'O', and 'U', which are deprecated and not available on all systems.
<span class="lineNum">      80 </span>            : //     Use %ld, %lo, and %lu instead.
<span class="lineNum">      81 </span>            : //
<span class="lineNum">      82 </span>            : // Note that there is no portable conversion specifier for char data when
<span class="lineNum">      83 </span>            : // working with wprintf.
<span class="lineNum">      84 </span>            : //
<span class="lineNum">      85 </span>            : // This function is intended to be called from base::vswprintf.
<span class="lineNum">      86 </span>            : BASE_EXPORT bool IsWprintfFormatPortable(const wchar_t* format);
<span class="lineNum">      87 </span>            : 
<a name="88"><span class="lineNum">      88 </span>            : // ASCII-specific tolower.  The standard library's tolower is locale sensitive,</a>
<span class="lineNum">      89 </span>            : // so we don't want to use it here.
<span class="lineNum">      90 </span><span class="lineNoCov">          0 : inline char ToLowerASCII(char c) {</span>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :   return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? (c + ('a' - 'A')) : c;</span></a>
<span class="lineNum">      92 </span>            : }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : inline char16 ToLowerASCII(char16 c) {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? (c + ('a' - 'A')) : c;</span>
<span class="lineNum">      95 </span>            : }
<span class="lineNum">      96 </span>            : 
<a name="97"><span class="lineNum">      97 </span>            : // ASCII-specific toupper.  The standard library's toupper is locale sensitive,</a>
<span class="lineNum">      98 </span>            : // so we don't want to use it here.
<span class="lineNum">      99 </span><span class="lineNoCov">          0 : inline char ToUpperASCII(char c) {</span>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :   return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ? (c + ('A' - 'a')) : c;</span></a>
<span class="lineNum">     101 </span>            : }
<span class="lineNum">     102 </span><span class="lineNoCov">          0 : inline char16 ToUpperASCII(char16 c) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ? (c + ('A' - 'a')) : c;</span>
<span class="lineNum">     104 </span>            : }
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : // Converts the given string to it's ASCII-lowercase equivalent.
<span class="lineNum">     107 </span>            : BASE_EXPORT std::string ToLowerASCII(StringPiece str);
<span class="lineNum">     108 </span>            : BASE_EXPORT string16 ToLowerASCII(StringPiece16 str);
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : // Converts the given string to it's ASCII-uppercase equivalent.
<span class="lineNum">     111 </span>            : BASE_EXPORT std::string ToUpperASCII(StringPiece str);
<span class="lineNum">     112 </span>            : BASE_EXPORT string16 ToUpperASCII(StringPiece16 str);
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : // Functor for case-insensitive ASCII comparisons for STL algorithms like
<span class="lineNum">     115 </span>            : // std::search.
<span class="lineNum">     116 </span>            : //
<span class="lineNum">     117 </span>            : // Note that a full Unicode version of this functor is not possible to write
<span class="lineNum">     118 </span>            : // because case mappings might change the number of characters, depend on
<span class="lineNum">     119 </span>            : // context (combining accents), and require handling UTF-16. If you need
<span class="lineNum">     120 </span>            : // proper Unicode support, use base::i18n::ToLower/FoldCase and then just
<span class="lineNum">     121 </span>            : // use a normal operator== on the result.
<a name="122"><span class="lineNum">     122 </span>            : template&lt;typename Char&gt; struct CaseInsensitiveCompareASCII {</a>
<span class="lineNum">     123 </span>            :  public:
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   bool operator()(Char x, Char y) const {</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     return ToLowerASCII(x) == ToLowerASCII(y);</span>
<span class="lineNum">     126 </span>            :   }
<span class="lineNum">     127 </span>            : };
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : // Like strcasecmp for case-insensitive ASCII characters only. Returns:
<span class="lineNum">     130 </span>            : //   -1  (a &lt; b)
<span class="lineNum">     131 </span>            : //    0  (a == b)
<span class="lineNum">     132 </span>            : //    1  (a &gt; b)
<span class="lineNum">     133 </span>            : // (unlike strcasecmp which can return values greater or less than 1/-1). For
<span class="lineNum">     134 </span>            : // full Unicode support, use base::i18n::ToLower or base::i18h::FoldCase
<span class="lineNum">     135 </span>            : // and then just call the normal string operators on the result.
<span class="lineNum">     136 </span>            : BASE_EXPORT int CompareCaseInsensitiveASCII(StringPiece a, StringPiece b);
<span class="lineNum">     137 </span>            : BASE_EXPORT int CompareCaseInsensitiveASCII(StringPiece16 a, StringPiece16 b);
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : // Equality for ASCII case-insensitive comparisons. For full Unicode support,
<span class="lineNum">     140 </span>            : // use base::i18n::ToLower or base::i18h::FoldCase and then compare with either
<span class="lineNum">     141 </span>            : // == or !=.
<span class="lineNum">     142 </span>            : BASE_EXPORT bool EqualsCaseInsensitiveASCII(StringPiece a, StringPiece b);
<span class="lineNum">     143 </span>            : BASE_EXPORT bool EqualsCaseInsensitiveASCII(StringPiece16 a, StringPiece16 b);
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : // These threadsafe functions return references to globally unique empty
<span class="lineNum">     146 </span>            : // strings.
<span class="lineNum">     147 </span>            : //
<span class="lineNum">     148 </span>            : // It is likely faster to construct a new empty string object (just a few
<span class="lineNum">     149 </span>            : // instructions to set the length to 0) than to get the empty string singleton
<span class="lineNum">     150 </span>            : // returned by these functions (which requires threadsafe singleton access).
<span class="lineNum">     151 </span>            : //
<span class="lineNum">     152 </span>            : // Therefore, DO NOT USE THESE AS A GENERAL-PURPOSE SUBSTITUTE FOR DEFAULT
<span class="lineNum">     153 </span>            : // CONSTRUCTORS. There is only one case where you should use these: functions
<span class="lineNum">     154 </span>            : // which need to return a string by reference (e.g. as a class member
<span class="lineNum">     155 </span>            : // accessor), and don't have an empty string to use (e.g. in an error case).
<span class="lineNum">     156 </span>            : // These should not be used as initializers, function arguments, or return
<span class="lineNum">     157 </span>            : // values for functions which return by value or outparam.
<span class="lineNum">     158 </span>            : BASE_EXPORT const std::string&amp; EmptyString();
<span class="lineNum">     159 </span>            : BASE_EXPORT const string16&amp; EmptyString16();
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : // Contains the set of characters representing whitespace in the corresponding
<span class="lineNum">     162 </span>            : // encoding. Null-terminated. The ASCII versions are the whitespaces as defined
<span class="lineNum">     163 </span>            : // by HTML5, and don't include control characters.
<span class="lineNum">     164 </span>            : BASE_EXPORT extern const wchar_t kWhitespaceWide[];  // Includes Unicode.
<span class="lineNum">     165 </span>            : BASE_EXPORT extern const char16 kWhitespaceUTF16[];  // Includes Unicode.
<span class="lineNum">     166 </span>            : BASE_EXPORT extern const char kWhitespaceASCII[];
<span class="lineNum">     167 </span>            : BASE_EXPORT extern const char16 kWhitespaceASCIIAs16[];  // No unicode.
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : // Null-terminated string representing the UTF-8 byte order mark.
<span class="lineNum">     170 </span>            : BASE_EXPORT extern const char kUtf8ByteOrderMark[];
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : // Removes characters in |remove_chars| from anywhere in |input|.  Returns true
<span class="lineNum">     173 </span>            : // if any characters were removed.  |remove_chars| must be null-terminated.
<span class="lineNum">     174 </span>            : // NOTE: Safe to use the same variable for both |input| and |output|.
<span class="lineNum">     175 </span>            : BASE_EXPORT bool RemoveChars(const string16&amp; input,
<span class="lineNum">     176 </span>            :                              const StringPiece16&amp; remove_chars,
<span class="lineNum">     177 </span>            :                              string16* output);
<span class="lineNum">     178 </span>            : BASE_EXPORT bool RemoveChars(const std::string&amp; input,
<span class="lineNum">     179 </span>            :                              const StringPiece&amp; remove_chars,
<span class="lineNum">     180 </span>            :                              std::string* output);
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : // Replaces characters in |replace_chars| from anywhere in |input| with
<span class="lineNum">     183 </span>            : // |replace_with|.  Each character in |replace_chars| will be replaced with
<span class="lineNum">     184 </span>            : // the |replace_with| string.  Returns true if any characters were replaced.
<span class="lineNum">     185 </span>            : // |replace_chars| must be null-terminated.
<span class="lineNum">     186 </span>            : // NOTE: Safe to use the same variable for both |input| and |output|.
<span class="lineNum">     187 </span>            : BASE_EXPORT bool ReplaceChars(const string16&amp; input,
<span class="lineNum">     188 </span>            :                               const StringPiece16&amp; replace_chars,
<span class="lineNum">     189 </span>            :                               const string16&amp; replace_with,
<span class="lineNum">     190 </span>            :                               string16* output);
<span class="lineNum">     191 </span>            : BASE_EXPORT bool ReplaceChars(const std::string&amp; input,
<span class="lineNum">     192 </span>            :                               const StringPiece&amp; replace_chars,
<span class="lineNum">     193 </span>            :                               const std::string&amp; replace_with,
<span class="lineNum">     194 </span>            :                               std::string* output);
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : enum TrimPositions {
<span class="lineNum">     197 </span>            :   TRIM_NONE     = 0,
<span class="lineNum">     198 </span>            :   TRIM_LEADING  = 1 &lt;&lt; 0,
<span class="lineNum">     199 </span>            :   TRIM_TRAILING = 1 &lt;&lt; 1,
<span class="lineNum">     200 </span>            :   TRIM_ALL      = TRIM_LEADING | TRIM_TRAILING,
<span class="lineNum">     201 </span>            : };
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : // Removes characters in |trim_chars| from the beginning and end of |input|.
<span class="lineNum">     204 </span>            : // The 8-bit version only works on 8-bit characters, not UTF-8.
<span class="lineNum">     205 </span>            : //
<span class="lineNum">     206 </span>            : // It is safe to use the same variable for both |input| and |output| (this is
<span class="lineNum">     207 </span>            : // the normal usage to trim in-place).
<span class="lineNum">     208 </span>            : BASE_EXPORT bool TrimString(const string16&amp; input,
<span class="lineNum">     209 </span>            :                             StringPiece16 trim_chars,
<span class="lineNum">     210 </span>            :                             string16* output);
<span class="lineNum">     211 </span>            : BASE_EXPORT bool TrimString(const std::string&amp; input,
<span class="lineNum">     212 </span>            :                             StringPiece trim_chars,
<span class="lineNum">     213 </span>            :                             std::string* output);
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : // StringPiece versions of the above. The returned pieces refer to the original
<span class="lineNum">     216 </span>            : // buffer.
<span class="lineNum">     217 </span>            : BASE_EXPORT StringPiece16 TrimString(StringPiece16 input,
<span class="lineNum">     218 </span>            :                                      const StringPiece16&amp; trim_chars,
<span class="lineNum">     219 </span>            :                                      TrimPositions positions);
<span class="lineNum">     220 </span>            : BASE_EXPORT StringPiece TrimString(StringPiece input,
<span class="lineNum">     221 </span>            :                                    const StringPiece&amp; trim_chars,
<span class="lineNum">     222 </span>            :                                    TrimPositions positions);
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : // Truncates a string to the nearest UTF-8 character that will leave
<span class="lineNum">     225 </span>            : // the string less than or equal to the specified byte size.
<span class="lineNum">     226 </span>            : BASE_EXPORT void TruncateUTF8ToByteSize(const std::string&amp; input,
<span class="lineNum">     227 </span>            :                                         const size_t byte_size,
<span class="lineNum">     228 </span>            :                                         std::string* output);
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : // Trims any whitespace from either end of the input string.
<span class="lineNum">     231 </span>            : //
<span class="lineNum">     232 </span>            : // The StringPiece versions return a substring referencing the input buffer.
<span class="lineNum">     233 </span>            : // The ASCII versions look only for ASCII whitespace.
<span class="lineNum">     234 </span>            : //
<span class="lineNum">     235 </span>            : // The std::string versions return where whitespace was found.
<span class="lineNum">     236 </span>            : // NOTE: Safe to use the same variable for both input and output.
<span class="lineNum">     237 </span>            : BASE_EXPORT TrimPositions TrimWhitespace(const string16&amp; input,
<span class="lineNum">     238 </span>            :                                          TrimPositions positions,
<span class="lineNum">     239 </span>            :                                          string16* output);
<span class="lineNum">     240 </span>            : BASE_EXPORT StringPiece16 TrimWhitespace(StringPiece16 input,
<span class="lineNum">     241 </span>            :                                          TrimPositions positions);
<span class="lineNum">     242 </span>            : BASE_EXPORT TrimPositions TrimWhitespaceASCII(const std::string&amp; input,
<span class="lineNum">     243 </span>            :                                               TrimPositions positions,
<span class="lineNum">     244 </span>            :                                               std::string* output);
<span class="lineNum">     245 </span>            : BASE_EXPORT StringPiece TrimWhitespaceASCII(StringPiece input,
<span class="lineNum">     246 </span>            :                                             TrimPositions positions);
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : // Searches  for CR or LF characters.  Removes all contiguous whitespace
<span class="lineNum">     249 </span>            : // strings that contain them.  This is useful when trying to deal with text
<span class="lineNum">     250 </span>            : // copied from terminals.
<span class="lineNum">     251 </span>            : // Returns |text|, with the following three transformations:
<span class="lineNum">     252 </span>            : // (1) Leading and trailing whitespace is trimmed.
<span class="lineNum">     253 </span>            : // (2) If |trim_sequences_with_line_breaks| is true, any other whitespace
<span class="lineNum">     254 </span>            : //     sequences containing a CR or LF are trimmed.
<span class="lineNum">     255 </span>            : // (3) All other whitespace sequences are converted to single spaces.
<span class="lineNum">     256 </span>            : BASE_EXPORT string16 CollapseWhitespace(
<span class="lineNum">     257 </span>            :     const string16&amp; text,
<span class="lineNum">     258 </span>            :     bool trim_sequences_with_line_breaks);
<span class="lineNum">     259 </span>            : BASE_EXPORT std::string CollapseWhitespaceASCII(
<span class="lineNum">     260 </span>            :     const std::string&amp; text,
<span class="lineNum">     261 </span>            :     bool trim_sequences_with_line_breaks);
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : // Returns true if |input| is empty or contains only characters found in
<span class="lineNum">     264 </span>            : // |characters|.
<span class="lineNum">     265 </span>            : BASE_EXPORT bool ContainsOnlyChars(const StringPiece&amp; input,
<span class="lineNum">     266 </span>            :                                    const StringPiece&amp; characters);
<span class="lineNum">     267 </span>            : BASE_EXPORT bool ContainsOnlyChars(const StringPiece16&amp; input,
<span class="lineNum">     268 </span>            :                                    const StringPiece16&amp; characters);
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : // Returns true if the specified string matches the criteria. How can a wide
<span class="lineNum">     271 </span>            : // string be 8-bit or UTF8? It contains only characters that are &lt; 256 (in the
<span class="lineNum">     272 </span>            : // first case) or characters that use only 8-bits and whose 8-bit
<span class="lineNum">     273 </span>            : // representation looks like a UTF-8 string (the second case).
<span class="lineNum">     274 </span>            : //
<span class="lineNum">     275 </span>            : // Note that IsStringUTF8 checks not only if the input is structurally
<span class="lineNum">     276 </span>            : // valid but also if it doesn't contain any non-character codepoint
<span class="lineNum">     277 </span>            : // (e.g. U+FFFE). It's done on purpose because all the existing callers want
<span class="lineNum">     278 </span>            : // to have the maximum 'discriminating' power from other encodings. If
<span class="lineNum">     279 </span>            : // there's a use case for just checking the structural validity, we have to
<span class="lineNum">     280 </span>            : // add a new function for that.
<span class="lineNum">     281 </span>            : //
<span class="lineNum">     282 </span>            : // IsStringASCII assumes the input is likely all ASCII, and does not leave early
<span class="lineNum">     283 </span>            : // if it is not the case.
<span class="lineNum">     284 </span>            : BASE_EXPORT bool IsStringUTF8(const StringPiece&amp; str);
<span class="lineNum">     285 </span>            : BASE_EXPORT bool IsStringASCII(const StringPiece&amp; str);
<span class="lineNum">     286 </span>            : BASE_EXPORT bool IsStringASCII(const StringPiece16&amp; str);
<span class="lineNum">     287 </span>            : // A convenience adaptor for WebStrings, as they don't convert into
<span class="lineNum">     288 </span>            : // StringPieces directly.
<span class="lineNum">     289 </span>            : BASE_EXPORT bool IsStringASCII(const string16&amp; str);
<span class="lineNum">     290 </span>            : #if defined(WCHAR_T_IS_UTF32)
<span class="lineNum">     291 </span>            : BASE_EXPORT bool IsStringASCII(const std::wstring&amp; str);
<span class="lineNum">     292 </span>            : #endif
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : // Compare the lower-case form of the given string against the given
<span class="lineNum">     295 </span>            : // previously-lower-cased ASCII string (typically a constant).
<span class="lineNum">     296 </span>            : BASE_EXPORT bool LowerCaseEqualsASCII(StringPiece str,
<span class="lineNum">     297 </span>            :                                       StringPiece lowecase_ascii);
<span class="lineNum">     298 </span>            : BASE_EXPORT bool LowerCaseEqualsASCII(StringPiece16 str,
<span class="lineNum">     299 </span>            :                                       StringPiece lowecase_ascii);
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : // Performs a case-sensitive string compare of the given 16-bit string against
<span class="lineNum">     302 </span>            : // the given 8-bit ASCII string (typically a constant). The behavior is
<span class="lineNum">     303 </span>            : // undefined if the |ascii| string is not ASCII.
<span class="lineNum">     304 </span>            : BASE_EXPORT bool EqualsASCII(StringPiece16 str, StringPiece ascii);
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : // Indicates case sensitivity of comparisons. Only ASCII case insensitivity
<span class="lineNum">     307 </span>            : // is supported. Full Unicode case-insensitive conversions would need to go in
<span class="lineNum">     308 </span>            : // base/i18n so it can use ICU.
<span class="lineNum">     309 </span>            : //
<span class="lineNum">     310 </span>            : // If you need to do Unicode-aware case-insensitive StartsWith/EndsWith, it's
<span class="lineNum">     311 </span>            : // best to call base::i18n::ToLower() or base::i18n::FoldCase() (see
<span class="lineNum">     312 </span>            : // base/i18n/case_conversion.h for usage advice) on the arguments, and then use
<span class="lineNum">     313 </span>            : // the results to a case-sensitive comparison.
<span class="lineNum">     314 </span>            : enum class CompareCase {
<span class="lineNum">     315 </span>            :   SENSITIVE,
<span class="lineNum">     316 </span>            :   INSENSITIVE_ASCII,
<span class="lineNum">     317 </span>            : };
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : BASE_EXPORT bool StartsWith(StringPiece str,
<span class="lineNum">     320 </span>            :                             StringPiece search_for,
<span class="lineNum">     321 </span>            :                             CompareCase case_sensitivity);
<span class="lineNum">     322 </span>            : BASE_EXPORT bool StartsWith(StringPiece16 str,
<span class="lineNum">     323 </span>            :                             StringPiece16 search_for,
<span class="lineNum">     324 </span>            :                             CompareCase case_sensitivity);
<span class="lineNum">     325 </span>            : BASE_EXPORT bool EndsWith(StringPiece str,
<span class="lineNum">     326 </span>            :                           StringPiece search_for,
<span class="lineNum">     327 </span>            :                           CompareCase case_sensitivity);
<span class="lineNum">     328 </span>            : BASE_EXPORT bool EndsWith(StringPiece16 str,
<span class="lineNum">     329 </span>            :                           StringPiece16 search_for,
<span class="lineNum">     330 </span>            :                           CompareCase case_sensitivity);
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : // Determines the type of ASCII character, independent of locale (the C
<span class="lineNum">     333 </span>            : // library versions will change based on locale).
<span class="lineNum">     334 </span>            : template &lt;typename Char&gt;
<span class="lineNum">     335 </span>            : inline bool IsAsciiWhitespace(Char c) {
<span class="lineNum">     336 </span>            :   return c == ' ' || c == '\r' || c == '\n' || c == '\t';
<span class="lineNum">     337 </span>            : }
<span class="lineNum">     338 </span>            : template &lt;typename Char&gt;
<span class="lineNum">     339 </span>            : inline bool IsAsciiAlpha(Char c) {
<span class="lineNum">     340 </span>            :   return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z');
<span class="lineNum">     341 </span>            : }
<span class="lineNum">     342 </span>            : template &lt;typename Char&gt;
<span class="lineNum">     343 </span>            : inline bool IsAsciiUpper(Char c) {
<span class="lineNum">     344 </span>            :   return c &gt;= 'A' &amp;&amp; c &lt;= 'Z';
<span class="lineNum">     345 </span>            : }
<span class="lineNum">     346 </span>            : template &lt;typename Char&gt;
<span class="lineNum">     347 </span>            : inline bool IsAsciiLower(Char c) {
<span class="lineNum">     348 </span>            :   return c &gt;= 'a' &amp;&amp; c &lt;= 'z';
<span class="lineNum">     349 </span>            : }
<span class="lineNum">     350 </span>            : template &lt;typename Char&gt;
<span class="lineNum">     351 </span>            : inline bool IsAsciiDigit(Char c) {
<span class="lineNum">     352 </span>            :   return c &gt;= '0' &amp;&amp; c &lt;= '9';
<span class="lineNum">     353 </span>            : }
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : template &lt;typename Char&gt;
<span class="lineNum">     356 </span>            : inline bool IsHexDigit(Char c) {
<span class="lineNum">     357 </span>            :   return (c &gt;= '0' &amp;&amp; c &lt;= '9') ||
<span class="lineNum">     358 </span>            :          (c &gt;= 'A' &amp;&amp; c &lt;= 'F') ||
<span class="lineNum">     359 </span>            :          (c &gt;= 'a' &amp;&amp; c &lt;= 'f');
<span class="lineNum">     360 </span>            : }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : // Returns the integer corresponding to the given hex character. For example:
<span class="lineNum">     363 </span>            : //    '4' -&gt; 4
<span class="lineNum">     364 </span>            : //    'a' -&gt; 10
<span class="lineNum">     365 </span>            : //    'B' -&gt; 11
<span class="lineNum">     366 </span>            : // Assumes the input is a valid hex character. DCHECKs in debug builds if not.
<span class="lineNum">     367 </span>            : BASE_EXPORT char HexDigitToInt(wchar_t c);
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : // Returns true if it's a Unicode whitespace character.
<span class="lineNum">     370 </span>            : BASE_EXPORT bool IsUnicodeWhitespace(wchar_t c);
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : // Return a byte string in human-readable format with a unit suffix. Not
<span class="lineNum">     373 </span>            : // appropriate for use in any UI; use of FormatBytes and friends in ui/base is
<span class="lineNum">     374 </span>            : // highly recommended instead. TODO(avi): Figure out how to get callers to use
<span class="lineNum">     375 </span>            : // FormatBytes instead; remove this.
<span class="lineNum">     376 </span>            : BASE_EXPORT string16 FormatBytesUnlocalized(int64_t bytes);
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            : // Starting at |start_offset| (usually 0), replace the first instance of
<span class="lineNum">     379 </span>            : // |find_this| with |replace_with|.
<span class="lineNum">     380 </span>            : BASE_EXPORT void ReplaceFirstSubstringAfterOffset(
<span class="lineNum">     381 </span>            :     base::string16* str,
<span class="lineNum">     382 </span>            :     size_t start_offset,
<span class="lineNum">     383 </span>            :     StringPiece16 find_this,
<span class="lineNum">     384 </span>            :     StringPiece16 replace_with);
<span class="lineNum">     385 </span>            : BASE_EXPORT void ReplaceFirstSubstringAfterOffset(
<span class="lineNum">     386 </span>            :     std::string* str,
<span class="lineNum">     387 </span>            :     size_t start_offset,
<span class="lineNum">     388 </span>            :     StringPiece find_this,
<span class="lineNum">     389 </span>            :     StringPiece replace_with);
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : // Starting at |start_offset| (usually 0), look through |str| and replace all
<span class="lineNum">     392 </span>            : // instances of |find_this| with |replace_with|.
<span class="lineNum">     393 </span>            : //
<span class="lineNum">     394 </span>            : // This does entire substrings; use std::replace in &lt;algorithm&gt; for single
<span class="lineNum">     395 </span>            : // characters, for example:
<span class="lineNum">     396 </span>            : //   std::replace(str.begin(), str.end(), 'a', 'b');
<span class="lineNum">     397 </span>            : BASE_EXPORT void ReplaceSubstringsAfterOffset(
<span class="lineNum">     398 </span>            :     string16* str,
<span class="lineNum">     399 </span>            :     size_t start_offset,
<span class="lineNum">     400 </span>            :     StringPiece16 find_this,
<span class="lineNum">     401 </span>            :     StringPiece16 replace_with);
<span class="lineNum">     402 </span>            : BASE_EXPORT void ReplaceSubstringsAfterOffset(
<span class="lineNum">     403 </span>            :     std::string* str,
<span class="lineNum">     404 </span>            :     size_t start_offset,
<span class="lineNum">     405 </span>            :     StringPiece find_this,
<span class="lineNum">     406 </span>            :     StringPiece replace_with);
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : // Reserves enough memory in |str| to accommodate |length_with_null| characters,
<span class="lineNum">     409 </span>            : // sets the size of |str| to |length_with_null - 1| characters, and returns a
<span class="lineNum">     410 </span>            : // pointer to the underlying contiguous array of characters.  This is typically
<span class="lineNum">     411 </span>            : // used when calling a function that writes results into a character array, but
<span class="lineNum">     412 </span>            : // the caller wants the data to be managed by a string-like object.  It is
<span class="lineNum">     413 </span>            : // convenient in that is can be used inline in the call, and fast in that it
<span class="lineNum">     414 </span>            : // avoids copying the results of the call from a char* into a string.
<span class="lineNum">     415 </span>            : //
<span class="lineNum">     416 </span>            : // |length_with_null| must be at least 2, since otherwise the underlying string
<span class="lineNum">     417 </span>            : // would have size 0, and trying to access &amp;((*str)[0]) in that case can result
<span class="lineNum">     418 </span>            : // in a number of problems.
<span class="lineNum">     419 </span>            : //
<span class="lineNum">     420 </span>            : // Internally, this takes linear time because the resize() call 0-fills the
<span class="lineNum">     421 </span>            : // underlying array for potentially all
<span class="lineNum">     422 </span>            : // (|length_with_null - 1| * sizeof(string_type::value_type)) bytes.  Ideally we
<span class="lineNum">     423 </span>            : // could avoid this aspect of the resize() call, as we expect the caller to
<span class="lineNum">     424 </span>            : // immediately write over this memory, but there is no other way to set the size
<span class="lineNum">     425 </span>            : // of the string, and not doing that will mean people who access |str| rather
<span class="lineNum">     426 </span>            : // than str.c_str() will get back a string of whatever size |str| had on entry
<span class="lineNum">     427 </span>            : // to this function (probably 0).
<span class="lineNum">     428 </span>            : BASE_EXPORT char* WriteInto(std::string* str, size_t length_with_null);
<span class="lineNum">     429 </span>            : BASE_EXPORT char16* WriteInto(string16* str, size_t length_with_null);
<span class="lineNum">     430 </span>            : #ifndef OS_WIN
<span class="lineNum">     431 </span>            : BASE_EXPORT wchar_t* WriteInto(std::wstring* str, size_t length_with_null);
<span class="lineNum">     432 </span>            : #endif
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            : // Does the opposite of SplitString().
<span class="lineNum">     435 </span>            : BASE_EXPORT std::string JoinString(const std::vector&lt;std::string&gt;&amp; parts,
<span class="lineNum">     436 </span>            :                                    StringPiece separator);
<span class="lineNum">     437 </span>            : BASE_EXPORT string16 JoinString(const std::vector&lt;string16&gt;&amp; parts,
<span class="lineNum">     438 </span>            :                                 StringPiece16 separator);
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : // Replace $1-$2-$3..$9 in the format string with values from |subst|.
<span class="lineNum">     441 </span>            : // Additionally, any number of consecutive '$' characters is replaced by that
<span class="lineNum">     442 </span>            : // number less one. Eg $$-&gt;$, $$$-&gt;$$, etc. The offsets parameter here can be
<span class="lineNum">     443 </span>            : // NULL. This only allows you to use up to nine replacements.
<span class="lineNum">     444 </span>            : BASE_EXPORT string16 ReplaceStringPlaceholders(
<span class="lineNum">     445 </span>            :     const string16&amp; format_string,
<span class="lineNum">     446 </span>            :     const std::vector&lt;string16&gt;&amp; subst,
<span class="lineNum">     447 </span>            :     std::vector&lt;size_t&gt;* offsets);
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : BASE_EXPORT std::string ReplaceStringPlaceholders(
<span class="lineNum">     450 </span>            :     const StringPiece&amp; format_string,
<span class="lineNum">     451 </span>            :     const std::vector&lt;std::string&gt;&amp; subst,
<span class="lineNum">     452 </span>            :     std::vector&lt;size_t&gt;* offsets);
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : // Single-string shortcut for ReplaceStringHolders. |offset| may be NULL.
<span class="lineNum">     455 </span>            : BASE_EXPORT string16 ReplaceStringPlaceholders(const string16&amp; format_string,
<span class="lineNum">     456 </span>            :                                                const string16&amp; a,
<span class="lineNum">     457 </span>            :                                                size_t* offset);
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : }  // namespace base
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : #if defined(OS_WIN)
<span class="lineNum">     462 </span>            : #include &quot;base/strings/string_util_win.h&quot;
<span class="lineNum">     463 </span>            : #elif defined(OS_POSIX)
<span class="lineNum">     464 </span>            : #include &quot;base/strings/string_util_posix.h&quot;
<span class="lineNum">     465 </span>            : #else
<span class="lineNum">     466 </span>            : #error Define string operations appropriately for your platform
<span class="lineNum">     467 </span>            : #endif
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : #endif  // BASE_STRINGS_STRING_UTIL_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
