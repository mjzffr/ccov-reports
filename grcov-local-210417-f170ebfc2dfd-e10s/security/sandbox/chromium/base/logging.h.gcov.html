<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/sandbox/chromium/base/logging.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">security/sandbox/chromium/base</a> - logging.h<span style="font-size: 80%;"> (source / <a href="logging.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2012 The Chromium Authors. All rights reserved.</a>
<span class="lineNum">       2 </span>            : // Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       3 </span>            : // found in the LICENSE file.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #ifndef BASE_LOGGING_H_
<span class="lineNum">       6 </span>            : #define BASE_LOGGING_H_
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;cassert&gt;
<span class="lineNum">      11 </span>            : #include &lt;cstring&gt;
<span class="lineNum">      12 </span>            : #include &lt;sstream&gt;
<span class="lineNum">      13 </span>            : #include &lt;string&gt;
<span class="lineNum">      14 </span>            : #include &lt;type_traits&gt;
<span class="lineNum">      15 </span>            : #include &lt;utility&gt;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;base/base_export.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;base/debug/debugger.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;base/macros.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;base/template_util.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;build/build_config.h&quot;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : //
<span class="lineNum">      24 </span>            : // Optional message capabilities
<span class="lineNum">      25 </span>            : // -----------------------------
<span class="lineNum">      26 </span>            : // Assertion failed messages and fatal errors are displayed in a dialog box
<span class="lineNum">      27 </span>            : // before the application exits. However, running this UI creates a message
<span class="lineNum">      28 </span>            : // loop, which causes application messages to be processed and potentially
<span class="lineNum">      29 </span>            : // dispatched to existing application windows. Since the application is in a
<span class="lineNum">      30 </span>            : // bad state when this assertion dialog is displayed, these messages may not
<span class="lineNum">      31 </span>            : // get processed and hang the dialog, or the application might go crazy.
<span class="lineNum">      32 </span>            : //
<span class="lineNum">      33 </span>            : // Therefore, it can be beneficial to display the error dialog in a separate
<span class="lineNum">      34 </span>            : // process from the main application. When the logging system needs to display
<span class="lineNum">      35 </span>            : // a fatal error dialog box, it will look for a program called
<span class="lineNum">      36 </span>            : // &quot;DebugMessage.exe&quot; in the same directory as the application executable. It
<span class="lineNum">      37 </span>            : // will run this application with the message as the command line, and will
<span class="lineNum">      38 </span>            : // not include the name of the application as is traditional for easier
<span class="lineNum">      39 </span>            : // parsing.
<span class="lineNum">      40 </span>            : //
<span class="lineNum">      41 </span>            : // The code for DebugMessage.exe is only one line. In WinMain, do:
<span class="lineNum">      42 </span>            : //   MessageBox(NULL, GetCommandLineW(), L&quot;Fatal Error&quot;, 0);
<span class="lineNum">      43 </span>            : //
<span class="lineNum">      44 </span>            : // If DebugMessage.exe is not found, the logging code will use a normal
<span class="lineNum">      45 </span>            : // MessageBox, potentially causing the problems discussed above.
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : // Instructions
<span class="lineNum">      49 </span>            : // ------------
<span class="lineNum">      50 </span>            : //
<span class="lineNum">      51 </span>            : // Make a bunch of macros for logging.  The way to log things is to stream
<span class="lineNum">      52 </span>            : // things to LOG(&lt;a particular severity level&gt;).  E.g.,
<span class="lineNum">      53 </span>            : //
<span class="lineNum">      54 </span>            : //   LOG(INFO) &lt;&lt; &quot;Found &quot; &lt;&lt; num_cookies &lt;&lt; &quot; cookies&quot;;
<span class="lineNum">      55 </span>            : //
<span class="lineNum">      56 </span>            : // You can also do conditional logging:
<span class="lineNum">      57 </span>            : //
<span class="lineNum">      58 </span>            : //   LOG_IF(INFO, num_cookies &gt; 10) &lt;&lt; &quot;Got lots of cookies&quot;;
<span class="lineNum">      59 </span>            : //
<span class="lineNum">      60 </span>            : // The CHECK(condition) macro is active in both debug and release builds and
<span class="lineNum">      61 </span>            : // effectively performs a LOG(FATAL) which terminates the process and
<span class="lineNum">      62 </span>            : // generates a crashdump unless a debugger is attached.
<span class="lineNum">      63 </span>            : //
<span class="lineNum">      64 </span>            : // There are also &quot;debug mode&quot; logging macros like the ones above:
<span class="lineNum">      65 </span>            : //
<span class="lineNum">      66 </span>            : //   DLOG(INFO) &lt;&lt; &quot;Found cookies&quot;;
<span class="lineNum">      67 </span>            : //
<span class="lineNum">      68 </span>            : //   DLOG_IF(INFO, num_cookies &gt; 10) &lt;&lt; &quot;Got lots of cookies&quot;;
<span class="lineNum">      69 </span>            : //
<span class="lineNum">      70 </span>            : // All &quot;debug mode&quot; logging is compiled away to nothing for non-debug mode
<span class="lineNum">      71 </span>            : // compiles.  LOG_IF and development flags also work well together
<span class="lineNum">      72 </span>            : // because the code can be compiled away sometimes.
<span class="lineNum">      73 </span>            : //
<span class="lineNum">      74 </span>            : // We also have
<span class="lineNum">      75 </span>            : //
<span class="lineNum">      76 </span>            : //   LOG_ASSERT(assertion);
<span class="lineNum">      77 </span>            : //   DLOG_ASSERT(assertion);
<span class="lineNum">      78 </span>            : //
<span class="lineNum">      79 </span>            : // which is syntactic sugar for {,D}LOG_IF(FATAL, assert fails) &lt;&lt; assertion;
<span class="lineNum">      80 </span>            : //
<span class="lineNum">      81 </span>            : // There are &quot;verbose level&quot; logging macros.  They look like
<span class="lineNum">      82 </span>            : //
<span class="lineNum">      83 </span>            : //   VLOG(1) &lt;&lt; &quot;I'm printed when you run the program with --v=1 or more&quot;;
<span class="lineNum">      84 </span>            : //   VLOG(2) &lt;&lt; &quot;I'm printed when you run the program with --v=2 or more&quot;;
<span class="lineNum">      85 </span>            : //
<span class="lineNum">      86 </span>            : // These always log at the INFO log level (when they log at all).
<span class="lineNum">      87 </span>            : // The verbose logging can also be turned on module-by-module.  For instance,
<span class="lineNum">      88 </span>            : //    --vmodule=profile=2,icon_loader=1,browser_*=3,*/chromeos/*=4 --v=0
<span class="lineNum">      89 </span>            : // will cause:
<span class="lineNum">      90 </span>            : //   a. VLOG(2) and lower messages to be printed from profile.{h,cc}
<span class="lineNum">      91 </span>            : //   b. VLOG(1) and lower messages to be printed from icon_loader.{h,cc}
<span class="lineNum">      92 </span>            : //   c. VLOG(3) and lower messages to be printed from files prefixed with
<span class="lineNum">      93 </span>            : //      &quot;browser&quot;
<span class="lineNum">      94 </span>            : //   d. VLOG(4) and lower messages to be printed from files under a
<span class="lineNum">      95 </span>            : //     &quot;chromeos&quot; directory.
<span class="lineNum">      96 </span>            : //   e. VLOG(0) and lower messages to be printed from elsewhere
<span class="lineNum">      97 </span>            : //
<span class="lineNum">      98 </span>            : // The wildcarding functionality shown by (c) supports both '*' (match
<span class="lineNum">      99 </span>            : // 0 or more characters) and '?' (match any single character)
<span class="lineNum">     100 </span>            : // wildcards.  Any pattern containing a forward or backward slash will
<span class="lineNum">     101 </span>            : // be tested against the whole pathname and not just the module.
<span class="lineNum">     102 </span>            : // E.g., &quot;*/foo/bar/*=2&quot; would change the logging level for all code
<span class="lineNum">     103 </span>            : // in source files under a &quot;foo/bar&quot; directory.
<span class="lineNum">     104 </span>            : //
<span class="lineNum">     105 </span>            : // There's also VLOG_IS_ON(n) &quot;verbose level&quot; condition macro. To be used as
<span class="lineNum">     106 </span>            : //
<span class="lineNum">     107 </span>            : //   if (VLOG_IS_ON(2)) {
<span class="lineNum">     108 </span>            : //     // do some logging preparation and logging
<span class="lineNum">     109 </span>            : //     // that can't be accomplished with just VLOG(2) &lt;&lt; ...;
<span class="lineNum">     110 </span>            : //   }
<span class="lineNum">     111 </span>            : //
<span class="lineNum">     112 </span>            : // There is also a VLOG_IF &quot;verbose level&quot; condition macro for sample
<span class="lineNum">     113 </span>            : // cases, when some extra computation and preparation for logs is not
<span class="lineNum">     114 </span>            : // needed.
<span class="lineNum">     115 </span>            : //
<span class="lineNum">     116 </span>            : //   VLOG_IF(1, (size &gt; 1024))
<span class="lineNum">     117 </span>            : //      &lt;&lt; &quot;I'm printed when size is more than 1024 and when you run the &quot;
<span class="lineNum">     118 </span>            : //         &quot;program with --v=1 or more&quot;;
<span class="lineNum">     119 </span>            : //
<span class="lineNum">     120 </span>            : // We also override the standard 'assert' to use 'DLOG_ASSERT'.
<span class="lineNum">     121 </span>            : //
<span class="lineNum">     122 </span>            : // Lastly, there is:
<span class="lineNum">     123 </span>            : //
<span class="lineNum">     124 </span>            : //   PLOG(ERROR) &lt;&lt; &quot;Couldn't do foo&quot;;
<span class="lineNum">     125 </span>            : //   DPLOG(ERROR) &lt;&lt; &quot;Couldn't do foo&quot;;
<span class="lineNum">     126 </span>            : //   PLOG_IF(ERROR, cond) &lt;&lt; &quot;Couldn't do foo&quot;;
<span class="lineNum">     127 </span>            : //   DPLOG_IF(ERROR, cond) &lt;&lt; &quot;Couldn't do foo&quot;;
<span class="lineNum">     128 </span>            : //   PCHECK(condition) &lt;&lt; &quot;Couldn't do foo&quot;;
<span class="lineNum">     129 </span>            : //   DPCHECK(condition) &lt;&lt; &quot;Couldn't do foo&quot;;
<span class="lineNum">     130 </span>            : //
<span class="lineNum">     131 </span>            : // which append the last system error to the message in string form (taken from
<span class="lineNum">     132 </span>            : // GetLastError() on Windows and errno on POSIX).
<span class="lineNum">     133 </span>            : //
<span class="lineNum">     134 </span>            : // The supported severity levels for macros that allow you to specify one
<span class="lineNum">     135 </span>            : // are (in increasing order of severity) INFO, WARNING, ERROR, and FATAL.
<span class="lineNum">     136 </span>            : //
<span class="lineNum">     137 </span>            : // Very important: logging a message at the FATAL severity level causes
<span class="lineNum">     138 </span>            : // the program to terminate (after the message is logged).
<span class="lineNum">     139 </span>            : //
<span class="lineNum">     140 </span>            : // There is the special severity of DFATAL, which logs FATAL in debug mode,
<span class="lineNum">     141 </span>            : // ERROR in normal mode.
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : namespace logging {
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : // TODO(avi): do we want to do a unification of character types here?
<span class="lineNum">     146 </span>            : #if defined(OS_WIN)
<span class="lineNum">     147 </span>            : typedef wchar_t PathChar;
<span class="lineNum">     148 </span>            : #else
<span class="lineNum">     149 </span>            : typedef char PathChar;
<span class="lineNum">     150 </span>            : #endif
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            : // Where to record logging output? A flat file and/or system debug log
<span class="lineNum">     153 </span>            : // via OutputDebugString.
<span class="lineNum">     154 </span>            : enum LoggingDestination {
<span class="lineNum">     155 </span>            :   LOG_NONE                = 0,
<span class="lineNum">     156 </span>            :   LOG_TO_FILE             = 1 &lt;&lt; 0,
<span class="lineNum">     157 </span>            :   LOG_TO_SYSTEM_DEBUG_LOG = 1 &lt;&lt; 1,
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :   LOG_TO_ALL = LOG_TO_FILE | LOG_TO_SYSTEM_DEBUG_LOG,
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :   // On Windows, use a file next to the exe; on POSIX platforms, where
<span class="lineNum">     162 </span>            :   // it may not even be possible to locate the executable on disk, use
<span class="lineNum">     163 </span>            :   // stderr.
<span class="lineNum">     164 </span>            : #if defined(OS_WIN)
<span class="lineNum">     165 </span>            :   LOG_DEFAULT = LOG_TO_FILE,
<span class="lineNum">     166 </span>            : #elif defined(OS_POSIX)
<span class="lineNum">     167 </span>            :   LOG_DEFAULT = LOG_TO_SYSTEM_DEBUG_LOG,
<span class="lineNum">     168 </span>            : #endif
<span class="lineNum">     169 </span>            : };
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : // Indicates that the log file should be locked when being written to.
<span class="lineNum">     172 </span>            : // Unless there is only one single-threaded process that is logging to
<span class="lineNum">     173 </span>            : // the log file, the file should be locked during writes to make each
<span class="lineNum">     174 </span>            : // log output atomic. Other writers will block.
<span class="lineNum">     175 </span>            : //
<span class="lineNum">     176 </span>            : // All processes writing to the log file must have their locking set for it to
<span class="lineNum">     177 </span>            : // work properly. Defaults to LOCK_LOG_FILE.
<span class="lineNum">     178 </span>            : enum LogLockingState { LOCK_LOG_FILE, DONT_LOCK_LOG_FILE };
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : // On startup, should we delete or append to an existing log file (if any)?
<span class="lineNum">     181 </span>            : // Defaults to APPEND_TO_OLD_LOG_FILE.
<span class="lineNum">     182 </span>            : enum OldFileDeletionState { DELETE_OLD_LOG_FILE, APPEND_TO_OLD_LOG_FILE };
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : struct BASE_EXPORT LoggingSettings {
<span class="lineNum">     185 </span>            :   // The defaults values are:
<span class="lineNum">     186 </span>            :   //
<span class="lineNum">     187 </span>            :   //  logging_dest: LOG_DEFAULT
<span class="lineNum">     188 </span>            :   //  log_file:     NULL
<span class="lineNum">     189 </span>            :   //  lock_log:     LOCK_LOG_FILE
<span class="lineNum">     190 </span>            :   //  delete_old:   APPEND_TO_OLD_LOG_FILE
<span class="lineNum">     191 </span>            :   LoggingSettings();
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   LoggingDestination logging_dest;
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   // The three settings below have an effect only when LOG_TO_FILE is
<span class="lineNum">     196 </span>            :   // set in |logging_dest|.
<span class="lineNum">     197 </span>            :   const PathChar* log_file;
<span class="lineNum">     198 </span>            :   LogLockingState lock_log;
<span class="lineNum">     199 </span>            :   OldFileDeletionState delete_old;
<span class="lineNum">     200 </span>            : };
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : // Define different names for the BaseInitLoggingImpl() function depending on
<span class="lineNum">     203 </span>            : // whether NDEBUG is defined or not so that we'll fail to link if someone tries
<span class="lineNum">     204 </span>            : // to compile logging.cc with NDEBUG but includes logging.h without defining it,
<span class="lineNum">     205 </span>            : // or vice versa.
<span class="lineNum">     206 </span>            : #if NDEBUG
<span class="lineNum">     207 </span>            : #define BaseInitLoggingImpl BaseInitLoggingImpl_built_with_NDEBUG
<span class="lineNum">     208 </span>            : #else
<span class="lineNum">     209 </span>            : #define BaseInitLoggingImpl BaseInitLoggingImpl_built_without_NDEBUG
<span class="lineNum">     210 </span>            : #endif
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : // Implementation of the InitLogging() method declared below.  We use a
<span class="lineNum">     213 </span>            : // more-specific name so we can #define it above without affecting other code
<span class="lineNum">     214 </span>            : // that has named stuff &quot;InitLogging&quot;.
<span class="lineNum">     215 </span>            : BASE_EXPORT bool BaseInitLoggingImpl(const LoggingSettings&amp; settings);
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : // Sets the log file name and other global logging state. Calling this function
<span class="lineNum">     218 </span>            : // is recommended, and is normally done at the beginning of application init.
<span class="lineNum">     219 </span>            : // If you don't call it, all the flags will be initialized to their default
<span class="lineNum">     220 </span>            : // values, and there is a race condition that may leak a critical section
<span class="lineNum">     221 </span>            : // object if two threads try to do the first log at the same time.
<span class="lineNum">     222 </span>            : // See the definition of the enums above for descriptions and default values.
<span class="lineNum">     223 </span>            : //
<span class="lineNum">     224 </span>            : // The default log file is initialized to &quot;debug.log&quot; in the application
<span class="lineNum">     225 </span>            : // directory. You probably don't want this, especially since the program
<span class="lineNum">     226 </span>            : // directory may not be writable on an enduser's system.
<span class="lineNum">     227 </span>            : //
<span class="lineNum">     228 </span>            : // This function may be called a second time to re-direct logging (e.g after
<span class="lineNum">     229 </span>            : // loging in to a user partition), however it should never be called more than
<span class="lineNum">     230 </span>            : // twice.
<span class="lineNum">     231 </span>            : inline bool InitLogging(const LoggingSettings&amp; settings) {
<span class="lineNum">     232 </span>            :   return BaseInitLoggingImpl(settings);
<span class="lineNum">     233 </span>            : }
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : // Sets the log level. Anything at or above this level will be written to the
<span class="lineNum">     236 </span>            : // log file/displayed to the user (if applicable). Anything below this level
<span class="lineNum">     237 </span>            : // will be silently ignored. The log level defaults to 0 (everything is logged
<span class="lineNum">     238 </span>            : // up to level INFO) if this function is not called.
<span class="lineNum">     239 </span>            : // Note that log messages for VLOG(x) are logged at level -x, so setting
<span class="lineNum">     240 </span>            : // the min log level to negative values enables verbose logging.
<span class="lineNum">     241 </span>            : BASE_EXPORT void SetMinLogLevel(int level);
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : // Gets the current log level.
<span class="lineNum">     244 </span>            : BASE_EXPORT int GetMinLogLevel();
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : // Used by LOG_IS_ON to lazy-evaluate stream arguments.
<span class="lineNum">     247 </span>            : BASE_EXPORT bool ShouldCreateLogMessage(int severity);
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : // Gets the VLOG default verbosity level.
<span class="lineNum">     250 </span>            : BASE_EXPORT int GetVlogVerbosity();
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : // Gets the current vlog level for the given file (usually taken from
<span class="lineNum">     253 </span>            : // __FILE__).
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : // Note that |N| is the size *with* the null terminator.
<span class="lineNum">     256 </span>            : BASE_EXPORT int GetVlogLevelHelper(const char* file_start, size_t N);
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : template &lt;size_t N&gt;
<span class="lineNum">     259 </span>            : int GetVlogLevel(const char (&amp;file)[N]) {
<span class="lineNum">     260 </span>            :   return GetVlogLevelHelper(file, N);
<span class="lineNum">     261 </span>            : }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : // Sets the common items you want to be prepended to each log message.
<span class="lineNum">     264 </span>            : // process and thread IDs default to off, the timestamp defaults to on.
<span class="lineNum">     265 </span>            : // If this function is not called, logging defaults to writing the timestamp
<span class="lineNum">     266 </span>            : // only.
<span class="lineNum">     267 </span>            : BASE_EXPORT void SetLogItems(bool enable_process_id, bool enable_thread_id,
<span class="lineNum">     268 </span>            :                              bool enable_timestamp, bool enable_tickcount);
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : // Sets whether or not you'd like to see fatal debug messages popped up in
<span class="lineNum">     271 </span>            : // a dialog box or not.
<span class="lineNum">     272 </span>            : // Dialogs are not shown by default.
<span class="lineNum">     273 </span>            : BASE_EXPORT void SetShowErrorDialogs(bool enable_dialogs);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : // Sets the Log Assert Handler that will be used to notify of check failures.
<span class="lineNum">     276 </span>            : // The default handler shows a dialog box and then terminate the process,
<span class="lineNum">     277 </span>            : // however clients can use this function to override with their own handling
<span class="lineNum">     278 </span>            : // (e.g. a silent one for Unit Tests)
<span class="lineNum">     279 </span>            : typedef void (*LogAssertHandlerFunction)(const std::string&amp; str);
<span class="lineNum">     280 </span>            : BASE_EXPORT void SetLogAssertHandler(LogAssertHandlerFunction handler);
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : // Sets the Log Message Handler that gets passed every log message before
<span class="lineNum">     283 </span>            : // it's sent to other log destinations (if any).
<span class="lineNum">     284 </span>            : // Returns true to signal that it handled the message and the message
<span class="lineNum">     285 </span>            : // should not be sent to other log destinations.
<span class="lineNum">     286 </span>            : typedef bool (*LogMessageHandlerFunction)(int severity,
<span class="lineNum">     287 </span>            :     const char* file, int line, size_t message_start, const std::string&amp; str);
<span class="lineNum">     288 </span>            : BASE_EXPORT void SetLogMessageHandler(LogMessageHandlerFunction handler);
<span class="lineNum">     289 </span>            : BASE_EXPORT LogMessageHandlerFunction GetLogMessageHandler();
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : typedef int LogSeverity;
<span class="lineNum">     292 </span>            : const LogSeverity LOG_VERBOSE = -1;  // This is level 1 verbosity
<span class="lineNum">     293 </span>            : // Note: the log severities are used to index into the array of names,
<span class="lineNum">     294 </span>            : // see log_severity_names.
<span class="lineNum">     295 </span>            : const LogSeverity LOG_INFO = 0;
<span class="lineNum">     296 </span>            : const LogSeverity LOG_WARNING = 1;
<span class="lineNum">     297 </span>            : const LogSeverity LOG_ERROR = 2;
<span class="lineNum">     298 </span>            : const LogSeverity LOG_FATAL = 3;
<span class="lineNum">     299 </span>            : const LogSeverity LOG_NUM_SEVERITIES = 4;
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : // LOG_DFATAL is LOG_FATAL in debug mode, ERROR in normal mode
<span class="lineNum">     302 </span>            : #ifdef NDEBUG
<span class="lineNum">     303 </span>            : const LogSeverity LOG_DFATAL = LOG_ERROR;
<span class="lineNum">     304 </span>            : #else
<span class="lineNum">     305 </span>            : const LogSeverity LOG_DFATAL = LOG_FATAL;
<span class="lineNum">     306 </span>            : #endif
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : // A few definitions of macros that don't generate much code. These are used
<span class="lineNum">     309 </span>            : // by LOG() and LOG_IF, etc. Since these are used all over our code, it's
<span class="lineNum">     310 </span>            : // better to have compact code for these operations.
<span class="lineNum">     311 </span>            : #define COMPACT_GOOGLE_LOG_EX_INFO(ClassName, ...) \
<span class="lineNum">     312 </span>            :   ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_INFO, ##__VA_ARGS__)
<span class="lineNum">     313 </span>            : #define COMPACT_GOOGLE_LOG_EX_WARNING(ClassName, ...)              \
<span class="lineNum">     314 </span>            :   ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_WARNING, \
<span class="lineNum">     315 </span>            :                        ##__VA_ARGS__)
<span class="lineNum">     316 </span>            : #define COMPACT_GOOGLE_LOG_EX_ERROR(ClassName, ...) \
<span class="lineNum">     317 </span>            :   ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_ERROR, ##__VA_ARGS__)
<span class="lineNum">     318 </span>            : #define COMPACT_GOOGLE_LOG_EX_FATAL(ClassName, ...) \
<span class="lineNum">     319 </span>            :   ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_FATAL, ##__VA_ARGS__)
<span class="lineNum">     320 </span>            : #define COMPACT_GOOGLE_LOG_EX_DFATAL(ClassName, ...) \
<span class="lineNum">     321 </span>            :   ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_DFATAL, ##__VA_ARGS__)
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : #define COMPACT_GOOGLE_LOG_INFO \
<span class="lineNum">     324 </span>            :   COMPACT_GOOGLE_LOG_EX_INFO(LogMessage)
<span class="lineNum">     325 </span>            : #define COMPACT_GOOGLE_LOG_WARNING \
<span class="lineNum">     326 </span>            :   COMPACT_GOOGLE_LOG_EX_WARNING(LogMessage)
<span class="lineNum">     327 </span>            : #define COMPACT_GOOGLE_LOG_ERROR \
<span class="lineNum">     328 </span>            :   COMPACT_GOOGLE_LOG_EX_ERROR(LogMessage)
<span class="lineNum">     329 </span>            : #define COMPACT_GOOGLE_LOG_FATAL \
<span class="lineNum">     330 </span>            :   COMPACT_GOOGLE_LOG_EX_FATAL(LogMessage)
<span class="lineNum">     331 </span>            : #define COMPACT_GOOGLE_LOG_DFATAL \
<span class="lineNum">     332 </span>            :   COMPACT_GOOGLE_LOG_EX_DFATAL(LogMessage)
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : #if defined(OS_WIN)
<span class="lineNum">     335 </span>            : // wingdi.h defines ERROR to be 0. When we call LOG(ERROR), it gets
<span class="lineNum">     336 </span>            : // substituted with 0, and it expands to COMPACT_GOOGLE_LOG_0. To allow us
<span class="lineNum">     337 </span>            : // to keep using this syntax, we define this macro to do the same thing
<span class="lineNum">     338 </span>            : // as COMPACT_GOOGLE_LOG_ERROR, and also define ERROR the same way that
<span class="lineNum">     339 </span>            : // the Windows SDK does for consistency.
<span class="lineNum">     340 </span>            : #define ERROR 0
<span class="lineNum">     341 </span>            : #define COMPACT_GOOGLE_LOG_EX_0(ClassName, ...) \
<span class="lineNum">     342 </span>            :   COMPACT_GOOGLE_LOG_EX_ERROR(ClassName , ##__VA_ARGS__)
<span class="lineNum">     343 </span>            : #define COMPACT_GOOGLE_LOG_0 COMPACT_GOOGLE_LOG_ERROR
<span class="lineNum">     344 </span>            : // Needed for LOG_IS_ON(ERROR).
<span class="lineNum">     345 </span>            : const LogSeverity LOG_0 = LOG_ERROR;
<span class="lineNum">     346 </span>            : #endif
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : // As special cases, we can assume that LOG_IS_ON(FATAL) always holds. Also,
<span class="lineNum">     349 </span>            : // LOG_IS_ON(DFATAL) always holds in debug mode. In particular, CHECK()s will
<span class="lineNum">     350 </span>            : // always fire if they fail.
<span class="lineNum">     351 </span>            : #define LOG_IS_ON(severity) \
<span class="lineNum">     352 </span>            :   (::logging::ShouldCreateLogMessage(::logging::LOG_##severity))
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : // We can't do any caching tricks with VLOG_IS_ON() like the
<span class="lineNum">     355 </span>            : // google-glog version since it requires GCC extensions.  This means
<span class="lineNum">     356 </span>            : // that using the v-logging functions in conjunction with --vmodule
<span class="lineNum">     357 </span>            : // may be slow.
<span class="lineNum">     358 </span>            : #define VLOG_IS_ON(verboselevel) \
<span class="lineNum">     359 </span>            :   ((verboselevel) &lt;= ::logging::GetVlogLevel(__FILE__))
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : // Helper macro which avoids evaluating the arguments to a stream if
<span class="lineNum">     362 </span>            : // the condition doesn't hold. Condition is evaluated once and only once.
<span class="lineNum">     363 </span>            : #define LAZY_STREAM(stream, condition)                                  \
<span class="lineNum">     364 </span>            :   !(condition) ? (void) 0 : ::logging::LogMessageVoidify() &amp; (stream)
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : // We use the preprocessor's merging operator, &quot;##&quot;, so that, e.g.,
<span class="lineNum">     367 </span>            : // LOG(INFO) becomes the token COMPACT_GOOGLE_LOG_INFO.  There's some funny
<span class="lineNum">     368 </span>            : // subtle difference between ostream member streaming functions (e.g.,
<span class="lineNum">     369 </span>            : // ostream::operator&lt;&lt;(int) and ostream non-member streaming functions
<span class="lineNum">     370 </span>            : // (e.g., ::operator&lt;&lt;(ostream&amp;, string&amp;): it turns out that it's
<span class="lineNum">     371 </span>            : // impossible to stream something like a string directly to an unnamed
<span class="lineNum">     372 </span>            : // ostream. We employ a neat hack by calling the stream() member
<span class="lineNum">     373 </span>            : // function of LogMessage which seems to avoid the problem.
<span class="lineNum">     374 </span>            : #define LOG_STREAM(severity) COMPACT_GOOGLE_LOG_ ## severity.stream()
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : #define LOG(severity) LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity))
<span class="lineNum">     377 </span>            : #define LOG_IF(severity, condition) \
<span class="lineNum">     378 </span>            :   LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity) &amp;&amp; (condition))
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : // The VLOG macros log with negative verbosities.
<span class="lineNum">     381 </span>            : #define VLOG_STREAM(verbose_level) \
<span class="lineNum">     382 </span>            :   ::logging::LogMessage(__FILE__, __LINE__, -verbose_level).stream()
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : #define VLOG(verbose_level) \
<span class="lineNum">     385 </span>            :   LAZY_STREAM(VLOG_STREAM(verbose_level), VLOG_IS_ON(verbose_level))
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : #define VLOG_IF(verbose_level, condition) \
<span class="lineNum">     388 </span>            :   LAZY_STREAM(VLOG_STREAM(verbose_level), \
<span class="lineNum">     389 </span>            :       VLOG_IS_ON(verbose_level) &amp;&amp; (condition))
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : #if defined (OS_WIN)
<span class="lineNum">     392 </span>            : #define VPLOG_STREAM(verbose_level) \
<span class="lineNum">     393 </span>            :   ::logging::Win32ErrorLogMessage(__FILE__, __LINE__, -verbose_level, \
<span class="lineNum">     394 </span>            :     ::logging::GetLastSystemErrorCode()).stream()
<span class="lineNum">     395 </span>            : #elif defined(OS_POSIX)
<span class="lineNum">     396 </span>            : #define VPLOG_STREAM(verbose_level) \
<span class="lineNum">     397 </span>            :   ::logging::ErrnoLogMessage(__FILE__, __LINE__, -verbose_level, \
<span class="lineNum">     398 </span>            :     ::logging::GetLastSystemErrorCode()).stream()
<span class="lineNum">     399 </span>            : #endif
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            : #define VPLOG(verbose_level) \
<span class="lineNum">     402 </span>            :   LAZY_STREAM(VPLOG_STREAM(verbose_level), VLOG_IS_ON(verbose_level))
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            : #define VPLOG_IF(verbose_level, condition) \
<span class="lineNum">     405 </span>            :   LAZY_STREAM(VPLOG_STREAM(verbose_level), \
<span class="lineNum">     406 </span>            :     VLOG_IS_ON(verbose_level) &amp;&amp; (condition))
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : // TODO(akalin): Add more VLOG variants, e.g. VPLOG.
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : #define LOG_ASSERT(condition)  \
<span class="lineNum">     411 </span>            :   LOG_IF(FATAL, !(condition)) &lt;&lt; &quot;Assert failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : #if defined(OS_WIN)
<span class="lineNum">     414 </span>            : #define PLOG_STREAM(severity) \
<span class="lineNum">     415 </span>            :   COMPACT_GOOGLE_LOG_EX_ ## severity(Win32ErrorLogMessage, \
<span class="lineNum">     416 </span>            :       ::logging::GetLastSystemErrorCode()).stream()
<span class="lineNum">     417 </span>            : #elif defined(OS_POSIX)
<span class="lineNum">     418 </span>            : #define PLOG_STREAM(severity) \
<span class="lineNum">     419 </span>            :   COMPACT_GOOGLE_LOG_EX_ ## severity(ErrnoLogMessage, \
<span class="lineNum">     420 </span>            :       ::logging::GetLastSystemErrorCode()).stream()
<span class="lineNum">     421 </span>            : #endif
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : #define PLOG(severity)                                          \
<span class="lineNum">     424 </span>            :   LAZY_STREAM(PLOG_STREAM(severity), LOG_IS_ON(severity))
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : #define PLOG_IF(severity, condition) \
<span class="lineNum">     427 </span>            :   LAZY_STREAM(PLOG_STREAM(severity), LOG_IS_ON(severity) &amp;&amp; (condition))
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : // The actual stream used isn't important.
<span class="lineNum">     430 </span>            : #define EAT_STREAM_PARAMETERS                                           \
<span class="lineNum">     431 </span>            :   true ? (void) 0 : ::logging::LogMessageVoidify() &amp; LOG_STREAM(FATAL)
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : // Captures the result of a CHECK_EQ (for example) and facilitates testing as a
<span class="lineNum">     434 </span>            : // boolean.
<span class="lineNum">     435 </span>            : class CheckOpResult {
<span class="lineNum">     436 </span>            :  public:
<span class="lineNum">     437 </span>            :   // |message| must be non-null if and only if the check failed.
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   CheckOpResult(std::string* message) : message_(message) {}</span>
<span class="lineNum">     439 </span>            :   // Returns true if the check succeeded.
<span class="lineNum">     440 </span>            :   operator bool() const { return !message_; }
<span class="lineNum">     441 </span>            :   // Returns the message.
<span class="lineNum">     442 </span>            :   std::string* message() { return message_; }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :  private:
<span class="lineNum">     445 </span>            :   std::string* message_;
<span class="lineNum">     446 </span>            : };
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            : // CHECK dies with a fatal error if condition is not true.  It is *not*
<span class="lineNum">     449 </span>            : // controlled by NDEBUG, so the check will be executed regardless of
<span class="lineNum">     450 </span>            : // compilation mode.
<span class="lineNum">     451 </span>            : //
<span class="lineNum">     452 </span>            : // We make sure CHECK et al. always evaluates their arguments, as
<span class="lineNum">     453 </span>            : // doing CHECK(FunctionWithSideEffect()) is a common idiom.
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : #if defined(OFFICIAL_BUILD) &amp;&amp; defined(NDEBUG)
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : // Make all CHECK functions discard their log strings to reduce code
<span class="lineNum">     458 </span>            : // bloat, and improve performance, for official release builds.
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : #if defined(COMPILER_GCC) || __clang__
<span class="lineNum">     461 </span>            : #define LOGGING_CRASH() __builtin_trap()
<span class="lineNum">     462 </span>            : #else
<span class="lineNum">     463 </span>            : #define LOGGING_CRASH() ((void)(*(volatile char*)0 = 0))
<span class="lineNum">     464 </span>            : #endif
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : // This is not calling BreakDebugger since this is called frequently, and
<span class="lineNum">     467 </span>            : // calling an out-of-line function instead of a noreturn inline macro prevents
<span class="lineNum">     468 </span>            : // compiler optimizations.
<span class="lineNum">     469 </span>            : #define CHECK(condition)                                                \
<span class="lineNum">     470 </span>            :   !(condition) ? LOGGING_CRASH() : EAT_STREAM_PARAMETERS
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : #define PCHECK(condition) CHECK(condition)
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : #define CHECK_OP(name, op, val1, val2) CHECK((val1) op (val2))
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            : #else  // !(OFFICIAL_BUILD &amp;&amp; NDEBUG)
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : #if defined(_PREFAST_) &amp;&amp; defined(OS_WIN)
<span class="lineNum">     479 </span>            : // Use __analysis_assume to tell the VC++ static analysis engine that
<span class="lineNum">     480 </span>            : // assert conditions are true, to suppress warnings.  The LAZY_STREAM
<span class="lineNum">     481 </span>            : // parameter doesn't reference 'condition' in /analyze builds because
<span class="lineNum">     482 </span>            : // this evaluation confuses /analyze. The !! before condition is because
<span class="lineNum">     483 </span>            : // __analysis_assume gets confused on some conditions:
<span class="lineNum">     484 </span>            : // http://randomascii.wordpress.com/2011/09/13/analyze-for-visual-studio-the-ugly-part-5/
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : #define CHECK(condition)                \
<span class="lineNum">     487 </span>            :   __analysis_assume(!!(condition)),     \
<span class="lineNum">     488 </span>            :   LAZY_STREAM(LOG_STREAM(FATAL), false) \
<span class="lineNum">     489 </span>            :   &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : #define PCHECK(condition)                \
<span class="lineNum">     492 </span>            :   __analysis_assume(!!(condition)),      \
<span class="lineNum">     493 </span>            :   LAZY_STREAM(PLOG_STREAM(FATAL), false) \
<span class="lineNum">     494 </span>            :   &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : #else  // _PREFAST_
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : // Do as much work as possible out of line to reduce inline code size.
<span class="lineNum">     499 </span>            : #define CHECK(condition)                                                      \
<span class="lineNum">     500 </span>            :   LAZY_STREAM(::logging::LogMessage(__FILE__, __LINE__, #condition).stream(), \
<span class="lineNum">     501 </span>            :               !(condition))
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : #define PCHECK(condition)                       \
<span class="lineNum">     504 </span>            :   LAZY_STREAM(PLOG_STREAM(FATAL), !(condition)) \
<span class="lineNum">     505 </span>            :   &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            : #endif  // _PREFAST_
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : // Helper macro for binary operators.
<span class="lineNum">     510 </span>            : // Don't use this macro directly in your code, use CHECK_EQ et al below.
<span class="lineNum">     511 </span>            : // The 'switch' is used to prevent the 'else' from being ambiguous when the
<span class="lineNum">     512 </span>            : // macro is used in an 'if' clause such as:
<span class="lineNum">     513 </span>            : // if (a == 1)
<span class="lineNum">     514 </span>            : //   CHECK_EQ(2, a);
<span class="lineNum">     515 </span>            : #define CHECK_OP(name, op, val1, val2)                                         \
<span class="lineNum">     516 </span>            :   switch (0) case 0: default:                                                  \
<span class="lineNum">     517 </span>            :   if (::logging::CheckOpResult true_if_passed =                                \
<span class="lineNum">     518 </span>            :       ::logging::Check##name##Impl((val1), (val2),                             \
<span class="lineNum">     519 </span>            :                                    #val1 &quot; &quot; #op &quot; &quot; #val2))                   \
<span class="lineNum">     520 </span>            :    ;                                                                           \
<span class="lineNum">     521 </span>            :   else                                                                         \
<span class="lineNum">     522 </span>            :     ::logging::LogMessage(__FILE__, __LINE__, true_if_passed.message()).stream()
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : #endif  // !(OFFICIAL_BUILD &amp;&amp; NDEBUG)
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : // This formats a value for a failing CHECK_XX statement.  Ordinarily,
<span class="lineNum">     527 </span>            : // it uses the definition for operator&lt;&lt;, with a few special cases below.
<span class="lineNum">     528 </span>            : template &lt;typename T&gt;
<span class="lineNum">     529 </span>            : inline typename std::enable_if&lt;
<span class="lineNum">     530 </span>            :     base::internal::SupportsOstreamOperator&lt;const T&amp;&gt;::value,
<span class="lineNum">     531 </span>            :     void&gt;::type
<span class="lineNum">     532 </span>            : MakeCheckOpValueString(std::ostream* os, const T&amp; v) {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   (*os) &lt;&lt; v;</span>
<span class="lineNum">     534 </span>            : }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : // We need overloads for enums that don't support operator&lt;&lt;.
<span class="lineNum">     537 </span>            : // (i.e. scoped enums where no operator&lt;&lt; overload was declared).
<span class="lineNum">     538 </span>            : template &lt;typename T&gt;
<span class="lineNum">     539 </span>            : inline typename std::enable_if&lt;
<span class="lineNum">     540 </span>            :     !base::internal::SupportsOstreamOperator&lt;const T&amp;&gt;::value &amp;&amp;
<span class="lineNum">     541 </span>            :         std::is_enum&lt;T&gt;::value,
<span class="lineNum">     542 </span>            :     void&gt;::type
<span class="lineNum">     543 </span>            : MakeCheckOpValueString(std::ostream* os, const T&amp; v) {
<span class="lineNum">     544 </span>            :   (*os) &lt;&lt; static_cast&lt;typename base::underlying_type&lt;T&gt;::type&gt;(v);
<span class="lineNum">     545 </span>            : }
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : // We need an explicit overload for std::nullptr_t.
<span class="lineNum">     548 </span>            : BASE_EXPORT void MakeCheckOpValueString(std::ostream* os, std::nullptr_t p);
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            : // Build the error message string.  This is separate from the &quot;Impl&quot;
<span class="lineNum">     551 </span>            : // function template because it is not performance critical and so can
<span class="lineNum">     552 </span>            : // be out of line, while the &quot;Impl&quot; code should be inline.  Caller
<a name="553"><span class="lineNum">     553 </span>            : // takes ownership of the returned string.</a>
<span class="lineNum">     554 </span>            : template&lt;class t1, class t2&gt;
<span class="lineNum">     555 </span><span class="lineNoCov">          0 : std::string* MakeCheckOpString(const t1&amp; v1, const t2&amp; v2, const char* names) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   std::ostringstream ss;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   ss &lt;&lt; names &lt;&lt; &quot; (&quot;;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   MakeCheckOpValueString(&amp;ss, v1);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   ss &lt;&lt; &quot; vs. &quot;;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   MakeCheckOpValueString(&amp;ss, v2);</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   ss &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   std::string* msg = new std::string(ss.str());</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   return msg;</span>
<span class="lineNum">     564 </span>            : }
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            : // Commonly used instantiations of MakeCheckOpString&lt;&gt;. Explicitly instantiated
<span class="lineNum">     567 </span>            : // in logging.cc.
<span class="lineNum">     568 </span>            : extern template BASE_EXPORT std::string* MakeCheckOpString&lt;int, int&gt;(
<span class="lineNum">     569 </span>            :     const int&amp;, const int&amp;, const char* names);
<span class="lineNum">     570 </span>            : extern template BASE_EXPORT
<span class="lineNum">     571 </span>            : std::string* MakeCheckOpString&lt;unsigned long, unsigned long&gt;(
<span class="lineNum">     572 </span>            :     const unsigned long&amp;, const unsigned long&amp;, const char* names);
<span class="lineNum">     573 </span>            : extern template BASE_EXPORT
<span class="lineNum">     574 </span>            : std::string* MakeCheckOpString&lt;unsigned long, unsigned int&gt;(
<span class="lineNum">     575 </span>            :     const unsigned long&amp;, const unsigned int&amp;, const char* names);
<span class="lineNum">     576 </span>            : extern template BASE_EXPORT
<span class="lineNum">     577 </span>            : std::string* MakeCheckOpString&lt;unsigned int, unsigned long&gt;(
<span class="lineNum">     578 </span>            :     const unsigned int&amp;, const unsigned long&amp;, const char* names);
<span class="lineNum">     579 </span>            : extern template BASE_EXPORT
<span class="lineNum">     580 </span>            : std::string* MakeCheckOpString&lt;std::string, std::string&gt;(
<span class="lineNum">     581 </span>            :     const std::string&amp;, const std::string&amp;, const char* name);
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            : // Helper functions for CHECK_OP macro.
<span class="lineNum">     584 </span>            : // The (int, int) specialization works around the issue that the compiler
<span class="lineNum">     585 </span>            : // will not instantiate the template version of the function on values of
<span class="lineNum">     586 </span>            : // unnamed enum type - see comment below.
<span class="lineNum">     587 </span>            : #define DEFINE_CHECK_OP_IMPL(name, op) \
<span class="lineNum">     588 </span>            :   template &lt;class t1, class t2&gt; \
<span class="lineNum">     589 </span>            :   inline std::string* Check##name##Impl(const t1&amp; v1, const t2&amp; v2, \
<span class="lineNum">     590 </span>            :                                         const char* names) { \
<span class="lineNum">     591 </span>            :     if (v1 op v2) return NULL; \
<span class="lineNum">     592 </span>            :     else return ::logging::MakeCheckOpString(v1, v2, names);    \
<span class="lineNum">     593 </span>            :   } \
<span class="lineNum">     594 </span>            :   inline std::string* Check##name##Impl(int v1, int v2, const char* names) { \
<span class="lineNum">     595 </span>            :     if (v1 op v2) return NULL; \
<a name="596"><span class="lineNum">     596 </span>            :     else return ::logging::MakeCheckOpString(v1, v2, names);    \</a>
<a name="597"><span class="lineNum">     597 </span>            :   }</a>
<a name="598"><span class="lineNum">     598 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(EQ, ==)</span></a>
<a name="599"><span class="lineNum">     599 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(NE, !=)</span></a>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(LE, &lt;=)</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : DEFINE_CHECK_OP_IMPL(LT, &lt; )</span>
<span class="lineNum">     602 </span>            : DEFINE_CHECK_OP_IMPL(GE, &gt;=)
<span class="lineNum">     603 </span>            : DEFINE_CHECK_OP_IMPL(GT, &gt; )
<span class="lineNum">     604 </span>            : #undef DEFINE_CHECK_OP_IMPL
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : #define CHECK_EQ(val1, val2) CHECK_OP(EQ, ==, val1, val2)
<span class="lineNum">     607 </span>            : #define CHECK_NE(val1, val2) CHECK_OP(NE, !=, val1, val2)
<span class="lineNum">     608 </span>            : #define CHECK_LE(val1, val2) CHECK_OP(LE, &lt;=, val1, val2)
<span class="lineNum">     609 </span>            : #define CHECK_LT(val1, val2) CHECK_OP(LT, &lt; , val1, val2)
<span class="lineNum">     610 </span>            : #define CHECK_GE(val1, val2) CHECK_OP(GE, &gt;=, val1, val2)
<span class="lineNum">     611 </span>            : #define CHECK_GT(val1, val2) CHECK_OP(GT, &gt; , val1, val2)
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : #if defined(NDEBUG) &amp;&amp; !defined(DCHECK_ALWAYS_ON)
<span class="lineNum">     614 </span>            : #define DCHECK_IS_ON() 0
<span class="lineNum">     615 </span>            : #else
<span class="lineNum">     616 </span>            : #define DCHECK_IS_ON() 1
<span class="lineNum">     617 </span>            : #endif
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : // Definitions for DLOG et al.
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : #if DCHECK_IS_ON()
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            : #define DLOG_IS_ON(severity) LOG_IS_ON(severity)
<span class="lineNum">     624 </span>            : #define DLOG_IF(severity, condition) LOG_IF(severity, condition)
<span class="lineNum">     625 </span>            : #define DLOG_ASSERT(condition) LOG_ASSERT(condition)
<span class="lineNum">     626 </span>            : #define DPLOG_IF(severity, condition) PLOG_IF(severity, condition)
<span class="lineNum">     627 </span>            : #define DVLOG_IF(verboselevel, condition) VLOG_IF(verboselevel, condition)
<span class="lineNum">     628 </span>            : #define DVPLOG_IF(verboselevel, condition) VPLOG_IF(verboselevel, condition)
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : #else  // DCHECK_IS_ON()
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : // If !DCHECK_IS_ON(), we want to avoid emitting any references to |condition|
<span class="lineNum">     633 </span>            : // (which may reference a variable defined only if DCHECK_IS_ON()).
<span class="lineNum">     634 </span>            : // Contrast this with DCHECK et al., which has different behavior.
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : #define DLOG_IS_ON(severity) false
<span class="lineNum">     637 </span>            : #define DLOG_IF(severity, condition) EAT_STREAM_PARAMETERS
<span class="lineNum">     638 </span>            : #define DLOG_ASSERT(condition) EAT_STREAM_PARAMETERS
<span class="lineNum">     639 </span>            : #define DPLOG_IF(severity, condition) EAT_STREAM_PARAMETERS
<span class="lineNum">     640 </span>            : #define DVLOG_IF(verboselevel, condition) EAT_STREAM_PARAMETERS
<span class="lineNum">     641 </span>            : #define DVPLOG_IF(verboselevel, condition) EAT_STREAM_PARAMETERS
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            : #endif  // DCHECK_IS_ON()
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : // DEBUG_MODE is for runtime uses like
<span class="lineNum">     646 </span>            : //   if (DEBUG_MODE) foo.CheckThatFoo();
<span class="lineNum">     647 </span>            : // We tie its state to DCHECK_IS_ON().
<span class="lineNum">     648 </span>            : //
<span class="lineNum">     649 </span>            : // For compile-time checks, #if DCHECK_IS_ON() can be used.
<span class="lineNum">     650 </span>            : enum { DEBUG_MODE = DCHECK_IS_ON() };
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : #define DLOG(severity)                                          \
<span class="lineNum">     653 </span>            :   LAZY_STREAM(LOG_STREAM(severity), DLOG_IS_ON(severity))
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            : #define DPLOG(severity)                                         \
<span class="lineNum">     656 </span>            :   LAZY_STREAM(PLOG_STREAM(severity), DLOG_IS_ON(severity))
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            : #define DVLOG(verboselevel) DVLOG_IF(verboselevel, VLOG_IS_ON(verboselevel))
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            : #define DVPLOG(verboselevel) DVPLOG_IF(verboselevel, VLOG_IS_ON(verboselevel))
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : // Definitions for DCHECK et al.
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : #if DCHECK_IS_ON()
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : #define COMPACT_GOOGLE_LOG_EX_DCHECK(ClassName, ...) \
<span class="lineNum">     667 </span>            :   COMPACT_GOOGLE_LOG_EX_FATAL(ClassName , ##__VA_ARGS__)
<span class="lineNum">     668 </span>            : #define COMPACT_GOOGLE_LOG_DCHECK COMPACT_GOOGLE_LOG_FATAL
<span class="lineNum">     669 </span>            : const LogSeverity LOG_DCHECK = LOG_FATAL;
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : #else  // DCHECK_IS_ON()
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : // These are just dummy values.
<span class="lineNum">     674 </span>            : #define COMPACT_GOOGLE_LOG_EX_DCHECK(ClassName, ...) \
<span class="lineNum">     675 </span>            :   COMPACT_GOOGLE_LOG_EX_INFO(ClassName , ##__VA_ARGS__)
<span class="lineNum">     676 </span>            : #define COMPACT_GOOGLE_LOG_DCHECK COMPACT_GOOGLE_LOG_INFO
<span class="lineNum">     677 </span>            : const LogSeverity LOG_DCHECK = LOG_INFO;
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : #endif  // DCHECK_IS_ON()
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : // DCHECK et al. make sure to reference |condition| regardless of
<span class="lineNum">     682 </span>            : // whether DCHECKs are enabled; this is so that we don't get unused
<span class="lineNum">     683 </span>            : // variable warnings if the only use of a variable is in a DCHECK.
<span class="lineNum">     684 </span>            : // This behavior is different from DLOG_IF et al.
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : #if defined(_PREFAST_) &amp;&amp; defined(OS_WIN)
<span class="lineNum">     687 </span>            : // See comments on the previous use of __analysis_assume.
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            : #define DCHECK(condition)                                               \
<span class="lineNum">     690 </span>            :   __analysis_assume(!!(condition)),                                     \
<span class="lineNum">     691 </span>            :   LAZY_STREAM(LOG_STREAM(DCHECK), false)                                \
<span class="lineNum">     692 </span>            :   &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : #define DPCHECK(condition)                                              \
<span class="lineNum">     695 </span>            :   __analysis_assume(!!(condition)),                                     \
<span class="lineNum">     696 </span>            :   LAZY_STREAM(PLOG_STREAM(DCHECK), false)                               \
<span class="lineNum">     697 </span>            :   &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : #else  // _PREFAST_
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            : #define DCHECK(condition)                                                \
<span class="lineNum">     702 </span>            :   LAZY_STREAM(LOG_STREAM(DCHECK), DCHECK_IS_ON() ? !(condition) : false) \
<span class="lineNum">     703 </span>            :       &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : #define DPCHECK(condition)                                                \
<span class="lineNum">     706 </span>            :   LAZY_STREAM(PLOG_STREAM(DCHECK), DCHECK_IS_ON() ? !(condition) : false) \
<span class="lineNum">     707 </span>            :       &lt;&lt; &quot;Check failed: &quot; #condition &quot;. &quot;
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : #endif  // _PREFAST_
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            : // Helper macro for binary operators.
<span class="lineNum">     712 </span>            : // Don't use this macro directly in your code, use DCHECK_EQ et al below.
<span class="lineNum">     713 </span>            : // The 'switch' is used to prevent the 'else' from being ambiguous when the
<span class="lineNum">     714 </span>            : // macro is used in an 'if' clause such as:
<span class="lineNum">     715 </span>            : // if (a == 1)
<span class="lineNum">     716 </span>            : //   DCHECK_EQ(2, a);
<span class="lineNum">     717 </span>            : #define DCHECK_OP(name, op, val1, val2)                                \
<span class="lineNum">     718 </span>            :   switch (0) case 0: default:                                          \
<span class="lineNum">     719 </span>            :   if (::logging::CheckOpResult true_if_passed =                        \
<span class="lineNum">     720 </span>            :       DCHECK_IS_ON() ?                                                 \
<span class="lineNum">     721 </span>            :       ::logging::Check##name##Impl((val1), (val2),                     \
<span class="lineNum">     722 </span>            :                                    #val1 &quot; &quot; #op &quot; &quot; #val2) : nullptr) \
<span class="lineNum">     723 </span>            :    ;                                                                   \
<span class="lineNum">     724 </span>            :   else                                                                 \
<span class="lineNum">     725 </span>            :     ::logging::LogMessage(__FILE__, __LINE__, ::logging::LOG_DCHECK,   \
<span class="lineNum">     726 </span>            :                           true_if_passed.message()).stream()
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            : // Equality/Inequality checks - compare two values, and log a
<span class="lineNum">     729 </span>            : // LOG_DCHECK message including the two values when the result is not
<span class="lineNum">     730 </span>            : // as expected.  The values must have operator&lt;&lt;(ostream, ...)
<span class="lineNum">     731 </span>            : // defined.
<span class="lineNum">     732 </span>            : //
<span class="lineNum">     733 </span>            : // You may append to the error message like so:
<span class="lineNum">     734 </span>            : //   DCHECK_NE(1, 2) &lt;&lt; &quot;The world must be ending!&quot;;
<span class="lineNum">     735 </span>            : //
<span class="lineNum">     736 </span>            : // We are very careful to ensure that each argument is evaluated exactly
<span class="lineNum">     737 </span>            : // once, and that anything which is legal to pass as a function argument is
<span class="lineNum">     738 </span>            : // legal here.  In particular, the arguments may be temporary expressions
<span class="lineNum">     739 </span>            : // which will end up being destroyed at the end of the apparent statement,
<span class="lineNum">     740 </span>            : // for example:
<span class="lineNum">     741 </span>            : //   DCHECK_EQ(string(&quot;abc&quot;)[1], 'b');
<span class="lineNum">     742 </span>            : //
<span class="lineNum">     743 </span>            : // WARNING: These don't compile correctly if one of the arguments is a pointer
<span class="lineNum">     744 </span>            : // and the other is NULL.  In new code, prefer nullptr instead.  To
<span class="lineNum">     745 </span>            : // work around this for C++98, simply static_cast NULL to the type of the
<span class="lineNum">     746 </span>            : // desired pointer.
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : #define DCHECK_EQ(val1, val2) DCHECK_OP(EQ, ==, val1, val2)
<span class="lineNum">     749 </span>            : #define DCHECK_NE(val1, val2) DCHECK_OP(NE, !=, val1, val2)
<span class="lineNum">     750 </span>            : #define DCHECK_LE(val1, val2) DCHECK_OP(LE, &lt;=, val1, val2)
<span class="lineNum">     751 </span>            : #define DCHECK_LT(val1, val2) DCHECK_OP(LT, &lt; , val1, val2)
<span class="lineNum">     752 </span>            : #define DCHECK_GE(val1, val2) DCHECK_OP(GE, &gt;=, val1, val2)
<span class="lineNum">     753 </span>            : #define DCHECK_GT(val1, val2) DCHECK_OP(GT, &gt; , val1, val2)
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : #if !DCHECK_IS_ON() &amp;&amp; defined(OS_CHROMEOS)
<span class="lineNum">     756 </span>            : // Implement logging of NOTREACHED() as a dedicated function to get function
<span class="lineNum">     757 </span>            : // call overhead down to a minimum.
<span class="lineNum">     758 </span>            : void LogErrorNotReached(const char* file, int line);
<span class="lineNum">     759 </span>            : #define NOTREACHED()                                       \
<span class="lineNum">     760 </span>            :   true ? ::logging::LogErrorNotReached(__FILE__, __LINE__) \
<span class="lineNum">     761 </span>            :        : EAT_STREAM_PARAMETERS
<span class="lineNum">     762 </span>            : #else
<span class="lineNum">     763 </span>            : #define NOTREACHED() DCHECK(false)
<span class="lineNum">     764 </span>            : #endif
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : // Redefine the standard assert to use our nice log files
<span class="lineNum">     767 </span>            : #undef assert
<span class="lineNum">     768 </span>            : #define assert(x) DLOG_ASSERT(x)
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : // This class more or less represents a particular log message.  You
<span class="lineNum">     771 </span>            : // create an instance of LogMessage and then stream stuff to it.
<span class="lineNum">     772 </span>            : // When you finish streaming to it, ~LogMessage is called and the
<span class="lineNum">     773 </span>            : // full message gets streamed to the appropriate destination.
<span class="lineNum">     774 </span>            : //
<span class="lineNum">     775 </span>            : // You shouldn't actually use LogMessage's constructor to log things,
<span class="lineNum">     776 </span>            : // though.  You should use the LOG() macro (and variants thereof)
<span class="lineNum">     777 </span>            : // above.
<span class="lineNum">     778 </span>            : class BASE_EXPORT LogMessage {
<span class="lineNum">     779 </span>            :  public:
<span class="lineNum">     780 </span>            :   // Used for LOG(severity).
<span class="lineNum">     781 </span>            :   LogMessage(const char* file, int line, LogSeverity severity);
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :   // Used for CHECK().  Implied severity = LOG_FATAL.
<span class="lineNum">     784 </span>            :   LogMessage(const char* file, int line, const char* condition);
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :   // Used for CHECK_EQ(), etc. Takes ownership of the given string.
<span class="lineNum">     787 </span>            :   // Implied severity = LOG_FATAL.
<span class="lineNum">     788 </span>            :   LogMessage(const char* file, int line, std::string* result);
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :   // Used for DCHECK_EQ(), etc. Takes ownership of the given string.
<span class="lineNum">     791 </span>            :   LogMessage(const char* file, int line, LogSeverity severity,
<span class="lineNum">     792 </span>            :              std::string* result);
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :   ~LogMessage();
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :   std::ostream&amp; stream() { return stream_; }
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :   LogSeverity severity() { return severity_; }
<span class="lineNum">     799 </span>            :   std::string str() { return stream_.str(); }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :  private:
<span class="lineNum">     802 </span>            :   void Init(const char* file, int line);
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :   LogSeverity severity_;
<span class="lineNum">     805 </span>            :   std::ostringstream stream_;
<span class="lineNum">     806 </span>            :   size_t message_start_;  // Offset of the start of the message (past prefix
<span class="lineNum">     807 </span>            :                           // info).
<span class="lineNum">     808 </span>            :   // The file and line information passed in to the constructor.
<span class="lineNum">     809 </span>            :   const char* file_;
<span class="lineNum">     810 </span>            :   const int line_;
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            : #if defined(OS_WIN)
<span class="lineNum">     813 </span>            :   // Stores the current value of GetLastError in the constructor and restores
<span class="lineNum">     814 </span>            :   // it in the destructor by calling SetLastError.
<span class="lineNum">     815 </span>            :   // This is useful since the LogMessage class uses a lot of Win32 calls
<span class="lineNum">     816 </span>            :   // that will lose the value of GLE and the code that called the log function
<span class="lineNum">     817 </span>            :   // will have lost the thread error value when the log call returns.
<span class="lineNum">     818 </span>            :   class SaveLastError {
<span class="lineNum">     819 </span>            :    public:
<span class="lineNum">     820 </span>            :     SaveLastError();
<span class="lineNum">     821 </span>            :     ~SaveLastError();
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     unsigned long get_error() const { return last_error_; }
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :    protected:
<span class="lineNum">     826 </span>            :     unsigned long last_error_;
<span class="lineNum">     827 </span>            :   };
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   SaveLastError last_error_;
<span class="lineNum">     830 </span>            : #endif
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :   DISALLOW_COPY_AND_ASSIGN(LogMessage);
<span class="lineNum">     833 </span>            : };
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            : // This class is used to explicitly ignore values in the conditional
<span class="lineNum">     836 </span>            : // logging macros.  This avoids compiler warnings like &quot;value computed
<span class="lineNum">     837 </span>            : // is not used&quot; and &quot;statement has no effect&quot;.
<span class="lineNum">     838 </span>            : class LogMessageVoidify {
<span class="lineNum">     839 </span>            :  public:
<span class="lineNum">     840 </span>            :   LogMessageVoidify() { }
<span class="lineNum">     841 </span>            :   // This has to be an operator with a precedence lower than &lt;&lt; but
<span class="lineNum">     842 </span>            :   // higher than ?:
<span class="lineNum">     843 </span>            :   void operator&amp;(std::ostream&amp;) { }
<span class="lineNum">     844 </span>            : };
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : #if defined(OS_WIN)
<span class="lineNum">     847 </span>            : typedef unsigned long SystemErrorCode;
<span class="lineNum">     848 </span>            : #elif defined(OS_POSIX)
<span class="lineNum">     849 </span>            : typedef int SystemErrorCode;
<span class="lineNum">     850 </span>            : #endif
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            : // Alias for ::GetLastError() on Windows and errno on POSIX. Avoids having to
<span class="lineNum">     853 </span>            : // pull in windows.h just for GetLastError() and DWORD.
<span class="lineNum">     854 </span>            : BASE_EXPORT SystemErrorCode GetLastSystemErrorCode();
<span class="lineNum">     855 </span>            : BASE_EXPORT std::string SystemErrorCodeToString(SystemErrorCode error_code);
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : #if defined(OS_WIN)
<span class="lineNum">     858 </span>            : // Appends a formatted system message of the GetLastError() type.
<span class="lineNum">     859 </span>            : class BASE_EXPORT Win32ErrorLogMessage {
<span class="lineNum">     860 </span>            :  public:
<span class="lineNum">     861 </span>            :   Win32ErrorLogMessage(const char* file,
<span class="lineNum">     862 </span>            :                        int line,
<span class="lineNum">     863 </span>            :                        LogSeverity severity,
<span class="lineNum">     864 </span>            :                        SystemErrorCode err);
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :   // Appends the error message before destructing the encapsulated class.
<span class="lineNum">     867 </span>            :   ~Win32ErrorLogMessage();
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            :   std::ostream&amp; stream() { return log_message_.stream(); }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :  private:
<span class="lineNum">     872 </span>            :   SystemErrorCode err_;
<span class="lineNum">     873 </span>            :   LogMessage log_message_;
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            :   DISALLOW_COPY_AND_ASSIGN(Win32ErrorLogMessage);
<span class="lineNum">     876 </span>            : };
<span class="lineNum">     877 </span>            : #elif defined(OS_POSIX)
<span class="lineNum">     878 </span>            : // Appends a formatted system message of the errno type
<span class="lineNum">     879 </span>            : class BASE_EXPORT ErrnoLogMessage {
<span class="lineNum">     880 </span>            :  public:
<span class="lineNum">     881 </span>            :   ErrnoLogMessage(const char* file,
<span class="lineNum">     882 </span>            :                   int line,
<span class="lineNum">     883 </span>            :                   LogSeverity severity,
<span class="lineNum">     884 </span>            :                   SystemErrorCode err);
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            :   // Appends the error message before destructing the encapsulated class.
<span class="lineNum">     887 </span>            :   ~ErrnoLogMessage();
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :   std::ostream&amp; stream() { return log_message_.stream(); }</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :  private:
<span class="lineNum">     892 </span>            :   SystemErrorCode err_;
<span class="lineNum">     893 </span>            :   LogMessage log_message_;
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span>            :   DISALLOW_COPY_AND_ASSIGN(ErrnoLogMessage);
<span class="lineNum">     896 </span>            : };
<span class="lineNum">     897 </span>            : #endif  // OS_WIN
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            : // Closes the log file explicitly if open.
<span class="lineNum">     900 </span>            : // NOTE: Since the log file is opened as necessary by the action of logging
<span class="lineNum">     901 </span>            : //       statements, there's no guarantee that it will stay closed
<span class="lineNum">     902 </span>            : //       after this call.
<span class="lineNum">     903 </span>            : BASE_EXPORT void CloseLogFile();
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            : // Async signal safe logging mechanism.
<span class="lineNum">     906 </span>            : BASE_EXPORT void RawLog(int level, const char* message);
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            : #define RAW_LOG(level, message) \
<span class="lineNum">     909 </span>            :   ::logging::RawLog(::logging::LOG_##level, message)
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : #define RAW_CHECK(condition)                               \
<span class="lineNum">     912 </span>            :   do {                                                     \
<span class="lineNum">     913 </span>            :     if (!(condition))                                      \
<span class="lineNum">     914 </span>            :       ::logging::RawLog(::logging::LOG_FATAL,              \
<span class="lineNum">     915 </span>            :                         &quot;Check failed: &quot; #condition &quot;\n&quot;); \
<span class="lineNum">     916 </span>            :   } while (0)
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            : #if defined(OS_WIN)
<span class="lineNum">     919 </span>            : // Returns true if logging to file is enabled.
<span class="lineNum">     920 </span>            : BASE_EXPORT bool IsLoggingToFileEnabled();
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : // Returns the default log file path.
<span class="lineNum">     923 </span>            : BASE_EXPORT std::wstring GetLogFileFullPath();
<span class="lineNum">     924 </span>            : #endif
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : }  // namespace logging
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            : // Note that &quot;The behavior of a C++ program is undefined if it adds declarations
<span class="lineNum">     929 </span>            : // or definitions to namespace std or to a namespace within namespace std unless
<span class="lineNum">     930 </span>            : // otherwise specified.&quot; --C++11[namespace.std]
<span class="lineNum">     931 </span>            : //
<span class="lineNum">     932 </span>            : // We've checked that this particular definition has the intended behavior on
<span class="lineNum">     933 </span>            : // our implementations, but it's prone to breaking in the future, and please
<span class="lineNum">     934 </span>            : // don't imitate this in your own definitions without checking with some
<span class="lineNum">     935 </span>            : // standard library experts.
<span class="lineNum">     936 </span>            : namespace std {
<span class="lineNum">     937 </span>            : // These functions are provided as a convenience for logging, which is where we
<span class="lineNum">     938 </span>            : // use streams (it is against Google style to use streams in other places). It
<span class="lineNum">     939 </span>            : // is designed to allow you to emit non-ASCII Unicode strings to the log file,
<span class="lineNum">     940 </span>            : // which is normally ASCII. It is relatively slow, so try not to use it for
<span class="lineNum">     941 </span>            : // common cases. Non-ASCII characters will be converted to UTF-8 by these
<span class="lineNum">     942 </span>            : // operators.
<span class="lineNum">     943 </span>            : BASE_EXPORT std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const wchar_t* wstr);
<span class="lineNum">     944 </span>            : inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::wstring&amp; wstr) {
<span class="lineNum">     945 </span>            :   return out &lt;&lt; wstr.c_str();
<span class="lineNum">     946 </span>            : }
<span class="lineNum">     947 </span>            : }  // namespace std
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            : // The NOTIMPLEMENTED() macro annotates codepaths which have
<span class="lineNum">     950 </span>            : // not been implemented yet.
<span class="lineNum">     951 </span>            : //
<span class="lineNum">     952 </span>            : // The implementation of this macro is controlled by NOTIMPLEMENTED_POLICY:
<span class="lineNum">     953 </span>            : //   0 -- Do nothing (stripped by compiler)
<span class="lineNum">     954 </span>            : //   1 -- Warn at compile time
<span class="lineNum">     955 </span>            : //   2 -- Fail at compile time
<span class="lineNum">     956 </span>            : //   3 -- Fail at runtime (DCHECK)
<span class="lineNum">     957 </span>            : //   4 -- [default] LOG(ERROR) at runtime
<span class="lineNum">     958 </span>            : //   5 -- LOG(ERROR) at runtime, only once per call-site
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            : #ifndef NOTIMPLEMENTED_POLICY
<span class="lineNum">     961 </span>            : #if defined(OS_ANDROID) &amp;&amp; defined(OFFICIAL_BUILD)
<span class="lineNum">     962 </span>            : #define NOTIMPLEMENTED_POLICY 0
<span class="lineNum">     963 </span>            : #else
<span class="lineNum">     964 </span>            : // Select default policy: LOG(ERROR)
<span class="lineNum">     965 </span>            : #define NOTIMPLEMENTED_POLICY 4
<span class="lineNum">     966 </span>            : #endif
<span class="lineNum">     967 </span>            : #endif
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : #if defined(COMPILER_GCC)
<span class="lineNum">     970 </span>            : // On Linux, with GCC, we can use __PRETTY_FUNCTION__ to get the demangled name
<span class="lineNum">     971 </span>            : // of the current function in the NOTIMPLEMENTED message.
<span class="lineNum">     972 </span>            : #define NOTIMPLEMENTED_MSG &quot;Not implemented reached in &quot; &lt;&lt; __PRETTY_FUNCTION__
<span class="lineNum">     973 </span>            : #else
<span class="lineNum">     974 </span>            : #define NOTIMPLEMENTED_MSG &quot;NOT IMPLEMENTED&quot;
<span class="lineNum">     975 </span>            : #endif
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : #if NOTIMPLEMENTED_POLICY == 0
<span class="lineNum">     978 </span>            : #define NOTIMPLEMENTED() EAT_STREAM_PARAMETERS
<span class="lineNum">     979 </span>            : #elif NOTIMPLEMENTED_POLICY == 1
<span class="lineNum">     980 </span>            : // TODO, figure out how to generate a warning
<span class="lineNum">     981 </span>            : #define NOTIMPLEMENTED() static_assert(false, &quot;NOT_IMPLEMENTED&quot;)
<span class="lineNum">     982 </span>            : #elif NOTIMPLEMENTED_POLICY == 2
<span class="lineNum">     983 </span>            : #define NOTIMPLEMENTED() static_assert(false, &quot;NOT_IMPLEMENTED&quot;)
<span class="lineNum">     984 </span>            : #elif NOTIMPLEMENTED_POLICY == 3
<span class="lineNum">     985 </span>            : #define NOTIMPLEMENTED() NOTREACHED()
<span class="lineNum">     986 </span>            : #elif NOTIMPLEMENTED_POLICY == 4
<span class="lineNum">     987 </span>            : #define NOTIMPLEMENTED() LOG(ERROR) &lt;&lt; NOTIMPLEMENTED_MSG
<span class="lineNum">     988 </span>            : #elif NOTIMPLEMENTED_POLICY == 5
<span class="lineNum">     989 </span>            : #define NOTIMPLEMENTED() do {\
<span class="lineNum">     990 </span>            :   static bool logged_once = false;\
<span class="lineNum">     991 </span>            :   LOG_IF(ERROR, !logged_once) &lt;&lt; NOTIMPLEMENTED_MSG;\
<span class="lineNum">     992 </span>            :   logged_once = true;\
<span class="lineNum">     993 </span>            : } while(0);\
<span class="lineNum">     994 </span>            : EAT_STREAM_PARAMETERS
<span class="lineNum">     995 </span>            : #endif
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : #endif  // BASE_LOGGING_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
