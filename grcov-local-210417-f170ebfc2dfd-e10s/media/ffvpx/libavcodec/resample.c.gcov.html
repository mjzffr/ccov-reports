<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/ffvpx/libavcodec/resample.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">media/ffvpx/libavcodec</a> - resample.c<span style="font-size: 80%;"> (source / <a href="resample.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">205</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * samplerate conversion for both audio and video
<span class="lineNum">       3 </span>            :  * Copyright (c) 2000 Fabrice Bellard
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * This file is part of FFmpeg.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * FFmpeg is free software; you can redistribute it and/or
<span class="lineNum">       8 </span>            :  * modify it under the terms of the GNU Lesser General Public
<span class="lineNum">       9 </span>            :  * License as published by the Free Software Foundation; either
<span class="lineNum">      10 </span>            :  * version 2.1 of the License, or (at your option) any later version.
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * FFmpeg is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      15 </span>            :  * Lesser General Public License for more details.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * You should have received a copy of the GNU Lesser General Public
<span class="lineNum">      18 </span>            :  * License along with FFmpeg; if not, write to the Free Software
<span class="lineNum">      19 </span>            :  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
<span class="lineNum">      20 </span>            :  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /**
<span class="lineNum">      23 </span>            :  * @file
<span class="lineNum">      24 </span>            :  * samplerate conversion for both audio and video
<span class="lineNum">      25 </span>            :  */
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;avcodec.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;audioconvert.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;libavutil/opt.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;libavutil/mem.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;libavutil/samplefmt.h&quot;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #if FF_API_AVCODEC_RESAMPLE
<span class="lineNum">      36 </span>            : FF_DISABLE_DEPRECATION_WARNINGS
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #define MAX_CHANNELS 8
<span class="lineNum">      39 </span>            : 
<a name="40"><span class="lineNum">      40 </span>            : struct AVResampleContext;</a>
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span><span class="lineNoCov">          0 : static const char *context_to_name(void *ptr)</span>
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :     return &quot;audioresample&quot;;</span>
<span class="lineNum">      45 </span>            : }
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : static const AVOption options[] = {{NULL}};
<span class="lineNum">      48 </span>            : static const AVClass audioresample_context_class = {
<span class="lineNum">      49 </span>            :     &quot;ReSampleContext&quot;, context_to_name, options, LIBAVUTIL_VERSION_INT
<span class="lineNum">      50 </span>            : };
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : struct ReSampleContext {
<span class="lineNum">      53 </span>            :     struct AVResampleContext *resample_context;
<span class="lineNum">      54 </span>            :     short *temp[MAX_CHANNELS];
<span class="lineNum">      55 </span>            :     int temp_len;
<span class="lineNum">      56 </span>            :     float ratio;
<span class="lineNum">      57 </span>            :     /* channel convert */
<span class="lineNum">      58 </span>            :     int input_channels, output_channels, filter_channels;
<span class="lineNum">      59 </span>            :     AVAudioConvert *convert_ctx[2];
<span class="lineNum">      60 </span>            :     enum AVSampleFormat sample_fmt[2]; ///&lt; input and output sample format
<span class="lineNum">      61 </span>            :     unsigned sample_size[2];           ///&lt; size of one sample in sample_fmt
<span class="lineNum">      62 </span>            :     short *buffer[2];                  ///&lt; buffers used for conversion to S16
<span class="lineNum">      63 </span>            :     unsigned buffer_size[2];           ///&lt; sizes of allocated buffers
<span class="lineNum">      64 </span>            : };
<a name="65"><span class="lineNum">      65 </span>            : </a>
<span class="lineNum">      66 </span>            : /* n1: number of samples */
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : static void stereo_to_mono(short *output, short *input, int n1)</span>
<span class="lineNum">      68 </span>            : {
<span class="lineNum">      69 </span>            :     short *p, *q;
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     int n = n1;</span>
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     p = input;</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     q = output;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     while (n &gt;= 4) {</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :         q[0] = (p[0] + p[1]) &gt;&gt; 1;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :         q[1] = (p[2] + p[3]) &gt;&gt; 1;</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :         q[2] = (p[4] + p[5]) &gt;&gt; 1;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :         q[3] = (p[6] + p[7]) &gt;&gt; 1;</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :         q += 4;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :         p += 8;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :         n -= 4;</span>
<span class="lineNum">      82 </span>            :     }
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     while (n &gt; 0) {</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :         q[0] = (p[0] + p[1]) &gt;&gt; 1;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :         q++;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :         p += 2;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         n--;</span>
<span class="lineNum">      88 </span>            :     }
<span class="lineNum">      89 </span><span class="lineNoCov">          0 : }</span>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<span class="lineNum">      91 </span>            : /* n1: number of samples */
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : static void mono_to_stereo(short *output, short *input, int n1)</span>
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span>            :     short *p, *q;
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     int n = n1;</span>
<span class="lineNum">      96 </span>            :     int v;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     p = input;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     q = output;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     while (n &gt;= 4) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         v = p[0]; q[0] = v; q[1] = v;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         v = p[1]; q[2] = v; q[3] = v;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         v = p[2]; q[4] = v; q[5] = v;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :         v = p[3]; q[6] = v; q[7] = v;</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :         q += 8;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :         p += 4;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         n -= 4;</span>
<span class="lineNum">     108 </span>            :     }
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     while (n &gt; 0) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :         v = p[0]; q[0] = v; q[1] = v;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         q += 2;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         p += 1;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :         n--;</span>
<span class="lineNum">     114 </span>            :     }
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : /*
<span class="lineNum">     118 </span>            : 5.1 to stereo input: [fl, fr, c, lfe, rl, rr]
<span class="lineNum">     119 </span>            : - Left = front_left + rear_gain * rear_left + center_gain * center
<span class="lineNum">     120 </span>            : - Right = front_right + rear_gain * rear_right + center_gain * center
<span class="lineNum">     121 </span>            : Where rear_gain is usually around 0.5-1.0 and
<a name="122"><span class="lineNum">     122 </span>            :       center_gain is almost always 0.7 (-3 dB)</a>
<span class="lineNum">     123 </span>            : */
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : static void surround_to_stereo(short **output, short *input, int channels, int samples)</span>
<span class="lineNum">     125 </span>            : {
<span class="lineNum">     126 </span>            :     int i;
<span class="lineNum">     127 </span>            :     short l, r;
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; samples; i++) {</span>
<span class="lineNum">     130 </span>            :         int fl,fr,c,rl,rr;
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :         fl = input[0];</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         fr = input[1];</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         c = input[2];</span>
<span class="lineNum">     134 </span>            :         // lfe = input[3];
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         rl = input[4];</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         rr = input[5];</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         l = av_clip_int16(fl + (0.5 * rl) + (0.7 * c));</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         r = av_clip_int16(fr + (0.5 * rr) + (0.7 * c));</span>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :         /* output l &amp; r. */
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         *output[0]++ = l;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         *output[1]++ = r;</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :         /* increment input. */
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         input += channels;</span>
<span class="lineNum">     147 </span>            :     }
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineNoCov">          0 : static void deinterleave(short **output, short *input, int channels, int samples)</span>
<span class="lineNum">     151 </span>            : {
<span class="lineNum">     152 </span>            :     int i, j;
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; samples; i++) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         for (j = 0; j &lt; channels; j++) {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :             *output[j]++ = *input++;</span>
<span class="lineNum">     157 </span>            :         }
<span class="lineNum">     158 </span>            :     }
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : static void interleave(short *output, short **input, int channels, int samples)</span>
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span>            :     int i, j;
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; samples; i++) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         for (j = 0; j &lt; channels; j++) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :             *output++ = *input[j]++;</span>
<span class="lineNum">     168 </span>            :         }
<span class="lineNum">     169 </span>            :     }
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 : static void ac3_5p1_mux(short *output, short *input1, short *input2, int n)</span>
<span class="lineNum">     173 </span>            : {
<span class="lineNum">     174 </span>            :     int i;
<span class="lineNum">     175 </span>            :     short l, r;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; n; i++) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         l = *input1++;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         r = *input2++;</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         *output++ = l;                  /* left */</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         *output++ = (l / 2) + (r / 2);  /* center */</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :         *output++ = r;                  /* right */</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         *output++ = 0;                  /* left surround */</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :         *output++ = 0;                  /* right surroud */</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         *output++ = 0;                  /* low freq */</span>
<span class="lineNum">     186 </span>            :     }
<span class="lineNum">     187 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : #define SUPPORT_RESAMPLE(ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8) \
<span class="lineNum">     190 </span>            :     ch8&lt;&lt;7 | ch7&lt;&lt;6 | ch6&lt;&lt;5 | ch5&lt;&lt;4 | ch4&lt;&lt;3 | ch3&lt;&lt;2 | ch2&lt;&lt;1 | ch1&lt;&lt;0
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : static const uint8_t supported_resampling[MAX_CHANNELS] = {
<span class="lineNum">     193 </span>            :     // output ch:    1  2  3  4  5  6  7  8
<span class="lineNum">     194 </span>            :     SUPPORT_RESAMPLE(1, 1, 0, 0, 0, 0, 0, 0), // 1 input channel
<span class="lineNum">     195 </span>            :     SUPPORT_RESAMPLE(1, 1, 0, 0, 0, 1, 0, 0), // 2 input channels
<span class="lineNum">     196 </span>            :     SUPPORT_RESAMPLE(0, 0, 1, 0, 0, 0, 0, 0), // 3 input channels
<span class="lineNum">     197 </span>            :     SUPPORT_RESAMPLE(0, 0, 0, 1, 0, 0, 0, 0), // 4 input channels
<span class="lineNum">     198 </span>            :     SUPPORT_RESAMPLE(0, 0, 0, 0, 1, 0, 0, 0), // 5 input channels
<span class="lineNum">     199 </span>            :     SUPPORT_RESAMPLE(0, 1, 0, 0, 0, 1, 0, 0), // 6 input channels
<span class="lineNum">     200 </span>            :     SUPPORT_RESAMPLE(0, 0, 0, 0, 0, 0, 1, 0), // 7 input channels
<span class="lineNum">     201 </span>            :     SUPPORT_RESAMPLE(0, 0, 0, 0, 0, 0, 0, 1), // 8 input channels
<a name="202"><span class="lineNum">     202 </span>            : };</a>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineNoCov">          0 : ReSampleContext *av_audio_resample_init(int output_channels, int input_channels,</span>
<span class="lineNum">     205 </span>            :                                         int output_rate, int input_rate,
<span class="lineNum">     206 </span>            :                                         enum AVSampleFormat sample_fmt_out,
<span class="lineNum">     207 </span>            :                                         enum AVSampleFormat sample_fmt_in,
<span class="lineNum">     208 </span>            :                                         int filter_length, int log2_phase_count,
<span class="lineNum">     209 </span>            :                                         int linear, double cutoff)
<span class="lineNum">     210 </span>            : {
<span class="lineNum">     211 </span>            :     ReSampleContext *s;
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     if (input_channels &gt; MAX_CHANNELS) {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         av_log(NULL, AV_LOG_ERROR,</span>
<span class="lineNum">     215 </span>            :                &quot;Resampling with input channels greater than %d is unsupported.\n&quot;,
<span class="lineNum">     216 </span>            :                MAX_CHANNELS);
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (!(supported_resampling[input_channels-1] &amp; (1&lt;&lt;(output_channels-1)))) {</span>
<span class="lineNum">     220 </span>            :         int i;
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         av_log(NULL, AV_LOG_ERROR, &quot;Unsupported audio resampling. Allowed &quot;</span>
<span class="lineNum">     222 </span>            :                &quot;output channels for %d input channel%s&quot;, input_channels,
<span class="lineNum">     223 </span>            :                input_channels &gt; 1 ? &quot;s:&quot; : &quot;:&quot;);
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; MAX_CHANNELS; i++)</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :             if (supported_resampling[input_channels-1] &amp; (1&lt;&lt;i))</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                 av_log(NULL, AV_LOG_ERROR, &quot; %d&quot;, i + 1);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         av_log(NULL, AV_LOG_ERROR, &quot;\n&quot;);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     s = av_mallocz(sizeof(ReSampleContext));</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (!s) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         av_log(NULL, AV_LOG_ERROR, &quot;Can't allocate memory for resample context.\n&quot;);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     235 </span>            :     }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     s-&gt;ratio = (float)output_rate / (float)input_rate;</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     s-&gt;input_channels = input_channels;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     s-&gt;output_channels = output_channels;</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     s-&gt;filter_channels = s-&gt;input_channels;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     if (s-&gt;output_channels &lt; s-&gt;filter_channels)</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         s-&gt;filter_channels = s-&gt;output_channels;</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     s-&gt;sample_fmt[0]  = sample_fmt_in;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     s-&gt;sample_fmt[1]  = sample_fmt_out;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     s-&gt;sample_size[0] = av_get_bytes_per_sample(s-&gt;sample_fmt[0]);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     s-&gt;sample_size[1] = av_get_bytes_per_sample(s-&gt;sample_fmt[1]);</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     if (s-&gt;sample_fmt[0] != AV_SAMPLE_FMT_S16) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         if (!(s-&gt;convert_ctx[0] = av_audio_convert_alloc(AV_SAMPLE_FMT_S16, 1,</span>
<span class="lineNum">     253 </span>            :                                                          s-&gt;sample_fmt[0], 1, NULL, 0))) {
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :             av_log(s, AV_LOG_ERROR,</span>
<span class="lineNum">     255 </span>            :                    &quot;Cannot convert %s sample format to s16 sample format\n&quot;,
<span class="lineNum">     256 </span>            :                    av_get_sample_fmt_name(s-&gt;sample_fmt[0]));
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :             av_free(s);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     259 </span>            :         }
<span class="lineNum">     260 </span>            :     }
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     if (s-&gt;sample_fmt[1] != AV_SAMPLE_FMT_S16) {</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :         if (!(s-&gt;convert_ctx[1] = av_audio_convert_alloc(s-&gt;sample_fmt[1], 1,</span>
<span class="lineNum">     264 </span>            :                                                          AV_SAMPLE_FMT_S16, 1, NULL, 0))) {
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :             av_log(s, AV_LOG_ERROR,</span>
<span class="lineNum">     266 </span>            :                    &quot;Cannot convert s16 sample format to %s sample format\n&quot;,
<span class="lineNum">     267 </span>            :                    av_get_sample_fmt_name(s-&gt;sample_fmt[1]));
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :             av_audio_convert_free(s-&gt;convert_ctx[0]);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :             av_free(s);</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     271 </span>            :         }
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     s-&gt;resample_context = av_resample_init(output_rate, input_rate,</span>
<span class="lineNum">     275 </span>            :                                            filter_length, log2_phase_count,
<span class="lineNum">     276 </span>            :                                            linear, cutoff);
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     *(const AVClass**)s-&gt;resample_context = &amp;audioresample_context_class;</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     return s;</span>
<span class="lineNum">     281 </span>            : }
<span class="lineNum">     282 </span>            : 
<a name="283"><span class="lineNum">     283 </span>            : /* resample audio. 'nb_samples' is the number of input samples */</a>
<span class="lineNum">     284 </span>            : /* XXX: optimize it ! */
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)</span>
<span class="lineNum">     286 </span>            : {
<span class="lineNum">     287 </span>            :     int i, nb_samples1;
<span class="lineNum">     288 </span>            :     short *bufin[MAX_CHANNELS];
<span class="lineNum">     289 </span>            :     short *bufout[MAX_CHANNELS];
<span class="lineNum">     290 </span>            :     short *buftmp2[MAX_CHANNELS], *buftmp3[MAX_CHANNELS];
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     short *output_bak = NULL;</span>
<span class="lineNum">     292 </span>            :     int lenout;
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     if (s-&gt;sample_fmt[0] != AV_SAMPLE_FMT_S16) {</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         int istride[1] = { s-&gt;sample_size[0] };</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         int ostride[1] = { 2 };</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         const void *ibuf[1] = { input };</span>
<span class="lineNum">     298 </span>            :         void       *obuf[1];
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         unsigned input_size = nb_samples * s-&gt;input_channels * 2;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         if (!s-&gt;buffer_size[0] || s-&gt;buffer_size[0] &lt; input_size) {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :             av_free(s-&gt;buffer[0]);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :             s-&gt;buffer_size[0] = input_size;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :             s-&gt;buffer[0] = av_malloc(s-&gt;buffer_size[0]);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :             if (!s-&gt;buffer[0]) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :                 av_log(s-&gt;resample_context, AV_LOG_ERROR, &quot;Could not allocate buffer\n&quot;);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     308 </span>            :             }
<span class="lineNum">     309 </span>            :         }
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         obuf[0] = s-&gt;buffer[0];</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         if (av_audio_convert(s-&gt;convert_ctx[0], obuf, ostride,</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :                              ibuf, istride, nb_samples * s-&gt;input_channels) &lt; 0) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :             av_log(s-&gt;resample_context, AV_LOG_ERROR,</span>
<span class="lineNum">     316 </span>            :                    &quot;Audio sample format conversion failed\n&quot;);
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     318 </span>            :         }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         input = s-&gt;buffer[0];</span>
<span class="lineNum">     321 </span>            :     }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     lenout= 2*s-&gt;output_channels*nb_samples * s-&gt;ratio + 16;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     if (s-&gt;sample_fmt[1] != AV_SAMPLE_FMT_S16) {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         int out_size = lenout * av_get_bytes_per_sample(s-&gt;sample_fmt[1]) *</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                        s-&gt;output_channels;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         output_bak = output;</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         if (!s-&gt;buffer_size[1] || s-&gt;buffer_size[1] &lt; out_size) {</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :             av_free(s-&gt;buffer[1]);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :             s-&gt;buffer_size[1] = out_size;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :             s-&gt;buffer[1] = av_malloc(s-&gt;buffer_size[1]);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :             if (!s-&gt;buffer[1]) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :                 av_log(s-&gt;resample_context, AV_LOG_ERROR, &quot;Could not allocate buffer\n&quot;);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     337 </span>            :             }
<span class="lineNum">     338 </span>            :         }
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :         output = s-&gt;buffer[1];</span>
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :     /* XXX: move those malloc to resample init code */
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; s-&gt;filter_channels; i++) {</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         bufin[i] = av_malloc_array((nb_samples + s-&gt;temp_len), sizeof(short));</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         bufout[i] = av_malloc_array(lenout, sizeof(short));</span>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         if (!bufin[i] || !bufout[i]) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :             av_log(s-&gt;resample_context, AV_LOG_ERROR, &quot;Could not allocate buffer\n&quot;);</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :             nb_samples1 = 0;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :             goto fail;</span>
<span class="lineNum">     352 </span>            :         }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         memcpy(bufin[i], s-&gt;temp[i], s-&gt;temp_len * sizeof(short));</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         buftmp2[i] = bufin[i] + s-&gt;temp_len;</span>
<span class="lineNum">     356 </span>            :     }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     if (s-&gt;input_channels == 2 &amp;&amp; s-&gt;output_channels == 1) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         buftmp3[0] = output;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         stereo_to_mono(buftmp2[0], input, nb_samples);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     } else if (s-&gt;output_channels &gt;= 2 &amp;&amp; s-&gt;input_channels == 1) {</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         buftmp3[0] = bufout[0];</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         memcpy(buftmp2[0], input, nb_samples * sizeof(short));</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     } else if (s-&gt;input_channels == 6 &amp;&amp; s-&gt;output_channels ==2) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         buftmp3[0] = bufout[0];</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         buftmp3[1] = bufout[1];</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         surround_to_stereo(buftmp2, input, s-&gt;input_channels, nb_samples);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     } else if (s-&gt;output_channels &gt;= s-&gt;input_channels &amp;&amp; s-&gt;input_channels &gt;= 2) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; s-&gt;input_channels; i++) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :             buftmp3[i] = bufout[i];</span>
<span class="lineNum">     371 </span>            :         }
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         deinterleave(buftmp2, input, s-&gt;input_channels, nb_samples);</span>
<span class="lineNum">     373 </span>            :     } else {
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         buftmp3[0] = output;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :         memcpy(buftmp2[0], input, nb_samples * sizeof(short));</span>
<span class="lineNum">     376 </span>            :     }
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     nb_samples += s-&gt;temp_len;</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :     /* resample each channel */
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     nb_samples1 = 0; /* avoid warning */</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; s-&gt;filter_channels; i++) {</span>
<span class="lineNum">     383 </span>            :         int consumed;
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         int is_last = i + 1 == s-&gt;filter_channels;</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         nb_samples1 = av_resample(s-&gt;resample_context, buftmp3[i], bufin[i],</span>
<span class="lineNum">     387 </span>            :                                   &amp;consumed, nb_samples, lenout, is_last);
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         s-&gt;temp_len = nb_samples - consumed;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         s-&gt;temp[i] = av_realloc_array(s-&gt;temp[i], s-&gt;temp_len, sizeof(short));</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         memcpy(s-&gt;temp[i], bufin[i] + consumed, s-&gt;temp_len * sizeof(short));</span>
<span class="lineNum">     391 </span>            :     }
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     if (s-&gt;output_channels == 2 &amp;&amp; s-&gt;input_channels == 1) {</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         mono_to_stereo(output, buftmp3[0], nb_samples1);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     } else if (s-&gt;output_channels == 6 &amp;&amp; s-&gt;input_channels == 2) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         ac3_5p1_mux(output, buftmp3[0], buftmp3[1], nb_samples1);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     } else if ((s-&gt;output_channels == s-&gt;input_channels &amp;&amp; s-&gt;input_channels &gt;= 2) ||</span>
<span class="lineNum">     398 </span>            :                (s-&gt;output_channels == 2 &amp;&amp; s-&gt;input_channels == 6)) {
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         interleave(output, buftmp3, s-&gt;output_channels, nb_samples1);</span>
<span class="lineNum">     400 </span>            :     }
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     if (s-&gt;sample_fmt[1] != AV_SAMPLE_FMT_S16) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         int istride[1] = { 2 };</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         int ostride[1] = { s-&gt;sample_size[1] };</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         const void *ibuf[1] = { output };</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         void       *obuf[1] = { output_bak };</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         if (av_audio_convert(s-&gt;convert_ctx[1], obuf, ostride,</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :                              ibuf, istride, nb_samples1 * s-&gt;output_channels) &lt; 0) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :             av_log(s-&gt;resample_context, AV_LOG_ERROR,</span>
<span class="lineNum">     411 </span>            :                    &quot;Audio sample format conversion failed\n&quot;);
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     413 </span>            :         }
<span class="lineNum">     414 </span>            :     }
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : fail:
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; s-&gt;filter_channels; i++) {</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         av_free(bufin[i]);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         av_free(bufout[i]);</span>
<span class="lineNum">     420 </span>            :     }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :     return nb_samples1;
<a name="423"><span class="lineNum">     423 </span>            : }</a>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 : void audio_resample_close(ReSampleContext *s)</span>
<span class="lineNum">     426 </span>            : {
<span class="lineNum">     427 </span>            :     int i;
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     av_resample_close(s-&gt;resample_context);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; s-&gt;filter_channels; i++)</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         av_freep(&amp;s-&gt;temp[i]);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     av_freep(&amp;s-&gt;buffer[0]);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     av_freep(&amp;s-&gt;buffer[1]);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     av_audio_convert_free(s-&gt;convert_ctx[0]);</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     av_audio_convert_free(s-&gt;convert_ctx[1]);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     av_free(s);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : FF_ENABLE_DEPRECATION_WARNINGS
<span class="lineNum">     439 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
