<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/vm/SavedStacks.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/vm</a> - SavedStacks.cpp<span style="font-size: 80%;"> (source / <a href="SavedStacks.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">566</td>
            <td class="headerCovTableEntry">664</td>
            <td class="headerCovTableEntryMed">85.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">70</td>
            <td class="headerCovTableEntry">83</td>
            <td class="headerCovTableEntryMed">84.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;vm/SavedStacks.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/ArrayUtils.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Move.h&quot;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      15 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;jsapi.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;jscompartment.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;jsfriendapi.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;jshashutil.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;jsmath.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;jsnum.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;jsscript.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #include &quot;gc/Marking.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;gc/Policy.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;gc/Rooting.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;js/CharacterEncoding.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;js/Vector.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;vm/Debugger.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;vm/GeckoProfiler.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;vm/SavedFrame.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;vm/StringBuffer.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;vm/Time.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;vm/WrapperObject.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &quot;jscntxtinlines.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #include &quot;vm/NativeObject-inl.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;vm/Stack-inl.h&quot;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : using mozilla::AddToHash;
<span class="lineNum">      43 </span>            : using mozilla::DebugOnly;
<span class="lineNum">      44 </span>            : using mozilla::HashString;
<span class="lineNum">      45 </span>            : using mozilla::Maybe;
<span class="lineNum">      46 </span>            : using mozilla::Move;
<span class="lineNum">      47 </span>            : using mozilla::Nothing;
<span class="lineNum">      48 </span>            : using mozilla::Some;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : namespace js {
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : /**
<span class="lineNum">      53 </span>            :  * Maximum number of saved frames returned for an async stack.
<span class="lineNum">      54 </span>            :  */
<span class="lineNum">      55 </span>            : const uint32_t ASYNC_STACK_MAX_FRAME_COUNT = 60;
<a name="56"><span class="lineNum">      56 </span>            : </a>
<span class="lineNum">      57 </span>            : /* static */ Maybe&lt;LiveSavedFrameCache::FramePtr&gt;
<span class="lineNum">      58 </span><span class="lineCov">          1 : LiveSavedFrameCache::getFramePtr(FrameIter&amp; iter)</span>
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span><span class="lineCov">          1 :     if (iter.hasUsableAbstractFramePtr())</span>
<span class="lineNum">      61 </span><span class="lineCov">          1 :         return Some(FramePtr(iter.abstractFramePtr()));</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span><span class="lineCov">          1 :     if (iter.isPhysicalIonFrame())</span>
<span class="lineNum">      64 </span><span class="lineCov">          1 :         return Some(FramePtr(iter.physicalIonFrame()));</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :     return Nothing();
<span class="lineNum">      67 </span>            : }
<a name="68"><span class="lineNum">      68 </span>            : </a>
<span class="lineNum">      69 </span>            : void
<span class="lineNum">      70 </span><span class="lineCov">          1 : LiveSavedFrameCache::trace(JSTracer* trc)</span>
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span><span class="lineCov">          1 :     if (!initialized())</span>
<span class="lineNum">      73 </span><span class="lineCov">          1 :         return;</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span><span class="lineCov">          1 :     for (auto* entry = frames-&gt;begin(); entry &lt; frames-&gt;end(); entry++) {</span>
<span class="lineNum">      76 </span>            :         TraceEdge(trc,
<span class="lineNum">      77 </span>            :                   &amp;entry-&gt;savedFrame,
<span class="lineNum">      78 </span><span class="lineCov">          1 :                   &quot;LiveSavedFrameCache::frames SavedFrame&quot;);</span>
<span class="lineNum">      79 </span>            :     }
<span class="lineNum">      80 </span>            : }
<a name="81"><span class="lineNum">      81 </span>            : </a>
<span class="lineNum">      82 </span>            : bool
<span class="lineNum">      83 </span><span class="lineCov">          1 : LiveSavedFrameCache::insert(JSContext* cx, FramePtr&amp; framePtr, jsbytecode* pc,</span>
<span class="lineNum">      84 </span>            :                             HandleSavedFrame savedFrame)
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span>            :     MOZ_ASSERT(initialized());
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineCov">          1 :     if (!frames-&gt;emplaceBack(framePtr, pc, savedFrame)) {</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      91 </span>            :     }
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :     // Safe to dereference the cache key because the stack frames are still
<span class="lineNum">      94 </span>            :     // live. After this point, they should never be dereferenced again.
<span class="lineNum">      95 </span><span class="lineCov">          1 :     if (framePtr.is&lt;AbstractFramePtr&gt;())</span>
<span class="lineNum">      96 </span><span class="lineCov">          1 :         framePtr.as&lt;AbstractFramePtr&gt;().setHasCachedSavedFrame();</span>
<span class="lineNum">      97 </span>            :     else
<span class="lineNum">      98 </span><span class="lineCov">          1 :         framePtr.as&lt;jit::CommonFrameLayout*&gt;()-&gt;setHasCachedSavedFrame();</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :     return true;
<span class="lineNum">     101 </span>            : }
<a name="102"><span class="lineNum">     102 </span>            : </a>
<span class="lineNum">     103 </span>            : void
<span class="lineNum">     104 </span><span class="lineCov">          1 : LiveSavedFrameCache::find(JSContext* cx, FrameIter&amp; frameIter, MutableHandleSavedFrame frame) const</span>
<span class="lineNum">     105 </span>            : {
<span class="lineNum">     106 </span>            :     MOZ_ASSERT(initialized());
<span class="lineNum">     107 </span>            :     MOZ_ASSERT(!frameIter.done());
<span class="lineNum">     108 </span>            :     MOZ_ASSERT(frameIter.hasCachedSavedFrame());
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineCov">          1 :     Maybe&lt;FramePtr&gt; maybeFramePtr = getFramePtr(frameIter);</span>
<span class="lineNum">     111 </span>            :     MOZ_ASSERT(maybeFramePtr.isSome());
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">          1 :     FramePtr framePtr(*maybeFramePtr);</span>
<span class="lineNum">     114 </span><span class="lineCov">          1 :     jsbytecode* pc = frameIter.pc();</span>
<span class="lineNum">     115 </span><span class="lineCov">          1 :     size_t numberStillValid = 0;</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span><span class="lineCov">          1 :     frame.set(nullptr);</span>
<span class="lineNum">     118 </span><span class="lineCov">          1 :     for (auto* p = frames-&gt;begin(); p &lt; frames-&gt;end(); p++) {</span>
<span class="lineNum">     119 </span><span class="lineCov">          1 :         numberStillValid++;</span>
<span class="lineNum">     120 </span><span class="lineCov">          1 :         if (framePtr == p-&gt;framePtr &amp;&amp; pc == p-&gt;pc) {</span>
<span class="lineNum">     121 </span><span class="lineCov">          1 :             frame.set(p-&gt;savedFrame);</span>
<span class="lineNum">     122 </span>            :             break;
<span class="lineNum">     123 </span>            :         }
<span class="lineNum">     124 </span>            :     }
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineCov">          1 :     if (!frame) {</span>
<span class="lineNum">     127 </span><span class="lineCov">          1 :         frames-&gt;clear();</span>
<span class="lineNum">     128 </span><span class="lineCov">          1 :         return;</span>
<span class="lineNum">     129 </span>            :     }
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :     MOZ_ASSERT(0 &lt; numberStillValid &amp;&amp; numberStillValid &lt;= frames-&gt;length());
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineCov">          1 :     if (frame-&gt;compartment() != cx-&gt;compartment()) {</span>
<span class="lineNum">     134 </span><span class="lineCov">          1 :         frame.set(nullptr);</span>
<span class="lineNum">     135 </span><span class="lineCov">          1 :         numberStillValid--;</span>
<span class="lineNum">     136 </span>            :     }
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     // Everything after the cached SavedFrame are stale younger frames we have
<span class="lineNum">     139 </span>            :     // since popped.
<span class="lineNum">     140 </span><span class="lineCov">          1 :     frames-&gt;shrinkBy(frames-&gt;length() - numberStillValid);</span>
<a name="141"><span class="lineNum">     141 </span>            : }</a>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">          1 : struct SavedFrame::Lookup {</span>
<span class="lineNum">     144 </span>            :     Lookup(JSAtom* source, uint32_t line, uint32_t column,
<span class="lineNum">     145 </span>            :            JSAtom* functionDisplayName, JSAtom* asyncCause, SavedFrame* parent,
<span class="lineNum">     146 </span>            :            JSPrincipals* principals,
<span class="lineNum">     147 </span>            :            const Maybe&lt;LiveSavedFrameCache::FramePtr&gt;&amp; framePtr = Nothing(),
<span class="lineNum">     148 </span>            :            jsbytecode* pc = nullptr, Activation* activation = nullptr)
<span class="lineNum">     149 </span>            :       : source(source),
<span class="lineNum">     150 </span>            :         line(line),
<span class="lineNum">     151 </span>            :         column(column),
<span class="lineNum">     152 </span>            :         functionDisplayName(functionDisplayName),
<span class="lineNum">     153 </span>            :         asyncCause(asyncCause),
<span class="lineNum">     154 </span>            :         parent(parent),
<span class="lineNum">     155 </span>            :         principals(principals),
<span class="lineNum">     156 </span>            :         framePtr(framePtr),
<span class="lineNum">     157 </span>            :         pc(pc),
<span class="lineNum">     158 </span><span class="lineCov">          1 :         activation(activation)</span>
<span class="lineNum">     159 </span>            :     {
<span class="lineNum">     160 </span>            :         MOZ_ASSERT(source);
<span class="lineNum">     161 </span>            :         MOZ_ASSERT_IF(framePtr.isSome(), activation);
<span class="lineNum">     162 </span>            :         MOZ_ASSERT_IF(framePtr.isSome() &amp;&amp; !activation-&gt;isWasm(), pc);
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : #ifdef JS_MORE_DETERMINISTIC
<span class="lineNum">     165 </span>            :         column = 0;
<span class="lineNum">     166 </span>            : #endif
<a name="167"><span class="lineNum">     167 </span>            :     }</a>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineCov">          1 :     explicit Lookup(SavedFrame&amp; savedFrame)</span>
<span class="lineNum">     170 </span>            :       : source(savedFrame.getSource()),
<span class="lineNum">     171 </span>            :         line(savedFrame.getLine()),
<span class="lineNum">     172 </span>            :         column(savedFrame.getColumn()),
<span class="lineNum">     173 </span>            :         functionDisplayName(savedFrame.getFunctionDisplayName()),
<span class="lineNum">     174 </span>            :         asyncCause(savedFrame.getAsyncCause()),
<span class="lineNum">     175 </span>            :         parent(savedFrame.getParent()),
<span class="lineNum">     176 </span>            :         principals(savedFrame.getPrincipals()),
<span class="lineNum">     177 </span>            :         framePtr(Nothing()),
<span class="lineNum">     178 </span>            :         pc(nullptr),
<span class="lineNum">     179 </span><span class="lineCov">          1 :         activation(nullptr)</span>
<span class="lineNum">     180 </span>            :     {
<span class="lineNum">     181 </span>            :         MOZ_ASSERT(source);
<span class="lineNum">     182 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :     JSAtom*       source;
<span class="lineNum">     185 </span>            :     uint32_t      line;
<span class="lineNum">     186 </span>            :     uint32_t      column;
<span class="lineNum">     187 </span>            :     JSAtom*       functionDisplayName;
<span class="lineNum">     188 </span>            :     JSAtom*       asyncCause;
<span class="lineNum">     189 </span>            :     SavedFrame*   parent;
<span class="lineNum">     190 </span>            :     JSPrincipals* principals;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :     // These are used only by the LiveSavedFrameCache and not used for identity or
<span class="lineNum">     193 </span>            :     // hashing.
<span class="lineNum">     194 </span>            :     Maybe&lt;LiveSavedFrameCache::FramePtr&gt; framePtr;
<span class="lineNum">     195 </span>            :     jsbytecode*                          pc;
<a name="196"><span class="lineNum">     196 </span>            :     Activation*                          activation;</a>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineCov">          1 :     void trace(JSTracer* trc) {</span>
<span class="lineNum">     199 </span><span class="lineCov">          1 :         TraceManuallyBarrieredEdge(trc, &amp;source, &quot;SavedFrame::Lookup::source&quot;);</span>
<span class="lineNum">     200 </span><span class="lineCov">          1 :         if (functionDisplayName) {</span>
<span class="lineNum">     201 </span>            :             TraceManuallyBarrieredEdge(trc, &amp;functionDisplayName,
<span class="lineNum">     202 </span><span class="lineCov">          1 :                                        &quot;SavedFrame::Lookup::functionDisplayName&quot;);</span>
<span class="lineNum">     203 </span>            :         }
<span class="lineNum">     204 </span><span class="lineCov">          1 :         if (asyncCause)</span>
<span class="lineNum">     205 </span><span class="lineCov">          1 :             TraceManuallyBarrieredEdge(trc, &amp;asyncCause, &quot;SavedFrame::Lookup::asyncCause&quot;);</span>
<span class="lineNum">     206 </span><span class="lineCov">          1 :         if (parent)</span>
<span class="lineNum">     207 </span><span class="lineCov">          1 :             TraceManuallyBarrieredEdge(trc, &amp;parent, &quot;SavedFrame::Lookup::parent&quot;);</span>
<span class="lineNum">     208 </span><span class="lineCov">          1 :     }</span>
<a name="209"><span class="lineNum">     209 </span>            : };</a>
<span class="lineNum">     210 </span>            : 
<a name="211"><span class="lineNum">     211 </span><span class="lineCov">          1 : class MOZ_STACK_CLASS SavedFrame::AutoLookupVector : public JS::CustomAutoRooter {</span></a>
<span class="lineNum">     212 </span>            :   public:
<span class="lineNum">     213 </span><span class="lineCov">          1 :     explicit AutoLookupVector(JSContext* cx)</span>
<span class="lineNum">     214 </span>            :       : JS::CustomAutoRooter(cx),
<span class="lineNum">     215 </span><span class="lineCov">          1 :         lookups(cx)</span>
<span class="lineNum">     216 </span><span class="lineCov">          1 :     { }</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     typedef Vector&lt;Lookup, ASYNC_STACK_MAX_FRAME_COUNT&gt; LookupVector;
<span class="lineNum">     219 </span>            :     inline LookupVector* operator-&gt;() { return &amp;lookups; }
<span class="lineNum">     220 </span><span class="lineCov">          1 :     inline HandleLookup operator[](size_t i) { return HandleLookup(lookups[i]); }</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   private:
<a name="223"><span class="lineNum">     223 </span>            :     LookupVector lookups;</a>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineCov">          1 :     virtual void trace(JSTracer* trc) {</span>
<span class="lineNum">     226 </span><span class="lineCov">          1 :         for (size_t i = 0; i &lt; lookups.length(); i++)</span>
<span class="lineNum">     227 </span><span class="lineCov">          1 :             lookups[i].trace(trc);</span>
<span class="lineNum">     228 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     229 </span>            : };
<a name="230"><span class="lineNum">     230 </span>            : </a>
<span class="lineNum">     231 </span>            : /* static */ bool
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : SavedFrame::HashPolicy::hasHash(const Lookup&amp; l)</span>
<span class="lineNum">     233 </span>            : {
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     return SavedFramePtrHasher::hasHash(l.parent);</span>
<span class="lineNum">     235 </span>            : }
<a name="236"><span class="lineNum">     236 </span>            : </a>
<span class="lineNum">     237 </span>            : /* static */ bool
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : SavedFrame::HashPolicy::ensureHash(const Lookup&amp; l)</span>
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span><span class="lineCov">          1 :     return SavedFramePtrHasher::ensureHash(l.parent);</span>
<span class="lineNum">     241 </span>            : }
<a name="242"><span class="lineNum">     242 </span>            : </a>
<span class="lineNum">     243 </span>            : /* static */ HashNumber
<span class="lineNum">     244 </span><span class="lineCov">          1 : SavedFrame::HashPolicy::hash(const Lookup&amp; lookup)</span>
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span>            :     JS::AutoCheckCannotGC nogc;
<span class="lineNum">     247 </span>            :     // Assume that we can take line mod 2^32 without losing anything of
<span class="lineNum">     248 </span>            :     // interest.  If that assumption changes, we'll just need to start with 0
<span class="lineNum">     249 </span>            :     // and add another overload of AddToHash with more arguments.
<span class="lineNum">     250 </span>            :     return AddToHash(lookup.line,
<span class="lineNum">     251 </span>            :                      lookup.column,
<span class="lineNum">     252 </span>            :                      lookup.source,
<span class="lineNum">     253 </span>            :                      lookup.functionDisplayName,
<span class="lineNum">     254 </span>            :                      lookup.asyncCause,
<span class="lineNum">     255 </span>            :                      SavedFramePtrHasher::hash(lookup.parent),
<span class="lineNum">     256 </span><span class="lineCov">          1 :                      JSPrincipalsPtrHasher::hash(lookup.principals));</span>
<span class="lineNum">     257 </span>            : }
<a name="258"><span class="lineNum">     258 </span>            : </a>
<span class="lineNum">     259 </span>            : /* static */ bool
<span class="lineNum">     260 </span><span class="lineCov">          1 : SavedFrame::HashPolicy::match(SavedFrame* existing, const Lookup&amp; lookup)</span>
<span class="lineNum">     261 </span>            : {
<span class="lineNum">     262 </span>            :     MOZ_ASSERT(existing);
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineCov">          1 :     if (existing-&gt;getLine() != lookup.line)</span>
<span class="lineNum">     265 </span>            :         return false;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineCov">          1 :     if (existing-&gt;getColumn() != lookup.column)</span>
<span class="lineNum">     268 </span>            :         return false;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineCov">          1 :     if (existing-&gt;getParent() != lookup.parent)</span>
<span class="lineNum">     271 </span>            :         return false;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineCov">          1 :     if (existing-&gt;getPrincipals() != lookup.principals)</span>
<span class="lineNum">     274 </span>            :         return false;
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineCov">          1 :     JSAtom* source = existing-&gt;getSource();</span>
<span class="lineNum">     277 </span><span class="lineCov">          1 :     if (source != lookup.source)</span>
<span class="lineNum">     278 </span>            :         return false;
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">          1 :     JSAtom* functionDisplayName = existing-&gt;getFunctionDisplayName();</span>
<span class="lineNum">     281 </span><span class="lineCov">          1 :     if (functionDisplayName != lookup.functionDisplayName)</span>
<span class="lineNum">     282 </span>            :         return false;
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineCov">          1 :     JSAtom* asyncCause = existing-&gt;getAsyncCause();</span>
<span class="lineNum">     285 </span><span class="lineCov">          1 :     if (asyncCause != lookup.asyncCause)</span>
<span class="lineNum">     286 </span>            :         return false;
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">     289 </span>            : }
<a name="290"><span class="lineNum">     290 </span>            : </a>
<span class="lineNum">     291 </span>            : /* static */ void
<span class="lineNum">     292 </span><span class="lineNoCov">          0 : SavedFrame::HashPolicy::rekey(Key&amp; key, const Key&amp; newKey)</span>
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span>            :     key = newKey;
<span class="lineNum">     295 </span><span class="lineNoCov">          0 : }</span>
<a name="296"><span class="lineNum">     296 </span>            : </a>
<span class="lineNum">     297 </span>            : /* static */ bool
<span class="lineNum">     298 </span><span class="lineCov">          1 : SavedFrame::finishSavedFrameInit(JSContext* cx, HandleObject ctor, HandleObject proto)</span>
<span class="lineNum">     299 </span>            : {
<span class="lineNum">     300 </span>            :     // The only object with the SavedFrame::class_ that doesn't have a source
<span class="lineNum">     301 </span>            :     // should be the prototype.
<span class="lineNum">     302 </span><span class="lineCov">          1 :     proto-&gt;as&lt;NativeObject&gt;().setReservedSlot(SavedFrame::JSSLOT_SOURCE, NullValue());</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineCov">          1 :     return FreezeObject(cx, proto);</span>
<span class="lineNum">     305 </span>            : }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : static const ClassOps SavedFrameClassOps = {
<span class="lineNum">     308 </span>            :     nullptr,                    // addProperty
<span class="lineNum">     309 </span>            :     nullptr,                    // delProperty
<span class="lineNum">     310 </span>            :     nullptr,                    // getProperty
<span class="lineNum">     311 </span>            :     nullptr,                    // setProperty
<span class="lineNum">     312 </span>            :     nullptr,                    // enumerate
<span class="lineNum">     313 </span>            :     nullptr,                    // resolve
<span class="lineNum">     314 </span>            :     nullptr,                    // mayResolve
<span class="lineNum">     315 </span>            :     SavedFrame::finalize,       // finalize
<span class="lineNum">     316 </span>            :     nullptr,                    // call
<span class="lineNum">     317 </span>            :     nullptr,                    // hasInstance
<span class="lineNum">     318 </span>            :     nullptr,                    // construct
<span class="lineNum">     319 </span>            :     nullptr,                    // trace
<span class="lineNum">     320 </span>            : };
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : const ClassSpec SavedFrame::classSpec_ = {
<span class="lineNum">     323 </span>            :     GenericCreateConstructor&lt;SavedFrame::construct, 0, gc::AllocKind::FUNCTION&gt;,
<span class="lineNum">     324 </span>            :     GenericCreatePrototype,
<span class="lineNum">     325 </span>            :     SavedFrame::staticFunctions,
<span class="lineNum">     326 </span>            :     nullptr,
<span class="lineNum">     327 </span>            :     SavedFrame::protoFunctions,
<span class="lineNum">     328 </span>            :     SavedFrame::protoAccessors,
<span class="lineNum">     329 </span>            :     SavedFrame::finishSavedFrameInit,
<span class="lineNum">     330 </span>            :     ClassSpec::DontDefineConstructor
<span class="lineNum">     331 </span>            : };
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : /* static */ const Class SavedFrame::class_ = {
<span class="lineNum">     334 </span>            :     &quot;SavedFrame&quot;,
<span class="lineNum">     335 </span>            :     JSCLASS_HAS_PRIVATE |
<span class="lineNum">     336 </span>            :     JSCLASS_HAS_RESERVED_SLOTS(SavedFrame::JSSLOT_COUNT) |
<span class="lineNum">     337 </span>            :     JSCLASS_HAS_CACHED_PROTO(JSProto_SavedFrame) |
<span class="lineNum">     338 </span>            :     JSCLASS_IS_ANONYMOUS |
<span class="lineNum">     339 </span>            :     JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     340 </span>            :     &amp;SavedFrameClassOps,
<span class="lineNum">     341 </span>            :     &amp;SavedFrame::classSpec_
<span class="lineNum">     342 </span>            : };
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : /* static */ const JSFunctionSpec
<span class="lineNum">     345 </span>            : SavedFrame::staticFunctions[] = {
<span class="lineNum">     346 </span>            :     JS_FS_END
<span class="lineNum">     347 </span>            : };
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : /* static */ const JSFunctionSpec
<span class="lineNum">     350 </span>            : SavedFrame::protoFunctions[] = {
<span class="lineNum">     351 </span>            :     JS_FN(&quot;constructor&quot;, SavedFrame::construct, 0, 0),
<span class="lineNum">     352 </span>            :     JS_FN(&quot;toString&quot;, SavedFrame::toStringMethod, 0, 0),
<span class="lineNum">     353 </span>            :     JS_FS_END
<span class="lineNum">     354 </span>            : };
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : /* static */ const JSPropertySpec
<span class="lineNum">     357 </span>            : SavedFrame::protoAccessors[] = {
<span class="lineNum">     358 </span>            :     JS_PSG(&quot;source&quot;, SavedFrame::sourceProperty, 0),
<span class="lineNum">     359 </span>            :     JS_PSG(&quot;line&quot;, SavedFrame::lineProperty, 0),
<span class="lineNum">     360 </span>            :     JS_PSG(&quot;column&quot;, SavedFrame::columnProperty, 0),
<span class="lineNum">     361 </span>            :     JS_PSG(&quot;functionDisplayName&quot;, SavedFrame::functionDisplayNameProperty, 0),
<span class="lineNum">     362 </span>            :     JS_PSG(&quot;asyncCause&quot;, SavedFrame::asyncCauseProperty, 0),
<span class="lineNum">     363 </span>            :     JS_PSG(&quot;asyncParent&quot;, SavedFrame::asyncParentProperty, 0),
<span class="lineNum">     364 </span>            :     JS_PSG(&quot;parent&quot;, SavedFrame::parentProperty, 0),
<span class="lineNum">     365 </span>            :     JS_PS_END
<span class="lineNum">     366 </span>            : };
<a name="367"><span class="lineNum">     367 </span>            : </a>
<span class="lineNum">     368 </span>            : /* static */ void
<span class="lineNum">     369 </span><span class="lineCov">          1 : SavedFrame::finalize(FreeOp* fop, JSObject* obj)</span>
<span class="lineNum">     370 </span>            : {
<span class="lineNum">     371 </span>            :     MOZ_ASSERT(fop-&gt;onActiveCooperatingThread());
<span class="lineNum">     372 </span><span class="lineCov">          1 :     JSPrincipals* p = obj-&gt;as&lt;SavedFrame&gt;().getPrincipals();</span>
<span class="lineNum">     373 </span><span class="lineCov">          1 :     if (p) {</span>
<span class="lineNum">     374 </span><span class="lineCov">          1 :         JSRuntime* rt = obj-&gt;runtimeFromActiveCooperatingThread();</span>
<span class="lineNum">     375 </span><span class="lineCov">          1 :         JS_DropPrincipals(rt-&gt;activeContextFromOwnThread(), p);</span>
<span class="lineNum">     376 </span>            :     }
<span class="lineNum">     377 </span><span class="lineCov">          1 : }</span>
<a name="378"><span class="lineNum">     378 </span>            : </a>
<span class="lineNum">     379 </span>            : JSAtom*
<span class="lineNum">     380 </span><span class="lineCov">          1 : SavedFrame::getSource()</span>
<span class="lineNum">     381 </span>            : {
<span class="lineNum">     382 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_SOURCE);</span>
<span class="lineNum">     383 </span><span class="lineCov">          1 :     JSString* s = v.toString();</span>
<span class="lineNum">     384 </span><span class="lineCov">          1 :     return &amp;s-&gt;asAtom();</span>
<span class="lineNum">     385 </span>            : }
<a name="386"><span class="lineNum">     386 </span>            : </a>
<span class="lineNum">     387 </span>            : uint32_t
<span class="lineNum">     388 </span><span class="lineCov">          1 : SavedFrame::getLine()</span>
<span class="lineNum">     389 </span>            : {
<span class="lineNum">     390 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_LINE);</span>
<span class="lineNum">     391 </span><span class="lineCov">          1 :     return v.toPrivateUint32();</span>
<span class="lineNum">     392 </span>            : }
<a name="393"><span class="lineNum">     393 </span>            : </a>
<span class="lineNum">     394 </span>            : uint32_t
<span class="lineNum">     395 </span><span class="lineCov">          1 : SavedFrame::getColumn()</span>
<span class="lineNum">     396 </span>            : {
<span class="lineNum">     397 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_COLUMN);</span>
<span class="lineNum">     398 </span><span class="lineCov">          1 :     return v.toPrivateUint32();</span>
<span class="lineNum">     399 </span>            : }
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : JSAtom*
<span class="lineNum">     402 </span><span class="lineCov">          1 : SavedFrame::getFunctionDisplayName()</span>
<span class="lineNum">     403 </span>            : {
<span class="lineNum">     404 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_FUNCTIONDISPLAYNAME);</span>
<span class="lineNum">     405 </span><span class="lineCov">          1 :     if (v.isNull())</span>
<span class="lineNum">     406 </span>            :         return nullptr;
<span class="lineNum">     407 </span><span class="lineCov">          1 :     JSString* s = v.toString();</span>
<span class="lineNum">     408 </span><span class="lineCov">          1 :     return &amp;s-&gt;asAtom();</span>
<span class="lineNum">     409 </span>            : }
<a name="410"><span class="lineNum">     410 </span>            : </a>
<span class="lineNum">     411 </span>            : JSAtom*
<span class="lineNum">     412 </span><span class="lineCov">          1 : SavedFrame::getAsyncCause()</span>
<span class="lineNum">     413 </span>            : {
<span class="lineNum">     414 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_ASYNCCAUSE);</span>
<span class="lineNum">     415 </span><span class="lineCov">          1 :     if (v.isNull())</span>
<span class="lineNum">     416 </span>            :         return nullptr;
<span class="lineNum">     417 </span><span class="lineCov">          1 :     JSString* s = v.toString();</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     return &amp;s-&gt;asAtom();</span>
<span class="lineNum">     419 </span>            : }
<a name="420"><span class="lineNum">     420 </span>            : </a>
<span class="lineNum">     421 </span>            : SavedFrame*
<span class="lineNum">     422 </span><span class="lineCov">          1 : SavedFrame::getParent() const</span>
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_PARENT);</span>
<span class="lineNum">     425 </span><span class="lineCov">          1 :     return v.isObject() ? &amp;v.toObject().as&lt;SavedFrame&gt;() : nullptr;</span>
<span class="lineNum">     426 </span>            : }
<a name="427"><span class="lineNum">     427 </span>            : </a>
<span class="lineNum">     428 </span>            : JSPrincipals*
<span class="lineNum">     429 </span><span class="lineCov">          1 : SavedFrame::getPrincipals()</span>
<span class="lineNum">     430 </span>            : {
<span class="lineNum">     431 </span><span class="lineCov">          1 :     const Value&amp; v = getReservedSlot(JSSLOT_PRINCIPALS);</span>
<span class="lineNum">     432 </span><span class="lineCov">          1 :     if (v.isUndefined())</span>
<span class="lineNum">     433 </span>            :         return nullptr;
<span class="lineNum">     434 </span><span class="lineCov">          1 :     return static_cast&lt;JSPrincipals*&gt;(v.toPrivate());</span>
<span class="lineNum">     435 </span>            : }
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : void
<span class="lineNum">     438 </span><span class="lineCov">          1 : SavedFrame::initSource(JSAtom* source)</span>
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span>            :     MOZ_ASSERT(source);
<span class="lineNum">     441 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_SOURCE, StringValue(source));</span>
<span class="lineNum">     442 </span><span class="lineCov">          1 : }</span>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<span class="lineNum">     444 </span>            : void
<span class="lineNum">     445 </span><span class="lineCov">          1 : SavedFrame::initLine(uint32_t line)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_LINE, PrivateUint32Value(line));</span>
<span class="lineNum">     448 </span><span class="lineCov">          1 : }</span>
<a name="449"><span class="lineNum">     449 </span>            : </a>
<span class="lineNum">     450 </span>            : void
<span class="lineNum">     451 </span><span class="lineCov">          1 : SavedFrame::initColumn(uint32_t column)</span>
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span>            : #ifdef JS_MORE_DETERMINISTIC
<span class="lineNum">     454 </span>            :     column = 0;
<span class="lineNum">     455 </span>            : #endif
<span class="lineNum">     456 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_COLUMN, PrivateUint32Value(column));</span>
<span class="lineNum">     457 </span><span class="lineCov">          1 : }</span>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<span class="lineNum">     459 </span>            : void
<span class="lineNum">     460 </span><span class="lineCov">          1 : SavedFrame::initPrincipals(JSPrincipals* principals)</span>
<span class="lineNum">     461 </span>            : {
<span class="lineNum">     462 </span><span class="lineCov">          1 :     if (principals)</span>
<span class="lineNum">     463 </span><span class="lineCov">          1 :         JS_HoldPrincipals(principals);</span>
<span class="lineNum">     464 </span>            :     initPrincipalsAlreadyHeld(principals);
<span class="lineNum">     465 </span><span class="lineCov">          1 : }</span>
<a name="466"><span class="lineNum">     466 </span>            : </a>
<span class="lineNum">     467 </span>            : void
<span class="lineNum">     468 </span><span class="lineCov">          1 : SavedFrame::initPrincipalsAlreadyHeld(JSPrincipals* principals)</span>
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span>            :     MOZ_ASSERT_IF(principals, principals-&gt;refcount &gt; 0);
<span class="lineNum">     471 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_PRINCIPALS, PrivateValue(principals));</span>
<span class="lineNum">     472 </span><span class="lineCov">          1 : }</span>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<span class="lineNum">     474 </span>            : void
<span class="lineNum">     475 </span><span class="lineCov">          1 : SavedFrame::initFunctionDisplayName(JSAtom* maybeName)</span>
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_FUNCTIONDISPLAYNAME, maybeName ? StringValue(maybeName) : NullValue());</span>
<span class="lineNum">     478 </span><span class="lineCov">          1 : }</span>
<a name="479"><span class="lineNum">     479 </span>            : </a>
<span class="lineNum">     480 </span>            : void
<span class="lineNum">     481 </span><span class="lineCov">          1 : SavedFrame::initAsyncCause(JSAtom* maybeCause)</span>
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_ASYNCCAUSE, maybeCause ? StringValue(maybeCause) : NullValue());</span>
<span class="lineNum">     484 </span><span class="lineCov">          1 : }</span>
<a name="485"><span class="lineNum">     485 </span>            : </a>
<span class="lineNum">     486 </span>            : void
<span class="lineNum">     487 </span><span class="lineCov">          1 : SavedFrame::initParent(SavedFrame* maybeParent)</span>
<span class="lineNum">     488 </span>            : {
<span class="lineNum">     489 </span><span class="lineCov">          1 :     initReservedSlot(JSSLOT_PARENT, ObjectOrNullValue(maybeParent));</span>
<span class="lineNum">     490 </span><span class="lineCov">          1 : }</span>
<a name="491"><span class="lineNum">     491 </span>            : </a>
<span class="lineNum">     492 </span>            : void
<span class="lineNum">     493 </span><span class="lineCov">          1 : SavedFrame::initFromLookup(JSContext* cx, SavedFrame::HandleLookup lookup)</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span>            :     // Make sure any atoms used in the lookup are marked in the current zone.
<span class="lineNum">     496 </span>            :     // Normally we would try to keep these mark bits up to date around the
<span class="lineNum">     497 </span>            :     // points where the context moves between compartments, but Lookups live on
<span class="lineNum">     498 </span>            :     // the stack (where the atoms are kept alive regardless) and this is a
<span class="lineNum">     499 </span>            :     // more convenient pinchpoint.
<span class="lineNum">     500 </span><span class="lineCov">          1 :     if (lookup-&gt;source)</span>
<span class="lineNum">     501 </span><span class="lineCov">          1 :         cx-&gt;markAtom(lookup-&gt;source);</span>
<span class="lineNum">     502 </span><span class="lineCov">          1 :     if (lookup-&gt;functionDisplayName)</span>
<span class="lineNum">     503 </span><span class="lineCov">          1 :         cx-&gt;markAtom(lookup-&gt;functionDisplayName);</span>
<span class="lineNum">     504 </span><span class="lineCov">          1 :     if (lookup-&gt;asyncCause)</span>
<span class="lineNum">     505 </span><span class="lineCov">          1 :         cx-&gt;markAtom(lookup-&gt;asyncCause);</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">          1 :     initSource(lookup-&gt;source);</span>
<span class="lineNum">     508 </span><span class="lineCov">          1 :     initLine(lookup-&gt;line);</span>
<span class="lineNum">     509 </span><span class="lineCov">          1 :     initColumn(lookup-&gt;column);</span>
<span class="lineNum">     510 </span><span class="lineCov">          1 :     initFunctionDisplayName(lookup-&gt;functionDisplayName);</span>
<span class="lineNum">     511 </span><span class="lineCov">          1 :     initAsyncCause(lookup-&gt;asyncCause);</span>
<span class="lineNum">     512 </span><span class="lineCov">          1 :     initParent(lookup-&gt;parent);</span>
<span class="lineNum">     513 </span><span class="lineCov">          1 :     initPrincipals(lookup-&gt;principals);</span>
<span class="lineNum">     514 </span><span class="lineCov">          1 : }</span>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<span class="lineNum">     516 </span>            : /* static */ SavedFrame*
<span class="lineNum">     517 </span><span class="lineCov">          1 : SavedFrame::create(JSContext* cx)</span>
<span class="lineNum">     518 </span>            : {
<span class="lineNum">     519 </span><span class="lineCov">          1 :     RootedGlobalObject global(cx, cx-&gt;global());</span>
<span class="lineNum">     520 </span><span class="lineCov">          1 :     assertSameCompartment(cx, global);</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :     // Ensure that we don't try to capture the stack again in the
<span class="lineNum">     523 </span>            :     // `SavedStacksMetadataBuilder` for this new SavedFrame object, and
<span class="lineNum">     524 </span>            :     // accidentally cause O(n^2) behavior.
<span class="lineNum">     525 </span><span class="lineCov">          1 :     SavedStacks::AutoReentrancyGuard guard(cx-&gt;compartment()-&gt;savedStacks());</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">          1 :     RootedNativeObject proto(cx, GlobalObject::getOrCreateSavedFramePrototype(cx, global));</span>
<span class="lineNum">     528 </span><span class="lineCov">          1 :     if (!proto)</span>
<span class="lineNum">     529 </span>            :         return nullptr;
<span class="lineNum">     530 </span><span class="lineCov">          1 :     assertSameCompartment(cx, proto);</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :     RootedObject frameObj(cx, NewObjectWithGivenProto(cx, &amp;SavedFrame::class_, proto,
<span class="lineNum">     533 </span><span class="lineCov">          1 :                                                       TenuredObject));</span>
<span class="lineNum">     534 </span><span class="lineCov">          1 :     if (!frameObj)</span>
<span class="lineNum">     535 </span>            :         return nullptr;
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineCov">          1 :     return &amp;frameObj-&gt;as&lt;SavedFrame&gt;();</span>
<span class="lineNum">     538 </span>            : }
<a name="539"><span class="lineNum">     539 </span>            : </a>
<span class="lineNum">     540 </span>            : bool
<span class="lineNum">     541 </span><span class="lineNoCov">          0 : SavedFrame::isSelfHosted(JSContext* cx)</span>
<span class="lineNum">     542 </span>            : {
<span class="lineNum">     543 </span><span class="lineCov">          1 :     JSAtom* source = getSource();</span>
<span class="lineNum">     544 </span><span class="lineCov">          1 :     return source == cx-&gt;names().selfHosted;</span>
<span class="lineNum">     545 </span>            : }
<a name="546"><span class="lineNum">     546 </span>            : </a>
<span class="lineNum">     547 </span>            : /* static */ bool
<span class="lineNum">     548 </span><span class="lineNoCov">          0 : SavedFrame::construct(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">     549 </span>            : {
<span class="lineNum">     550 </span>            :     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_NO_CONSTRUCTOR,
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                               &quot;SavedFrame&quot;);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     553 </span>            : }
<a name="554"><span class="lineNum">     554 </span>            : </a>
<span class="lineNum">     555 </span>            : static bool
<span class="lineNum">     556 </span><span class="lineCov">          1 : SavedFrameSubsumedByCaller(JSContext* cx, HandleSavedFrame frame)</span>
<span class="lineNum">     557 </span>            : {
<span class="lineNum">     558 </span><span class="lineCov">          1 :     auto subsumes = cx-&gt;runtime()-&gt;securityCallbacks-&gt;subsumes;</span>
<span class="lineNum">     559 </span><span class="lineCov">          1 :     if (!subsumes)</span>
<span class="lineNum">     560 </span>            :         return true;
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineCov">          1 :     auto currentCompartmentPrincipals = cx-&gt;compartment()-&gt;principals();</span>
<span class="lineNum">     563 </span>            :     MOZ_ASSERT(!ReconstructedSavedFramePrincipals::is(currentCompartmentPrincipals));
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineCov">          1 :     auto framePrincipals = frame-&gt;getPrincipals();</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            :     // Handle SavedFrames that have been reconstructed from stacks in a heap
<span class="lineNum">     568 </span>            :     // snapshot.
<span class="lineNum">     569 </span><span class="lineCov">          1 :     if (framePrincipals == &amp;ReconstructedSavedFramePrincipals::IsSystem)</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         return cx-&gt;runningWithTrustedPrincipals();</span>
<span class="lineNum">     571 </span><span class="lineCov">          1 :     if (framePrincipals == &amp;ReconstructedSavedFramePrincipals::IsNotSystem)</span>
<span class="lineNum">     572 </span>            :         return true;
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineCov">          1 :     return subsumes(currentCompartmentPrincipals, framePrincipals);</span>
<span class="lineNum">     575 </span>            : }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : // Return the first SavedFrame in the chain that starts with |frame| whose
<span class="lineNum">     578 </span>            : // principals are subsumed by |principals|, according to |subsumes|. If there is
<span class="lineNum">     579 </span>            : // no such frame, return nullptr. |skippedAsync| is set to true if any of the
<span class="lineNum">     580 </span>            : // skipped frames had the |asyncCause| property set, otherwise it is explicitly
<a name="581"><span class="lineNum">     581 </span>            : // set to false.</a>
<span class="lineNum">     582 </span>            : static SavedFrame*
<span class="lineNum">     583 </span><span class="lineCov">          1 : GetFirstSubsumedFrame(JSContext* cx, HandleSavedFrame frame, JS::SavedFrameSelfHosted selfHosted,</span>
<span class="lineNum">     584 </span>            :                       bool&amp; skippedAsync)
<span class="lineNum">     585 </span>            : {
<span class="lineNum">     586 </span><span class="lineCov">          1 :     skippedAsync = false;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :     RootedSavedFrame rootedFrame(cx, frame);
<span class="lineNum">     589 </span><span class="lineCov">          1 :     while (rootedFrame) {</span>
<span class="lineNum">     590 </span><span class="lineCov">          1 :         if ((selfHosted == JS::SavedFrameSelfHosted::Include ||</span>
<span class="lineNum">     591 </span><span class="lineCov">          1 :              !rootedFrame-&gt;isSelfHosted(cx)) &amp;&amp;</span>
<span class="lineNum">     592 </span><span class="lineCov">          1 :             SavedFrameSubsumedByCaller(cx, rootedFrame))</span>
<span class="lineNum">     593 </span>            :         {
<span class="lineNum">     594 </span><span class="lineCov">          1 :             return rootedFrame;</span>
<span class="lineNum">     595 </span>            :         }
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineCov">          1 :         if (rootedFrame-&gt;getAsyncCause())</span>
<span class="lineNum">     598 </span><span class="lineCov">          1 :             skippedAsync = true;</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineCov">          1 :         rootedFrame = rootedFrame-&gt;getParent();</span>
<span class="lineNum">     601 </span>            :     }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     return nullptr;
<span class="lineNum">     604 </span>            : }
<a name="605"><span class="lineNum">     605 </span>            : </a>
<span class="lineNum">     606 </span>            : JS_FRIEND_API(JSObject*)
<span class="lineNum">     607 </span><span class="lineNoCov">          0 : GetFirstSubsumedSavedFrame(JSContext* cx, HandleObject savedFrame,</span>
<span class="lineNum">     608 </span>            :                            JS::SavedFrameSelfHosted selfHosted)
<span class="lineNum">     609 </span>            : {
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     if (!savedFrame)</span>
<span class="lineNum">     611 </span>            :         return nullptr;
<span class="lineNum">     612 </span>            :     bool skippedAsync;
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     RootedSavedFrame frame(cx, &amp;savedFrame-&gt;as&lt;SavedFrame&gt;());</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     return GetFirstSubsumedFrame(cx, frame, selfHosted, skippedAsync);</span>
<span class="lineNum">     615 </span>            : }
<a name="616"><span class="lineNum">     616 </span>            : </a>
<span class="lineNum">     617 </span>            : static MOZ_MUST_USE bool
<span class="lineNum">     618 </span><span class="lineCov">          1 : SavedFrame_checkThis(JSContext* cx, CallArgs&amp; args, const char* fnName,</span>
<span class="lineNum">     619 </span>            :                      MutableHandleObject frame)
<span class="lineNum">     620 </span>            : {
<span class="lineNum">     621 </span><span class="lineCov">          1 :     const Value&amp; thisValue = args.thisv();</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineCov">          1 :     if (!thisValue.isObject()) {</span>
<span class="lineNum">     624 </span>            :         JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_NOT_NONNULL_OBJECT,
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                                   InformalValueTypeName(thisValue));</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineCov">          1 :     JSObject* thisObject = CheckedUnwrap(&amp;thisValue.toObject());</span>
<span class="lineNum">     630 </span><span class="lineCov">          1 :     if (!thisObject || !thisObject-&gt;is&lt;SavedFrame&gt;()) {</span>
<span class="lineNum">     631 </span>            :         JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_INCOMPATIBLE_PROTO,
<span class="lineNum">     632 </span>            :                                   SavedFrame::class_.name, fnName,
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                                   thisObject ? thisObject-&gt;getClass()-&gt;name : &quot;object&quot;);</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     635 </span>            :     }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :     // Check for SavedFrame.prototype, which has the same class as SavedFrame
<span class="lineNum">     638 </span>            :     // instances, however doesn't actually represent a captured stack frame. It
<span class="lineNum">     639 </span>            :     // is the only object that is&lt;SavedFrame&gt;() but doesn't have a source.
<span class="lineNum">     640 </span><span class="lineCov">          1 :     if (!SavedFrame::isSavedFrameAndNotProto(*thisObject)) {</span>
<span class="lineNum">     641 </span>            :         JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_INCOMPATIBLE_PROTO,
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :                                   SavedFrame::class_.name, fnName, &quot;prototype object&quot;);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     644 </span>            :     }
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :     // Now set &quot;frame&quot; to the actual object we were invoked in (which may be a
<span class="lineNum">     647 </span>            :     // wrapper), not the unwrapped version.  Consumers will need to know what
<span class="lineNum">     648 </span>            :     // that original object was, and will do principal checks as needed.
<span class="lineNum">     649 </span><span class="lineCov">          1 :     frame.set(&amp;thisValue.toObject());</span>
<span class="lineNum">     650 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">     651 </span>            : }
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            : // Get the SavedFrame * from the current this value and handle any errors that
<span class="lineNum">     654 </span>            : // might occur therein.
<span class="lineNum">     655 </span>            : //
<span class="lineNum">     656 </span>            : // These parameters must already exist when calling this macro:
<span class="lineNum">     657 </span>            : //   - JSContext* cx
<span class="lineNum">     658 </span>            : //   - unsigned   argc
<span class="lineNum">     659 </span>            : //   - Value*     vp
<span class="lineNum">     660 </span>            : //   - const char* fnName
<span class="lineNum">     661 </span>            : // These parameters will be defined after calling this macro:
<span class="lineNum">     662 </span>            : //   - CallArgs args
<span class="lineNum">     663 </span>            : //   - Rooted&lt;SavedFrame*&gt; frame (will be non-null)
<span class="lineNum">     664 </span>            : #define THIS_SAVEDFRAME(cx, argc, vp, fnName, args, frame)             \
<span class="lineNum">     665 </span>            :     CallArgs args = CallArgsFromVp(argc, vp);                          \
<span class="lineNum">     666 </span>            :     RootedObject frame(cx);                                            \
<span class="lineNum">     667 </span>            :     if (!SavedFrame_checkThis(cx, args, fnName, &amp;frame))               \
<span class="lineNum">     668 </span>            :         return false;
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            : } /* namespace js */
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : namespace JS {
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : namespace {
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : // It's possible that our caller is privileged (and hence would see the entire
<span class="lineNum">     677 </span>            : // stack) but we're working with an SavedFrame object that was captured in
<span class="lineNum">     678 </span>            : // unprivileged code.  If so, drop privileges down to its level.  The idea is
<span class="lineNum">     679 </span>            : // that this way devtools code that's asking an exception object for a stack to
<span class="lineNum">     680 </span>            : // display will end up with the stack the web developer would see via doing
<span class="lineNum">     681 </span>            : // .stack in a web page, with Firefox implementation details excluded.
<span class="lineNum">     682 </span>            : //
<span class="lineNum">     683 </span>            : // We want callers to pass us the object they were actually passed, not an
<span class="lineNum">     684 </span>            : // unwrapped form of it.  That way Xray access to SavedFrame objects should not
<span class="lineNum">     685 </span>            : // be affected by AutoMaybeEnterFrameCompartment and the only things that will
<span class="lineNum">     686 </span>            : // be affected will be cases in which privileged code works with some C++ object
<span class="lineNum">     687 </span>            : // that then pokes at an unprivileged StackFrame it has on hand.
<span class="lineNum">     688 </span><span class="lineCov">          1 : class MOZ_STACK_CLASS AutoMaybeEnterFrameCompartment</span>
<a name="689"><span class="lineNum">     689 </span>            : {</a>
<span class="lineNum">     690 </span>            : public:
<span class="lineNum">     691 </span><span class="lineCov">          1 :     AutoMaybeEnterFrameCompartment(JSContext* cx,</span>
<span class="lineNum">     692 </span>            :                                    HandleObject obj
<span class="lineNum">     693 </span>            :                                    MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">     694 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">     695 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineCov">          1 :         MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     698 </span><span class="lineCov">          1 :         if (obj)</span>
<span class="lineNum">     699 </span><span class="lineCov">          1 :             MOZ_RELEASE_ASSERT(obj-&gt;compartment());</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :         // Note that obj might be null here, since we're doing this before
<span class="lineNum">     702 </span>            :         // UnwrapSavedFrame.
<span class="lineNum">     703 </span><span class="lineCov">          1 :         if (obj &amp;&amp; cx-&gt;compartment() != obj-&gt;compartment())</span>
<span class="lineNum">     704 </span>            :         {
<span class="lineNum">     705 </span><span class="lineCov">          1 :             JSSubsumesOp subsumes = cx-&gt;runtime()-&gt;securityCallbacks-&gt;subsumes;</span>
<span class="lineNum">     706 </span><span class="lineCov">          1 :             if (subsumes &amp;&amp; subsumes(cx-&gt;compartment()-&gt;principals(),</span>
<span class="lineNum">     707 </span><span class="lineCov">          1 :                                      obj-&gt;compartment()-&gt;principals()))</span>
<span class="lineNum">     708 </span>            :             {
<span class="lineNum">     709 </span><span class="lineCov">          1 :                 ac_.emplace(cx, obj);</span>
<span class="lineNum">     710 </span>            :             }
<span class="lineNum">     711 </span>            :         }
<span class="lineNum">     712 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :  private:
<span class="lineNum">     715 </span>            :     Maybe&lt;JSAutoCompartment&gt; ac_;
<span class="lineNum">     716 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     717 </span>            : };
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : } // namespace
<a name="720"><span class="lineNum">     720 </span>            : </a>
<span class="lineNum">     721 </span>            : static inline js::SavedFrame*
<span class="lineNum">     722 </span><span class="lineCov">          1 : UnwrapSavedFrame(JSContext* cx, HandleObject obj, SavedFrameSelfHosted selfHosted,</span>
<span class="lineNum">     723 </span>            :                  bool&amp; skippedAsync)
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span><span class="lineCov">          1 :     if (!obj)</span>
<span class="lineNum">     726 </span>            :         return nullptr;
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineCov">          1 :     RootedObject savedFrameObj(cx, CheckedUnwrap(obj));</span>
<span class="lineNum">     729 </span><span class="lineCov">          1 :     if (!savedFrameObj)</span>
<span class="lineNum">     730 </span>            :         return nullptr;
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(js::SavedFrame::isSavedFrameAndNotProto(*savedFrameObj));</span>
<span class="lineNum">     733 </span><span class="lineCov">          1 :     js::RootedSavedFrame frame(cx, &amp;savedFrameObj-&gt;as&lt;js::SavedFrame&gt;());</span>
<span class="lineNum">     734 </span><span class="lineCov">          1 :     return GetFirstSubsumedFrame(cx, frame, selfHosted, skippedAsync);</span>
<span class="lineNum">     735 </span>            : }
<a name="736"><span class="lineNum">     736 </span>            : </a>
<span class="lineNum">     737 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     738 </span><span class="lineCov">          1 : GetSavedFrameSource(JSContext* cx, HandleObject savedFrame, MutableHandleString sourcep,</span>
<span class="lineNum">     739 </span>            :                     SavedFrameSelfHosted selfHosted /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     740 </span>            : {
<span class="lineNum">     741 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     742 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     743 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :     {
<span class="lineNum">     746 </span><span class="lineCov">          1 :         AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     747 </span>            :         bool skippedAsync;
<span class="lineNum">     748 </span><span class="lineCov">          1 :         js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, selfHosted, skippedAsync));</span>
<span class="lineNum">     749 </span><span class="lineCov">          1 :         if (!frame) {</span>
<span class="lineNum">     750 </span><span class="lineCov">          1 :             sourcep.set(cx-&gt;runtime()-&gt;emptyString);</span>
<span class="lineNum">     751 </span><span class="lineCov">          1 :             return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     752 </span>            :         }
<span class="lineNum">     753 </span><span class="lineCov">          1 :         sourcep.set(frame-&gt;getSource());</span>
<span class="lineNum">     754 </span>            :     }
<span class="lineNum">     755 </span><span class="lineCov">          1 :     if (sourcep-&gt;isAtom())</span>
<span class="lineNum">     756 </span><span class="lineCov">          1 :         cx-&gt;markAtom(&amp;sourcep-&gt;asAtom());</span>
<span class="lineNum">     757 </span>            :     return SavedFrameResult::Ok;
<span class="lineNum">     758 </span>            : }
<a name="759"><span class="lineNum">     759 </span>            : </a>
<span class="lineNum">     760 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     761 </span><span class="lineCov">          1 : GetSavedFrameLine(JSContext* cx, HandleObject savedFrame, uint32_t* linep,</span>
<span class="lineNum">     762 </span>            :                   SavedFrameSelfHosted selfHosted /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     763 </span>            : {
<span class="lineNum">     764 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     765 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     766 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     767 </span>            :     MOZ_ASSERT(linep);
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">          1 :     AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     770 </span>            :     bool skippedAsync;
<span class="lineNum">     771 </span><span class="lineCov">          1 :     js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, selfHosted, skippedAsync));</span>
<span class="lineNum">     772 </span><span class="lineCov">          1 :     if (!frame) {</span>
<span class="lineNum">     773 </span><span class="lineCov">          1 :         *linep = 0;</span>
<span class="lineNum">     774 </span><span class="lineCov">          1 :         return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     775 </span>            :     }
<span class="lineNum">     776 </span><span class="lineCov">          1 :     *linep = frame-&gt;getLine();</span>
<span class="lineNum">     777 </span><span class="lineCov">          1 :     return SavedFrameResult::Ok;</span>
<span class="lineNum">     778 </span>            : }
<a name="779"><span class="lineNum">     779 </span>            : </a>
<span class="lineNum">     780 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     781 </span><span class="lineCov">          1 : GetSavedFrameColumn(JSContext* cx, HandleObject savedFrame, uint32_t* columnp,</span>
<span class="lineNum">     782 </span>            :                     SavedFrameSelfHosted selfHosted /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     783 </span>            : {
<span class="lineNum">     784 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     785 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     786 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     787 </span>            :     MOZ_ASSERT(columnp);
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineCov">          1 :     AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     790 </span>            :     bool skippedAsync;
<span class="lineNum">     791 </span><span class="lineCov">          1 :     js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, selfHosted, skippedAsync));</span>
<span class="lineNum">     792 </span><span class="lineCov">          1 :     if (!frame) {</span>
<span class="lineNum">     793 </span><span class="lineCov">          1 :         *columnp = 0;</span>
<span class="lineNum">     794 </span><span class="lineCov">          1 :         return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span><span class="lineCov">          1 :     *columnp = frame-&gt;getColumn();</span>
<span class="lineNum">     797 </span><span class="lineCov">          1 :     return SavedFrameResult::Ok;</span>
<span class="lineNum">     798 </span>            : }
<a name="799"><span class="lineNum">     799 </span>            : </a>
<span class="lineNum">     800 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     801 </span><span class="lineCov">          1 : GetSavedFrameFunctionDisplayName(JSContext* cx, HandleObject savedFrame, MutableHandleString namep,</span>
<span class="lineNum">     802 </span>            :                                  SavedFrameSelfHosted selfHosted /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     803 </span>            : {
<span class="lineNum">     804 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     805 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     806 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :     {
<span class="lineNum">     809 </span><span class="lineCov">          1 :         AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     810 </span>            :         bool skippedAsync;
<span class="lineNum">     811 </span><span class="lineCov">          1 :         js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, selfHosted, skippedAsync));</span>
<span class="lineNum">     812 </span><span class="lineCov">          1 :         if (!frame) {</span>
<span class="lineNum">     813 </span><span class="lineCov">          1 :             namep.set(nullptr);</span>
<span class="lineNum">     814 </span><span class="lineCov">          1 :             return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     815 </span>            :         }
<span class="lineNum">     816 </span><span class="lineCov">          1 :         namep.set(frame-&gt;getFunctionDisplayName());</span>
<span class="lineNum">     817 </span>            :     }
<span class="lineNum">     818 </span><span class="lineCov">          1 :     if (namep &amp;&amp; namep-&gt;isAtom())</span>
<span class="lineNum">     819 </span><span class="lineCov">          1 :         cx-&gt;markAtom(&amp;namep-&gt;asAtom());</span>
<span class="lineNum">     820 </span>            :     return SavedFrameResult::Ok;
<span class="lineNum">     821 </span>            : }
<a name="822"><span class="lineNum">     822 </span>            : </a>
<span class="lineNum">     823 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     824 </span><span class="lineCov">          1 : GetSavedFrameAsyncCause(JSContext* cx, HandleObject savedFrame, MutableHandleString asyncCausep,</span>
<span class="lineNum">     825 </span>            :                         SavedFrameSelfHosted unused_ /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     826 </span>            : {
<span class="lineNum">     827 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     828 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     829 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :     {
<span class="lineNum">     832 </span><span class="lineCov">          1 :         AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     833 </span>            :         bool skippedAsync;
<span class="lineNum">     834 </span>            :         // This function is always called with self-hosted frames excluded by
<span class="lineNum">     835 </span>            :         // GetValueIfNotCached in dom/bindings/Exceptions.cpp. However, we want
<span class="lineNum">     836 </span>            :         // to include them because our Promise implementation causes us to have
<span class="lineNum">     837 </span>            :         // the async cause on a self-hosted frame. So we just ignore the
<span class="lineNum">     838 </span>            :         // parameter and always include self-hosted frames.
<span class="lineNum">     839 </span>            :         js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, SavedFrameSelfHosted::Include,
<span class="lineNum">     840 </span><span class="lineCov">          1 :                                                         skippedAsync));</span>
<span class="lineNum">     841 </span><span class="lineCov">          1 :         if (!frame) {</span>
<span class="lineNum">     842 </span><span class="lineCov">          1 :             asyncCausep.set(nullptr);</span>
<span class="lineNum">     843 </span><span class="lineCov">          1 :             return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     844 </span>            :         }
<span class="lineNum">     845 </span><span class="lineCov">          1 :         asyncCausep.set(frame-&gt;getAsyncCause());</span>
<span class="lineNum">     846 </span><span class="lineCov">          1 :         if (!asyncCausep &amp;&amp; skippedAsync)</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :             asyncCausep.set(cx-&gt;names().Async);</span>
<span class="lineNum">     848 </span>            :     }
<span class="lineNum">     849 </span><span class="lineCov">          1 :     if (asyncCausep &amp;&amp; asyncCausep-&gt;isAtom())</span>
<span class="lineNum">     850 </span><span class="lineCov">          1 :         cx-&gt;markAtom(&amp;asyncCausep-&gt;asAtom());</span>
<span class="lineNum">     851 </span>            :     return SavedFrameResult::Ok;
<span class="lineNum">     852 </span>            : }
<a name="853"><span class="lineNum">     853 </span>            : </a>
<span class="lineNum">     854 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     855 </span><span class="lineCov">          1 : GetSavedFrameAsyncParent(JSContext* cx, HandleObject savedFrame, MutableHandleObject asyncParentp,</span>
<span class="lineNum">     856 </span>            :                          SavedFrameSelfHosted selfHosted /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     859 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     860 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">          1 :     AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     863 </span>            :     bool skippedAsync;
<span class="lineNum">     864 </span><span class="lineCov">          1 :     js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, selfHosted, skippedAsync));</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :     if (!frame) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :         asyncParentp.set(nullptr);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span><span class="lineCov">          1 :     js::RootedSavedFrame parent(cx, frame-&gt;getParent());</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :     // The current value of |skippedAsync| is not interesting, because we are
<span class="lineNum">     872 </span>            :     // interested in whether we would cross any async parents to get from here
<span class="lineNum">     873 </span>            :     // to the first subsumed parent frame instead.
<span class="lineNum">     874 </span>            :     js::RootedSavedFrame subsumedParent(cx, GetFirstSubsumedFrame(cx, parent, selfHosted,
<span class="lineNum">     875 </span><span class="lineCov">          1 :                                                                   skippedAsync));</span>
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            :     // Even if |parent| is not subsumed, we still want to return a pointer to it
<span class="lineNum">     878 </span>            :     // rather than |subsumedParent| so it can pick up any |asyncCause| from the
<span class="lineNum">     879 </span>            :     // inaccessible part of the chain.
<span class="lineNum">     880 </span><span class="lineCov">          1 :     if (subsumedParent &amp;&amp; (subsumedParent-&gt;getAsyncCause() || skippedAsync))</span>
<span class="lineNum">     881 </span><span class="lineCov">          1 :         asyncParentp.set(parent);</span>
<span class="lineNum">     882 </span>            :     else
<span class="lineNum">     883 </span><span class="lineCov">          1 :         asyncParentp.set(nullptr);</span>
<span class="lineNum">     884 </span><span class="lineCov">          1 :     return SavedFrameResult::Ok;</span>
<span class="lineNum">     885 </span>            : }
<a name="886"><span class="lineNum">     886 </span>            : </a>
<span class="lineNum">     887 </span>            : JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">     888 </span><span class="lineCov">          1 : GetSavedFrameParent(JSContext* cx, HandleObject savedFrame, MutableHandleObject parentp,</span>
<span class="lineNum">     889 </span>            :                     SavedFrameSelfHosted selfHosted /* = SavedFrameSelfHosted::Include */)
<span class="lineNum">     890 </span>            : {
<span class="lineNum">     891 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     892 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     893 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">          1 :     AutoMaybeEnterFrameCompartment ac(cx, savedFrame);</span>
<span class="lineNum">     896 </span>            :     bool skippedAsync;
<span class="lineNum">     897 </span><span class="lineCov">          1 :     js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, savedFrame, selfHosted, skippedAsync));</span>
<span class="lineNum">     898 </span><span class="lineCov">          1 :     if (!frame) {</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         parentp.set(nullptr);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         return SavedFrameResult::AccessDenied;</span>
<span class="lineNum">     901 </span>            :     }
<span class="lineNum">     902 </span><span class="lineCov">          1 :     js::RootedSavedFrame parent(cx, frame-&gt;getParent());</span>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span>            :     // The current value of |skippedAsync| is not interesting, because we are
<span class="lineNum">     905 </span>            :     // interested in whether we would cross any async parents to get from here
<span class="lineNum">     906 </span>            :     // to the first subsumed parent frame instead.
<span class="lineNum">     907 </span>            :     js::RootedSavedFrame subsumedParent(cx, GetFirstSubsumedFrame(cx, parent, selfHosted,
<span class="lineNum">     908 </span><span class="lineCov">          1 :                                                                   skippedAsync));</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :     // Even if |parent| is not subsumed, we still want to return a pointer to it
<span class="lineNum">     911 </span>            :     // rather than |subsumedParent| so it can pick up any |asyncCause| from the
<span class="lineNum">     912 </span>            :     // inaccessible part of the chain.
<span class="lineNum">     913 </span><span class="lineCov">          1 :     if (subsumedParent &amp;&amp; !(subsumedParent-&gt;getAsyncCause() || skippedAsync))</span>
<span class="lineNum">     914 </span><span class="lineCov">          1 :         parentp.set(parent);</span>
<span class="lineNum">     915 </span>            :     else
<span class="lineNum">     916 </span><span class="lineCov">          1 :         parentp.set(nullptr);</span>
<span class="lineNum">     917 </span><span class="lineCov">          1 :     return SavedFrameResult::Ok;</span>
<span class="lineNum">     918 </span>            : }
<a name="919"><span class="lineNum">     919 </span>            : </a>
<span class="lineNum">     920 </span>            : static bool
<span class="lineNum">     921 </span><span class="lineCov">          1 : FormatSpiderMonkeyStackFrame(JSContext* cx, js::StringBuffer&amp; sb,</span>
<span class="lineNum">     922 </span>            :                              js::HandleSavedFrame frame, size_t indent,
<span class="lineNum">     923 </span>            :                              bool skippedAsync)
<span class="lineNum">     924 </span>            : {
<span class="lineNum">     925 </span><span class="lineCov">          1 :     RootedString asyncCause(cx, frame-&gt;getAsyncCause());</span>
<span class="lineNum">     926 </span><span class="lineCov">          1 :     if (!asyncCause &amp;&amp; skippedAsync)</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :         asyncCause.set(cx-&gt;names().Async);</span>
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineCov">          1 :     js::RootedAtom name(cx, frame-&gt;getFunctionDisplayName());</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     return (!indent || sb.appendN(' ', indent))</span>
<span class="lineNum">     931 </span><span class="lineCov">          1 :         &amp;&amp; (!asyncCause || (sb.append(asyncCause) &amp;&amp; sb.append('*')))</span>
<span class="lineNum">     932 </span><span class="lineCov">          1 :         &amp;&amp; (!name || sb.append(name))</span>
<span class="lineNum">     933 </span><span class="lineCov">          1 :         &amp;&amp; sb.append('@')</span>
<span class="lineNum">     934 </span><span class="lineCov">          1 :         &amp;&amp; sb.append(frame-&gt;getSource())</span>
<span class="lineNum">     935 </span><span class="lineCov">          1 :         &amp;&amp; sb.append(':')</span>
<span class="lineNum">     936 </span><span class="lineCov">          1 :         &amp;&amp; NumberValueToStringBuffer(cx, NumberValue(frame-&gt;getLine()), sb)</span>
<span class="lineNum">     937 </span><span class="lineCov">          1 :         &amp;&amp; sb.append(':')</span>
<span class="lineNum">     938 </span><span class="lineCov">          1 :         &amp;&amp; NumberValueToStringBuffer(cx, NumberValue(frame-&gt;getColumn()), sb)</span>
<span class="lineNum">     939 </span><span class="lineCov">          1 :         &amp;&amp; sb.append('\n');</span>
<span class="lineNum">     940 </span>            : }
<a name="941"><span class="lineNum">     941 </span>            : </a>
<span class="lineNum">     942 </span>            : static bool
<span class="lineNum">     943 </span><span class="lineNoCov">          0 : FormatV8StackFrame(JSContext* cx, js::StringBuffer&amp; sb,</span>
<span class="lineNum">     944 </span>            :                    js::HandleSavedFrame frame, size_t indent, bool lastFrame)
<span class="lineNum">     945 </span>            : {
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     js::RootedAtom name(cx, frame-&gt;getFunctionDisplayName());</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     return sb.appendN(' ', indent + 4)</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         &amp;&amp; sb.append('a')</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :         &amp;&amp; sb.append('t')</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         &amp;&amp; sb.append(' ')</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :         &amp;&amp; (!name || (sb.append(name) &amp;&amp;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :                       sb.append(' ') &amp;&amp;</span>
<span class="lineNum">     953 </span>            :                       sb.append('(')))
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         &amp;&amp; sb.append(frame-&gt;getSource())</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         &amp;&amp; sb.append(':')</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         &amp;&amp; NumberValueToStringBuffer(cx, NumberValue(frame-&gt;getLine()), sb)</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         &amp;&amp; sb.append(':')</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         &amp;&amp; NumberValueToStringBuffer(cx, NumberValue(frame-&gt;getColumn()), sb)</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :         &amp;&amp; (!name || sb.append(')'))</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         &amp;&amp; (lastFrame || sb.append('\n'));</span>
<span class="lineNum">     961 </span>            : }
<a name="962"><span class="lineNum">     962 </span>            : </a>
<span class="lineNum">     963 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">     964 </span><span class="lineCov">          1 : BuildStackString(JSContext* cx, HandleObject stack, MutableHandleString stringp,</span>
<span class="lineNum">     965 </span>            :                  size_t indent, js::StackFormat format)
<span class="lineNum">     966 </span>            : {
<span class="lineNum">     967 </span><span class="lineCov">          1 :     js::AssertHeapIsIdle();</span>
<span class="lineNum">     968 </span>            :     CHECK_REQUEST(cx);
<span class="lineNum">     969 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span><span class="lineCov">          1 :     js::StringBuffer sb(cx);</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span><span class="lineCov">          1 :     if (format == js::StackFormat::Default)</span>
<span class="lineNum">     974 </span><span class="lineCov">          1 :         format = cx-&gt;runtime()-&gt;stackFormat();</span>
<span class="lineNum">     975 </span>            :     MOZ_ASSERT(format != js::StackFormat::Default);
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :     // Enter a new block to constrain the scope of possibly entering the stack's
<span class="lineNum">     978 </span>            :     // compartment. This ensures that when we finish the StringBuffer, we are
<span class="lineNum">     979 </span>            :     // back in the cx's original compartment, and fulfill our contract with
<span class="lineNum">     980 </span>            :     // callers to place the output string in the cx's current compartment.
<span class="lineNum">     981 </span>            :     {
<span class="lineNum">     982 </span><span class="lineCov">          1 :         AutoMaybeEnterFrameCompartment ac(cx, stack);</span>
<span class="lineNum">     983 </span>            :         bool skippedAsync;
<span class="lineNum">     984 </span>            :         js::RootedSavedFrame frame(cx, UnwrapSavedFrame(cx, stack, SavedFrameSelfHosted::Exclude,
<span class="lineNum">     985 </span><span class="lineCov">          1 :                                                         skippedAsync));</span>
<span class="lineNum">     986 </span><span class="lineCov">          1 :         if (!frame) {</span>
<span class="lineNum">     987 </span><span class="lineCov">          1 :             stringp.set(cx-&gt;runtime()-&gt;emptyString);</span>
<span class="lineNum">     988 </span><span class="lineCov">          1 :             return true;</span>
<span class="lineNum">     989 </span>            :         }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :         js::RootedSavedFrame parent(cx);
<span class="lineNum">     992 </span><span class="lineCov">          1 :         do {</span>
<span class="lineNum">     993 </span>            :             MOZ_ASSERT(SavedFrameSubsumedByCaller(cx, frame));
<span class="lineNum">     994 </span>            :             MOZ_ASSERT(!frame-&gt;isSelfHosted(cx));
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">          1 :             parent = frame-&gt;getParent();</span>
<span class="lineNum">     997 </span>            :             bool skippedNextAsync;
<span class="lineNum">     998 </span>            :             js::RootedSavedFrame nextFrame(cx, js::GetFirstSubsumedFrame(cx, parent,
<span class="lineNum">     999 </span><span class="lineCov">          1 :                                                                          SavedFrameSelfHosted::Exclude, skippedNextAsync));</span>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span><span class="lineCov">          1 :             switch (format) {</span>
<span class="lineNum">    1002 </span>            :                 case js::StackFormat::SpiderMonkey:
<span class="lineNum">    1003 </span><span class="lineCov">          1 :                     if (!FormatSpiderMonkeyStackFrame(cx, sb, frame, indent, skippedAsync))</span>
<span class="lineNum">    1004 </span>            :                         return false;
<span class="lineNum">    1005 </span>            :                     break;
<span class="lineNum">    1006 </span>            :                 case js::StackFormat::V8:
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                     if (!FormatV8StackFrame(cx, sb, frame, indent, !nextFrame))</span>
<span class="lineNum">    1008 </span>            :                         return false;
<span class="lineNum">    1009 </span>            :                     break;
<span class="lineNum">    1010 </span>            :                 case js::StackFormat::Default:
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                     MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE(&quot;Unexpected value&quot;);</span>
<span class="lineNum">    1012 </span>            :                     break;
<span class="lineNum">    1013 </span>            :             }
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            :             frame = nextFrame;
<span class="lineNum">    1016 </span><span class="lineCov">          1 :             skippedAsync = skippedNextAsync;</span>
<span class="lineNum">    1017 </span>            :         } while (frame);
<span class="lineNum">    1018 </span>            :     }
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineCov">          1 :     JSString* str = sb.finishString();</span>
<span class="lineNum">    1021 </span><span class="lineCov">          1 :     if (!str)</span>
<span class="lineNum">    1022 </span>            :         return false;
<span class="lineNum">    1023 </span><span class="lineCov">          1 :     assertSameCompartment(cx, str);</span>
<span class="lineNum">    1024 </span><span class="lineCov">          1 :     stringp.set(str);</span>
<span class="lineNum">    1025 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1026 </span>            : }
<a name="1027"><span class="lineNum">    1027 </span>            : </a>
<span class="lineNum">    1028 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    1029 </span><span class="lineCov">          1 : IsSavedFrame(JSObject* obj)</span>
<span class="lineNum">    1030 </span>            : {
<span class="lineNum">    1031 </span><span class="lineCov">          1 :     if (!obj)</span>
<span class="lineNum">    1032 </span>            :         return false;
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineCov">          1 :     JSObject* unwrapped = js::CheckedUnwrap(obj);</span>
<span class="lineNum">    1035 </span><span class="lineCov">          1 :     if (!unwrapped)</span>
<span class="lineNum">    1036 </span>            :         return false;
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">          1 :     return js::SavedFrame::isSavedFrameAndNotProto(*unwrapped);</span>
<span class="lineNum">    1039 </span>            : }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            : } /* namespace JS */
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            : namespace js {
<a name="1044"><span class="lineNum">    1044 </span>            : </a>
<span class="lineNum">    1045 </span>            : /* static */ bool
<span class="lineNum">    1046 </span><span class="lineCov">          1 : SavedFrame::sourceProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1047 </span>            : {
<span class="lineNum">    1048 </span><span class="lineCov">          1 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get source)&quot;, args, frame);</span>
<span class="lineNum">    1049 </span>            :     RootedString source(cx);
<span class="lineNum">    1050 </span><span class="lineCov">          1 :     if (JS::GetSavedFrameSource(cx, frame, &amp;source) == JS::SavedFrameResult::Ok) {</span>
<span class="lineNum">    1051 </span><span class="lineCov">          1 :         if (!cx-&gt;compartment()-&gt;wrap(cx, &amp;source))</span>
<span class="lineNum">    1052 </span>            :             return false;
<span class="lineNum">    1053 </span><span class="lineCov">          1 :         args.rval().setString(source);</span>
<span class="lineNum">    1054 </span>            :     } else {
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         args.rval().setNull();</span>
<span class="lineNum">    1056 </span>            :     }
<span class="lineNum">    1057 </span>            :     return true;
<span class="lineNum">    1058 </span>            : }
<a name="1059"><span class="lineNum">    1059 </span>            : </a>
<span class="lineNum">    1060 </span>            : /* static */ bool
<span class="lineNum">    1061 </span><span class="lineCov">          1 : SavedFrame::lineProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1062 </span>            : {
<span class="lineNum">    1063 </span><span class="lineCov">          1 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get line)&quot;, args, frame);</span>
<span class="lineNum">    1064 </span>            :     uint32_t line;
<span class="lineNum">    1065 </span><span class="lineCov">          1 :     if (JS::GetSavedFrameLine(cx, frame, &amp;line) == JS::SavedFrameResult::Ok)</span>
<span class="lineNum">    1066 </span><span class="lineCov">          1 :         args.rval().setNumber(line);</span>
<span class="lineNum">    1067 </span>            :     else
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         args.rval().setNull();</span>
<span class="lineNum">    1069 </span>            :     return true;
<span class="lineNum">    1070 </span>            : }
<a name="1071"><span class="lineNum">    1071 </span>            : </a>
<span class="lineNum">    1072 </span>            : /* static */ bool
<span class="lineNum">    1073 </span><span class="lineCov">          1 : SavedFrame::columnProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1074 </span>            : {
<span class="lineNum">    1075 </span><span class="lineCov">          1 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get column)&quot;, args, frame);</span>
<span class="lineNum">    1076 </span>            :     uint32_t column;
<span class="lineNum">    1077 </span><span class="lineCov">          1 :     if (JS::GetSavedFrameColumn(cx, frame, &amp;column) == JS::SavedFrameResult::Ok)</span>
<span class="lineNum">    1078 </span><span class="lineCov">          1 :         args.rval().setNumber(column);</span>
<span class="lineNum">    1079 </span>            :     else
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         args.rval().setNull();</span>
<span class="lineNum">    1081 </span>            :     return true;
<span class="lineNum">    1082 </span>            : }
<a name="1083"><span class="lineNum">    1083 </span>            : </a>
<span class="lineNum">    1084 </span>            : /* static */ bool
<span class="lineNum">    1085 </span><span class="lineCov">          1 : SavedFrame::functionDisplayNameProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1086 </span>            : {
<span class="lineNum">    1087 </span><span class="lineCov">          1 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get functionDisplayName)&quot;, args, frame);</span>
<span class="lineNum">    1088 </span>            :     RootedString name(cx);
<span class="lineNum">    1089 </span><span class="lineCov">          1 :     JS::SavedFrameResult result = JS::GetSavedFrameFunctionDisplayName(cx, frame, &amp;name);</span>
<span class="lineNum">    1090 </span><span class="lineCov">          1 :     if (result == JS::SavedFrameResult::Ok &amp;&amp; name) {</span>
<span class="lineNum">    1091 </span><span class="lineCov">          1 :         if (!cx-&gt;compartment()-&gt;wrap(cx, &amp;name))</span>
<span class="lineNum">    1092 </span>            :             return false;
<span class="lineNum">    1093 </span><span class="lineCov">          1 :         args.rval().setString(name);</span>
<span class="lineNum">    1094 </span>            :     } else {
<span class="lineNum">    1095 </span><span class="lineCov">          1 :         args.rval().setNull();</span>
<span class="lineNum">    1096 </span>            :     }
<span class="lineNum">    1097 </span>            :     return true;
<span class="lineNum">    1098 </span>            : }
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<span class="lineNum">    1100 </span>            : /* static */ bool
<span class="lineNum">    1101 </span><span class="lineCov">          1 : SavedFrame::asyncCauseProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1102 </span>            : {
<span class="lineNum">    1103 </span><span class="lineCov">          1 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get asyncCause)&quot;, args, frame);</span>
<span class="lineNum">    1104 </span>            :     RootedString asyncCause(cx);
<span class="lineNum">    1105 </span><span class="lineCov">          1 :     JS::SavedFrameResult result = JS::GetSavedFrameAsyncCause(cx, frame, &amp;asyncCause);</span>
<span class="lineNum">    1106 </span><span class="lineCov">          1 :     if (result == JS::SavedFrameResult::Ok &amp;&amp; asyncCause) {</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         if (!cx-&gt;compartment()-&gt;wrap(cx, &amp;asyncCause))</span>
<span class="lineNum">    1108 </span>            :             return false;
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         args.rval().setString(asyncCause);</span>
<span class="lineNum">    1110 </span>            :     } else {
<span class="lineNum">    1111 </span><span class="lineCov">          1 :         args.rval().setNull();</span>
<span class="lineNum">    1112 </span>            :     }
<span class="lineNum">    1113 </span>            :     return true;
<span class="lineNum">    1114 </span>            : }
<a name="1115"><span class="lineNum">    1115 </span>            : </a>
<span class="lineNum">    1116 </span>            : /* static */ bool
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 : SavedFrame::asyncParentProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1118 </span>            : {
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get asyncParent)&quot;, args, frame);</span>
<span class="lineNum">    1120 </span>            :     RootedObject asyncParent(cx);
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     (void) JS::GetSavedFrameAsyncParent(cx, frame, &amp;asyncParent);</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     if (!cx-&gt;compartment()-&gt;wrap(cx, &amp;asyncParent))</span>
<span class="lineNum">    1123 </span>            :         return false;
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     args.rval().setObjectOrNull(asyncParent);</span>
<span class="lineNum">    1125 </span>            :     return true;
<span class="lineNum">    1126 </span>            : }
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<span class="lineNum">    1128 </span>            : /* static */ bool
<span class="lineNum">    1129 </span><span class="lineCov">          1 : SavedFrame::parentProperty(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span><span class="lineCov">          1 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;(get parent)&quot;, args, frame);</span>
<span class="lineNum">    1132 </span>            :     RootedObject parent(cx);
<span class="lineNum">    1133 </span><span class="lineCov">          1 :     (void) JS::GetSavedFrameParent(cx, frame, &amp;parent);</span>
<span class="lineNum">    1134 </span><span class="lineCov">          1 :     if (!cx-&gt;compartment()-&gt;wrap(cx, &amp;parent))</span>
<span class="lineNum">    1135 </span>            :         return false;
<span class="lineNum">    1136 </span><span class="lineCov">          1 :     args.rval().setObjectOrNull(parent);</span>
<span class="lineNum">    1137 </span>            :     return true;
<span class="lineNum">    1138 </span>            : }
<a name="1139"><span class="lineNum">    1139 </span>            : </a>
<span class="lineNum">    1140 </span>            : /* static */ bool
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 : SavedFrame::toStringMethod(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    1142 </span>            : {
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :     THIS_SAVEDFRAME(cx, argc, vp, &quot;toString&quot;, args, frame);</span>
<span class="lineNum">    1144 </span>            :     RootedString string(cx);
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     if (!JS::BuildStackString(cx, frame, &amp;string))</span>
<span class="lineNum">    1146 </span>            :         return false;
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     args.rval().setString(string);</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1149 </span>            : }
<a name="1150"><span class="lineNum">    1150 </span>            : </a>
<span class="lineNum">    1151 </span>            : bool
<span class="lineNum">    1152 </span><span class="lineCov">          1 : SavedStacks::init()</span>
<span class="lineNum">    1153 </span>            : {
<span class="lineNum">    1154 </span><span class="lineCov">          1 :     return frames.init() &amp;&amp;</span>
<span class="lineNum">    1155 </span><span class="lineCov">          1 :            pcLocationMap.init();</span>
<span class="lineNum">    1156 </span>            : }
<a name="1157"><span class="lineNum">    1157 </span>            : </a>
<span class="lineNum">    1158 </span>            : bool
<span class="lineNum">    1159 </span><span class="lineCov">          1 : SavedStacks::saveCurrentStack(JSContext* cx, MutableHandleSavedFrame frame,</span>
<span class="lineNum">    1160 </span>            :                               JS::StackCapture&amp;&amp; capture /* = JS::StackCapture(JS::AllFrames()) */)
<span class="lineNum">    1161 </span>            : {
<span class="lineNum">    1162 </span>            :     MOZ_ASSERT(initialized());
<span class="lineNum">    1163 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">    1164 </span><span class="lineCov">          1 :     assertSameCompartment(cx, this);</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineCov">          1 :     if (creatingSavedFrame ||</span>
<span class="lineNum">    1167 </span><span class="lineCov">          1 :         cx-&gt;isExceptionPending() ||</span>
<span class="lineNum">    1168 </span><span class="lineCov">          1 :         !cx-&gt;global() ||</span>
<span class="lineNum">    1169 </span><span class="lineCov">          1 :         !cx-&gt;global()-&gt;isStandardClassResolved(JSProto_Object))</span>
<span class="lineNum">    1170 </span>            :     {
<span class="lineNum">    1171 </span><span class="lineCov">          1 :         frame.set(nullptr);</span>
<span class="lineNum">    1172 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    1173 </span>            :     }
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineCov">          1 :     AutoGeckoProfilerEntry psuedoFrame(cx-&gt;runtime(), &quot;js::SavedStacks::saveCurrentStack&quot;);</span>
<span class="lineNum">    1176 </span><span class="lineCov">          1 :     FrameIter iter(cx);</span>
<span class="lineNum">    1177 </span><span class="lineCov">          1 :     return insertFrames(cx, iter, frame, mozilla::Move(capture));</span>
<span class="lineNum">    1178 </span>            : }
<a name="1179"><span class="lineNum">    1179 </span>            : </a>
<span class="lineNum">    1180 </span>            : bool
<span class="lineNum">    1181 </span><span class="lineCov">          1 : SavedStacks::copyAsyncStack(JSContext* cx, HandleObject asyncStack, HandleString asyncCause,</span>
<span class="lineNum">    1182 </span>            :                             MutableHandleSavedFrame adoptedStack, uint32_t maxFrameCount)
<span class="lineNum">    1183 </span>            : {
<span class="lineNum">    1184 </span>            :     MOZ_ASSERT(initialized());
<span class="lineNum">    1185 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(cx-&gt;compartment());</span>
<span class="lineNum">    1186 </span><span class="lineCov">          1 :     assertSameCompartment(cx, this);</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineCov">          1 :     RootedObject asyncStackObj(cx, CheckedUnwrap(asyncStack));</span>
<span class="lineNum">    1189 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(asyncStackObj);</span>
<span class="lineNum">    1190 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(js::SavedFrame::isSavedFrameAndNotProto(*asyncStackObj));</span>
<span class="lineNum">    1191 </span><span class="lineCov">          1 :     RootedSavedFrame frame(cx, &amp;asyncStackObj-&gt;as&lt;js::SavedFrame&gt;());</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineCov">          1 :     return adoptAsyncStack(cx, frame, asyncCause, adoptedStack, maxFrameCount);</span>
<span class="lineNum">    1194 </span>            : }
<a name="1195"><span class="lineNum">    1195 </span>            : </a>
<span class="lineNum">    1196 </span>            : void
<span class="lineNum">    1197 </span><span class="lineCov">          1 : SavedStacks::sweep()</span>
<span class="lineNum">    1198 </span>            : {
<span class="lineNum">    1199 </span><span class="lineCov">          1 :     frames.sweep();</span>
<span class="lineNum">    1200 </span><span class="lineCov">          1 :     pcLocationMap.sweep();</span>
<span class="lineNum">    1201 </span><span class="lineCov">          1 : }</span>
<a name="1202"><span class="lineNum">    1202 </span>            : </a>
<span class="lineNum">    1203 </span>            : void
<span class="lineNum">    1204 </span><span class="lineCov">          1 : SavedStacks::trace(JSTracer* trc)</span>
<span class="lineNum">    1205 </span>            : {
<span class="lineNum">    1206 </span><span class="lineCov">          1 :     pcLocationMap.trace(trc);</span>
<span class="lineNum">    1207 </span><span class="lineCov">          1 : }</span>
<a name="1208"><span class="lineNum">    1208 </span>            : </a>
<span class="lineNum">    1209 </span>            : uint32_t
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 : SavedStacks::count()</span>
<span class="lineNum">    1211 </span>            : {
<span class="lineNum">    1212 </span>            :     MOZ_ASSERT(initialized());
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     return frames.count();</span>
<span class="lineNum">    1214 </span>            : }
<a name="1215"><span class="lineNum">    1215 </span>            : </a>
<span class="lineNum">    1216 </span>            : void
<span class="lineNum">    1217 </span><span class="lineCov">          1 : SavedStacks::clear()</span>
<span class="lineNum">    1218 </span>            : {
<span class="lineNum">    1219 </span><span class="lineCov">          1 :     frames.clear();</span>
<span class="lineNum">    1220 </span><span class="lineCov">          1 : }</span>
<a name="1221"><span class="lineNum">    1221 </span>            : </a>
<span class="lineNum">    1222 </span>            : size_t
<span class="lineNum">    1223 </span><span class="lineCov">          1 : SavedStacks::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf)</span>
<span class="lineNum">    1224 </span>            : {
<span class="lineNum">    1225 </span><span class="lineCov">          1 :     return frames.sizeOfExcludingThis(mallocSizeOf) +</span>
<span class="lineNum">    1226 </span><span class="lineCov">          1 :            pcLocationMap.sizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    1227 </span>            : }
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            : // Given that we have captured a stqck frame with the given principals and
<span class="lineNum">    1230 </span>            : // source, return true if the requested `StackCapture` has been satisfied and
<span class="lineNum">    1231 </span>            : // stack walking can halt. Return false otherwise (and stack walking and frame
<span class="lineNum">    1232 </span>            : // capturing should continue).
<span class="lineNum">    1233 </span>            : static inline bool
<span class="lineNum">    1234 </span>            : captureIsSatisfied(JSContext* cx, JSPrincipals* principals, const JSAtom* source,
<span class="lineNum">    1235 </span>            :                    JS::StackCapture&amp; capture)
<span class="lineNum">    1236 </span>            : {
<span class="lineNum">    1237 </span>            :     class Matcher
<span class="lineNum">    1238 </span>            :     {
<span class="lineNum">    1239 </span>            :         JSContext* cx_;
<span class="lineNum">    1240 </span>            :         JSPrincipals* framePrincipals_;
<span class="lineNum">    1241 </span>            :         const JSAtom* frameSource_;
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            :       public:
<span class="lineNum">    1244 </span>            :         Matcher(JSContext* cx, JSPrincipals* principals, const JSAtom* source)
<span class="lineNum">    1245 </span>            :           : cx_(cx)
<span class="lineNum">    1246 </span>            :           , framePrincipals_(principals)
<span class="lineNum">    1247 </span><span class="lineCov">          1 :           , frameSource_(source)</span>
<a name="1248"><span class="lineNum">    1248 </span>            :         { }</a>
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineCov">          1 :         bool match(JS::FirstSubsumedFrame&amp; target) {</span>
<span class="lineNum">    1251 </span><span class="lineCov">          1 :             auto subsumes = cx_-&gt;runtime()-&gt;securityCallbacks-&gt;subsumes;</span>
<span class="lineNum">    1252 </span><span class="lineCov">          1 :             return (!subsumes || subsumes(target.principals, framePrincipals_)) &amp;&amp;</span>
<span class="lineNum">    1253 </span><span class="lineCov">          1 :                    (!target.ignoreSelfHosted || frameSource_ != cx_-&gt;names().selfHosted);</span>
<span class="lineNum">    1254 </span>            :         }
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :         bool match(JS::MaxFrames&amp; target) {
<span class="lineNum">    1257 </span><span class="lineCov">          1 :             return target.maxFrames == 1;</span>
<span class="lineNum">    1258 </span>            :         }
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :         bool match(JS::AllFrames&amp;) {
<span class="lineNum">    1261 </span>            :             return false;
<span class="lineNum">    1262 </span>            :         }
<span class="lineNum">    1263 </span>            :     };
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :     Matcher m(cx, principals, source);
<span class="lineNum">    1266 </span>            :     return capture.match(m);
<span class="lineNum">    1267 </span>            : }
<a name="1268"><span class="lineNum">    1268 </span>            : </a>
<span class="lineNum">    1269 </span>            : bool
<span class="lineNum">    1270 </span><span class="lineCov">          1 : SavedStacks::insertFrames(JSContext* cx, FrameIter&amp; iter, MutableHandleSavedFrame frame,</span>
<span class="lineNum">    1271 </span>            :                           JS::StackCapture&amp;&amp; capture)
<span class="lineNum">    1272 </span>            : {
<span class="lineNum">    1273 </span>            :     // In order to lookup a cached SavedFrame object, we need to have its parent
<span class="lineNum">    1274 </span>            :     // SavedFrame, which means we need to walk the stack from oldest frame to
<span class="lineNum">    1275 </span>            :     // youngest. However, FrameIter walks the stack from youngest frame to
<span class="lineNum">    1276 </span>            :     // oldest. The solution is to append stack frames to a vector as we walk the
<span class="lineNum">    1277 </span>            :     // stack with FrameIter, and then do a second pass through that vector in
<span class="lineNum">    1278 </span>            :     // reverse order after the traversal has completed and get or create the
<span class="lineNum">    1279 </span>            :     // SavedFrame objects at that time.
<span class="lineNum">    1280 </span>            :     //
<span class="lineNum">    1281 </span>            :     // To avoid making many copies of FrameIter (whose copy constructor is
<span class="lineNum">    1282 </span>            :     // relatively slow), we use a vector of `SavedFrame::Lookup` objects, which
<span class="lineNum">    1283 </span>            :     // only contain the FrameIter data we need. The `SavedFrame::Lookup`
<span class="lineNum">    1284 </span>            :     // objects are partially initialized with everything except their parent
<span class="lineNum">    1285 </span>            :     // pointers on the first pass, and then we fill in the parent pointers as we
<span class="lineNum">    1286 </span>            :     // return in the second pass.
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span><span class="lineCov">          1 :     Activation* asyncActivation = nullptr;</span>
<span class="lineNum">    1289 </span><span class="lineCov">          1 :     RootedSavedFrame asyncStack(cx, nullptr);</span>
<span class="lineNum">    1290 </span><span class="lineCov">          1 :     RootedString asyncCause(cx, nullptr);</span>
<span class="lineNum">    1291 </span><span class="lineCov">          1 :     bool parentIsInCache = false;</span>
<span class="lineNum">    1292 </span><span class="lineCov">          1 :     RootedSavedFrame cachedFrame(cx, nullptr);</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span>            :     // Accumulate the vector of Lookup objects in |stackChain|.
<span class="lineNum">    1295 </span><span class="lineCov">          1 :     SavedFrame::AutoLookupVector stackChain(cx);</span>
<span class="lineNum">    1296 </span><span class="lineCov">          1 :     while (!iter.done()) {</span>
<span class="lineNum">    1297 </span><span class="lineCov">          1 :         Activation&amp; activation = *iter.activation();</span>
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span><span class="lineCov">          1 :         if (asyncActivation &amp;&amp; asyncActivation != &amp;activation) {</span>
<span class="lineNum">    1300 </span>            :             // We found an async stack in the previous activation, and we
<span class="lineNum">    1301 </span>            :             // walked past the oldest frame of that activation, we're done.
<span class="lineNum">    1302 </span>            :             // However, we only want to use the async parent if it was
<span class="lineNum">    1303 </span>            :             // explicitly requested; if we got here otherwise, we have
<span class="lineNum">    1304 </span>            :             // a direct parent, which we prefer.
<span class="lineNum">    1305 </span><span class="lineCov">          1 :             if (asyncActivation-&gt;asyncCallIsExplicit())</span>
<span class="lineNum">    1306 </span>            :                 break;
<span class="lineNum">    1307 </span>            :             asyncActivation = nullptr;
<span class="lineNum">    1308 </span>            :         }
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineCov">          1 :         if (!asyncActivation) {</span>
<span class="lineNum">    1311 </span><span class="lineCov">          1 :             asyncStack = activation.asyncStack();</span>
<span class="lineNum">    1312 </span><span class="lineCov">          1 :             if (asyncStack) {</span>
<span class="lineNum">    1313 </span>            :                 // While walking from the youngest to the oldest frame, we found
<span class="lineNum">    1314 </span>            :                 // an activation that has an async stack set. We will use the
<span class="lineNum">    1315 </span>            :                 // youngest frame of the async stack as the parent of the oldest
<span class="lineNum">    1316 </span>            :                 // frame of this activation. We still need to iterate over other
<span class="lineNum">    1317 </span>            :                 // frames in this activation before reaching the oldest frame.
<span class="lineNum">    1318 </span><span class="lineCov">          1 :                 AutoCompartmentUnchecked ac(cx, iter.compartment());</span>
<span class="lineNum">    1319 </span><span class="lineCov">          1 :                 const char* cause = activation.asyncCause();</span>
<span class="lineNum">    1320 </span><span class="lineCov">          1 :                 UTF8Chars utf8Chars(cause, strlen(cause));</span>
<span class="lineNum">    1321 </span><span class="lineCov">          1 :                 size_t twoByteCharsLen = 0;</span>
<span class="lineNum">    1322 </span>            :                 char16_t* twoByteChars = UTF8CharsToNewTwoByteCharsZ(cx, utf8Chars,
<span class="lineNum">    1323 </span><span class="lineCov">          1 :                                                                      &amp;twoByteCharsLen).get();</span>
<span class="lineNum">    1324 </span><span class="lineCov">          1 :                 if (!twoByteChars)</span>
<span class="lineNum">    1325 </span>            :                     return false;
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            :                 // We expect that there will be a relatively small set of
<span class="lineNum">    1328 </span>            :                 // asyncCause reasons (&quot;setTimeout&quot;, &quot;promise&quot;, etc.), so we
<span class="lineNum">    1329 </span>            :                 // atomize the cause here in hopes of being able to benefit
<span class="lineNum">    1330 </span>            :                 // from reuse.
<span class="lineNum">    1331 </span><span class="lineCov">          1 :                 asyncCause = JS_AtomizeUCStringN(cx, twoByteChars, twoByteCharsLen);</span>
<span class="lineNum">    1332 </span>            :                 js_free(twoByteChars);
<span class="lineNum">    1333 </span><span class="lineCov">          1 :                 if (!asyncCause)</span>
<span class="lineNum">    1334 </span>            :                     return false;
<span class="lineNum">    1335 </span><span class="lineCov">          1 :                 asyncActivation = &amp;activation;</span>
<span class="lineNum">    1336 </span>            :             }
<span class="lineNum">    1337 </span>            :         }
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            :         Rooted&lt;LocationValue&gt; location(cx);
<span class="lineNum">    1340 </span>            :         {
<span class="lineNum">    1341 </span><span class="lineCov">          1 :             AutoCompartmentUnchecked ac(cx, iter.compartment());</span>
<span class="lineNum">    1342 </span><span class="lineCov">          1 :             if (!cx-&gt;compartment()-&gt;savedStacks().getLocation(cx, iter, &amp;location))</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1344 </span>            :         }
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :         // The bit set means that the next older parent (frame, pc) pair *must*
<span class="lineNum">    1347 </span>            :         // be in the cache.
<span class="lineNum">    1348 </span><span class="lineCov">          1 :         if (capture.is&lt;JS::AllFrames&gt;())</span>
<span class="lineNum">    1349 </span><span class="lineCov">          1 :             parentIsInCache = iter.hasCachedSavedFrame();</span>
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineCov">          1 :         auto principals = iter.compartment()-&gt;principals();</span>
<span class="lineNum">    1352 </span><span class="lineCov">          1 :         auto displayAtom = (iter.isWasm() || iter.isFunctionFrame()) ? iter.functionDisplayAtom() : nullptr;</span>
<span class="lineNum">    1353 </span><span class="lineCov">          1 :         if (!stackChain-&gt;emplaceBack(location.source(),</span>
<span class="lineNum">    1354 </span>            :                                      location.line(),
<span class="lineNum">    1355 </span>            :                                      location.column(),
<span class="lineNum">    1356 </span>            :                                      displayAtom,
<span class="lineNum">    1357 </span>            :                                      nullptr,
<span class="lineNum">    1358 </span>            :                                      nullptr,
<span class="lineNum">    1359 </span>            :                                      principals,
<span class="lineNum">    1360 </span>            :                                      LiveSavedFrameCache::getFramePtr(iter),
<span class="lineNum">    1361 </span><span class="lineCov">          1 :                                      iter.pc(),</span>
<span class="lineNum">    1362 </span><span class="lineCov">          1 :                                      &amp;activation))</span>
<span class="lineNum">    1363 </span>            :         {
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :             ReportOutOfMemory(cx);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1366 </span>            :         }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineCov">          1 :         if (captureIsSatisfied(cx, principals, location.source(), capture)) {</span>
<span class="lineNum">    1369 </span>            :             // The frame we just saved was the last one we were asked to save.
<span class="lineNum">    1370 </span>            :             // If we had an async stack, ensure we don't use any of its frames.
<span class="lineNum">    1371 </span><span class="lineCov">          1 :             asyncStack.set(nullptr);</span>
<span class="lineNum">    1372 </span><span class="lineCov">          1 :             break;</span>
<span class="lineNum">    1373 </span>            :         }
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineCov">          1 :         ++iter;</span>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineCov">          1 :         if (parentIsInCache &amp;&amp;</span>
<span class="lineNum">    1378 </span><span class="lineCov">          1 :             !iter.done() &amp;&amp;</span>
<span class="lineNum">    1379 </span><span class="lineCov">          1 :             iter.hasCachedSavedFrame())</span>
<span class="lineNum">    1380 </span>            :         {
<span class="lineNum">    1381 </span><span class="lineCov">          1 :             auto* cache = activation.getLiveSavedFrameCache(cx);</span>
<span class="lineNum">    1382 </span><span class="lineCov">          1 :             if (!cache)</span>
<span class="lineNum">    1383 </span>            :                 return false;
<span class="lineNum">    1384 </span><span class="lineCov">          1 :             cache-&gt;find(cx, iter, &amp;cachedFrame);</span>
<span class="lineNum">    1385 </span><span class="lineCov">          1 :             if (cachedFrame)</span>
<span class="lineNum">    1386 </span>            :                 break;
<span class="lineNum">    1387 </span>            :         }
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineCov">          1 :         if (capture.is&lt;JS::MaxFrames&gt;())</span>
<span class="lineNum">    1390 </span><span class="lineCov">          1 :             capture.as&lt;JS::MaxFrames&gt;().maxFrames--;</span>
<span class="lineNum">    1391 </span>            :     }
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            :     // Limit the depth of the async stack, if any, and ensure that the
<span class="lineNum">    1394 </span>            :     // SavedFrame instances we use are stored in the same compartment as the
<span class="lineNum">    1395 </span>            :     // rest of the synchronous stack chain.
<span class="lineNum">    1396 </span>            :     RootedSavedFrame parentFrame(cx, cachedFrame);
<span class="lineNum">    1397 </span><span class="lineCov">          1 :     if (asyncStack &amp;&amp; !capture.is&lt;JS::FirstSubsumedFrame&gt;()) {</span>
<span class="lineNum">    1398 </span>            :         uint32_t maxAsyncFrames = capture.is&lt;JS::MaxFrames&gt;()
<span class="lineNum">    1399 </span>            :             ? capture.as&lt;JS::MaxFrames&gt;().maxFrames
<span class="lineNum">    1400 </span><span class="lineCov">          1 :             : ASYNC_STACK_MAX_FRAME_COUNT;</span>
<span class="lineNum">    1401 </span><span class="lineCov">          1 :         if (!adoptAsyncStack(cx, asyncStack, asyncCause, &amp;parentFrame, maxAsyncFrames))</span>
<span class="lineNum">    1402 </span>            :             return false;
<span class="lineNum">    1403 </span>            :     }
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span>            :     // Iterate through |stackChain| in reverse order and get or create the
<span class="lineNum">    1406 </span>            :     // actual SavedFrame instances.
<span class="lineNum">    1407 </span><span class="lineCov">          1 :     for (size_t i = stackChain-&gt;length(); i != 0; i--) {</span>
<span class="lineNum">    1408 </span><span class="lineCov">          1 :         SavedFrame::HandleLookup lookup = stackChain[i-1];</span>
<span class="lineNum">    1409 </span><span class="lineCov">          1 :         lookup-&gt;parent = parentFrame;</span>
<span class="lineNum">    1410 </span><span class="lineCov">          1 :         parentFrame.set(getOrCreateSavedFrame(cx, lookup));</span>
<span class="lineNum">    1411 </span><span class="lineCov">          1 :         if (!parentFrame)</span>
<span class="lineNum">    1412 </span>            :             return false;
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineCov">          1 :         if (capture.is&lt;JS::AllFrames&gt;() &amp;&amp; lookup-&gt;framePtr &amp;&amp; parentFrame != cachedFrame) {</span>
<span class="lineNum">    1415 </span><span class="lineCov">          1 :             auto* cache = lookup-&gt;activation-&gt;getLiveSavedFrameCache(cx);</span>
<span class="lineNum">    1416 </span><span class="lineCov">          1 :             if (!cache || !cache-&gt;insert(cx, *lookup-&gt;framePtr, lookup-&gt;pc, parentFrame))</span>
<span class="lineNum">    1417 </span>            :                 return false;
<span class="lineNum">    1418 </span>            :         }
<span class="lineNum">    1419 </span>            :     }
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineCov">          1 :     frame.set(parentFrame);</span>
<span class="lineNum">    1422 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1423 </span>            : }
<a name="1424"><span class="lineNum">    1424 </span>            : </a>
<span class="lineNum">    1425 </span>            : bool
<span class="lineNum">    1426 </span><span class="lineCov">          1 : SavedStacks::adoptAsyncStack(JSContext* cx, HandleSavedFrame asyncStack,</span>
<span class="lineNum">    1427 </span>            :                              HandleString asyncCause,
<span class="lineNum">    1428 </span>            :                              MutableHandleSavedFrame adoptedStack,
<span class="lineNum">    1429 </span>            :                              uint32_t maxFrameCount)
<span class="lineNum">    1430 </span>            : {
<span class="lineNum">    1431 </span><span class="lineCov">          1 :     RootedAtom asyncCauseAtom(cx, AtomizeString(cx, asyncCause));</span>
<span class="lineNum">    1432 </span><span class="lineCov">          1 :     if (!asyncCauseAtom)</span>
<span class="lineNum">    1433 </span>            :         return false;
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            :     // If maxFrameCount is zero, the caller asked for an unlimited number of
<span class="lineNum">    1436 </span>            :     // stack frames, but async stacks are not limited by the available stack
<span class="lineNum">    1437 </span>            :     // memory, so we need to set an arbitrary limit when collecting them. We
<span class="lineNum">    1438 </span>            :     // still don't enforce an upper limit if the caller requested more frames.
<span class="lineNum">    1439 </span><span class="lineCov">          1 :     uint32_t maxFrames = maxFrameCount &gt; 0 ? maxFrameCount : ASYNC_STACK_MAX_FRAME_COUNT;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :     // Accumulate the vector of Lookup objects in |stackChain|.
<span class="lineNum">    1442 </span><span class="lineCov">          1 :     SavedFrame::AutoLookupVector stackChain(cx);</span>
<span class="lineNum">    1443 </span><span class="lineCov">          1 :     SavedFrame* currentSavedFrame = asyncStack;</span>
<span class="lineNum">    1444 </span><span class="lineCov">          1 :     SavedFrame* firstSavedFrameParent = nullptr;</span>
<span class="lineNum">    1445 </span><span class="lineCov">          1 :     for (uint32_t i = 0; i &lt; maxFrames &amp;&amp; currentSavedFrame; i++) {</span>
<span class="lineNum">    1446 </span><span class="lineCov">          1 :         if (!stackChain-&gt;emplaceBack(*currentSavedFrame)) {</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :             ReportOutOfMemory(cx);</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1449 </span>            :         }
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span><span class="lineCov">          1 :         currentSavedFrame = currentSavedFrame-&gt;getParent();</span>
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span>            :         // Attach the asyncCause to the youngest frame.
<span class="lineNum">    1454 </span><span class="lineCov">          1 :         if (i == 0) {</span>
<span class="lineNum">    1455 </span><span class="lineCov">          1 :             stackChain-&gt;back().asyncCause = asyncCauseAtom;</span>
<span class="lineNum">    1456 </span><span class="lineCov">          1 :             firstSavedFrameParent = currentSavedFrame;</span>
<span class="lineNum">    1457 </span>            :         }
<span class="lineNum">    1458 </span>            :     }
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            :     // This is the 1-based index of the oldest frame we care about.
<span class="lineNum">    1461 </span><span class="lineCov">          1 :     size_t oldestFramePosition = stackChain-&gt;length();</span>
<span class="lineNum">    1462 </span><span class="lineCov">          1 :     RootedSavedFrame parentFrame(cx, nullptr);</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineCov">          1 :     if (currentSavedFrame == nullptr &amp;&amp;</span>
<span class="lineNum">    1465 </span><span class="lineCov">          1 :         asyncStack-&gt;compartment() == cx-&gt;compartment()) {</span>
<span class="lineNum">    1466 </span>            :         // If we consumed the full async stack, and the stack is in the same
<span class="lineNum">    1467 </span>            :         // compartment as the one requested, we don't need to rebuild the full
<span class="lineNum">    1468 </span>            :         // chain again using the lookup objects, we can just reference the
<span class="lineNum">    1469 </span>            :         // existing chain and change the asyncCause on the younger frame.
<span class="lineNum">    1470 </span><span class="lineCov">          1 :         oldestFramePosition = 1;</span>
<span class="lineNum">    1471 </span><span class="lineCov">          1 :         parentFrame = firstSavedFrameParent;</span>
<span class="lineNum">    1472 </span><span class="lineCov">          1 :     } else if (maxFrameCount == 0 &amp;&amp;</span>
<span class="lineNum">    1473 </span><span class="lineCov">          1 :                oldestFramePosition == ASYNC_STACK_MAX_FRAME_COUNT) {</span>
<span class="lineNum">    1474 </span>            :         // If we captured the maximum number of frames and the caller requested
<span class="lineNum">    1475 </span>            :         // no specific limit, we only return half of them. This means that for
<span class="lineNum">    1476 </span>            :         // the next iterations, it's likely we can use the optimization above.
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :         oldestFramePosition = ASYNC_STACK_MAX_FRAME_COUNT / 2;</span>
<span class="lineNum">    1478 </span>            :     }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :     // Iterate through |stackChain| in reverse order and get or create the
<span class="lineNum">    1481 </span>            :     // actual SavedFrame instances.
<span class="lineNum">    1482 </span><span class="lineCov">          1 :     for (size_t i = oldestFramePosition; i != 0; i--) {</span>
<span class="lineNum">    1483 </span><span class="lineCov">          1 :         SavedFrame::HandleLookup lookup = stackChain[i-1];</span>
<span class="lineNum">    1484 </span><span class="lineCov">          1 :         lookup-&gt;parent = parentFrame;</span>
<span class="lineNum">    1485 </span><span class="lineCov">          1 :         parentFrame.set(getOrCreateSavedFrame(cx, lookup));</span>
<span class="lineNum">    1486 </span><span class="lineCov">          1 :         if (!parentFrame)</span>
<span class="lineNum">    1487 </span>            :             return false;
<span class="lineNum">    1488 </span>            :     }
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineCov">          1 :     adoptedStack.set(parentFrame);</span>
<span class="lineNum">    1491 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1492 </span>            : }
<a name="1493"><span class="lineNum">    1493 </span>            : </a>
<span class="lineNum">    1494 </span>            : SavedFrame*
<span class="lineNum">    1495 </span><span class="lineCov">          1 : SavedStacks::getOrCreateSavedFrame(JSContext* cx, SavedFrame::HandleLookup lookup)</span>
<span class="lineNum">    1496 </span>            : {
<span class="lineNum">    1497 </span><span class="lineCov">          1 :     const SavedFrame::Lookup&amp; lookupInstance = lookup.get();</span>
<span class="lineNum">    1498 </span><span class="lineCov">          1 :     DependentAddPtr&lt;SavedFrame::Set&gt; p(cx, frames, lookupInstance);</span>
<span class="lineNum">    1499 </span><span class="lineCov">          1 :     if (p) {</span>
<span class="lineNum">    1500 </span>            :         MOZ_ASSERT(*p);
<span class="lineNum">    1501 </span><span class="lineCov">          1 :         return *p;</span>
<span class="lineNum">    1502 </span>            :     }
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineCov">          1 :     RootedSavedFrame frame(cx, createFrameFromLookup(cx, lookup));</span>
<span class="lineNum">    1505 </span><span class="lineCov">          1 :     if (!frame)</span>
<span class="lineNum">    1506 </span>            :         return nullptr;
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span><span class="lineCov">          1 :     if (!p.add(cx, frames, lookupInstance, frame))</span>
<span class="lineNum">    1509 </span>            :         return nullptr;
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineCov">          1 :     return frame;</span>
<span class="lineNum">    1512 </span>            : }
<a name="1513"><span class="lineNum">    1513 </span>            : </a>
<span class="lineNum">    1514 </span>            : SavedFrame*
<span class="lineNum">    1515 </span><span class="lineCov">          1 : SavedStacks::createFrameFromLookup(JSContext* cx, SavedFrame::HandleLookup lookup)</span>
<span class="lineNum">    1516 </span>            : {
<span class="lineNum">    1517 </span><span class="lineCov">          1 :     RootedSavedFrame frame(cx, SavedFrame::create(cx));</span>
<span class="lineNum">    1518 </span><span class="lineCov">          1 :     if (!frame)</span>
<span class="lineNum">    1519 </span>            :         return nullptr;
<span class="lineNum">    1520 </span><span class="lineCov">          1 :     frame-&gt;initFromLookup(cx, lookup);</span>
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineCov">          1 :     if (!FreezeObject(cx, frame))</span>
<span class="lineNum">    1523 </span>            :         return nullptr;
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span><span class="lineCov">          1 :     return frame;</span>
<span class="lineNum">    1526 </span>            : }
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<span class="lineNum">    1528 </span>            : bool
<span class="lineNum">    1529 </span><span class="lineCov">          1 : SavedStacks::getLocation(JSContext* cx, const FrameIter&amp; iter,</span>
<span class="lineNum">    1530 </span>            :                          MutableHandle&lt;LocationValue&gt; locationp)
<span class="lineNum">    1531 </span>            : {
<span class="lineNum">    1532 </span>            :     // We should only ever be caching location values for scripts in this
<span class="lineNum">    1533 </span>            :     // compartment. Otherwise, we would get dead cross-compartment scripts in
<span class="lineNum">    1534 </span>            :     // the cache because our compartment's sweep method isn't called when their
<span class="lineNum">    1535 </span>            :     // compartment gets collected.
<span class="lineNum">    1536 </span><span class="lineCov">          1 :     assertSameCompartment(cx, this, iter.compartment());</span>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :     // When we have a |JSScript| for this frame, use a potentially memoized
<span class="lineNum">    1539 </span>            :     // location from our PCLocationMap and copy it into |locationp|. When we do
<span class="lineNum">    1540 </span>            :     // not have a |JSScript| for this frame (wasm frames), we take a slow path
<span class="lineNum">    1541 </span>            :     // that doesn't employ memoization, and update |locationp|'s slots directly.
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span><span class="lineCov">          1 :     if (!iter.hasScript()) {</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :         if (const char16_t* displayURL = iter.displayURL()) {</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :             locationp.setSource(AtomizeChars(cx, displayURL, js_strlen(displayURL)));</span>
<span class="lineNum">    1546 </span>            :         } else {
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :             const char* filename = iter.filename() ? iter.filename() : &quot;&quot;;</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :             locationp.setSource(Atomize(cx, filename, strlen(filename)));</span>
<span class="lineNum">    1549 </span>            :         }
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :         if (!locationp.source())</span>
<span class="lineNum">    1551 </span>            :             return false;
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         uint32_t column = 0;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :         locationp.setLine(iter.computeLine(&amp;column));</span>
<span class="lineNum">    1555 </span>            :         // XXX: Make the column 1-based as in other browsers, instead of 0-based
<span class="lineNum">    1556 </span>            :         // which is how SpiderMonkey stores it internally. This will be
<span class="lineNum">    1557 </span>            :         // unnecessary once bug 1144340 is fixed.
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :         locationp.setColumn(column + 1);</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1560 </span>            :     }
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineCov">          1 :     RootedScript script(cx, iter.script());</span>
<span class="lineNum">    1563 </span><span class="lineCov">          1 :     jsbytecode* pc = iter.pc();</span>
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span><span class="lineCov">          1 :     PCKey key(script, pc);</span>
<span class="lineNum">    1566 </span><span class="lineCov">          1 :     PCLocationMap::AddPtr p = pcLocationMap.lookupForAdd(key);</span>
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineCov">          1 :     if (!p) {</span>
<span class="lineNum">    1569 </span>            :         RootedAtom source(cx);
<span class="lineNum">    1570 </span><span class="lineCov">          1 :         if (const char16_t* displayURL = iter.displayURL()) {</span>
<span class="lineNum">    1571 </span><span class="lineCov">          1 :             source = AtomizeChars(cx, displayURL, js_strlen(displayURL));</span>
<span class="lineNum">    1572 </span>            :         } else {
<span class="lineNum">    1573 </span><span class="lineCov">          1 :             const char* filename = script-&gt;filename() ? script-&gt;filename() : &quot;&quot;;</span>
<span class="lineNum">    1574 </span><span class="lineCov">          1 :             source = Atomize(cx, filename, strlen(filename));</span>
<span class="lineNum">    1575 </span>            :         }
<span class="lineNum">    1576 </span><span class="lineCov">          1 :         if (!source)</span>
<span class="lineNum">    1577 </span>            :             return false;
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span>            :         uint32_t column;
<span class="lineNum">    1580 </span><span class="lineCov">          1 :         uint32_t line = PCToLineNumber(script, pc, &amp;column);</span>
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span>            :         // Make the column 1-based. See comment above.
<span class="lineNum">    1583 </span><span class="lineCov">          1 :         LocationValue value(source, line, column + 1);</span>
<span class="lineNum">    1584 </span><span class="lineCov">          1 :         if (!pcLocationMap.add(p, key, value)) {</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :             ReportOutOfMemory(cx);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1587 </span>            :         }
<span class="lineNum">    1588 </span>            :     }
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span><span class="lineCov">          1 :     locationp.set(p-&gt;value());</span>
<span class="lineNum">    1591 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1592 </span>            : }
<a name="1593"><span class="lineNum">    1593 </span>            : </a>
<span class="lineNum">    1594 </span>            : void
<span class="lineNum">    1595 </span><span class="lineCov">          1 : SavedStacks::chooseSamplingProbability(JSCompartment* compartment)</span>
<span class="lineNum">    1596 </span>            : {
<span class="lineNum">    1597 </span><span class="lineCov">          1 :     GlobalObject* global = compartment-&gt;maybeGlobal();</span>
<span class="lineNum">    1598 </span><span class="lineCov">          1 :     if (!global)</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineCov">          1 :     GlobalObject::DebuggerVector* dbgs = global-&gt;getDebuggers();</span>
<span class="lineNum">    1602 </span><span class="lineCov">          1 :     if (!dbgs || dbgs-&gt;empty())</span>
<span class="lineNum">    1603 </span>            :         return;
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span><span class="lineCov">          1 :     mozilla::DebugOnly&lt;ReadBarriered&lt;Debugger*&gt;*&gt; begin = dbgs-&gt;begin();</span>
<span class="lineNum">    1606 </span><span class="lineCov">          1 :     mozilla::DebugOnly&lt;bool&gt; foundAnyDebuggers = false;</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span><span class="lineCov">          1 :     double probability = 0;</span>
<span class="lineNum">    1609 </span><span class="lineCov">          1 :     for (auto dbgp = dbgs-&gt;begin(); dbgp &lt; dbgs-&gt;end(); dbgp++) {</span>
<span class="lineNum">    1610 </span>            :         // The set of debuggers had better not change while we're iterating,
<span class="lineNum">    1611 </span>            :         // such that the vector gets reallocated.
<span class="lineNum">    1612 </span>            :         MOZ_ASSERT(dbgs-&gt;begin() == begin);
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span><span class="lineCov">          1 :         if ((*dbgp)-&gt;trackingAllocationSites &amp;&amp; (*dbgp)-&gt;enabled) {</span>
<span class="lineNum">    1615 </span><span class="lineCov">          1 :             foundAnyDebuggers = true;</span>
<span class="lineNum">    1616 </span>            :             probability = std::max((*dbgp)-&gt;allocationSamplingProbability,
<span class="lineNum">    1617 </span><span class="lineCov">          1 :                                    probability);</span>
<span class="lineNum">    1618 </span>            :         }
<span class="lineNum">    1619 </span>            :     }
<span class="lineNum">    1620 </span>            :     MOZ_ASSERT(foundAnyDebuggers);
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span><span class="lineCov">          1 :     if (!bernoulliSeeded) {</span>
<span class="lineNum">    1623 </span>            :         mozilla::Array&lt;uint64_t, 2&gt; seed;
<span class="lineNum">    1624 </span><span class="lineCov">          1 :         GenerateXorShift128PlusSeed(seed);</span>
<span class="lineNum">    1625 </span><span class="lineCov">          1 :         bernoulli.setRandomState(seed[0], seed[1]);</span>
<span class="lineNum">    1626 </span><span class="lineCov">          1 :         bernoulliSeeded = true;</span>
<span class="lineNum">    1627 </span>            :     }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span><span class="lineCov">          1 :     bernoulli.setProbability(probability);</span>
<span class="lineNum">    1630 </span>            : }
<a name="1631"><span class="lineNum">    1631 </span>            : </a>
<span class="lineNum">    1632 </span>            : JSObject*
<span class="lineNum">    1633 </span><span class="lineCov">          1 : SavedStacks::MetadataBuilder::build(JSContext* cx, HandleObject target,</span>
<span class="lineNum">    1634 </span>            :                                     AutoEnterOOMUnsafeRegion&amp; oomUnsafe) const
<span class="lineNum">    1635 </span>            : {
<span class="lineNum">    1636 </span>            :     RootedObject obj(cx, target);
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span><span class="lineCov">          1 :     SavedStacks&amp; stacks = cx-&gt;compartment()-&gt;savedStacks();</span>
<span class="lineNum">    1639 </span><span class="lineCov">          1 :     if (!stacks.bernoulli.trial())</span>
<span class="lineNum">    1640 </span>            :         return nullptr;
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span>            :     RootedSavedFrame frame(cx);
<span class="lineNum">    1643 </span><span class="lineCov">          1 :     if (!stacks.saveCurrentStack(cx, &amp;frame))</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :         oomUnsafe.crash(&quot;SavedStacksMetadataBuilder&quot;);</span>
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span><span class="lineCov">          1 :     if (!Debugger::onLogAllocationSite(cx, obj, frame, mozilla::TimeStamp::Now()))</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :         oomUnsafe.crash(&quot;SavedStacksMetadataBuilder&quot;);</span>
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            :     MOZ_ASSERT_IF(frame, !frame-&gt;is&lt;WrapperObject&gt;());
<span class="lineNum">    1650 </span><span class="lineCov">          1 :     return frame;</span>
<span class="lineNum">    1651 </span>            : }
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            : const SavedStacks::MetadataBuilder SavedStacks::metadataBuilder;
<span class="lineNum">    1654 </span>            : 
<a name="1655"><span class="lineNum">    1655 </span>            : #ifdef JS_CRASH_DIAGNOSTICS</a>
<span class="lineNum">    1656 </span>            : void
<span class="lineNum">    1657 </span><span class="lineCov">          1 : CompartmentChecker::check(SavedStacks* stacks)</span>
<span class="lineNum">    1658 </span>            : {
<span class="lineNum">    1659 </span><span class="lineCov">          1 :     if (&amp;compartment-&gt;savedStacks() != stacks) {</span>
<span class="lineNum">    1660 </span>            :         printf(&quot;*** Compartment SavedStacks mismatch: %p vs. %p\n&quot;,
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :                (void*) &amp;compartment-&gt;savedStacks(), stacks);</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :         MOZ_CRASH();</span>
<span class="lineNum">    1663 </span>            :     }
<span class="lineNum">    1664 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1665 </span>            : #endif /* JS_CRASH_DIAGNOSTICS */
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            : /* static */ ReconstructedSavedFramePrincipals ReconstructedSavedFramePrincipals::IsSystem;
<span class="lineNum">    1668 </span>            : /* static */ ReconstructedSavedFramePrincipals ReconstructedSavedFramePrincipals::IsNotSystem;
<a name="1669"><span class="lineNum">    1669 </span>            : </a>
<span class="lineNum">    1670 </span>            : UTF8CharsZ
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 : BuildUTF8StackString(JSContext* cx, HandleObject stack)</span>
<span class="lineNum">    1672 </span>            : {
<span class="lineNum">    1673 </span>            :     RootedString stackStr(cx);
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :     if (!JS::BuildStackString(cx, stack, &amp;stackStr))</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :         return UTF8CharsZ();</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :     char* chars = JS_EncodeStringToUTF8(cx, stackStr);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     return UTF8CharsZ(chars, strlen(chars));</span>
<span class="lineNum">    1679 </span>            : }
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span>            : } /* namespace js */
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            : namespace JS {
<span class="lineNum">    1684 </span>            : namespace ubi {
<a name="1685"><span class="lineNum">    1685 </span>            : </a>
<span class="lineNum">    1686 </span>            : bool
<span class="lineNum">    1687 </span><span class="lineCov">          1 : ConcreteStackFrame&lt;SavedFrame&gt;::isSystem() const</span>
<span class="lineNum">    1688 </span>            : {
<span class="lineNum">    1689 </span><span class="lineCov">          1 :     auto trustedPrincipals = get().runtimeFromAnyThread()-&gt;trustedPrincipals();</span>
<span class="lineNum">    1690 </span><span class="lineCov">          1 :     return get().getPrincipals() == trustedPrincipals ||</span>
<span class="lineNum">    1691 </span><span class="lineCov">          1 :            get().getPrincipals() == &amp;js::ReconstructedSavedFramePrincipals::IsSystem;</span>
<span class="lineNum">    1692 </span>            : }
<a name="1693"><span class="lineNum">    1693 </span>            : </a>
<span class="lineNum">    1694 </span>            : bool
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 : ConcreteStackFrame&lt;SavedFrame&gt;::constructSavedFrameStack(JSContext* cx,</span>
<span class="lineNum">    1696 </span>            :                                                          MutableHandleObject outSavedFrameStack)
<span class="lineNum">    1697 </span>            :     const
<span class="lineNum">    1698 </span>            : {
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :     outSavedFrameStack.set(&amp;get());</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     if (!cx-&gt;compartment()-&gt;wrap(cx, outSavedFrameStack)) {</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :         outSavedFrameStack.set(nullptr);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1703 </span>            :     }
<span class="lineNum">    1704 </span>            :     return true;
<span class="lineNum">    1705 </span>            : }
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            : // A `mozilla::Variant` matcher that converts the inner value of a
<span class="lineNum">    1708 </span>            : // `JS::ubi::AtomOrTwoByteChars` string to a `JSAtom*`.
<span class="lineNum">    1709 </span>            : struct MOZ_STACK_CLASS AtomizingMatcher
<span class="lineNum">    1710 </span>            : {
<span class="lineNum">    1711 </span>            :     JSContext* cx;
<span class="lineNum">    1712 </span>            :     size_t     length;
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            :     explicit AtomizingMatcher(JSContext* cx, size_t length)
<span class="lineNum">    1715 </span>            :       : cx(cx)
<span class="lineNum">    1716 </span><span class="lineCov">          1 :       , length(length)</span>
<span class="lineNum">    1717 </span>            :     { }
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            :     JSAtom* match(JSAtom* atom) {
<span class="lineNum">    1720 </span>            :         MOZ_ASSERT(atom);
<span class="lineNum">    1721 </span>            :         return atom;
<span class="lineNum">    1722 </span>            :     }
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span>            :     JSAtom* match(const char16_t* chars) {
<span class="lineNum">    1725 </span>            :         MOZ_ASSERT(chars);
<span class="lineNum">    1726 </span><span class="lineCov">          1 :         return AtomizeChars(cx, chars, length);</span>
<span class="lineNum">    1727 </span>            :     }
<span class="lineNum">    1728 </span>            : };
<a name="1729"><span class="lineNum">    1729 </span>            : </a>
<span class="lineNum">    1730 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    1731 </span><span class="lineCov">          1 : ConstructSavedFrameStackSlow(JSContext* cx, JS::ubi::StackFrame&amp; frame,</span>
<span class="lineNum">    1732 </span>            :                              MutableHandleObject outSavedFrameStack)
<span class="lineNum">    1733 </span>            : {
<span class="lineNum">    1734 </span><span class="lineCov">          1 :     SavedFrame::AutoLookupVector stackChain(cx);</span>
<span class="lineNum">    1735 </span>            :     Rooted&lt;JS::ubi::StackFrame&gt; ubiFrame(cx, frame);
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineCov">          1 :     while (ubiFrame.get()) {</span>
<span class="lineNum">    1738 </span>            :         // Convert the source and functionDisplayName strings to atoms.
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            :         js::RootedAtom source(cx);
<span class="lineNum">    1741 </span><span class="lineCov">          1 :         AtomizingMatcher atomizer(cx, ubiFrame.get().sourceLength());</span>
<span class="lineNum">    1742 </span><span class="lineCov">          1 :         source = ubiFrame.get().source().match(atomizer);</span>
<span class="lineNum">    1743 </span><span class="lineCov">          1 :         if (!source)</span>
<span class="lineNum">    1744 </span>            :             return false;
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :         js::RootedAtom functionDisplayName(cx);
<span class="lineNum">    1747 </span><span class="lineCov">          1 :         auto nameLength = ubiFrame.get().functionDisplayNameLength();</span>
<span class="lineNum">    1748 </span><span class="lineCov">          1 :         if (nameLength &gt; 0) {</span>
<span class="lineNum">    1749 </span><span class="lineCov">          1 :             AtomizingMatcher atomizer(cx, nameLength);</span>
<span class="lineNum">    1750 </span><span class="lineCov">          1 :             functionDisplayName = ubiFrame.get().functionDisplayName().match(atomizer);</span>
<span class="lineNum">    1751 </span><span class="lineCov">          1 :             if (!functionDisplayName)</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1753 </span>            :         }
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span><span class="lineCov">          1 :         auto principals = js::ReconstructedSavedFramePrincipals::getSingleton(ubiFrame.get());</span>
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span><span class="lineCov">          1 :         if (!stackChain-&gt;emplaceBack(source, ubiFrame.get().line(), ubiFrame.get().column(),</span>
<span class="lineNum">    1758 </span>            :                                      functionDisplayName, /* asyncCause */ nullptr,
<span class="lineNum">    1759 </span><span class="lineCov">          1 :                                      /* parent */ nullptr, principals))</span>
<span class="lineNum">    1760 </span>            :         {
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :             ReportOutOfMemory(cx);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1763 </span>            :         }
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span><span class="lineCov">          1 :         ubiFrame = ubiFrame.get().parent();</span>
<span class="lineNum">    1766 </span>            :     }
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :     js::RootedSavedFrame parentFrame(cx);
<span class="lineNum">    1769 </span><span class="lineCov">          1 :     for (size_t i = stackChain-&gt;length(); i != 0; i--) {</span>
<span class="lineNum">    1770 </span><span class="lineCov">          1 :         SavedFrame::HandleLookup lookup = stackChain[i-1];</span>
<span class="lineNum">    1771 </span><span class="lineCov">          1 :         lookup-&gt;parent = parentFrame;</span>
<span class="lineNum">    1772 </span><span class="lineCov">          1 :         parentFrame = cx-&gt;compartment()-&gt;savedStacks().getOrCreateSavedFrame(cx, lookup);</span>
<span class="lineNum">    1773 </span><span class="lineCov">          1 :         if (!parentFrame)</span>
<span class="lineNum">    1774 </span>            :             return false;
<span class="lineNum">    1775 </span>            :     }
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span><span class="lineCov">          1 :     outSavedFrameStack.set(parentFrame);</span>
<span class="lineNum">    1778 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1779 </span>            : }
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            : } // namespace ubi
<span class="lineNum">    1783 </span>            : } // namespace JS
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
