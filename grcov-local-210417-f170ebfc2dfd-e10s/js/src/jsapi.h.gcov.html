<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/jsapi.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">js/src</a> - jsapi.h<span style="font-size: 80%;"> (source / <a href="jsapi.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">207</td>
            <td class="headerCovTableEntry">240</td>
            <td class="headerCovTableEntryMed">86.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntry">38</td>
            <td class="headerCovTableEntryMed">81.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* JavaScript API. */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #ifndef jsapi_h
<span class="lineNum">      10 </span>            : #define jsapi_h
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;mozilla/AlreadyAddRefed.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/FloatingPoint.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/Range.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/RangedPtr.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/RefPtr.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/Variant.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &lt;iterator&gt;
<span class="lineNum">      21 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;jsalloc.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;jspubtd.h&quot;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;js/CallArgs.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;js/CharacterEncoding.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;js/Class.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;js/GCVector.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;js/HashTable.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;js/Id.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;js/Principals.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;js/Realm.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;js/RefCounted.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;js/RootingAPI.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;js/TracingAPI.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;js/UniquePtr.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;js/Utility.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;js/Value.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;js/Vector.h&quot;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /************************************************************************/
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : namespace JS {
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : class TwoByteChars;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #ifdef JS_DEBUG
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : class JS_PUBLIC_API(AutoCheckRequestDepth)
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span>            :     JSContext* cx;
<span class="lineNum">      56 </span>            :   public:
<span class="lineNum">      57 </span>            :     explicit AutoCheckRequestDepth(JSContext* cx);
<span class="lineNum">      58 </span>            :     ~AutoCheckRequestDepth();
<span class="lineNum">      59 </span>            : };
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : # define CHECK_REQUEST(cx) \
<span class="lineNum">      62 </span>            :     JS::AutoCheckRequestDepth _autoCheckRequestDepth(cx)
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #else
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : # define CHECK_REQUEST(cx) \
<span class="lineNum">      67 </span>            :     ((void) 0)
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #endif /* JS_DEBUG */
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : /** AutoValueArray roots an internal fixed-size array of Values. */
<span class="lineNum">      72 </span>            : template &lt;size_t N&gt;
<span class="lineNum">      73 </span><span class="lineCov">          1 : class MOZ_RAII AutoValueArray : public AutoGCRooter</span>
<span class="lineNum">      74 </span>            : {
<span class="lineNum">      75 </span>            :     const size_t length_;
<span class="lineNum">      76 </span>            :     Value elements_[N];
<a name="77"><span class="lineNum">      77 </span>            : </a>
<span class="lineNum">      78 </span>            :   public:
<span class="lineNum">      79 </span><span class="lineCov">          1 :     explicit AutoValueArray(JSContext* cx</span>
<span class="lineNum">      80 </span>            :                             MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">      81 </span><span class="lineCov">          1 :       : AutoGCRooter(cx, VALARRAY), length_(N)</span>
<span class="lineNum">      82 </span>            :     {
<span class="lineNum">      83 </span>            :         /* Always initialize in case we GC before assignment. */
<span class="lineNum">      84 </span><span class="lineCov">          1 :         mozilla::PodArrayZero(elements_);</span>
<span class="lineNum">      85 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">      86 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineCov">          1 :     unsigned length() const { return length_; }</span>
<span class="lineNum">      89 </span>            :     const Value* begin() const { return elements_; }
<span class="lineNum">      90 </span><span class="lineCov">          1 :     Value* begin() { return elements_; }</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :     HandleValue operator[](unsigned i) const {
<span class="lineNum">      93 </span>            :         MOZ_ASSERT(i &lt; N);
<span class="lineNum">      94 </span>            :         return HandleValue::fromMarkedLocation(&amp;elements_[i]);
<span class="lineNum">      95 </span>            :     }
<span class="lineNum">      96 </span>            :     MutableHandleValue operator[](unsigned i) {
<span class="lineNum">      97 </span>            :         MOZ_ASSERT(i &lt; N);
<span class="lineNum">      98 </span><span class="lineCov">          1 :         return MutableHandleValue::fromMarkedLocation(&amp;elements_[i]);</span>
<span class="lineNum">      99 </span>            :     }
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     102 </span>            : };
<a name="103"><span class="lineNum">     103 </span>            : </a>
<span class="lineNum">     104 </span>            : template&lt;class T&gt;
<span class="lineNum">     105 </span><span class="lineCov">          1 : class MOZ_RAII AutoVectorRooterBase : protected AutoGCRooter</span>
<span class="lineNum">     106 </span>            : {
<span class="lineNum">     107 </span>            :     typedef js::Vector&lt;T, 8&gt; VectorImpl;
<span class="lineNum">     108 </span>            :     VectorImpl vector;
<a name="109"><span class="lineNum">     109 </span>            : </a>
<span class="lineNum">     110 </span>            :   public:
<span class="lineNum">     111 </span><span class="lineCov">          1 :     explicit AutoVectorRooterBase(JSContext* cx, ptrdiff_t tag</span>
<span class="lineNum">     112 </span>            :                               MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">     113 </span><span class="lineCov">          1 :       : AutoGCRooter(cx, tag), vector(cx)</span>
<span class="lineNum">     114 </span>            :     {
<span class="lineNum">     115 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     116 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :     typedef T ElementType;
<span class="lineNum">     119 </span>            :     typedef typename VectorImpl::Range Range;
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :     size_t length() const { return vector.length(); }
<a name="122"><span class="lineNum">     122 </span>            :     bool empty() const { return vector.empty(); }</a>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineCov">          1 :     MOZ_MUST_USE bool append(const T&amp; v) { return vector.append(v); }</span>
<span class="lineNum">     125 </span>            :     MOZ_MUST_USE bool appendN(const T&amp; v, size_t len) { return vector.appendN(v, len); }
<span class="lineNum">     126 </span>            :     MOZ_MUST_USE bool append(const T* ptr, size_t len) { return vector.append(ptr, len); }
<span class="lineNum">     127 </span>            :     MOZ_MUST_USE bool appendAll(const AutoVectorRooterBase&lt;T&gt;&amp; other) {
<span class="lineNum">     128 </span>            :         return vector.appendAll(other.vector);
<span class="lineNum">     129 </span>            :     }
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :     MOZ_MUST_USE bool insert(T* p, const T&amp; val) { return vector.insert(p, val); }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :     /* For use when space has already been reserved. */
<span class="lineNum">     134 </span><span class="lineCov">          1 :     void infallibleAppend(const T&amp; v) { vector.infallibleAppend(v); }</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :     void popBack() { vector.popBack(); }
<span class="lineNum">     137 </span>            :     T popCopy() { return vector.popCopy(); }
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :     MOZ_MUST_USE bool growBy(size_t inc) {
<span class="lineNum">     140 </span>            :         size_t oldLength = vector.length();
<span class="lineNum">     141 </span>            :         if (!vector.growByUninitialized(inc))
<span class="lineNum">     142 </span>            :             return false;
<span class="lineNum">     143 </span>            :         makeRangeGCSafe(oldLength);
<span class="lineNum">     144 </span>            :         return true;
<span class="lineNum">     145 </span>            :     }
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :     MOZ_MUST_USE bool resize(size_t newLength) {
<span class="lineNum">     148 </span>            :         size_t oldLength = vector.length();
<span class="lineNum">     149 </span>            :         if (newLength &lt;= oldLength) {
<span class="lineNum">     150 </span>            :             vector.shrinkBy(oldLength - newLength);
<span class="lineNum">     151 </span>            :             return true;
<span class="lineNum">     152 </span>            :         }
<span class="lineNum">     153 </span>            :         if (!vector.growByUninitialized(newLength - oldLength))
<span class="lineNum">     154 </span>            :             return false;
<span class="lineNum">     155 </span>            :         makeRangeGCSafe(oldLength);
<span class="lineNum">     156 </span>            :         return true;
<span class="lineNum">     157 </span>            :     }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :     void clear() { vector.clear(); }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     MOZ_MUST_USE bool reserve(size_t newLength) {
<span class="lineNum">     162 </span><span class="lineCov">          1 :         return vector.reserve(newLength);</span>
<span class="lineNum">     163 </span>            :     }
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :     JS::MutableHandle&lt;T&gt; operator[](size_t i) {
<span class="lineNum">     166 </span>            :         return JS::MutableHandle&lt;T&gt;::fromMarkedLocation(&amp;vector[i]);
<span class="lineNum">     167 </span>            :     }
<span class="lineNum">     168 </span>            :     JS::Handle&lt;T&gt; operator[](size_t i) const {
<span class="lineNum">     169 </span>            :         return JS::Handle&lt;T&gt;::fromMarkedLocation(&amp;vector[i]);
<span class="lineNum">     170 </span>            :     }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     const T* begin() const { return vector.begin(); }
<span class="lineNum">     173 </span><span class="lineCov">          1 :     T* begin() { return vector.begin(); }</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :     const T* end() const { return vector.end(); }
<span class="lineNum">     176 </span><span class="lineCov">          1 :     T* end() { return vector.end(); }</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :     Range all() { return vector.all(); }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :     const T&amp; back() const { return vector.back(); }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :     friend void AutoGCRooter::trace(JSTracer* trc);
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   private:
<span class="lineNum">     185 </span>            :     void makeRangeGCSafe(size_t oldLength) {
<span class="lineNum">     186 </span>            :         T* t = vector.begin() + oldLength;
<span class="lineNum">     187 </span>            :         for (size_t i = oldLength; i &lt; vector.length(); ++i, ++t)
<span class="lineNum">     188 </span>            :             memset(t, 0, sizeof(T));
<span class="lineNum">     189 </span>            :     }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     192 </span>            : };
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : template &lt;typename T&gt;
<span class="lineNum">     195 </span>            : class MOZ_RAII AutoVectorRooter : public AutoVectorRooterBase&lt;T&gt;
<span class="lineNum">     196 </span>            : {
<span class="lineNum">     197 </span>            :   public:
<span class="lineNum">     198 </span>            :     explicit AutoVectorRooter(JSContext* cx
<span class="lineNum">     199 </span>            :                              MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">     200 </span>            :         : AutoVectorRooterBase&lt;T&gt;(cx, this-&gt;GetTag(T()))
<span class="lineNum">     201 </span>            :     {
<span class="lineNum">     202 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     203 </span>            :     }
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     206 </span>            : };
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineCov">          1 : class AutoValueVector : public Rooted&lt;GCVector&lt;Value, 8&gt;&gt; {</span>
<span class="lineNum">     209 </span>            :     using Vec = GCVector&lt;Value, 8&gt;;
<a name="210"><span class="lineNum">     210 </span>            :     using Base = Rooted&lt;Vec&gt;;</a>
<span class="lineNum">     211 </span>            :   public:
<span class="lineNum">     212 </span><span class="lineCov">          1 :     explicit AutoValueVector(JSContext* cx) : Base(cx, Vec(cx)) {}</span>
<span class="lineNum">     213 </span>            : };
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineCov">          1 : class AutoIdVector : public Rooted&lt;GCVector&lt;jsid, 8&gt;&gt; {</span>
<span class="lineNum">     216 </span>            :     using Vec = GCVector&lt;jsid, 8&gt;;
<a name="217"><span class="lineNum">     217 </span>            :     using Base = Rooted&lt;Vec&gt;;</a>
<span class="lineNum">     218 </span>            :   public:
<span class="lineNum">     219 </span><span class="lineCov">          1 :     explicit AutoIdVector(JSContext* cx) : Base(cx, Vec(cx)) {}</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineCov">          1 :     bool appendAll(const AutoIdVector&amp; other) { return this-&gt;Base::appendAll(other.get()); }</span>
<span class="lineNum">     222 </span>            : };
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">          1 : class AutoObjectVector : public Rooted&lt;GCVector&lt;JSObject*, 8&gt;&gt; {</span>
<span class="lineNum">     225 </span>            :     using Vec = GCVector&lt;JSObject*, 8&gt;;
<a name="226"><span class="lineNum">     226 </span>            :     using Base = Rooted&lt;Vec&gt;;</a>
<span class="lineNum">     227 </span>            :   public:
<span class="lineNum">     228 </span><span class="lineCov">          1 :     explicit AutoObjectVector(JSContext* cx) : Base(cx, Vec(cx)) {}</span>
<span class="lineNum">     229 </span>            : };
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : using ValueVector = JS::GCVector&lt;JS::Value&gt;;
<span class="lineNum">     232 </span>            : using IdVector = JS::GCVector&lt;jsid&gt;;
<span class="lineNum">     233 </span>            : using ScriptVector = JS::GCVector&lt;JSScript*&gt;;
<span class="lineNum">     234 </span>            : using StringVector = JS::GCVector&lt;JSString*&gt;;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : template&lt;class Key, class Value&gt;
<span class="lineNum">     237 </span>            : class MOZ_RAII AutoHashMapRooter : protected AutoGCRooter
<span class="lineNum">     238 </span>            : {
<span class="lineNum">     239 </span>            :   private:
<span class="lineNum">     240 </span>            :     typedef js::HashMap&lt;Key, Value&gt; HashMapImpl;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :   public:
<span class="lineNum">     243 </span>            :     explicit AutoHashMapRooter(JSContext* cx, ptrdiff_t tag
<span class="lineNum">     244 </span>            :                                MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">     245 </span>            :       : AutoGCRooter(cx, tag), map(cx)
<span class="lineNum">     246 </span>            :     {
<span class="lineNum">     247 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     248 </span>            :     }
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :     typedef Key KeyType;
<span class="lineNum">     251 </span>            :     typedef Value ValueType;
<span class="lineNum">     252 </span>            :     typedef typename HashMapImpl::Entry Entry;
<span class="lineNum">     253 </span>            :     typedef typename HashMapImpl::Lookup Lookup;
<span class="lineNum">     254 </span>            :     typedef typename HashMapImpl::Ptr Ptr;
<span class="lineNum">     255 </span>            :     typedef typename HashMapImpl::AddPtr AddPtr;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :     bool init(uint32_t len = 16) {
<span class="lineNum">     258 </span>            :         return map.init(len);
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            :     bool initialized() const {
<span class="lineNum">     261 </span>            :         return map.initialized();
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span>            :     Ptr lookup(const Lookup&amp; l) const {
<span class="lineNum">     264 </span>            :         return map.lookup(l);
<span class="lineNum">     265 </span>            :     }
<span class="lineNum">     266 </span>            :     void remove(Ptr p) {
<span class="lineNum">     267 </span>            :         map.remove(p);
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            :     AddPtr lookupForAdd(const Lookup&amp; l) const {
<span class="lineNum">     270 </span>            :         return map.lookupForAdd(l);
<span class="lineNum">     271 </span>            :     }
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :     template&lt;typename KeyInput, typename ValueInput&gt;
<span class="lineNum">     274 </span>            :     bool add(AddPtr&amp; p, const KeyInput&amp; k, const ValueInput&amp; v) {
<span class="lineNum">     275 </span>            :         return map.add(p, k, v);
<span class="lineNum">     276 </span>            :     }
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     bool add(AddPtr&amp; p, const Key&amp; k) {
<span class="lineNum">     279 </span>            :         return map.add(p, k);
<span class="lineNum">     280 </span>            :     }
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :     template&lt;typename KeyInput, typename ValueInput&gt;
<span class="lineNum">     283 </span>            :     bool relookupOrAdd(AddPtr&amp; p, const KeyInput&amp; k, const ValueInput&amp; v) {
<span class="lineNum">     284 </span>            :         return map.relookupOrAdd(p, k, v);
<span class="lineNum">     285 </span>            :     }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :     typedef typename HashMapImpl::Range Range;
<span class="lineNum">     288 </span>            :     Range all() const {
<span class="lineNum">     289 </span>            :         return map.all();
<span class="lineNum">     290 </span>            :     }
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     typedef typename HashMapImpl::Enum Enum;
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :     void clear() {
<span class="lineNum">     295 </span>            :         map.clear();
<span class="lineNum">     296 </span>            :     }
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :     void finish() {
<span class="lineNum">     299 </span>            :         map.finish();
<span class="lineNum">     300 </span>            :     }
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :     bool empty() const {
<span class="lineNum">     303 </span>            :         return map.empty();
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :     uint32_t count() const {
<span class="lineNum">     307 </span>            :         return map.count();
<span class="lineNum">     308 </span>            :     }
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :     size_t capacity() const {
<span class="lineNum">     311 </span>            :         return map.capacity();
<span class="lineNum">     312 </span>            :     }
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :     size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
<span class="lineNum">     315 </span>            :         return map.sizeOfExcludingThis(mallocSizeOf);
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            :     size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
<span class="lineNum">     318 </span>            :         return map.sizeOfIncludingThis(mallocSizeOf);
<span class="lineNum">     319 </span>            :     }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     /************************************************** Shorthand operations */
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     bool has(const Lookup&amp; l) const {
<span class="lineNum">     324 </span>            :         return map.has(l);
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :     template&lt;typename KeyInput, typename ValueInput&gt;
<span class="lineNum">     328 </span>            :     bool put(const KeyInput&amp; k, const ValueInput&amp; v) {
<span class="lineNum">     329 </span>            :         return map.put(k, v);
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :     template&lt;typename KeyInput, typename ValueInput&gt;
<span class="lineNum">     333 </span>            :     bool putNew(const KeyInput&amp; k, const ValueInput&amp; v) {
<span class="lineNum">     334 </span>            :         return map.putNew(k, v);
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :     Ptr lookupWithDefault(const Key&amp; k, const Value&amp; defaultValue) {
<span class="lineNum">     338 </span>            :         return map.lookupWithDefault(k, defaultValue);
<span class="lineNum">     339 </span>            :     }
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :     void remove(const Lookup&amp; l) {
<span class="lineNum">     342 </span>            :         map.remove(l);
<span class="lineNum">     343 </span>            :     }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :     friend void AutoGCRooter::trace(JSTracer* trc);
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :   private:
<span class="lineNum">     348 </span>            :     AutoHashMapRooter(const AutoHashMapRooter&amp; hmr) = delete;
<span class="lineNum">     349 </span>            :     AutoHashMapRooter&amp; operator=(const AutoHashMapRooter&amp; hmr) = delete;
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :     HashMapImpl map;
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     354 </span>            : };
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : template&lt;class T&gt;
<span class="lineNum">     357 </span>            : class MOZ_RAII AutoHashSetRooter : protected AutoGCRooter
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            :   private:
<span class="lineNum">     360 </span>            :     typedef js::HashSet&lt;T&gt; HashSetImpl;
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :   public:
<span class="lineNum">     363 </span>            :     explicit AutoHashSetRooter(JSContext* cx, ptrdiff_t tag
<span class="lineNum">     364 </span>            :                                MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">     365 </span>            :       : AutoGCRooter(cx, tag), set(cx)
<span class="lineNum">     366 </span>            :     {
<span class="lineNum">     367 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     368 </span>            :     }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :     typedef typename HashSetImpl::Lookup Lookup;
<span class="lineNum">     371 </span>            :     typedef typename HashSetImpl::Ptr Ptr;
<span class="lineNum">     372 </span>            :     typedef typename HashSetImpl::AddPtr AddPtr;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :     bool init(uint32_t len = 16) {
<span class="lineNum">     375 </span>            :         return set.init(len);
<span class="lineNum">     376 </span>            :     }
<span class="lineNum">     377 </span>            :     bool initialized() const {
<span class="lineNum">     378 </span>            :         return set.initialized();
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span>            :     Ptr lookup(const Lookup&amp; l) const {
<span class="lineNum">     381 </span>            :         return set.lookup(l);
<span class="lineNum">     382 </span>            :     }
<span class="lineNum">     383 </span>            :     void remove(Ptr p) {
<span class="lineNum">     384 </span>            :         set.remove(p);
<span class="lineNum">     385 </span>            :     }
<span class="lineNum">     386 </span>            :     AddPtr lookupForAdd(const Lookup&amp; l) const {
<span class="lineNum">     387 </span>            :         return set.lookupForAdd(l);
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :     bool add(AddPtr&amp; p, const T&amp; t) {
<span class="lineNum">     391 </span>            :         return set.add(p, t);
<span class="lineNum">     392 </span>            :     }
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :     bool relookupOrAdd(AddPtr&amp; p, const Lookup&amp; l, const T&amp; t) {
<span class="lineNum">     395 </span>            :         return set.relookupOrAdd(p, l, t);
<span class="lineNum">     396 </span>            :     }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :     typedef typename HashSetImpl::Range Range;
<span class="lineNum">     399 </span>            :     Range all() const {
<span class="lineNum">     400 </span>            :         return set.all();
<span class="lineNum">     401 </span>            :     }
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :     typedef typename HashSetImpl::Enum Enum;
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :     void clear() {
<span class="lineNum">     406 </span>            :         set.clear();
<span class="lineNum">     407 </span>            :     }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :     void finish() {
<span class="lineNum">     410 </span>            :         set.finish();
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :     bool empty() const {
<span class="lineNum">     414 </span>            :         return set.empty();
<span class="lineNum">     415 </span>            :     }
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :     uint32_t count() const {
<span class="lineNum">     418 </span>            :         return set.count();
<span class="lineNum">     419 </span>            :     }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :     size_t capacity() const {
<span class="lineNum">     422 </span>            :         return set.capacity();
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
<span class="lineNum">     426 </span>            :         return set.sizeOfExcludingThis(mallocSizeOf);
<span class="lineNum">     427 </span>            :     }
<span class="lineNum">     428 </span>            :     size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
<span class="lineNum">     429 </span>            :         return set.sizeOfIncludingThis(mallocSizeOf);
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :     /************************************************** Shorthand operations */
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :     bool has(const Lookup&amp; l) const {
<span class="lineNum">     435 </span>            :         return set.has(l);
<span class="lineNum">     436 </span>            :     }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     bool put(const T&amp; t) {
<span class="lineNum">     439 </span>            :         return set.put(t);
<span class="lineNum">     440 </span>            :     }
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :     bool putNew(const T&amp; t) {
<span class="lineNum">     443 </span>            :         return set.putNew(t);
<span class="lineNum">     444 </span>            :     }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :     void remove(const Lookup&amp; l) {
<span class="lineNum">     447 </span>            :         set.remove(l);
<span class="lineNum">     448 </span>            :     }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :     friend void AutoGCRooter::trace(JSTracer* trc);
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   private:
<span class="lineNum">     453 </span>            :     AutoHashSetRooter(const AutoHashSetRooter&amp; hmr) = delete;
<span class="lineNum">     454 </span>            :     AutoHashSetRooter&amp; operator=(const AutoHashSetRooter&amp; hmr) = delete;
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :     HashSetImpl set;
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     459 </span>            : };
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : /**
<span class="lineNum">     462 </span>            :  * Custom rooting behavior for internal and external clients.
<span class="lineNum">     463 </span>            :  */
<span class="lineNum">     464 </span>            : class MOZ_RAII JS_PUBLIC_API(CustomAutoRooter) : private AutoGCRooter
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span>            :   public:
<span class="lineNum">     467 </span>            :     template &lt;typename CX&gt;
<span class="lineNum">     468 </span>            :     explicit CustomAutoRooter(const CX&amp; cx MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">     469 </span><span class="lineCov">          1 :       : AutoGCRooter(cx, CUSTOM)</span>
<span class="lineNum">     470 </span>            :     {
<span class="lineNum">     471 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     472 </span>            :     }
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :     friend void AutoGCRooter::trace(JSTracer* trc);
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :   protected:
<span class="lineNum">     477 </span><span class="lineCov">          1 :     virtual ~CustomAutoRooter() {}</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :     /** Supplied by derived class to trace roots. */
<span class="lineNum">     480 </span>            :     virtual void trace(JSTracer* trc) = 0;
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :   private:
<span class="lineNum">     483 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     484 </span>            : };
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : /** A handle to an array of rooted values. */
<span class="lineNum">     487 </span>            : class HandleValueArray
<span class="lineNum">     488 </span>            : {
<span class="lineNum">     489 </span>            :     const size_t length_;
<span class="lineNum">     490 </span>            :     const Value * const elements_;
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :     HandleValueArray(size_t len, const Value* elements) : length_(len), elements_(elements) {}
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :   public:
<span class="lineNum">     495 </span>            :     explicit HandleValueArray(const RootedValue&amp; value) : length_(1), elements_(value.address()) {}
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :     MOZ_IMPLICIT HandleValueArray(const AutoValueVector&amp; values)
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       : length_(values.length()), elements_(values.begin()) {}</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :     template &lt;size_t N&gt;
<span class="lineNum">     501 </span>            :     MOZ_IMPLICIT HandleValueArray(const AutoValueArray&lt;N&gt;&amp; values) : length_(N), elements_(values.begin()) {}
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :     /** CallArgs must already be rooted somewhere up the stack. */
<span class="lineNum">     504 </span><span class="lineCov">          1 :     MOZ_IMPLICIT HandleValueArray(const JS::CallArgs&amp; args) : length_(args.length()), elements_(args.array()) {}</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     /** Use with care! Only call this if the data is guaranteed to be marked. */
<span class="lineNum">     507 </span>            :     static HandleValueArray fromMarkedLocation(size_t len, const Value* elements) {
<span class="lineNum">     508 </span>            :         return HandleValueArray(len, elements);
<span class="lineNum">     509 </span>            :     }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :     static HandleValueArray subarray(const HandleValueArray&amp; values, size_t startIndex, size_t len) {
<span class="lineNum">     512 </span>            :         MOZ_ASSERT(startIndex + len &lt;= values.length());
<span class="lineNum">     513 </span><span class="lineCov">          1 :         return HandleValueArray(len, values.begin() + startIndex);</span>
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :     static HandleValueArray empty() {
<span class="lineNum">     517 </span>            :         return HandleValueArray(0, nullptr);
<span class="lineNum">     518 </span>            :     }
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :     size_t length() const { return length_; }
<span class="lineNum">     521 </span>            :     const Value* begin() const { return elements_; }
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :     HandleValue operator[](size_t i) const {
<span class="lineNum">     524 </span>            :         MOZ_ASSERT(i &lt; length_);
<span class="lineNum">     525 </span><span class="lineCov">          1 :         return HandleValue::fromMarkedLocation(&amp;elements_[i]);</span>
<span class="lineNum">     526 </span>            :     }
<span class="lineNum">     527 </span>            : };
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            : }  /* namespace JS */
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : /************************************************************************/
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : struct JSFreeOp {
<span class="lineNum">     534 </span>            :   protected:
<span class="lineNum">     535 </span>            :     JSRuntime*  runtime_;
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :     explicit JSFreeOp(JSRuntime* rt)
<span class="lineNum">     538 </span><span class="lineCov">          1 :       : runtime_(rt) { }</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   public:
<span class="lineNum">     541 </span>            :     JSRuntime* runtime() const {
<span class="lineNum">     542 </span>            :         MOZ_ASSERT(runtime_);
<span class="lineNum">     543 </span><span class="lineCov">          1 :         return runtime_;</span>
<span class="lineNum">     544 </span>            :     }
<span class="lineNum">     545 </span>            : };
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : /* Callbacks and their arguments. */
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : /************************************************************************/
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            : typedef enum JSGCStatus {
<span class="lineNum">     552 </span>            :     JSGC_BEGIN,
<span class="lineNum">     553 </span>            :     JSGC_END
<span class="lineNum">     554 </span>            : } JSGCStatus;
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : typedef void
<span class="lineNum">     557 </span>            : (* JSGCCallback)(JSContext* cx, JSGCStatus status, void* data);
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            : typedef void
<span class="lineNum">     560 </span>            : (* JSObjectsTenuredCallback)(JSContext* cx, void* data);
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            : typedef enum JSFinalizeStatus {
<span class="lineNum">     563 </span>            :     /**
<span class="lineNum">     564 </span>            :      * Called when preparing to sweep a group of zones, before anything has been
<span class="lineNum">     565 </span>            :      * swept.  The collector will not yield to the mutator before calling the
<span class="lineNum">     566 </span>            :      * callback with JSFINALIZE_GROUP_END status.
<span class="lineNum">     567 </span>            :      */
<span class="lineNum">     568 </span>            :     JSFINALIZE_GROUP_START,
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :     /**
<span class="lineNum">     571 </span>            :      * Called when preparing to sweep a group of zones. Weak references to
<span class="lineNum">     572 </span>            :      * unmarked things have been removed and things that are not swept
<span class="lineNum">     573 </span>            :      * incrementally have been finalized at this point.  The collector may yield
<span class="lineNum">     574 </span>            :      * to the mutator after this point.
<span class="lineNum">     575 </span>            :      */
<span class="lineNum">     576 </span>            :     JSFINALIZE_GROUP_END,
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :     /**
<span class="lineNum">     579 </span>            :      * Called at the end of collection when everything has been swept.
<span class="lineNum">     580 </span>            :      */
<span class="lineNum">     581 </span>            :     JSFINALIZE_COLLECTION_END
<span class="lineNum">     582 </span>            : } JSFinalizeStatus;
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            : typedef void
<span class="lineNum">     585 </span>            : (* JSFinalizeCallback)(JSFreeOp* fop, JSFinalizeStatus status, bool isZoneGC, void* data);
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            : typedef void
<span class="lineNum">     588 </span>            : (* JSWeakPointerZonesCallback)(JSContext* cx, void* data);
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            : typedef void
<span class="lineNum">     591 </span>            : (* JSWeakPointerCompartmentCallback)(JSContext* cx, JSCompartment* comp, void* data);
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            : typedef bool
<span class="lineNum">     594 </span>            : (* JSInterruptCallback)(JSContext* cx);
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            : typedef JSObject*
<span class="lineNum">     597 </span>            : (* JSGetIncumbentGlobalCallback)(JSContext* cx);
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            : typedef bool
<span class="lineNum">     600 </span>            : (* JSEnqueuePromiseJobCallback)(JSContext* cx, JS::HandleObject job,
<span class="lineNum">     601 </span>            :                                 JS::HandleObject allocationSite, JS::HandleObject incumbentGlobal,
<span class="lineNum">     602 </span>            :                                 void* data);
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : enum class PromiseRejectionHandlingState {
<span class="lineNum">     605 </span>            :     Unhandled,
<span class="lineNum">     606 </span>            :     Handled
<span class="lineNum">     607 </span>            : };
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : typedef void
<span class="lineNum">     610 </span>            : (* JSPromiseRejectionTrackerCallback)(JSContext* cx, JS::HandleObject promise,
<span class="lineNum">     611 </span>            :                                       PromiseRejectionHandlingState state, void* data);
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : typedef void
<span class="lineNum">     614 </span>            : (* JSProcessPromiseCallback)(JSContext* cx, JS::HandleObject promise);
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            : /**
<span class="lineNum">     617 </span>            :  * Possible exception types. These types are part of a JSErrorFormatString
<span class="lineNum">     618 </span>            :  * structure. They define which error to throw in case of a runtime error.
<span class="lineNum">     619 </span>            :  *
<span class="lineNum">     620 </span>            :  * JSEXN_WARN is used for warnings in js.msg files (for instance because we
<span class="lineNum">     621 </span>            :  * don't want to prepend 'Error:' to warning messages). This value can go away
<span class="lineNum">     622 </span>            :  * if we ever decide to use an entirely separate mechanism for warnings.
<span class="lineNum">     623 </span>            :  */
<span class="lineNum">     624 </span>            : typedef enum JSExnType {
<span class="lineNum">     625 </span>            :     JSEXN_ERR,
<span class="lineNum">     626 </span>            :     JSEXN_FIRST = JSEXN_ERR,
<span class="lineNum">     627 </span>            :         JSEXN_INTERNALERR,
<span class="lineNum">     628 </span>            :         JSEXN_EVALERR,
<span class="lineNum">     629 </span>            :         JSEXN_RANGEERR,
<span class="lineNum">     630 </span>            :         JSEXN_REFERENCEERR,
<span class="lineNum">     631 </span>            :         JSEXN_SYNTAXERR,
<span class="lineNum">     632 </span>            :         JSEXN_TYPEERR,
<span class="lineNum">     633 </span>            :         JSEXN_URIERR,
<span class="lineNum">     634 </span>            :         JSEXN_DEBUGGEEWOULDRUN,
<span class="lineNum">     635 </span>            :         JSEXN_WASMCOMPILEERROR,
<span class="lineNum">     636 </span>            :         JSEXN_WASMLINKERROR,
<span class="lineNum">     637 </span>            :         JSEXN_WASMRUNTIMEERROR,
<span class="lineNum">     638 </span>            :     JSEXN_ERROR_LIMIT,
<span class="lineNum">     639 </span>            :     JSEXN_WARN = JSEXN_ERROR_LIMIT,
<span class="lineNum">     640 </span>            :     JSEXN_NOTE,
<span class="lineNum">     641 </span>            :     JSEXN_LIMIT
<span class="lineNum">     642 </span>            : } JSExnType;
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            : struct JSErrorFormatString {
<span class="lineNum">     645 </span>            :      /** The error message name in ASCII. */
<span class="lineNum">     646 </span>            :     const char* name;
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :     /** The error format string in ASCII. */
<span class="lineNum">     649 </span>            :     const char* format;
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :     /** The number of arguments to expand in the formatted error message. */
<span class="lineNum">     652 </span>            :     uint16_t argCount;
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :     /** One of the JSExnType constants above. */
<span class="lineNum">     655 </span>            :     int16_t exnType;
<span class="lineNum">     656 </span>            : };
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            : typedef const JSErrorFormatString*
<span class="lineNum">     659 </span>            : (* JSErrorCallback)(void* userRef, const unsigned errorNumber);
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : typedef bool
<span class="lineNum">     662 </span>            : (* JSLocaleToUpperCase)(JSContext* cx, JS::HandleString src, JS::MutableHandleValue rval);
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : typedef bool
<span class="lineNum">     665 </span>            : (* JSLocaleToLowerCase)(JSContext* cx, JS::HandleString src, JS::MutableHandleValue rval);
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : typedef bool
<span class="lineNum">     668 </span>            : (* JSLocaleCompare)(JSContext* cx, JS::HandleString src1, JS::HandleString src2,
<span class="lineNum">     669 </span>            :                     JS::MutableHandleValue rval);
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : typedef bool
<span class="lineNum">     672 </span>            : (* JSLocaleToUnicode)(JSContext* cx, const char* src, JS::MutableHandleValue rval);
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : /**
<span class="lineNum">     675 </span>            :  * Callback used to ask the embedding for the cross compartment wrapper handler
<span class="lineNum">     676 </span>            :  * that implements the desired prolicy for this kind of object in the
<span class="lineNum">     677 </span>            :  * destination compartment. |obj| is the object to be wrapped. If |existing| is
<span class="lineNum">     678 </span>            :  * non-nullptr, it will point to an existing wrapper object that should be
<span class="lineNum">     679 </span>            :  * re-used if possible. |existing| is guaranteed to be a cross-compartment
<span class="lineNum">     680 </span>            :  * wrapper with a lazily-defined prototype and the correct global. It is
<span class="lineNum">     681 </span>            :  * guaranteed not to wrap a function.
<span class="lineNum">     682 </span>            :  */
<span class="lineNum">     683 </span>            : typedef JSObject*
<span class="lineNum">     684 </span>            : (* JSWrapObjectCallback)(JSContext* cx, JS::HandleObject existing, JS::HandleObject obj);
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : /**
<span class="lineNum">     687 </span>            :  * Callback used by the wrap hook to ask the embedding to prepare an object
<span class="lineNum">     688 </span>            :  * for wrapping in a context. This might include unwrapping other wrappers
<span class="lineNum">     689 </span>            :  * or even finding a more suitable object for the new compartment.
<span class="lineNum">     690 </span>            :  */
<span class="lineNum">     691 </span>            : typedef void
<span class="lineNum">     692 </span>            : (* JSPreWrapCallback)(JSContext* cx, JS::HandleObject scope, JS::HandleObject obj,
<span class="lineNum">     693 </span>            :                       JS::HandleObject objectPassedToWrap,
<span class="lineNum">     694 </span>            :                       JS::MutableHandleObject retObj);
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : struct JSWrapObjectCallbacks
<span class="lineNum">     697 </span>            : {
<span class="lineNum">     698 </span>            :     JSWrapObjectCallback wrap;
<span class="lineNum">     699 </span>            :     JSPreWrapCallback preWrap;
<span class="lineNum">     700 </span>            : };
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : typedef void
<span class="lineNum">     703 </span>            : (* JSDestroyCompartmentCallback)(JSFreeOp* fop, JSCompartment* compartment);
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : typedef size_t
<span class="lineNum">     706 </span>            : (* JSSizeOfIncludingThisCompartmentCallback)(mozilla::MallocSizeOf mallocSizeOf,
<span class="lineNum">     707 </span>            :                                              JSCompartment* compartment);
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : typedef void
<span class="lineNum">     710 </span>            : (* JSCompartmentNameCallback)(JSContext* cx, JSCompartment* compartment,
<span class="lineNum">     711 </span>            :                               char* buf, size_t bufsize);
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : /**
<span class="lineNum">     714 </span>            :  * Callback used by memory reporting to ask the embedder how much memory an
<span class="lineNum">     715 </span>            :  * external string is keeping alive.  The embedder is expected to return a value
<span class="lineNum">     716 </span>            :  * that corresponds to the size of the allocation that will be released by the
<span class="lineNum">     717 </span>            :  * JSStringFinalizer passed to JS_NewExternalString for this string.
<span class="lineNum">     718 </span>            :  *
<span class="lineNum">     719 </span>            :  * Implementations of this callback MUST NOT do anything that can cause GC.
<span class="lineNum">     720 </span>            :  */
<span class="lineNum">     721 </span>            : using JSExternalStringSizeofCallback =
<span class="lineNum">     722 </span>            :     size_t (*)(JSString* str, mozilla::MallocSizeOf mallocSizeOf);
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            : /************************************************************************/
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : static MOZ_ALWAYS_INLINE JS::Value
<span class="lineNum">     727 </span>            : JS_NumberValue(double d)
<span class="lineNum">     728 </span>            : {
<span class="lineNum">     729 </span>            :     int32_t i;
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     d = JS::CanonicalizeNaN(d);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     if (mozilla::NumberIsInt32(d, &amp;i))</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         return JS::Int32Value(i);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     return JS::DoubleValue(d);</span>
<span class="lineNum">     734 </span>            : }
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            : /************************************************************************/
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">     739 </span>            : JS_StringHasBeenPinned(JSContext* cx, JSString* str);
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : namespace JS {
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : /**
<span class="lineNum">     744 </span>            :  * Container class for passing in script source buffers to the JS engine.  This
<span class="lineNum">     745 </span>            :  * not only groups the buffer and length values, it also provides a way to
<span class="lineNum">     746 </span>            :  * optionally pass ownership of the buffer to the JS engine without copying.
<span class="lineNum">     747 </span>            :  * Rules for use:
<span class="lineNum">     748 </span>            :  *
<span class="lineNum">     749 </span>            :  *  1) The data array must be allocated with js_malloc() or js_realloc() if
<span class="lineNum">     750 </span>            :  *     ownership is being granted to the SourceBufferHolder.
<span class="lineNum">     751 </span>            :  *  2) If ownership is not given to the SourceBufferHolder, then the memory
<span class="lineNum">     752 </span>            :  *     must be kept alive until the JS compilation is complete.
<span class="lineNum">     753 </span>            :  *  3) Any code calling SourceBufferHolder::take() must guarantee to keep the
<span class="lineNum">     754 </span>            :  *     memory alive until JS compilation completes.  Normally only the JS
<span class="lineNum">     755 </span>            :  *     engine should be calling take().
<span class="lineNum">     756 </span>            :  *
<span class="lineNum">     757 </span>            :  * Example use:
<span class="lineNum">     758 </span>            :  *
<span class="lineNum">     759 </span>            :  *    size_t length = 512;
<span class="lineNum">     760 </span>            :  *    char16_t* chars = static_cast&lt;char16_t*&gt;(js_malloc(sizeof(char16_t) * length));
<span class="lineNum">     761 </span>            :  *    JS::SourceBufferHolder srcBuf(chars, length, JS::SourceBufferHolder::GiveOwnership);
<span class="lineNum">     762 </span>            :  *    JS::Compile(cx, options, srcBuf);
<span class="lineNum">     763 </span>            :  */
<span class="lineNum">     764 </span>            : class MOZ_STACK_CLASS SourceBufferHolder final
<span class="lineNum">     765 </span>            : {
<span class="lineNum">     766 </span>            :   public:
<span class="lineNum">     767 </span>            :     enum Ownership {
<span class="lineNum">     768 </span>            :       NoOwnership,
<span class="lineNum">     769 </span>            :       GiveOwnership
<span class="lineNum">     770 </span>            :     };
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :     SourceBufferHolder(const char16_t* data, size_t dataLength, Ownership ownership)
<span class="lineNum">     773 </span>            :       : data_(data),
<span class="lineNum">     774 </span>            :         length_(dataLength),
<span class="lineNum">     775 </span><span class="lineCov">          1 :         ownsChars_(ownership == GiveOwnership)</span>
<span class="lineNum">     776 </span>            :     {
<span class="lineNum">     777 </span>            :         // Ensure that null buffers properly return an unowned, empty,
<span class="lineNum">     778 </span>            :         // null-terminated string.
<span class="lineNum">     779 </span>            :         static const char16_t NullChar_ = 0;
<span class="lineNum">     780 </span><span class="lineCov">          1 :         if (!get()) {</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :             data_ = &amp;NullChar_;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :             length_ = 0;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :             ownsChars_ = false;</span>
<span class="lineNum">     784 </span>            :         }
<span class="lineNum">     785 </span>            :     }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :     SourceBufferHolder(SourceBufferHolder&amp;&amp; other)
<span class="lineNum">     788 </span>            :       : data_(other.data_),
<span class="lineNum">     789 </span>            :         length_(other.length_),
<span class="lineNum">     790 </span>            :         ownsChars_(other.ownsChars_)
<span class="lineNum">     791 </span>            :     {
<span class="lineNum">     792 </span>            :         other.data_ = nullptr;
<span class="lineNum">     793 </span>            :         other.length_ = 0;
<span class="lineNum">     794 </span>            :         other.ownsChars_ = false;
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     ~SourceBufferHolder() {
<span class="lineNum">     798 </span><span class="lineCov">          1 :         if (ownsChars_)</span>
<span class="lineNum">     799 </span><span class="lineCov">          1 :             js_free(const_cast&lt;char16_t*&gt;(data_));</span>
<span class="lineNum">     800 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :     // Access the underlying source buffer without affecting ownership.
<span class="lineNum">     803 </span>            :     const char16_t* get() const { return data_; }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :     // Length of the source buffer in char16_t code units (not bytes)
<span class="lineNum">     806 </span>            :     size_t length() const { return length_; }
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :     // Returns true if the SourceBufferHolder owns the buffer and will free
<span class="lineNum">     809 </span>            :     // it upon destruction.  If true, it is legal to call take().
<span class="lineNum">     810 </span>            :     bool ownsChars() const { return ownsChars_; }
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :     // Retrieve and take ownership of the underlying data buffer.  The caller
<span class="lineNum">     813 </span>            :     // is now responsible for calling js_free() on the returned value, *but only
<span class="lineNum">     814 </span>            :     // after JS script compilation has completed*.
<span class="lineNum">     815 </span>            :     //
<span class="lineNum">     816 </span>            :     // After the buffer has been taken the SourceBufferHolder functions as if
<span class="lineNum">     817 </span>            :     // it had been constructed on an unowned buffer;  get() and length() still
<span class="lineNum">     818 </span>            :     // work.  In order for this to be safe the taken buffer must be kept alive
<span class="lineNum">     819 </span>            :     // until after JS script compilation completes as noted above.
<span class="lineNum">     820 </span>            :     //
<span class="lineNum">     821 </span>            :     // Note, it's the caller's responsibility to check ownsChars() before taking
<span class="lineNum">     822 </span>            :     // the buffer.  Taking and then free'ing an unowned buffer will have dire
<span class="lineNum">     823 </span>            :     // consequences.
<span class="lineNum">     824 </span>            :     char16_t* take() {
<span class="lineNum">     825 </span>            :         MOZ_ASSERT(ownsChars_);
<span class="lineNum">     826 </span><span class="lineCov">          1 :         ownsChars_ = false;</span>
<span class="lineNum">     827 </span>            :         return const_cast&lt;char16_t*&gt;(data_);
<span class="lineNum">     828 </span>            :     }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            :   private:
<span class="lineNum">     831 </span>            :     SourceBufferHolder(SourceBufferHolder&amp;) = delete;
<span class="lineNum">     832 </span>            :     SourceBufferHolder&amp; operator=(SourceBufferHolder&amp;) = delete;
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :     const char16_t* data_;
<span class="lineNum">     835 </span>            :     size_t length_;
<span class="lineNum">     836 </span>            :     bool ownsChars_;
<span class="lineNum">     837 </span>            : };
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : } /* namespace JS */
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            : /************************************************************************/
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : /* Property attributes, set in JSPropertySpec and passed to API functions.
<span class="lineNum">     844 </span>            :  *
<span class="lineNum">     845 </span>            :  * NB: The data structure in which some of these values are stored only uses
<span class="lineNum">     846 </span>            :  *     a uint8_t to store the relevant information. Proceed with caution if
<span class="lineNum">     847 </span>            :  *     trying to reorder or change the the first byte worth of flags.
<span class="lineNum">     848 </span>            :  */
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : /* property is visible to for/in loop */
<span class="lineNum">     851 </span>            : static const uint8_t JSPROP_ENUMERATE =        0x01;
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : /* not settable: assignment is no-op.  This flag is only valid when neither
<span class="lineNum">     854 </span>            :    JSPROP_GETTER nor JSPROP_SETTER is set. */
<span class="lineNum">     855 </span>            : static const uint8_t JSPROP_READONLY =         0x02;
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : /* property cannot be deleted */
<span class="lineNum">     858 </span>            : static const uint8_t JSPROP_PERMANENT =        0x04;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : /* Passed to JS_Define(UC)Property* and JS_DefineElement if getters/setters are
<span class="lineNum">     861 </span>            :    JSGetterOp/JSSetterOp */
<span class="lineNum">     862 </span>            : static const uint8_t JSPROP_PROPOP_ACCESSORS = 0x08;
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : /* property holds getter function */
<span class="lineNum">     865 </span>            : static const uint8_t JSPROP_GETTER =           0x10;
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            : /* property holds setter function */
<span class="lineNum">     868 </span>            : static const uint8_t JSPROP_SETTER =           0x20;
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            : /* don't allocate a value slot for this property; don't copy the property on set
<span class="lineNum">     871 </span>            :    of the same-named property in an object that delegates to a prototype
<span class="lineNum">     872 </span>            :    containing this property */
<span class="lineNum">     873 </span>            : static const uint8_t JSPROP_SHARED =           0x40;
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            : /* internal JS engine use only */
<span class="lineNum">     876 </span>            : static const uint8_t JSPROP_INTERNAL_USE_BIT = 0x80;
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : /* use JS_PropertyStub getter/setter instead of defaulting to class gsops for
<span class="lineNum">     879 </span>            :    property holding function */
<span class="lineNum">     880 </span>            : static const unsigned JSFUN_STUB_GSOPS =      0x200;
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : /* native that can be called as a ctor */
<span class="lineNum">     883 </span>            : static const unsigned JSFUN_CONSTRUCTOR =     0x400;
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            : /* | of all the JSFUN_* flags */
<span class="lineNum">     886 </span>            : static const unsigned JSFUN_FLAGS_MASK =      0x600;
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : /*
<span class="lineNum">     889 </span>            :  * If set, will allow redefining a non-configurable property, but only on a
<span class="lineNum">     890 </span>            :  * non-DOM global.  This is a temporary hack that will need to go away in bug
<span class="lineNum">     891 </span>            :  * 1105518.
<span class="lineNum">     892 </span>            :  */
<span class="lineNum">     893 </span>            : static const unsigned JSPROP_REDEFINE_NONCONFIGURABLE = 0x1000;
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span>            : /*
<span class="lineNum">     896 </span>            :  * Resolve hooks and enumerate hooks must pass this flag when calling
<span class="lineNum">     897 </span>            :  * JS_Define* APIs to reify lazily-defined properties.
<span class="lineNum">     898 </span>            :  *
<span class="lineNum">     899 </span>            :  * JSPROP_RESOLVING is used only with property-defining APIs. It tells the
<span class="lineNum">     900 </span>            :  * engine to skip the resolve hook when performing the lookup at the beginning
<span class="lineNum">     901 </span>            :  * of property definition. This keeps the resolve hook from accidentally
<span class="lineNum">     902 </span>            :  * triggering itself: unchecked recursion.
<span class="lineNum">     903 </span>            :  *
<span class="lineNum">     904 </span>            :  * For enumerate hooks, triggering the resolve hook would be merely silly, not
<span class="lineNum">     905 </span>            :  * fatal, except in some cases involving non-configurable properties.
<span class="lineNum">     906 </span>            :  */
<span class="lineNum">     907 </span>            : static const unsigned JSPROP_RESOLVING =         0x2000;
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : /* ignore the value in JSPROP_ENUMERATE.  This flag only valid when defining
<span class="lineNum">     910 </span>            :    over an existing property. */
<span class="lineNum">     911 </span>            : static const unsigned JSPROP_IGNORE_ENUMERATE =  0x4000;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : /* ignore the value in JSPROP_READONLY.  This flag only valid when defining over
<span class="lineNum">     914 </span>            :    an existing property. */
<span class="lineNum">     915 </span>            : static const unsigned JSPROP_IGNORE_READONLY =   0x8000;
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            : /* ignore the value in JSPROP_PERMANENT.  This flag only valid when defining
<span class="lineNum">     918 </span>            :    over an existing property. */
<span class="lineNum">     919 </span>            : static const unsigned JSPROP_IGNORE_PERMANENT = 0x10000;
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            : /* ignore the Value in the descriptor. Nothing was specified when passed to
<span class="lineNum">     922 </span>            :    Object.defineProperty from script. */
<span class="lineNum">     923 </span>            : static const unsigned JSPROP_IGNORE_VALUE =     0x20000;
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : /** Microseconds since the epoch, midnight, January 1, 1970 UTC. */
<span class="lineNum">     926 </span>            : extern JS_PUBLIC_API(int64_t)
<span class="lineNum">     927 </span>            : JS_Now(void);
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            : /** Don't want to export data, so provide accessors for non-inline Values. */
<span class="lineNum">     930 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">     931 </span>            : JS_GetNaNValue(JSContext* cx);
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">     934 </span>            : JS_GetNegativeInfinityValue(JSContext* cx);
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">     937 </span>            : JS_GetPositiveInfinityValue(JSContext* cx);
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">     940 </span>            : JS_GetEmptyStringValue(JSContext* cx);
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">     943 </span>            : JS_GetEmptyString(JSContext* cx);
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     946 </span>            : JS_ValueToObject(JSContext* cx, JS::HandleValue v, JS::MutableHandleObject objp);
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">     949 </span>            : JS_ValueToFunction(JSContext* cx, JS::HandleValue v);
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">     952 </span>            : JS_ValueToConstructor(JSContext* cx, JS::HandleValue v);
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">     955 </span>            : JS_ValueToSource(JSContext* cx, JS::Handle&lt;JS::Value&gt; v);
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     958 </span>            : JS_DoubleIsInt32(double d, int32_t* ip);
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            : extern JS_PUBLIC_API(JSType)
<span class="lineNum">     961 </span>            : JS_TypeOfValue(JSContext* cx, JS::Handle&lt;JS::Value&gt; v);
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : namespace JS {
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : extern JS_PUBLIC_API(const char*)
<span class="lineNum">     966 </span>            : InformalValueTypeName(const JS::Value&amp; v);
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            : } /* namespace JS */
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     971 </span>            : JS_StrictlyEqual(JSContext* cx, JS::Handle&lt;JS::Value&gt; v1, JS::Handle&lt;JS::Value&gt; v2, bool* equal);
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     974 </span>            : JS_LooselyEqual(JSContext* cx, JS::Handle&lt;JS::Value&gt; v1, JS::Handle&lt;JS::Value&gt; v2, bool* equal);
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     977 </span>            : JS_SameValue(JSContext* cx, JS::Handle&lt;JS::Value&gt; v1, JS::Handle&lt;JS::Value&gt; v2, bool* same);
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            : /** True iff fun is the global eval function. */
<span class="lineNum">     980 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     981 </span>            : JS_IsBuiltinEvalFunction(JSFunction* fun);
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            : /** True iff fun is the Function constructor. */
<span class="lineNum">     984 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">     985 </span>            : JS_IsBuiltinFunctionConstructor(JSFunction* fun);
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : /************************************************************************/
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            : /*
<span class="lineNum">     990 </span>            :  * Locking, contexts, and memory allocation.
<span class="lineNum">     991 </span>            :  *
<span class="lineNum">     992 </span>            :  * It is important that SpiderMonkey be initialized, and the first context
<span class="lineNum">     993 </span>            :  * be created, in a single-threaded fashion.  Otherwise the behavior of the
<span class="lineNum">     994 </span>            :  * library is undefined.
<span class="lineNum">     995 </span>            :  * See: http://developer.mozilla.org/en/docs/Category:JSAPI_Reference
<span class="lineNum">     996 </span>            :  */
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : // Create a new runtime, with a single cooperative context for this thread.
<span class="lineNum">     999 </span>            : // On success, the new context will be the active context for the runtime.
<span class="lineNum">    1000 </span>            : extern JS_PUBLIC_API(JSContext*)
<span class="lineNum">    1001 </span>            : JS_NewContext(uint32_t maxbytes,
<span class="lineNum">    1002 </span>            :               uint32_t maxNurseryBytes = JS::DefaultNurseryBytes,
<span class="lineNum">    1003 </span>            :               JSRuntime* parentRuntime = nullptr);
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : // The methods below for controlling the active context in a cooperatively
<span class="lineNum">    1006 </span>            : // multithreaded runtime are not threadsafe, and the caller must ensure they
<span class="lineNum">    1007 </span>            : // are called serially if there is a chance for contention between threads.
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : // Called from the active context for a runtime, yield execution so that
<span class="lineNum">    1010 </span>            : // this context is no longer active and can no longer use the API.
<span class="lineNum">    1011 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1012 </span>            : JS_YieldCooperativeContext(JSContext* cx);
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            : // Called from a context whose runtime has no active context, this thread
<span class="lineNum">    1015 </span>            : // becomes the active context for that runtime and may use the API.
<span class="lineNum">    1016 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1017 </span>            : JS_ResumeCooperativeContext(JSContext* cx);
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : // Create a new context on this thread for cooperative multithreading in the
<span class="lineNum">    1020 </span>            : // same runtime as siblingContext. Called on a runtime (as indicated by
<span class="lineNum">    1021 </span>            : // siblingContet) which has no active context, on success the new context will
<span class="lineNum">    1022 </span>            : // become the runtime's active context.
<span class="lineNum">    1023 </span>            : extern JS_PUBLIC_API(JSContext*)
<span class="lineNum">    1024 </span>            : JS_NewCooperativeContext(JSContext* siblingContext);
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : // Destroy a context allocated with JS_NewContext or JS_NewCooperativeContext.
<span class="lineNum">    1027 </span>            : // The context must be the current active context in the runtime, and after
<span class="lineNum">    1028 </span>            : // this call the runtime will have no active context.
<span class="lineNum">    1029 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1030 </span>            : JS_DestroyContext(JSContext* cx);
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            : JS_PUBLIC_API(void*)
<span class="lineNum">    1033 </span>            : JS_GetContextPrivate(JSContext* cx);
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            : JS_PUBLIC_API(void)
<span class="lineNum">    1036 </span>            : JS_SetContextPrivate(JSContext* cx, void* data);
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            : extern JS_PUBLIC_API(JSRuntime*)
<span class="lineNum">    1039 </span>            : JS_GetParentRuntime(JSContext* cx);
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1042 </span>            : JS_BeginRequest(JSContext* cx);
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1045 </span>            : JS_EndRequest(JSContext* cx);
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1048 </span>            : JS_SetFutexCanWait(JSContext* cx);
<span class="lineNum">    1049 </span>            : 
<span class="lineNum">    1050 </span>            : namespace JS {
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            : // Single threaded execution callbacks are used to notify API clients that a
<span class="lineNum">    1053 </span>            : // feature is in use on a context's runtime that is not yet compatible with
<span class="lineNum">    1054 </span>            : // cooperatively multithreaded execution.
<span class="lineNum">    1055 </span>            : //
<span class="lineNum">    1056 </span>            : // Between a call to BeginSingleThreadedExecutionCallback and a corresponding
<span class="lineNum">    1057 </span>            : // call to EndSingleThreadedExecutionCallback, only one thread at a time may
<span class="lineNum">    1058 </span>            : // enter compartments in the runtime. The begin callback may yield as necessary
<span class="lineNum">    1059 </span>            : // to permit other threads to finish up what they're doing, while the end
<span class="lineNum">    1060 </span>            : // callback may not yield or otherwise operate on the runtime (it may be called
<span class="lineNum">    1061 </span>            : // during GC).
<span class="lineNum">    1062 </span>            : //
<span class="lineNum">    1063 </span>            : // These callbacks may be left unspecified for runtimes which only ever have a
<span class="lineNum">    1064 </span>            : // single context.
<span class="lineNum">    1065 </span>            : typedef void (*BeginSingleThreadedExecutionCallback)(JSContext* cx);
<span class="lineNum">    1066 </span>            : typedef void (*EndSingleThreadedExecutionCallback)(JSContext* cx);
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1069 </span>            : SetSingleThreadedExecutionCallbacks(JSContext* cx,
<span class="lineNum">    1070 </span>            :                                     BeginSingleThreadedExecutionCallback begin,
<span class="lineNum">    1071 </span>            :                                     EndSingleThreadedExecutionCallback end);
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            : } // namespace JS
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            : namespace js {
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            : void
<span class="lineNum">    1078 </span>            : AssertHeapIsIdle();
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            : } /* namespace js */
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            : class MOZ_RAII JSAutoRequest
<span class="lineNum">    1083 </span>            : {
<span class="lineNum">    1084 </span>            :   public:
<span class="lineNum">    1085 </span>            :     explicit JSAutoRequest(JSContext* cx
<span class="lineNum">    1086 </span>            :                            MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">    1087 </span><span class="lineCov">          1 :       : mContext(cx)</span>
<span class="lineNum">    1088 </span>            :     {
<span class="lineNum">    1089 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">    1090 </span><span class="lineCov">          1 :         JS_BeginRequest(mContext);</span>
<span class="lineNum">    1091 </span>            :     }
<span class="lineNum">    1092 </span>            :     ~JSAutoRequest() {
<span class="lineNum">    1093 </span><span class="lineCov">          1 :         JS_EndRequest(mContext);</span>
<span class="lineNum">    1094 </span>            :     }
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   protected:
<span class="lineNum">    1097 </span>            :     JSContext* mContext;
<span class="lineNum">    1098 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : #if 0
<span class="lineNum">    1101 </span>            :   private:
<span class="lineNum">    1102 </span>            :     static void* operator new(size_t) CPP_THROW_NEW { return 0; }
<span class="lineNum">    1103 </span>            :     static void operator delete(void*, size_t) { }
<span class="lineNum">    1104 </span>            : #endif
<span class="lineNum">    1105 </span>            : };
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            : extern JS_PUBLIC_API(JSVersion)
<span class="lineNum">    1108 </span>            : JS_GetVersion(JSContext* cx);
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            : /**
<span class="lineNum">    1111 </span>            :  * Mutate the version on the compartment. This is generally discouraged, but
<span class="lineNum">    1112 </span>            :  * necessary to support the version mutation in the js and xpc shell command
<span class="lineNum">    1113 </span>            :  * set.
<span class="lineNum">    1114 </span>            :  *
<span class="lineNum">    1115 </span>            :  * It would be nice to put this in jsfriendapi, but the linkage requirements
<span class="lineNum">    1116 </span>            :  * of the shells make that impossible.
<span class="lineNum">    1117 </span>            :  */
<span class="lineNum">    1118 </span>            : JS_PUBLIC_API(void)
<span class="lineNum">    1119 </span>            : JS_SetVersionForCompartment(JSCompartment* compartment, JSVersion version);
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            : extern JS_PUBLIC_API(const char*)
<span class="lineNum">    1122 </span>            : JS_VersionToString(JSVersion version);
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            : extern JS_PUBLIC_API(JSVersion)
<span class="lineNum">    1125 </span>            : JS_StringToVersion(const char* string);
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            : namespace JS {
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span>            : class JS_PUBLIC_API(ContextOptions) {
<span class="lineNum">    1130 </span>            :   public:
<span class="lineNum">    1131 </span>            :     ContextOptions()
<span class="lineNum">    1132 </span>            :       : baseline_(true),
<span class="lineNum">    1133 </span>            :         ion_(true),
<span class="lineNum">    1134 </span>            :         asmJS_(true),
<span class="lineNum">    1135 </span>            :         wasm_(false),
<span class="lineNum">    1136 </span>            :         wasmAlwaysBaseline_(false),
<span class="lineNum">    1137 </span>            :         throwOnAsmJSValidationFailure_(false),
<span class="lineNum">    1138 </span>            :         nativeRegExp_(true),
<span class="lineNum">    1139 </span>            :         unboxedArrays_(false),
<span class="lineNum">    1140 </span>            :         asyncStack_(true),
<span class="lineNum">    1141 </span>            :         throwOnDebuggeeWouldRun_(true),
<span class="lineNum">    1142 </span>            :         dumpStackOnDebuggeeWouldRun_(false),
<span class="lineNum">    1143 </span>            :         werror_(false),
<span class="lineNum">    1144 </span>            :         strictMode_(false),
<span class="lineNum">    1145 </span>            :         extraWarnings_(false),
<span class="lineNum">    1146 </span>            : #ifdef NIGHTLY_BUILD
<span class="lineNum">    1147 </span><span class="lineCov">          1 :         forEachStatement_(false)</span>
<span class="lineNum">    1148 </span>            : #else
<span class="lineNum">    1149 </span>            :         forEachStatement_(true)
<span class="lineNum">    1150 </span>            : #endif
<span class="lineNum">    1151 </span>            :     {
<span class="lineNum">    1152 </span>            :     }
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineCov">          1 :     bool baseline() const { return baseline_; }</span>
<span class="lineNum">    1155 </span>            :     ContextOptions&amp; setBaseline(bool flag) {
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         baseline_ = flag;</span>
<span class="lineNum">    1157 </span>            :         return *this;
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span>            :     ContextOptions&amp; toggleBaseline() {
<span class="lineNum">    1160 </span>            :         baseline_ = !baseline_;
<span class="lineNum">    1161 </span>            :         return *this;
<span class="lineNum">    1162 </span>            :     }
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span><span class="lineCov">          1 :     bool ion() const { return ion_; }</span>
<span class="lineNum">    1165 </span>            :     ContextOptions&amp; setIon(bool flag) {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         ion_ = flag;</span>
<span class="lineNum">    1167 </span>            :         return *this;
<span class="lineNum">    1168 </span>            :     }
<span class="lineNum">    1169 </span>            :     ContextOptions&amp; toggleIon() {
<span class="lineNum">    1170 </span>            :         ion_ = !ion_;
<span class="lineNum">    1171 </span>            :         return *this;
<span class="lineNum">    1172 </span>            :     }
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineCov">          1 :     bool asmJS() const { return asmJS_; }</span>
<span class="lineNum">    1175 </span>            :     ContextOptions&amp; setAsmJS(bool flag) {
<span class="lineNum">    1176 </span>            :         asmJS_ = flag;
<span class="lineNum">    1177 </span>            :         return *this;
<span class="lineNum">    1178 </span>            :     }
<span class="lineNum">    1179 </span>            :     ContextOptions&amp; toggleAsmJS() {
<span class="lineNum">    1180 </span>            :         asmJS_ = !asmJS_;
<span class="lineNum">    1181 </span>            :         return *this;
<span class="lineNum">    1182 </span>            :     }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">          1 :     bool wasm() const { return wasm_; }</span>
<span class="lineNum">    1185 </span>            :     ContextOptions&amp; setWasm(bool flag) {
<span class="lineNum">    1186 </span>            :         wasm_ = flag;
<span class="lineNum">    1187 </span>            :         return *this;
<span class="lineNum">    1188 </span>            :     }
<span class="lineNum">    1189 </span>            :     ContextOptions&amp; toggleWasm() {
<span class="lineNum">    1190 </span>            :         wasm_ = !wasm_;
<span class="lineNum">    1191 </span>            :         return *this;
<span class="lineNum">    1192 </span>            :     }
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineCov">          1 :     bool wasmAlwaysBaseline() const { return wasmAlwaysBaseline_; }</span>
<span class="lineNum">    1195 </span>            :     ContextOptions&amp; setWasmAlwaysBaseline(bool flag) {
<span class="lineNum">    1196 </span>            :         wasmAlwaysBaseline_ = flag;
<span class="lineNum">    1197 </span>            :         return *this;
<span class="lineNum">    1198 </span>            :     }
<span class="lineNum">    1199 </span>            :     ContextOptions&amp; toggleWasmAlwaysBaseline() {
<span class="lineNum">    1200 </span>            :         wasmAlwaysBaseline_ = !wasmAlwaysBaseline_;
<span class="lineNum">    1201 </span>            :         return *this;
<span class="lineNum">    1202 </span>            :     }
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span><span class="lineCov">          1 :     bool throwOnAsmJSValidationFailure() const { return throwOnAsmJSValidationFailure_; }</span>
<span class="lineNum">    1205 </span>            :     ContextOptions&amp; setThrowOnAsmJSValidationFailure(bool flag) {
<span class="lineNum">    1206 </span>            :         throwOnAsmJSValidationFailure_ = flag;
<span class="lineNum">    1207 </span>            :         return *this;
<span class="lineNum">    1208 </span>            :     }
<span class="lineNum">    1209 </span>            :     ContextOptions&amp; toggleThrowOnAsmJSValidationFailure() {
<span class="lineNum">    1210 </span>            :         throwOnAsmJSValidationFailure_ = !throwOnAsmJSValidationFailure_;
<span class="lineNum">    1211 </span>            :         return *this;
<span class="lineNum">    1212 </span>            :     }
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span><span class="lineCov">          1 :     bool nativeRegExp() const { return nativeRegExp_; }</span>
<span class="lineNum">    1215 </span>            :     ContextOptions&amp; setNativeRegExp(bool flag) {
<span class="lineNum">    1216 </span>            :         nativeRegExp_ = flag;
<span class="lineNum">    1217 </span>            :         return *this;
<span class="lineNum">    1218 </span>            :     }
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineCov">          1 :     bool unboxedArrays() const { return unboxedArrays_; }</span>
<span class="lineNum">    1221 </span>            :     ContextOptions&amp; setUnboxedArrays(bool flag) {
<span class="lineNum">    1222 </span>            :         unboxedArrays_ = flag;
<span class="lineNum">    1223 </span>            :         return *this;
<span class="lineNum">    1224 </span>            :     }
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineCov">          1 :     bool asyncStack() const { return asyncStack_; }</span>
<span class="lineNum">    1227 </span>            :     ContextOptions&amp; setAsyncStack(bool flag) {
<span class="lineNum">    1228 </span>            :         asyncStack_ = flag;
<span class="lineNum">    1229 </span>            :         return *this;
<span class="lineNum">    1230 </span>            :     }
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span><span class="lineCov">          1 :     bool throwOnDebuggeeWouldRun() const { return throwOnDebuggeeWouldRun_; }</span>
<span class="lineNum">    1233 </span>            :     ContextOptions&amp; setThrowOnDebuggeeWouldRun(bool flag) {
<span class="lineNum">    1234 </span>            :         throwOnDebuggeeWouldRun_ = flag;
<span class="lineNum">    1235 </span>            :         return *this;
<span class="lineNum">    1236 </span>            :     }
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span><span class="lineCov">          1 :     bool dumpStackOnDebuggeeWouldRun() const { return dumpStackOnDebuggeeWouldRun_; }</span>
<span class="lineNum">    1239 </span>            :     ContextOptions&amp; setDumpStackOnDebuggeeWouldRun(bool flag) {
<span class="lineNum">    1240 </span>            :         dumpStackOnDebuggeeWouldRun_ = flag;
<span class="lineNum">    1241 </span>            :         return *this;
<span class="lineNum">    1242 </span>            :     }
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineCov">          1 :     bool werror() const { return werror_; }</span>
<span class="lineNum">    1245 </span>            :     ContextOptions&amp; setWerror(bool flag) {
<span class="lineNum">    1246 </span>            :         werror_ = flag;
<span class="lineNum">    1247 </span>            :         return *this;
<span class="lineNum">    1248 </span>            :     }
<span class="lineNum">    1249 </span>            :     ContextOptions&amp; toggleWerror() {
<span class="lineNum">    1250 </span>            :         werror_ = !werror_;
<span class="lineNum">    1251 </span>            :         return *this;
<span class="lineNum">    1252 </span>            :     }
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineCov">          1 :     bool strictMode() const { return strictMode_; }</span>
<span class="lineNum">    1255 </span>            :     ContextOptions&amp; setStrictMode(bool flag) {
<span class="lineNum">    1256 </span>            :         strictMode_ = flag;
<span class="lineNum">    1257 </span>            :         return *this;
<span class="lineNum">    1258 </span>            :     }
<span class="lineNum">    1259 </span>            :     ContextOptions&amp; toggleStrictMode() {
<span class="lineNum">    1260 </span>            :         strictMode_ = !strictMode_;
<span class="lineNum">    1261 </span>            :         return *this;
<span class="lineNum">    1262 </span>            :     }
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineCov">          1 :     bool extraWarnings() const { return extraWarnings_; }</span>
<span class="lineNum">    1265 </span>            :     ContextOptions&amp; setExtraWarnings(bool flag) {
<span class="lineNum">    1266 </span>            :         extraWarnings_ = flag;
<span class="lineNum">    1267 </span>            :         return *this;
<span class="lineNum">    1268 </span>            :     }
<span class="lineNum">    1269 </span>            :     ContextOptions&amp; toggleExtraWarnings() {
<span class="lineNum">    1270 </span>            :         extraWarnings_ = !extraWarnings_;
<span class="lineNum">    1271 </span>            :         return *this;
<span class="lineNum">    1272 </span>            :     }
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span><span class="lineCov">          1 :     bool forEachStatement() const { return forEachStatement_; }</span>
<span class="lineNum">    1275 </span>            :     ContextOptions&amp; setForEachStatement(bool flag) {
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         forEachStatement_ = flag;</span>
<span class="lineNum">    1277 </span>            :         return *this;
<span class="lineNum">    1278 </span>            :     }
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            : #ifdef FUZZING
<span class="lineNum">    1281 </span>            :     bool fuzzing() const { return fuzzing_; }
<span class="lineNum">    1282 </span>            :     ContextOptions&amp; setFuzzing(bool flag) {
<span class="lineNum">    1283 </span>            :         fuzzing_ = flag;
<span class="lineNum">    1284 </span>            :         return *this;
<span class="lineNum">    1285 </span>            :     }
<span class="lineNum">    1286 </span>            : #endif
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :   private:
<span class="lineNum">    1289 </span>            :     bool baseline_ : 1;
<span class="lineNum">    1290 </span>            :     bool ion_ : 1;
<span class="lineNum">    1291 </span>            :     bool asmJS_ : 1;
<span class="lineNum">    1292 </span>            :     bool wasm_ : 1;
<span class="lineNum">    1293 </span>            :     bool wasmAlwaysBaseline_ : 1;
<span class="lineNum">    1294 </span>            :     bool throwOnAsmJSValidationFailure_ : 1;
<span class="lineNum">    1295 </span>            :     bool nativeRegExp_ : 1;
<span class="lineNum">    1296 </span>            :     bool unboxedArrays_ : 1;
<span class="lineNum">    1297 </span>            :     bool asyncStack_ : 1;
<span class="lineNum">    1298 </span>            :     bool throwOnDebuggeeWouldRun_ : 1;
<span class="lineNum">    1299 </span>            :     bool dumpStackOnDebuggeeWouldRun_ : 1;
<span class="lineNum">    1300 </span>            :     bool werror_ : 1;
<span class="lineNum">    1301 </span>            :     bool strictMode_ : 1;
<span class="lineNum">    1302 </span>            :     bool extraWarnings_ : 1;
<span class="lineNum">    1303 </span>            :     bool forEachStatement_: 1;
<span class="lineNum">    1304 </span>            : #ifdef FUZZING
<span class="lineNum">    1305 </span>            :     bool fuzzing_ : 1;
<span class="lineNum">    1306 </span>            : #endif
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span>            : };
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            : JS_PUBLIC_API(ContextOptions&amp;)
<span class="lineNum">    1311 </span>            : ContextOptionsRef(JSContext* cx);
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : /**
<span class="lineNum">    1314 </span>            :  * Initialize the runtime's self-hosted code. Embeddings should call this
<span class="lineNum">    1315 </span>            :  * exactly once per runtime/context, before the first JS_NewGlobalObject
<span class="lineNum">    1316 </span>            :  * call.
<span class="lineNum">    1317 </span>            :  */
<span class="lineNum">    1318 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    1319 </span>            : InitSelfHostedCode(JSContext* cx);
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : /**
<span class="lineNum">    1322 </span>            :  * Asserts (in debug and release builds) that `obj` belongs to the current
<span class="lineNum">    1323 </span>            :  * thread's context.
<span class="lineNum">    1324 </span>            :  */
<span class="lineNum">    1325 </span>            : JS_PUBLIC_API(void)
<span class="lineNum">    1326 </span>            : AssertObjectBelongsToCurrentThread(JSObject* obj);
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            : } /* namespace JS */
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            : extern JS_PUBLIC_API(const char*)
<span class="lineNum">    1331 </span>            : JS_GetImplementationVersion(void);
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1334 </span>            : JS_SetDestroyCompartmentCallback(JSContext* cx, JSDestroyCompartmentCallback callback);
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1337 </span>            : JS_SetSizeOfIncludingThisCompartmentCallback(JSContext* cx,
<span class="lineNum">    1338 </span>            :                                              JSSizeOfIncludingThisCompartmentCallback callback);
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1341 </span>            : JS_SetCompartmentNameCallback(JSContext* cx, JSCompartmentNameCallback callback);
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1344 </span>            : JS_SetWrapObjectCallbacks(JSContext* cx, const JSWrapObjectCallbacks* callbacks);
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1347 </span>            : JS_SetExternalStringSizeofCallback(JSContext* cx, JSExternalStringSizeofCallback callback);
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1350 </span>            : JS_SetCompartmentPrivate(JSCompartment* compartment, void* data);
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    1353 </span>            : JS_GetCompartmentPrivate(JSCompartment* compartment);
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1356 </span>            : JS_SetZoneUserData(JS::Zone* zone, void* data);
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    1359 </span>            : JS_GetZoneUserData(JS::Zone* zone);
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1362 </span>            : JS_WrapObject(JSContext* cx, JS::MutableHandleObject objp);
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1365 </span>            : JS_WrapValue(JSContext* cx, JS::MutableHandleValue vp);
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1368 </span>            : JS_TransplantObject(JSContext* cx, JS::HandleObject origobj, JS::HandleObject target);
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1371 </span>            : JS_RefreshCrossCompartmentWrappers(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj);
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            : /*
<span class="lineNum">    1374 </span>            :  * At any time, a JSContext has a current (possibly-nullptr) compartment.
<span class="lineNum">    1375 </span>            :  * Compartments are described in:
<span class="lineNum">    1376 </span>            :  *
<span class="lineNum">    1377 </span>            :  *   developer.mozilla.org/en-US/docs/SpiderMonkey/SpiderMonkey_compartments
<span class="lineNum">    1378 </span>            :  *
<span class="lineNum">    1379 </span>            :  * The current compartment of a context may be changed. The preferred way to do
<span class="lineNum">    1380 </span>            :  * this is with JSAutoCompartment:
<span class="lineNum">    1381 </span>            :  *
<span class="lineNum">    1382 </span>            :  *   void foo(JSContext* cx, JSObject* obj) {
<span class="lineNum">    1383 </span>            :  *     // in some compartment 'c'
<span class="lineNum">    1384 </span>            :  *     {
<span class="lineNum">    1385 </span>            :  *       JSAutoCompartment ac(cx, obj);  // constructor enters
<span class="lineNum">    1386 </span>            :  *       // in the compartment of 'obj'
<span class="lineNum">    1387 </span>            :  *     }                                 // destructor leaves
<span class="lineNum">    1388 </span>            :  *     // back in compartment 'c'
<span class="lineNum">    1389 </span>            :  *   }
<span class="lineNum">    1390 </span>            :  *
<span class="lineNum">    1391 </span>            :  * For more complicated uses that don't neatly fit in a C++ stack frame, the
<span class="lineNum">    1392 </span>            :  * compartment can entered and left using separate function calls:
<span class="lineNum">    1393 </span>            :  *
<span class="lineNum">    1394 </span>            :  *   void foo(JSContext* cx, JSObject* obj) {
<span class="lineNum">    1395 </span>            :  *     // in 'oldCompartment'
<span class="lineNum">    1396 </span>            :  *     JSCompartment* oldCompartment = JS_EnterCompartment(cx, obj);
<span class="lineNum">    1397 </span>            :  *     // in the compartment of 'obj'
<span class="lineNum">    1398 </span>            :  *     JS_LeaveCompartment(cx, oldCompartment);
<span class="lineNum">    1399 </span>            :  *     // back in 'oldCompartment'
<span class="lineNum">    1400 </span>            :  *   }
<span class="lineNum">    1401 </span>            :  *
<span class="lineNum">    1402 </span>            :  * Note: these calls must still execute in a LIFO manner w.r.t all other
<span class="lineNum">    1403 </span>            :  * enter/leave calls on the context. Furthermore, only the return value of a
<span class="lineNum">    1404 </span>            :  * JS_EnterCompartment call may be passed as the 'oldCompartment' argument of
<span class="lineNum">    1405 </span>            :  * the corresponding JS_LeaveCompartment call.
<span class="lineNum">    1406 </span>            :  */
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            : class MOZ_RAII JS_PUBLIC_API(JSAutoCompartment)
<span class="lineNum">    1409 </span>            : {
<span class="lineNum">    1410 </span>            :     JSContext* cx_;
<span class="lineNum">    1411 </span>            :     JSCompartment* oldCompartment_;
<span class="lineNum">    1412 </span>            :   public:
<span class="lineNum">    1413 </span>            :     JSAutoCompartment(JSContext* cx, JSObject* target
<span class="lineNum">    1414 </span>            :                       MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
<span class="lineNum">    1415 </span>            :     JSAutoCompartment(JSContext* cx, JSScript* target
<span class="lineNum">    1416 </span>            :                       MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
<span class="lineNum">    1417 </span>            :     ~JSAutoCompartment();
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    1420 </span>            : };
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            : class MOZ_RAII JS_PUBLIC_API(JSAutoNullableCompartment)
<span class="lineNum">    1423 </span>            : {
<span class="lineNum">    1424 </span>            :     JSContext* cx_;
<span class="lineNum">    1425 </span>            :     JSCompartment* oldCompartment_;
<span class="lineNum">    1426 </span>            :   public:
<span class="lineNum">    1427 </span>            :     explicit JSAutoNullableCompartment(JSContext* cx, JSObject* targetOrNull
<span class="lineNum">    1428 </span>            :                                        MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
<span class="lineNum">    1429 </span>            :     ~JSAutoNullableCompartment();
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    1432 </span>            : };
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            : /** NB: This API is infallible; a nullptr return value does not indicate error. */
<span class="lineNum">    1435 </span>            : extern JS_PUBLIC_API(JSCompartment*)
<span class="lineNum">    1436 </span>            : JS_EnterCompartment(JSContext* cx, JSObject* target);
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1439 </span>            : JS_LeaveCompartment(JSContext* cx, JSCompartment* oldCompartment);
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            : typedef void (*JSIterateCompartmentCallback)(JSContext* cx, void* data, JSCompartment* compartment);
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            : /**
<span class="lineNum">    1444 </span>            :  * This function calls |compartmentCallback| on every compartment. Beware that
<span class="lineNum">    1445 </span>            :  * there is no guarantee that the compartment will survive after the callback
<span class="lineNum">    1446 </span>            :  * returns. Also, barriers are disabled via the TraceSession.
<span class="lineNum">    1447 </span>            :  */
<span class="lineNum">    1448 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1449 </span>            : JS_IterateCompartments(JSContext* cx, void* data,
<span class="lineNum">    1450 </span>            :                        JSIterateCompartmentCallback compartmentCallback);
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : /**
<span class="lineNum">    1453 </span>            :  * Mark a jsid after entering a new compartment. Different zones separately
<span class="lineNum">    1454 </span>            :  * mark the ids in a runtime, and this must be used any time an id is obtained
<span class="lineNum">    1455 </span>            :  * from one compartment and then used in another compartment, unless the two
<span class="lineNum">    1456 </span>            :  * compartments are guaranteed to be in the same zone.
<span class="lineNum">    1457 </span>            :  */
<span class="lineNum">    1458 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1459 </span>            : JS_MarkCrossZoneId(JSContext* cx, jsid id);
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span>            : /**
<span class="lineNum">    1462 </span>            :  * If value stores a jsid (an atomized string or symbol), mark that id as for
<span class="lineNum">    1463 </span>            :  * JS_MarkCrossZoneId.
<span class="lineNum">    1464 </span>            :  */
<span class="lineNum">    1465 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1466 </span>            : JS_MarkCrossZoneIdValue(JSContext* cx, const JS::Value&amp; value);
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            : /**
<span class="lineNum">    1469 </span>            :  * Initialize standard JS class constructors, prototypes, and any top-level
<span class="lineNum">    1470 </span>            :  * functions and constants associated with the standard classes (e.g. isNaN
<span class="lineNum">    1471 </span>            :  * for Number).
<span class="lineNum">    1472 </span>            :  *
<span class="lineNum">    1473 </span>            :  * NB: This sets cx's global object to obj if it was null.
<span class="lineNum">    1474 </span>            :  */
<span class="lineNum">    1475 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1476 </span>            : JS_InitStandardClasses(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj);
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span>            : /**
<span class="lineNum">    1479 </span>            :  * Resolve id, which must contain either a string or an int, to a standard
<span class="lineNum">    1480 </span>            :  * class name in obj if possible, defining the class's constructor and/or
<span class="lineNum">    1481 </span>            :  * prototype and storing true in *resolved.  If id does not name a standard
<span class="lineNum">    1482 </span>            :  * class or a top-level property induced by initializing a standard class,
<span class="lineNum">    1483 </span>            :  * store false in *resolved and just return true.  Return false on error,
<span class="lineNum">    1484 </span>            :  * as usual for bool result-typed API entry points.
<span class="lineNum">    1485 </span>            :  *
<span class="lineNum">    1486 </span>            :  * This API can be called directly from a global object class's resolve op,
<span class="lineNum">    1487 </span>            :  * to define standard classes lazily.  The class's enumerate op should call
<span class="lineNum">    1488 </span>            :  * JS_EnumerateStandardClasses(cx, obj), to define eagerly during for..in
<span class="lineNum">    1489 </span>            :  * loops any classes not yet resolved lazily.
<span class="lineNum">    1490 </span>            :  */
<span class="lineNum">    1491 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1492 </span>            : JS_ResolveStandardClass(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* resolved);
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1495 </span>            : JS_MayResolveStandardClass(const JSAtomState&amp; names, jsid id, JSObject* maybeObj);
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1498 </span>            : JS_EnumerateStandardClasses(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1501 </span>            : JS_GetClassObject(JSContext* cx, JSProtoKey key, JS::MutableHandle&lt;JSObject*&gt; objp);
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1504 </span>            : JS_GetClassPrototype(JSContext* cx, JSProtoKey key, JS::MutableHandle&lt;JSObject*&gt; objp);
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span>            : namespace JS {
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            : /*
<span class="lineNum">    1509 </span>            :  * Determine if the given object is an instance/prototype/constructor for a standard
<span class="lineNum">    1510 </span>            :  * class. If so, return the associated JSProtoKey. If not, return JSProto_Null.
<span class="lineNum">    1511 </span>            :  */
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : extern JS_PUBLIC_API(JSProtoKey)
<span class="lineNum">    1514 </span>            : IdentifyStandardInstance(JSObject* obj);
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            : extern JS_PUBLIC_API(JSProtoKey)
<span class="lineNum">    1517 </span>            : IdentifyStandardPrototype(JSObject* obj);
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            : extern JS_PUBLIC_API(JSProtoKey)
<span class="lineNum">    1520 </span>            : IdentifyStandardInstanceOrPrototype(JSObject* obj);
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span>            : extern JS_PUBLIC_API(JSProtoKey)
<span class="lineNum">    1523 </span>            : IdentifyStandardConstructor(JSObject* obj);
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1526 </span>            : ProtoKeyToId(JSContext* cx, JSProtoKey key, JS::MutableHandleId idp);
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            : } /* namespace JS */
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            : extern JS_PUBLIC_API(JSProtoKey)
<span class="lineNum">    1531 </span>            : JS_IdToProtoKey(JSContext* cx, JS::HandleId id);
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            : /**
<span class="lineNum">    1534 </span>            :  * Returns the original value of |Function.prototype| from the global object in
<span class="lineNum">    1535 </span>            :  * which |forObj| was created.
<span class="lineNum">    1536 </span>            :  */
<span class="lineNum">    1537 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1538 </span>            : JS_GetFunctionPrototype(JSContext* cx, JS::HandleObject forObj);
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            : /**
<span class="lineNum">    1541 </span>            :  * Returns the original value of |Object.prototype| from the global object in
<span class="lineNum">    1542 </span>            :  * which |forObj| was created.
<span class="lineNum">    1543 </span>            :  */
<span class="lineNum">    1544 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1545 </span>            : JS_GetObjectPrototype(JSContext* cx, JS::HandleObject forObj);
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : /**
<span class="lineNum">    1548 </span>            :  * Returns the original value of |Array.prototype| from the global object in
<span class="lineNum">    1549 </span>            :  * which |forObj| was created.
<span class="lineNum">    1550 </span>            :  */
<span class="lineNum">    1551 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1552 </span>            : JS_GetArrayPrototype(JSContext* cx, JS::HandleObject forObj);
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            : /**
<span class="lineNum">    1555 </span>            :  * Returns the original value of |Error.prototype| from the global
<span class="lineNum">    1556 </span>            :  * object of the current compartment of cx.
<span class="lineNum">    1557 </span>            :  */
<span class="lineNum">    1558 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1559 </span>            : JS_GetErrorPrototype(JSContext* cx);
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            : /**
<span class="lineNum">    1562 </span>            :  * Returns the %IteratorPrototype% object that all built-in iterator prototype
<span class="lineNum">    1563 </span>            :  * chains go through for the global object of the current compartment of cx.
<span class="lineNum">    1564 </span>            :  */
<span class="lineNum">    1565 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1566 </span>            : JS_GetIteratorPrototype(JSContext* cx);
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1569 </span>            : JS_GetGlobalForObject(JSContext* cx, JSObject* obj);
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1572 </span>            : JS_IsGlobalObject(JSObject* obj);
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1575 </span>            : JS_GlobalLexicalEnvironment(JSObject* obj);
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1578 </span>            : JS_HasExtensibleLexicalEnvironment(JSObject* obj);
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1581 </span>            : JS_ExtensibleLexicalEnvironment(JSObject* obj);
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span>            : /**
<span class="lineNum">    1584 </span>            :  * May return nullptr, if |c| never had a global (e.g. the atoms compartment),
<span class="lineNum">    1585 </span>            :  * or if |c|'s global has been collected.
<span class="lineNum">    1586 </span>            :  */
<span class="lineNum">    1587 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1588 </span>            : JS_GetGlobalForCompartmentOrNull(JSContext* cx, JSCompartment* c);
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            : namespace JS {
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    1593 </span>            : CurrentGlobalOrNull(JSContext* cx);
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            : } // namespace JS
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span>            : /**
<span class="lineNum">    1598 </span>            :  * Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
<span class="lineNum">    1599 </span>            :  * given global.
<span class="lineNum">    1600 </span>            :  */
<span class="lineNum">    1601 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1602 </span>            : JS_InitReflectParse(JSContext* cx, JS::HandleObject global);
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span>            : /**
<span class="lineNum">    1605 </span>            :  * Add various profiling-related functions as properties of the given object.
<span class="lineNum">    1606 </span>            :  * Defined in builtin/Profilers.cpp.
<span class="lineNum">    1607 </span>            :  */
<span class="lineNum">    1608 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1609 </span>            : JS_DefineProfilingFunctions(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            : /* Defined in vm/Debugger.cpp. */
<span class="lineNum">    1612 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1613 </span>            : JS_DefineDebuggerObject(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            : #ifdef JS_HAS_CTYPES
<span class="lineNum">    1616 </span>            : /**
<span class="lineNum">    1617 </span>            :  * Initialize the 'ctypes' object on a global variable 'obj'. The 'ctypes'
<span class="lineNum">    1618 </span>            :  * object will be sealed.
<span class="lineNum">    1619 </span>            :  */
<span class="lineNum">    1620 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1621 </span>            : JS_InitCTypesClass(JSContext* cx, JS::HandleObject global);
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span>            : /**
<span class="lineNum">    1624 </span>            :  * Convert a unicode string 'source' of length 'slen' to the platform native
<span class="lineNum">    1625 </span>            :  * charset, returning a null-terminated string allocated with JS_malloc. On
<span class="lineNum">    1626 </span>            :  * failure, this function should report an error.
<span class="lineNum">    1627 </span>            :  */
<span class="lineNum">    1628 </span>            : typedef char*
<span class="lineNum">    1629 </span>            : (* JSCTypesUnicodeToNativeFun)(JSContext* cx, const char16_t* source, size_t slen);
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            : /**
<span class="lineNum">    1632 </span>            :  * Set of function pointers that ctypes can use for various internal functions.
<span class="lineNum">    1633 </span>            :  * See JS_SetCTypesCallbacks below. Providing nullptr for a function is safe,
<span class="lineNum">    1634 </span>            :  * and will result in the applicable ctypes functionality not being available.
<span class="lineNum">    1635 </span>            :  */
<span class="lineNum">    1636 </span>            : struct JSCTypesCallbacks {
<span class="lineNum">    1637 </span>            :     JSCTypesUnicodeToNativeFun unicodeToNative;
<span class="lineNum">    1638 </span>            : };
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            : /**
<span class="lineNum">    1641 </span>            :  * Set the callbacks on the provided 'ctypesObj' object. 'callbacks' should be a
<span class="lineNum">    1642 </span>            :  * pointer to static data that exists for the lifetime of 'ctypesObj', but it
<span class="lineNum">    1643 </span>            :  * may safely be altered after calling this function and without having
<span class="lineNum">    1644 </span>            :  * to call this function again.
<span class="lineNum">    1645 </span>            :  */
<span class="lineNum">    1646 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1647 </span>            : JS_SetCTypesCallbacks(JSObject* ctypesObj, const JSCTypesCallbacks* callbacks);
<span class="lineNum">    1648 </span>            : #endif
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    1651 </span>            : JS_malloc(JSContext* cx, size_t nbytes);
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    1654 </span>            : JS_realloc(JSContext* cx, void* p, size_t oldBytes, size_t newBytes);
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span>            : /**
<span class="lineNum">    1657 </span>            :  * A wrapper for js_free(p) that may delay js_free(p) invocation as a
<span class="lineNum">    1658 </span>            :  * performance optimization.
<span class="lineNum">    1659 </span>            :  * cx may be nullptr.
<span class="lineNum">    1660 </span>            :  */
<span class="lineNum">    1661 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1662 </span>            : JS_free(JSContext* cx, void* p);
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span>            : /**
<span class="lineNum">    1665 </span>            :  * A wrapper for js_free(p) that may delay js_free(p) invocation as a
<span class="lineNum">    1666 </span>            :  * performance optimization as specified by the given JSFreeOp instance.
<span class="lineNum">    1667 </span>            :  */
<span class="lineNum">    1668 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1669 </span>            : JS_freeop(JSFreeOp* fop, void* p);
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1672 </span>            : JS_updateMallocCounter(JSContext* cx, size_t nbytes);
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            : extern JS_PUBLIC_API(char*)
<span class="lineNum">    1675 </span>            : JS_strdup(JSContext* cx, const char* s);
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            : /**
<span class="lineNum">    1678 </span>            :  * Register externally maintained GC roots.
<span class="lineNum">    1679 </span>            :  *
<span class="lineNum">    1680 </span>            :  * traceOp: the trace operation. For each root the implementation should call
<span class="lineNum">    1681 </span>            :  *          JS::TraceEdge whenever the root contains a traceable thing.
<span class="lineNum">    1682 </span>            :  * data:    the data argument to pass to each invocation of traceOp.
<span class="lineNum">    1683 </span>            :  */
<span class="lineNum">    1684 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1685 </span>            : JS_AddExtraGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span>            : /** Undo a call to JS_AddExtraGCRootsTracer. */
<span class="lineNum">    1688 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1689 </span>            : JS_RemoveExtraGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            : /*
<span class="lineNum">    1692 </span>            :  * Garbage collector API.
<span class="lineNum">    1693 </span>            :  */
<span class="lineNum">    1694 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1695 </span>            : JS_GC(JSContext* cx);
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1698 </span>            : JS_MaybeGC(JSContext* cx);
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1701 </span>            : JS_SetGCCallback(JSContext* cx, JSGCCallback cb, void* data);
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1704 </span>            : JS_SetObjectsTenuredCallback(JSContext* cx, JSObjectsTenuredCallback cb,
<span class="lineNum">    1705 </span>            :                              void* data);
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1708 </span>            : JS_AddFinalizeCallback(JSContext* cx, JSFinalizeCallback cb, void* data);
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1711 </span>            : JS_RemoveFinalizeCallback(JSContext* cx, JSFinalizeCallback cb);
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            : /*
<span class="lineNum">    1714 </span>            :  * Weak pointers and garbage collection
<span class="lineNum">    1715 </span>            :  *
<span class="lineNum">    1716 </span>            :  * Weak pointers are by their nature not marked as part of garbage collection,
<span class="lineNum">    1717 </span>            :  * but they may need to be updated in two cases after a GC:
<span class="lineNum">    1718 </span>            :  *
<span class="lineNum">    1719 </span>            :  *  1) Their referent was found not to be live and is about to be finalized
<span class="lineNum">    1720 </span>            :  *  2) Their referent has been moved by a compacting GC
<span class="lineNum">    1721 </span>            :  *
<span class="lineNum">    1722 </span>            :  * To handle this, any part of the system that maintain weak pointers to
<span class="lineNum">    1723 </span>            :  * JavaScript GC things must register a callback with
<span class="lineNum">    1724 </span>            :  * JS_(Add,Remove)WeakPointer{ZoneGroup,Compartment}Callback(). This callback
<span class="lineNum">    1725 </span>            :  * must then call JS_UpdateWeakPointerAfterGC() on all weak pointers it knows
<span class="lineNum">    1726 </span>            :  * about.
<span class="lineNum">    1727 </span>            :  *
<span class="lineNum">    1728 </span>            :  * Since sweeping is incremental, we have several callbacks to avoid repeatedly
<span class="lineNum">    1729 </span>            :  * having to visit all embedder structures. The WeakPointerZonesCallback is
<span class="lineNum">    1730 </span>            :  * called once for each strongly connected group of zones, whereas the
<span class="lineNum">    1731 </span>            :  * WeakPointerCompartmentCallback is called once for each compartment that is
<span class="lineNum">    1732 </span>            :  * visited while sweeping. Structures that cannot contain references in more
<span class="lineNum">    1733 </span>            :  * than one compartment should sweep the relevant per-compartment structures
<span class="lineNum">    1734 </span>            :  * using the latter callback to minimizer per-slice overhead.
<span class="lineNum">    1735 </span>            :  *
<span class="lineNum">    1736 </span>            :  * The argument to JS_UpdateWeakPointerAfterGC() is an in-out param. If the
<span class="lineNum">    1737 </span>            :  * referent is about to be finalized the pointer will be set to null. If the
<span class="lineNum">    1738 </span>            :  * referent has been moved then the pointer will be updated to point to the new
<span class="lineNum">    1739 </span>            :  * location.
<span class="lineNum">    1740 </span>            :  *
<span class="lineNum">    1741 </span>            :  * Callers of this method are responsible for updating any state that is
<span class="lineNum">    1742 </span>            :  * dependent on the object's address. For example, if the object's address is
<span class="lineNum">    1743 </span>            :  * used as a key in a hashtable, then the object must be removed and
<span class="lineNum">    1744 </span>            :  * re-inserted with the correct hash.
<span class="lineNum">    1745 </span>            :  */
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1748 </span>            : JS_AddWeakPointerZonesCallback(JSContext* cx, JSWeakPointerZonesCallback cb, void* data);
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1751 </span>            : JS_RemoveWeakPointerZonesCallback(JSContext* cx, JSWeakPointerZonesCallback cb);
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1754 </span>            : JS_AddWeakPointerCompartmentCallback(JSContext* cx, JSWeakPointerCompartmentCallback cb,
<span class="lineNum">    1755 </span>            :                                      void* data);
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1758 </span>            : JS_RemoveWeakPointerCompartmentCallback(JSContext* cx, JSWeakPointerCompartmentCallback cb);
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1761 </span>            : JS_UpdateWeakPointerAfterGC(JS::Heap&lt;JSObject*&gt;* objp);
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1764 </span>            : JS_UpdateWeakPointerAfterGCUnbarriered(JSObject** objp);
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            : typedef enum JSGCParamKey {
<span class="lineNum">    1767 </span>            :     /** Maximum nominal heap before last ditch GC. */
<span class="lineNum">    1768 </span>            :     JSGC_MAX_BYTES          = 0,
<span class="lineNum">    1769 </span>            : 
<span class="lineNum">    1770 </span>            :     /** Number of JS_malloc bytes before last ditch GC. */
<span class="lineNum">    1771 </span>            :     JSGC_MAX_MALLOC_BYTES   = 1,
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :     /** Maximum size of the generational GC nurseries. */
<span class="lineNum">    1774 </span>            :     JSGC_MAX_NURSERY_BYTES  = 2,
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :     /** Amount of bytes allocated by the GC. */
<span class="lineNum">    1777 </span>            :     JSGC_BYTES = 3,
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span>            :     /** Number of times GC has been invoked. Includes both major and minor GC. */
<span class="lineNum">    1780 </span>            :     JSGC_NUMBER = 4,
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            :     /** Select GC mode. */
<span class="lineNum">    1783 </span>            :     JSGC_MODE = 6,
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span>            :     /** Number of cached empty GC chunks. */
<span class="lineNum">    1786 </span>            :     JSGC_UNUSED_CHUNKS = 7,
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span>            :     /** Total number of allocated GC chunks. */
<span class="lineNum">    1789 </span>            :     JSGC_TOTAL_CHUNKS = 8,
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :     /** Max milliseconds to spend in an incremental GC slice. */
<span class="lineNum">    1792 </span>            :     JSGC_SLICE_TIME_BUDGET = 9,
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span>            :     /** Maximum size the GC mark stack can grow to. */
<span class="lineNum">    1795 </span>            :     JSGC_MARK_STACK_LIMIT = 10,
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span>            :     /**
<span class="lineNum">    1798 </span>            :      * GCs less than this far apart in time will be considered 'high-frequency GCs'.
<span class="lineNum">    1799 </span>            :      * See setGCLastBytes in jsgc.cpp.
<span class="lineNum">    1800 </span>            :      */
<span class="lineNum">    1801 </span>            :     JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
<span class="lineNum">    1802 </span>            : 
<span class="lineNum">    1803 </span>            :     /** Start of dynamic heap growth. */
<span class="lineNum">    1804 </span>            :     JSGC_HIGH_FREQUENCY_LOW_LIMIT = 12,
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span>            :     /** End of dynamic heap growth. */
<span class="lineNum">    1807 </span>            :     JSGC_HIGH_FREQUENCY_HIGH_LIMIT = 13,
<span class="lineNum">    1808 </span>            : 
<span class="lineNum">    1809 </span>            :     /** Upper bound of heap growth. */
<span class="lineNum">    1810 </span>            :     JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX = 14,
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span>            :     /** Lower bound of heap growth. */
<span class="lineNum">    1813 </span>            :     JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN = 15,
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            :     /** Heap growth for low frequency GCs. */
<span class="lineNum">    1816 </span>            :     JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span>            :     /**
<span class="lineNum">    1819 </span>            :      * If false, the heap growth factor is fixed at 3. If true, it is determined
<span class="lineNum">    1820 </span>            :      * based on whether GCs are high- or low- frequency.
<span class="lineNum">    1821 </span>            :      */
<span class="lineNum">    1822 </span>            :     JSGC_DYNAMIC_HEAP_GROWTH = 17,
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :     /** If true, high-frequency GCs will use a longer mark slice. */
<span class="lineNum">    1825 </span>            :     JSGC_DYNAMIC_MARK_SLICE = 18,
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            :     /** Lower limit after which we limit the heap growth. */
<span class="lineNum">    1828 </span>            :     JSGC_ALLOCATION_THRESHOLD = 19,
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            :     /**
<span class="lineNum">    1831 </span>            :      * We try to keep at least this many unused chunks in the free chunk pool at
<span class="lineNum">    1832 </span>            :      * all times, even after a shrinking GC.
<span class="lineNum">    1833 </span>            :      */
<span class="lineNum">    1834 </span>            :     JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            :     /** We never keep more than this many unused chunks in the free chunk pool. */
<span class="lineNum">    1837 </span>            :     JSGC_MAX_EMPTY_CHUNK_COUNT = 22,
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span>            :     /** Whether compacting GC is enabled. */
<span class="lineNum">    1840 </span>            :     JSGC_COMPACTING_ENABLED = 23,
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span>            :     /** If true, painting can trigger IGC slices. */
<span class="lineNum">    1843 </span>            :     JSGC_REFRESH_FRAME_SLICES_ENABLED = 24,
<span class="lineNum">    1844 </span>            : } JSGCParamKey;
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1847 </span>            : JS_SetGCParameter(JSContext* cx, JSGCParamKey key, uint32_t value);
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            : extern JS_PUBLIC_API(uint32_t)
<span class="lineNum">    1850 </span>            : JS_GetGCParameter(JSContext* cx, JSGCParamKey key);
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1853 </span>            : JS_SetGCParametersBasedOnAvailableMemory(JSContext* cx, uint32_t availMem);
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            : /**
<span class="lineNum">    1856 </span>            :  * Create a new JSString whose chars member refers to external memory, i.e.,
<span class="lineNum">    1857 </span>            :  * memory requiring application-specific finalization.
<span class="lineNum">    1858 </span>            :  */
<span class="lineNum">    1859 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    1860 </span>            : JS_NewExternalString(JSContext* cx, const char16_t* chars, size_t length,
<span class="lineNum">    1861 </span>            :                      const JSStringFinalizer* fin);
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : /**
<span class="lineNum">    1864 </span>            :  * Create a new JSString whose chars member may refer to external memory.
<span class="lineNum">    1865 </span>            :  * If a new external string is allocated, |*allocatedExternal| is set to true.
<span class="lineNum">    1866 </span>            :  * Otherwise the returned string is either not an external string or an
<span class="lineNum">    1867 </span>            :  * external string allocated by a previous call and |*allocatedExternal| is set
<span class="lineNum">    1868 </span>            :  * to false. If |*allocatedExternal| is false, |fin| won't be called.
<span class="lineNum">    1869 </span>            :  */
<span class="lineNum">    1870 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    1871 </span>            : JS_NewMaybeExternalString(JSContext* cx, const char16_t* chars, size_t length,
<span class="lineNum">    1872 </span>            :                           const JSStringFinalizer* fin, bool* allocatedExternal);
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span>            : /**
<span class="lineNum">    1875 </span>            :  * Return whether 'str' was created with JS_NewExternalString or
<span class="lineNum">    1876 </span>            :  * JS_NewExternalStringWithClosure.
<span class="lineNum">    1877 </span>            :  */
<span class="lineNum">    1878 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1879 </span>            : JS_IsExternalString(JSString* str);
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            : /**
<span class="lineNum">    1882 </span>            :  * Return the 'fin' arg passed to JS_NewExternalString.
<span class="lineNum">    1883 </span>            :  */
<span class="lineNum">    1884 </span>            : extern JS_PUBLIC_API(const JSStringFinalizer*)
<span class="lineNum">    1885 </span>            : JS_GetExternalStringFinalizer(JSString* str);
<span class="lineNum">    1886 </span>            : 
<span class="lineNum">    1887 </span>            : /**
<span class="lineNum">    1888 </span>            :  * Set the size of the native stack that should not be exceed. To disable
<span class="lineNum">    1889 </span>            :  * stack size checking pass 0.
<span class="lineNum">    1890 </span>            :  *
<span class="lineNum">    1891 </span>            :  * SpiderMonkey allows for a distinction between system code (such as GCs, which
<span class="lineNum">    1892 </span>            :  * may incidentally be triggered by script but are not strictly performed on
<span class="lineNum">    1893 </span>            :  * behalf of such script), trusted script (as determined by JS_SetTrustedPrincipals),
<span class="lineNum">    1894 </span>            :  * and untrusted script. Each kind of code may have a different stack quota,
<span class="lineNum">    1895 </span>            :  * allowing embedders to keep higher-priority machinery running in the face of
<span class="lineNum">    1896 </span>            :  * scripted stack exhaustion by something else.
<span class="lineNum">    1897 </span>            :  *
<span class="lineNum">    1898 </span>            :  * The stack quotas for each kind of code should be monotonically descending,
<span class="lineNum">    1899 </span>            :  * and may be specified with this function. If 0 is passed for a given kind
<span class="lineNum">    1900 </span>            :  * of code, it defaults to the value of the next-highest-priority kind.
<span class="lineNum">    1901 </span>            :  *
<span class="lineNum">    1902 </span>            :  * This function may only be called immediately after the runtime is initialized
<span class="lineNum">    1903 </span>            :  * and before any code is executed and/or interrupts requested.
<span class="lineNum">    1904 </span>            :  */
<span class="lineNum">    1905 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    1906 </span>            : JS_SetNativeStackQuota(JSContext* cx, size_t systemCodeStackSize,
<span class="lineNum">    1907 </span>            :                        size_t trustedScriptStackSize = 0,
<span class="lineNum">    1908 </span>            :                        size_t untrustedScriptStackSize = 0);
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span>            : /************************************************************************/
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1913 </span>            : JS_ValueToId(JSContext* cx, JS::HandleValue v, JS::MutableHandleId idp);
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1916 </span>            : JS_StringToId(JSContext* cx, JS::HandleString s, JS::MutableHandleId idp);
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1919 </span>            : JS_IdToValue(JSContext* cx, jsid id, JS::MutableHandle&lt;JS::Value&gt; vp);
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span>            : namespace JS {
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            : /**
<span class="lineNum">    1924 </span>            :  * Convert obj to a primitive value. On success, store the result in vp and
<span class="lineNum">    1925 </span>            :  * return true.
<span class="lineNum">    1926 </span>            :  *
<span class="lineNum">    1927 </span>            :  * The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or
<span class="lineNum">    1928 </span>            :  * JSTYPE_UNDEFINED (no hint).
<span class="lineNum">    1929 </span>            :  *
<span class="lineNum">    1930 </span>            :  * Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType]).
<span class="lineNum">    1931 </span>            :  */
<span class="lineNum">    1932 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1933 </span>            : ToPrimitive(JSContext* cx, JS::HandleObject obj, JSType hint, JS::MutableHandleValue vp);
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span>            : /**
<span class="lineNum">    1936 </span>            :  * If args.get(0) is one of the strings &quot;string&quot;, &quot;number&quot;, or &quot;default&quot;, set
<span class="lineNum">    1937 </span>            :  * result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_UNDEFINED accordingly and
<span class="lineNum">    1938 </span>            :  * return true. Otherwise, return false with a TypeError pending.
<span class="lineNum">    1939 </span>            :  *
<span class="lineNum">    1940 </span>            :  * This can be useful in implementing a @@toPrimitive method.
<span class="lineNum">    1941 </span>            :  */
<span class="lineNum">    1942 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1943 </span>            : GetFirstArgumentAsTypeHint(JSContext* cx, CallArgs args, JSType *result);
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span>            : } /* namespace JS */
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1948 </span>            : JS_PropertyStub(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    1949 </span>            :                 JS::MutableHandleValue vp);
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    1952 </span>            : JS_StrictPropertyStub(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    1953 </span>            :                       JS::MutableHandleValue vp, JS::ObjectOpResult&amp; result);
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span>            : template&lt;typename T&gt;
<span class="lineNum">    1956 </span>            : struct JSConstScalarSpec {
<span class="lineNum">    1957 </span>            :     const char* name;
<span class="lineNum">    1958 </span>            :     T val;
<span class="lineNum">    1959 </span>            : };
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            : typedef JSConstScalarSpec&lt;double&gt; JSConstDoubleSpec;
<span class="lineNum">    1962 </span>            : typedef JSConstScalarSpec&lt;int32_t&gt; JSConstIntegerSpec;
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            : struct JSJitInfo;
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            : /**
<span class="lineNum">    1967 </span>            :  * Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will
<span class="lineNum">    1968 </span>            :  * allow us to pass one JSJitInfo per function with the property/function spec,
<span class="lineNum">    1969 </span>            :  * without additional field overhead.
<span class="lineNum">    1970 </span>            :  */
<span class="lineNum">    1971 </span>            : struct JSNativeWrapper {
<span class="lineNum">    1972 </span>            :     JSNative        op;
<span class="lineNum">    1973 </span>            :     const JSJitInfo* info;
<span class="lineNum">    1974 </span>            : };
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            : /*
<span class="lineNum">    1977 </span>            :  * Macro static initializers which make it easy to pass no JSJitInfo as part of a
<span class="lineNum">    1978 </span>            :  * JSPropertySpec or JSFunctionSpec.
<span class="lineNum">    1979 </span>            :  */
<span class="lineNum">    1980 </span>            : #define JSNATIVE_WRAPPER(native) { {native, nullptr} }
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            : /**
<span class="lineNum">    1983 </span>            :  * Description of a property. JS_DefineProperties and JS_InitClass take arrays
<span class="lineNum">    1984 </span>            :  * of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END
<span class="lineNum">    1985 </span>            :  * are helper macros for defining such arrays.
<span class="lineNum">    1986 </span>            :  */
<span class="lineNum">    1987 </span>            : struct JSPropertySpec {
<span class="lineNum">    1988 </span>            :     struct SelfHostedWrapper {
<span class="lineNum">    1989 </span>            :         void*       unused;
<span class="lineNum">    1990 </span>            :         const char* funname;
<span class="lineNum">    1991 </span>            :     };
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span>            :     struct ValueWrapper {
<span class="lineNum">    1994 </span>            :         uintptr_t   type;
<span class="lineNum">    1995 </span>            :         union {
<span class="lineNum">    1996 </span>            :             const char* string;
<span class="lineNum">    1997 </span>            :             int32_t     int32;
<span class="lineNum">    1998 </span>            :         };
<span class="lineNum">    1999 </span>            :     };
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            :     const char*                 name;
<span class="lineNum">    2002 </span>            :     uint8_t                     flags;
<span class="lineNum">    2003 </span>            :     union {
<span class="lineNum">    2004 </span>            :         struct {
<span class="lineNum">    2005 </span>            :             union {
<span class="lineNum">    2006 </span>            :                 JSNativeWrapper    native;
<span class="lineNum">    2007 </span>            :                 SelfHostedWrapper  selfHosted;
<span class="lineNum">    2008 </span>            :             } getter;
<span class="lineNum">    2009 </span>            :             union {
<span class="lineNum">    2010 </span>            :                 JSNativeWrapper    native;
<span class="lineNum">    2011 </span>            :                 SelfHostedWrapper  selfHosted;
<span class="lineNum">    2012 </span>            :             } setter;
<span class="lineNum">    2013 </span>            :         } accessors;
<span class="lineNum">    2014 </span>            :         ValueWrapper            value;
<span class="lineNum">    2015 </span>            :     };
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span>            :     bool isAccessor() const {
<span class="lineNum">    2018 </span><span class="lineCov">          1 :         return !(flags &amp; JSPROP_INTERNAL_USE_BIT);</span>
<span class="lineNum">    2019 </span>            :     }
<span class="lineNum">    2020 </span>            :     JS_PUBLIC_API(bool) getValue(JSContext* cx, JS::MutableHandleValue value) const;
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     bool isSelfHosted() const {
<span class="lineNum">    2023 </span>            :         MOZ_ASSERT(isAccessor());
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            : #ifdef DEBUG
<span class="lineNum">    2026 </span>            :         // Verify that our accessors match our JSPROP_GETTER flag.
<span class="lineNum">    2027 </span>            :         if (flags &amp; JSPROP_GETTER)
<span class="lineNum">    2028 </span>            :             checkAccessorsAreSelfHosted();
<span class="lineNum">    2029 </span>            :         else
<span class="lineNum">    2030 </span>            :             checkAccessorsAreNative();
<span class="lineNum">    2031 </span>            : #endif
<span class="lineNum">    2032 </span><span class="lineCov">          1 :         return (flags &amp; JSPROP_GETTER);</span>
<span class="lineNum">    2033 </span>            :     }
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span>            :     static_assert(sizeof(SelfHostedWrapper) == sizeof(JSNativeWrapper),
<span class="lineNum">    2036 </span>            :                   &quot;JSPropertySpec::getter/setter must be compact&quot;);
<span class="lineNum">    2037 </span>            :     static_assert(offsetof(SelfHostedWrapper, funname) == offsetof(JSNativeWrapper, info),
<span class="lineNum">    2038 </span>            :                   &quot;JS_SELF_HOSTED* macros below require that &quot;
<span class="lineNum">    2039 </span>            :                   &quot;SelfHostedWrapper::funname overlay &quot;
<span class="lineNum">    2040 </span>            :                   &quot;JSNativeWrapper::info&quot;);
<span class="lineNum">    2041 </span>            : private:
<span class="lineNum">    2042 </span>            :     void checkAccessorsAreNative() const {
<span class="lineNum">    2043 </span>            :         MOZ_ASSERT(accessors.getter.native.op);
<span class="lineNum">    2044 </span>            :         // We may not have a setter at all.  So all we can assert here, for the
<span class="lineNum">    2045 </span>            :         // native case is that if we have a jitinfo for the setter then we have
<span class="lineNum">    2046 </span>            :         // a setter op too.  This is good enough to make sure we don't have a
<span class="lineNum">    2047 </span>            :         // SelfHostedWrapper for the setter.
<span class="lineNum">    2048 </span>            :         MOZ_ASSERT_IF(accessors.setter.native.info, accessors.setter.native.op);
<span class="lineNum">    2049 </span>            :     }
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            :     void checkAccessorsAreSelfHosted() const {
<span class="lineNum">    2052 </span>            :         MOZ_ASSERT(!accessors.getter.selfHosted.unused);
<span class="lineNum">    2053 </span>            :         MOZ_ASSERT(!accessors.setter.selfHosted.unused);
<span class="lineNum">    2054 </span>            :     }
<span class="lineNum">    2055 </span>            : };
<span class="lineNum">    2056 </span>            : 
<span class="lineNum">    2057 </span>            : namespace JS {
<span class="lineNum">    2058 </span>            : namespace detail {
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            : /* NEVER DEFINED, DON'T USE.  For use by JS_CAST_NATIVE_TO only. */
<span class="lineNum">    2061 </span>            : inline int CheckIsNative(JSNative native);
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span>            : /* NEVER DEFINED, DON'T USE.  For use by JS_CAST_STRING_TO only. */
<span class="lineNum">    2064 </span>            : template&lt;size_t N&gt;
<span class="lineNum">    2065 </span>            : inline int
<span class="lineNum">    2066 </span>            : CheckIsCharacterLiteral(const char (&amp;arr)[N]);
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            : /* NEVER DEFINED, DON'T USE.  For use by JS_CAST_INT32_TO only. */
<span class="lineNum">    2069 </span>            : inline int CheckIsInt32(int32_t value);
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span>            : /* NEVER DEFINED, DON'T USE.  For use by JS_PROPERTYOP_GETTER only. */
<span class="lineNum">    2072 </span>            : inline int CheckIsGetterOp(JSGetterOp op);
<span class="lineNum">    2073 </span>            : 
<span class="lineNum">    2074 </span>            : /* NEVER DEFINED, DON'T USE.  For use by JS_PROPERTYOP_SETTER only. */
<span class="lineNum">    2075 </span>            : inline int CheckIsSetterOp(JSSetterOp op);
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            : } // namespace detail
<span class="lineNum">    2078 </span>            : } // namespace JS
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span>            : #define JS_CAST_NATIVE_TO(v, To) \
<span class="lineNum">    2081 </span>            :   (static_cast&lt;void&gt;(sizeof(JS::detail::CheckIsNative(v))), \
<span class="lineNum">    2082 </span>            :    reinterpret_cast&lt;To&gt;(v))
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            : #define JS_CAST_STRING_TO(s, To) \
<span class="lineNum">    2085 </span>            :   (static_cast&lt;void&gt;(sizeof(JS::detail::CheckIsCharacterLiteral(s))), \
<span class="lineNum">    2086 </span>            :    reinterpret_cast&lt;To&gt;(s))
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span>            : #define JS_CAST_INT32_TO(s, To) \
<span class="lineNum">    2089 </span>            :   (static_cast&lt;void&gt;(sizeof(JS::detail::CheckIsInt32(s))), \
<span class="lineNum">    2090 </span>            :    reinterpret_cast&lt;To&gt;(s))
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : #define JS_CHECK_ACCESSOR_FLAGS(flags) \
<span class="lineNum">    2093 </span>            :   (static_cast&lt;mozilla::EnableIf&lt;((flags) &amp; ~(JSPROP_ENUMERATE | JSPROP_PERMANENT)) == 0&gt;::Type&gt;(0), \
<span class="lineNum">    2094 </span>            :    (flags))
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span>            : #define JS_PROPERTYOP_GETTER(v) \
<span class="lineNum">    2097 </span>            :   (static_cast&lt;void&gt;(sizeof(JS::detail::CheckIsGetterOp(v))), \
<span class="lineNum">    2098 </span>            :    reinterpret_cast&lt;JSNative&gt;(v))
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            : #define JS_PROPERTYOP_SETTER(v) \
<span class="lineNum">    2101 </span>            :   (static_cast&lt;void&gt;(sizeof(JS::detail::CheckIsSetterOp(v))), \
<span class="lineNum">    2102 </span>            :    reinterpret_cast&lt;JSNative&gt;(v))
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span>            : #define JS_STUBGETTER JS_PROPERTYOP_GETTER(JS_PropertyStub)
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span>            : #define JS_STUBSETTER JS_PROPERTYOP_SETTER(JS_StrictPropertyStub)
<span class="lineNum">    2107 </span>            : 
<span class="lineNum">    2108 </span>            : #define JS_PS_ACCESSOR_SPEC(name, getter, setter, flags, extraFlags) \
<span class="lineNum">    2109 </span>            :     { name, uint8_t(JS_CHECK_ACCESSOR_FLAGS(flags) | extraFlags), \
<span class="lineNum">    2110 </span>            :       { {  getter, setter  } } }
<span class="lineNum">    2111 </span>            : #define JS_PS_VALUE_SPEC(name, value, flags) \
<span class="lineNum">    2112 </span>            :     { name, uint8_t(flags | JSPROP_INTERNAL_USE_BIT), \
<span class="lineNum">    2113 </span>            :       { { value, JSNATIVE_WRAPPER(nullptr) } } }
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span>            : #define SELFHOSTED_WRAPPER(name) \
<span class="lineNum">    2116 </span>            :     { { nullptr, JS_CAST_STRING_TO(name, const JSJitInfo*) } }
<span class="lineNum">    2117 </span>            : #define STRINGVALUE_WRAPPER(value) \
<span class="lineNum">    2118 </span>            :     { { reinterpret_cast&lt;JSNative&gt;(JSVAL_TYPE_STRING), JS_CAST_STRING_TO(value, const JSJitInfo*) } }
<span class="lineNum">    2119 </span>            : #define INT32VALUE_WRAPPER(value) \
<span class="lineNum">    2120 </span>            :     { { reinterpret_cast&lt;JSNative&gt;(JSVAL_TYPE_INT32), JS_CAST_INT32_TO(value, const JSJitInfo*) } }
<span class="lineNum">    2121 </span>            : 
<span class="lineNum">    2122 </span>            : /*
<span class="lineNum">    2123 </span>            :  * JSPropertySpec uses JSNativeWrapper.  These macros encapsulate the definition
<span class="lineNum">    2124 </span>            :  * of JSNative-backed JSPropertySpecs, by defining the JSNativeWrappers for
<span class="lineNum">    2125 </span>            :  * them.
<span class="lineNum">    2126 </span>            :  */
<span class="lineNum">    2127 </span>            : #define JS_PSG(name, getter, flags) \
<span class="lineNum">    2128 </span>            :     JS_PS_ACCESSOR_SPEC(name, JSNATIVE_WRAPPER(getter), JSNATIVE_WRAPPER(nullptr), flags, \
<span class="lineNum">    2129 </span>            :                         JSPROP_SHARED)
<span class="lineNum">    2130 </span>            : #define JS_PSGS(name, getter, setter, flags) \
<span class="lineNum">    2131 </span>            :     JS_PS_ACCESSOR_SPEC(name, JSNATIVE_WRAPPER(getter), JSNATIVE_WRAPPER(setter), flags, \
<span class="lineNum">    2132 </span>            :                          JSPROP_SHARED)
<span class="lineNum">    2133 </span>            : #define JS_SELF_HOSTED_GET(name, getterName, flags) \
<span class="lineNum">    2134 </span>            :     JS_PS_ACCESSOR_SPEC(name, SELFHOSTED_WRAPPER(getterName), JSNATIVE_WRAPPER(nullptr), flags, \
<span class="lineNum">    2135 </span>            :                          JSPROP_SHARED | JSPROP_GETTER)
<span class="lineNum">    2136 </span>            : #define JS_SELF_HOSTED_GETSET(name, getterName, setterName, flags) \
<span class="lineNum">    2137 </span>            :     JS_PS_ACCESSOR_SPEC(name, SELFHOSTED_WRAPPER(getterName), SELFHOSTED_WRAPPER(setterName), \
<span class="lineNum">    2138 </span>            :                          flags, JSPROP_SHARED | JSPROP_GETTER | JSPROP_SETTER)
<span class="lineNum">    2139 </span>            : #define JS_SELF_HOSTED_SYM_GET(symbol, getterName, flags) \
<span class="lineNum">    2140 </span>            :     JS_PS_ACCESSOR_SPEC(reinterpret_cast&lt;const char*&gt;(uint32_t(::JS::SymbolCode::symbol) + 1), \
<span class="lineNum">    2141 </span>            :                          SELFHOSTED_WRAPPER(getterName), JSNATIVE_WRAPPER(nullptr), flags, \
<span class="lineNum">    2142 </span>            :                          JSPROP_SHARED | JSPROP_GETTER)
<span class="lineNum">    2143 </span>            : #define JS_STRING_PS(name, string, flags) \
<span class="lineNum">    2144 </span>            :     JS_PS_VALUE_SPEC(name, STRINGVALUE_WRAPPER(string), flags)
<span class="lineNum">    2145 </span>            : #define JS_STRING_SYM_PS(symbol, string, flags) \
<span class="lineNum">    2146 </span>            :     JS_PS_VALUE_SPEC(reinterpret_cast&lt;const char*&gt;(uint32_t(::JS::SymbolCode::symbol) + 1), \
<span class="lineNum">    2147 </span>            :                      STRINGVALUE_WRAPPER(string), flags)
<span class="lineNum">    2148 </span>            : #define JS_INT32_PS(name, value, flags) \
<span class="lineNum">    2149 </span>            :     JS_PS_VALUE_SPEC(name, INT32VALUE_WRAPPER(value), flags)
<span class="lineNum">    2150 </span>            : #define JS_PS_END \
<span class="lineNum">    2151 </span>            :     JS_PS_ACCESSOR_SPEC(nullptr, JSNATIVE_WRAPPER(nullptr), JSNATIVE_WRAPPER(nullptr), 0, 0)
<span class="lineNum">    2152 </span>            : 
<span class="lineNum">    2153 </span>            : /**
<span class="lineNum">    2154 </span>            :  * To define a native function, set call to a JSNativeWrapper. To define a
<span class="lineNum">    2155 </span>            :  * self-hosted function, set selfHostedName to the name of a function
<span class="lineNum">    2156 </span>            :  * compiled during JSRuntime::initSelfHosting.
<span class="lineNum">    2157 </span>            :  */
<span class="lineNum">    2158 </span>            : struct JSFunctionSpec {
<span class="lineNum">    2159 </span>            :     const char*     name;
<span class="lineNum">    2160 </span>            :     JSNativeWrapper call;
<span class="lineNum">    2161 </span>            :     uint16_t        nargs;
<span class="lineNum">    2162 </span>            :     uint16_t        flags;
<span class="lineNum">    2163 </span>            :     const char*     selfHostedName;
<span class="lineNum">    2164 </span>            : };
<span class="lineNum">    2165 </span>            : 
<span class="lineNum">    2166 </span>            : /*
<span class="lineNum">    2167 </span>            :  * Terminating sentinel initializer to put at the end of a JSFunctionSpec array
<span class="lineNum">    2168 </span>            :  * that's passed to JS_DefineFunctions or JS_InitClass.
<span class="lineNum">    2169 </span>            :  */
<span class="lineNum">    2170 </span>            : #define JS_FS_END JS_FS(nullptr,nullptr,0,0)
<span class="lineNum">    2171 </span>            : 
<span class="lineNum">    2172 </span>            : /*
<span class="lineNum">    2173 </span>            :  * Initializer macros for a JSFunctionSpec array element. JS_FN (whose name pays
<span class="lineNum">    2174 </span>            :  * homage to the old JSNative/JSFastNative split) simply adds the flag
<span class="lineNum">    2175 </span>            :  * JSFUN_STUB_GSOPS. JS_FNINFO allows the simple adding of
<span class="lineNum">    2176 </span>            :  * JSJitInfos. JS_SELF_HOSTED_FN declares a self-hosted function.
<span class="lineNum">    2177 </span>            :  * JS_INLINABLE_FN allows specifying an InlinableNative enum value for natives
<span class="lineNum">    2178 </span>            :  * inlined or specialized by the JIT. Finally JS_FNSPEC has slots for all the
<span class="lineNum">    2179 </span>            :  * fields.
<span class="lineNum">    2180 </span>            :  *
<span class="lineNum">    2181 </span>            :  * The _SYM variants allow defining a function with a symbol key rather than a
<span class="lineNum">    2182 </span>            :  * string key. For example, use JS_SYM_FN(iterator, ...) to define an
<span class="lineNum">    2183 </span>            :  * @@iterator method.
<span class="lineNum">    2184 </span>            :  */
<span class="lineNum">    2185 </span>            : #define JS_FS(name,call,nargs,flags)                                          \
<span class="lineNum">    2186 </span>            :     JS_FNSPEC(name, call, nullptr, nargs, flags, nullptr)
<span class="lineNum">    2187 </span>            : #define JS_FN(name,call,nargs,flags)                                          \
<span class="lineNum">    2188 </span>            :     JS_FNSPEC(name, call, nullptr, nargs, (flags) | JSFUN_STUB_GSOPS, nullptr)
<span class="lineNum">    2189 </span>            : #define JS_INLINABLE_FN(name,call,nargs,flags,native)                         \
<span class="lineNum">    2190 </span>            :     JS_FNSPEC(name, call, &amp;js::jit::JitInfo_##native, nargs, (flags) | JSFUN_STUB_GSOPS, nullptr)
<span class="lineNum">    2191 </span>            : #define JS_SYM_FN(symbol,call,nargs,flags)                                    \
<span class="lineNum">    2192 </span>            :     JS_SYM_FNSPEC(symbol, call, nullptr, nargs, (flags) | JSFUN_STUB_GSOPS, nullptr)
<span class="lineNum">    2193 </span>            : #define JS_FNINFO(name,call,info,nargs,flags)                                 \
<span class="lineNum">    2194 </span>            :     JS_FNSPEC(name, call, info, nargs, flags, nullptr)
<span class="lineNum">    2195 </span>            : #define JS_SELF_HOSTED_FN(name,selfHostedName,nargs,flags)                    \
<span class="lineNum">    2196 </span>            :     JS_FNSPEC(name, nullptr, nullptr, nargs, flags, selfHostedName)
<span class="lineNum">    2197 </span>            : #define JS_SELF_HOSTED_SYM_FN(symbol, selfHostedName, nargs, flags)           \
<span class="lineNum">    2198 </span>            :     JS_SYM_FNSPEC(symbol, nullptr, nullptr, nargs, flags, selfHostedName)
<span class="lineNum">    2199 </span>            : #define JS_SYM_FNSPEC(symbol, call, info, nargs, flags, selfHostedName)       \
<span class="lineNum">    2200 </span>            :     JS_FNSPEC(reinterpret_cast&lt;const char*&gt;(                                 \
<span class="lineNum">    2201 </span>            :                   uint32_t(::JS::SymbolCode::symbol) + 1),                    \
<span class="lineNum">    2202 </span>            :               call, info, nargs, flags, selfHostedName)
<span class="lineNum">    2203 </span>            : #define JS_FNSPEC(name,call,info,nargs,flags,selfHostedName)                  \
<span class="lineNum">    2204 </span>            :     {name, {call, info}, nargs, flags, selfHostedName}
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    2207 </span>            : JS_InitClass(JSContext* cx, JS::HandleObject obj, JS::HandleObject parent_proto,
<span class="lineNum">    2208 </span>            :              const JSClass* clasp, JSNative constructor, unsigned nargs,
<span class="lineNum">    2209 </span>            :              const JSPropertySpec* ps, const JSFunctionSpec* fs,
<span class="lineNum">    2210 </span>            :              const JSPropertySpec* static_ps, const JSFunctionSpec* static_fs);
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span>            : /**
<span class="lineNum">    2213 </span>            :  * Set up ctor.prototype = proto and proto.constructor = ctor with the
<span class="lineNum">    2214 </span>            :  * right property flags.
<span class="lineNum">    2215 </span>            :  */
<span class="lineNum">    2216 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2217 </span>            : JS_LinkConstructorAndPrototype(JSContext* cx, JS::Handle&lt;JSObject*&gt; ctor,
<span class="lineNum">    2218 </span>            :                                JS::Handle&lt;JSObject*&gt; proto);
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span>            : extern JS_PUBLIC_API(const JSClass*)
<span class="lineNum">    2221 </span>            : JS_GetClass(JSObject* obj);
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2224 </span>            : JS_InstanceOf(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, const JSClass* clasp, JS::CallArgs* args);
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2227 </span>            : JS_HasInstance(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, JS::Handle&lt;JS::Value&gt; v, bool* bp);
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            : namespace JS {
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span>            : // Implementation of
<span class="lineNum">    2232 </span>            : // http://www.ecma-international.org/ecma-262/6.0/#sec-ordinaryhasinstance.  If
<span class="lineNum">    2233 </span>            : // you're looking for the equivalent of &quot;instanceof&quot;, you want JS_HasInstance,
<span class="lineNum">    2234 </span>            : // not this function.
<span class="lineNum">    2235 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2236 </span>            : OrdinaryHasInstance(JSContext* cx, HandleObject objArg, HandleValue v, bool* bp);
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span>            : } // namespace JS
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    2241 </span>            : JS_GetPrivate(JSObject* obj);
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    2244 </span>            : JS_SetPrivate(JSObject* obj, void* data);
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    2247 </span>            : JS_GetInstancePrivate(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, const JSClass* clasp,
<span class="lineNum">    2248 </span>            :                       JS::CallArgs* args);
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    2251 </span>            : JS_GetConstructor(JSContext* cx, JS::Handle&lt;JSObject*&gt; proto);
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span>            : namespace JS {
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span>            : // Specification for which zone a newly created compartment should use.
<span class="lineNum">    2256 </span>            : enum ZoneSpecifier {
<span class="lineNum">    2257 </span>            :     // Use the single runtime wide system zone. The meaning of this zone is
<span class="lineNum">    2258 </span>            :     // left to the embedder.
<span class="lineNum">    2259 </span>            :     SystemZone,
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span>            :     // Use a particular existing zone.
<span class="lineNum">    2262 </span>            :     ExistingZone,
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span>            :     // Create a new zone with its own new zone group.
<span class="lineNum">    2265 </span>            :     NewZoneInNewZoneGroup,
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span>            :     // Create a new zone in the same zone group as the system zone.
<span class="lineNum">    2268 </span>            :     NewZoneInSystemZoneGroup,
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            :     // Create a new zone in the same zone group as another existing zone.
<span class="lineNum">    2271 </span>            :     NewZoneInExistingZoneGroup
<span class="lineNum">    2272 </span>            : };
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span>            : /**
<span class="lineNum">    2275 </span>            :  * CompartmentCreationOptions specifies options relevant to creating a new
<span class="lineNum">    2276 </span>            :  * compartment, that are either immutable characteristics of that compartment
<span class="lineNum">    2277 </span>            :  * or that are discarded after the compartment has been created.
<span class="lineNum">    2278 </span>            :  *
<span class="lineNum">    2279 </span>            :  * Access to these options on an existing compartment is read-only: if you
<span class="lineNum">    2280 </span>            :  * need particular selections, make them before you create the compartment.
<span class="lineNum">    2281 </span>            :  */
<span class="lineNum">    2282 </span>            : class JS_PUBLIC_API(CompartmentCreationOptions)
<span class="lineNum">    2283 </span>            : {
<span class="lineNum">    2284 </span>            :   public:
<span class="lineNum">    2285 </span>            :     CompartmentCreationOptions()
<span class="lineNum">    2286 </span>            :       : addonId_(nullptr),
<span class="lineNum">    2287 </span>            :         traceGlobal_(nullptr),
<span class="lineNum">    2288 </span>            :         zoneSpec_(NewZoneInSystemZoneGroup),
<span class="lineNum">    2289 </span>            :         zonePointer_(nullptr),
<span class="lineNum">    2290 </span>            :         invisibleToDebugger_(false),
<span class="lineNum">    2291 </span>            :         mergeable_(false),
<span class="lineNum">    2292 </span>            :         preserveJitCode_(false),
<span class="lineNum">    2293 </span>            :         cloneSingletons_(false),
<span class="lineNum">    2294 </span>            :         experimentalNumberFormatFormatToPartsEnabled_(false),
<span class="lineNum">    2295 </span>            :         sharedMemoryAndAtomics_(false),
<span class="lineNum">    2296 </span><span class="lineCov">          1 :         secureContext_(false)</span>
<span class="lineNum">    2297 </span>            :     {}
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span>            :     // A null add-on ID means that the compartment is not associated with an
<span class="lineNum">    2300 </span>            :     // add-on.
<span class="lineNum">    2301 </span>            :     JSAddonId* addonIdOrNull() const { return addonId_; }
<span class="lineNum">    2302 </span>            :     CompartmentCreationOptions&amp; setAddonId(JSAddonId* id) {
<span class="lineNum">    2303 </span>            :         addonId_ = id;
<span class="lineNum">    2304 </span>            :         return *this;
<span class="lineNum">    2305 </span>            :     }
<span class="lineNum">    2306 </span>            : 
<span class="lineNum">    2307 </span>            :     JSTraceOp getTrace() const {
<span class="lineNum">    2308 </span>            :         return traceGlobal_;
<span class="lineNum">    2309 </span>            :     }
<span class="lineNum">    2310 </span>            :     CompartmentCreationOptions&amp; setTrace(JSTraceOp op) {
<span class="lineNum">    2311 </span><span class="lineCov">          1 :         traceGlobal_ = op;</span>
<span class="lineNum">    2312 </span>            :         return *this;
<span class="lineNum">    2313 </span>            :     }
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            :     void* zonePointer() const { return zonePointer_; }
<span class="lineNum">    2316 </span>            :     ZoneSpecifier zoneSpecifier() const { return zoneSpec_; }
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span>            :     // Set the zone to use for the compartment. See ZoneSpecifier above.
<span class="lineNum">    2319 </span>            :     CompartmentCreationOptions&amp; setSystemZone();
<span class="lineNum">    2320 </span>            :     CompartmentCreationOptions&amp; setExistingZone(JSObject* obj);
<span class="lineNum">    2321 </span>            :     CompartmentCreationOptions&amp; setNewZoneInNewZoneGroup();
<span class="lineNum">    2322 </span>            :     CompartmentCreationOptions&amp; setNewZoneInSystemZoneGroup();
<span class="lineNum">    2323 </span>            :     CompartmentCreationOptions&amp; setNewZoneInExistingZoneGroup(JSObject* obj);
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span>            :     // Certain scopes (i.e. XBL compilation scopes) are implementation details
<span class="lineNum">    2326 </span>            :     // of the embedding, and references to them should never leak out to script.
<span class="lineNum">    2327 </span>            :     // This flag causes the this compartment to skip firing onNewGlobalObject
<span class="lineNum">    2328 </span>            :     // and makes addDebuggee a no-op for this global.
<span class="lineNum">    2329 </span>            :     bool invisibleToDebugger() const { return invisibleToDebugger_; }
<span class="lineNum">    2330 </span>            :     CompartmentCreationOptions&amp; setInvisibleToDebugger(bool flag) {
<span class="lineNum">    2331 </span><span class="lineCov">          1 :         invisibleToDebugger_ = flag;</span>
<span class="lineNum">    2332 </span>            :         return *this;
<span class="lineNum">    2333 </span>            :     }
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span>            :     // Compartments used for off-thread compilation have their contents merged
<span class="lineNum">    2336 </span>            :     // into a target compartment when the compilation is finished. This is only
<span class="lineNum">    2337 </span>            :     // allowed if this flag is set. The invisibleToDebugger flag must also be
<span class="lineNum">    2338 </span>            :     // set for such compartments.
<span class="lineNum">    2339 </span>            :     bool mergeable() const { return mergeable_; }
<span class="lineNum">    2340 </span>            :     CompartmentCreationOptions&amp; setMergeable(bool flag) {
<span class="lineNum">    2341 </span><span class="lineCov">          1 :         mergeable_ = flag;</span>
<span class="lineNum">    2342 </span>            :         return *this;
<span class="lineNum">    2343 </span>            :     }
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            :     // Determines whether this compartment should preserve JIT code on
<span class="lineNum">    2346 </span>            :     // non-shrinking GCs.
<span class="lineNum">    2347 </span>            :     bool preserveJitCode() const { return preserveJitCode_; }
<span class="lineNum">    2348 </span>            :     CompartmentCreationOptions&amp; setPreserveJitCode(bool flag) {
<span class="lineNum">    2349 </span>            :         preserveJitCode_ = flag;
<span class="lineNum">    2350 </span>            :         return *this;
<span class="lineNum">    2351 </span>            :     }
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            :     bool cloneSingletons() const { return cloneSingletons_; }
<span class="lineNum">    2354 </span>            :     CompartmentCreationOptions&amp; setCloneSingletons(bool flag) {
<span class="lineNum">    2355 </span>            :         cloneSingletons_ = flag;
<span class="lineNum">    2356 </span>            :         return *this;
<span class="lineNum">    2357 </span>            :     }
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            :     // ECMA-402 is considering adding a &quot;formatToParts&quot; NumberFormat method,
<span class="lineNum">    2360 </span>            :     // that exposes not just a formatted string but its subcomponents.  The
<span class="lineNum">    2361 </span>            :     // method, its semantics, and its name aren't finalized, so for now it's
<span class="lineNum">    2362 </span>            :     // exposed *only* if requested.
<span class="lineNum">    2363 </span>            :     //
<span class="lineNum">    2364 </span>            :     // Until &quot;formatToParts&quot; is included in a final specification edition, it's
<span class="lineNum">    2365 </span>            :     // subject to change or removal at any time.  Do *not* rely on it in
<span class="lineNum">    2366 </span>            :     // mission-critical code that can't be changed if ECMA-402 decides not to
<span class="lineNum">    2367 </span>            :     // accept the method in its current form.
<span class="lineNum">    2368 </span>            :     bool experimentalNumberFormatFormatToPartsEnabled() const {
<span class="lineNum">    2369 </span>            :         return experimentalNumberFormatFormatToPartsEnabled_;
<span class="lineNum">    2370 </span>            :     }
<span class="lineNum">    2371 </span>            :     CompartmentCreationOptions&amp; setExperimentalNumberFormatFormatToPartsEnabled(bool flag) {
<span class="lineNum">    2372 </span>            :         experimentalNumberFormatFormatToPartsEnabled_ = flag;
<span class="lineNum">    2373 </span>            :         return *this;
<span class="lineNum">    2374 </span>            :     }
<span class="lineNum">    2375 </span>            : 
<span class="lineNum">    2376 </span>            :     bool getSharedMemoryAndAtomicsEnabled() const;
<span class="lineNum">    2377 </span>            :     CompartmentCreationOptions&amp; setSharedMemoryAndAtomicsEnabled(bool flag);
<span class="lineNum">    2378 </span>            : 
<span class="lineNum">    2379 </span>            :     // This flag doesn't affect JS engine behavior.  It is used by Gecko to
<span class="lineNum">    2380 </span>            :     // mark whether content windows and workers are &quot;Secure Context&quot;s. See
<span class="lineNum">    2381 </span>            :     // https://w3c.github.io/webappsec-secure-contexts/
<span class="lineNum">    2382 </span>            :     // https://bugzilla.mozilla.org/show_bug.cgi?id=1162772#c34
<span class="lineNum">    2383 </span>            :     bool secureContext() const { return secureContext_; }
<span class="lineNum">    2384 </span>            :     CompartmentCreationOptions&amp; setSecureContext(bool flag) {
<span class="lineNum">    2385 </span>            :         secureContext_ = flag;
<span class="lineNum">    2386 </span>            :         return *this;
<span class="lineNum">    2387 </span>            :     }
<span class="lineNum">    2388 </span>            : 
<span class="lineNum">    2389 </span>            :   private:
<span class="lineNum">    2390 </span>            :     JSAddonId* addonId_;
<span class="lineNum">    2391 </span>            :     JSTraceOp traceGlobal_;
<span class="lineNum">    2392 </span>            :     ZoneSpecifier zoneSpec_;
<span class="lineNum">    2393 </span>            :     void* zonePointer_; // Per zoneSpec_, either a Zone, ZoneGroup, or null.
<span class="lineNum">    2394 </span>            :     bool invisibleToDebugger_;
<span class="lineNum">    2395 </span>            :     bool mergeable_;
<span class="lineNum">    2396 </span>            :     bool preserveJitCode_;
<span class="lineNum">    2397 </span>            :     bool cloneSingletons_;
<span class="lineNum">    2398 </span>            :     bool experimentalNumberFormatFormatToPartsEnabled_;
<span class="lineNum">    2399 </span>            :     bool sharedMemoryAndAtomics_;
<span class="lineNum">    2400 </span>            :     bool secureContext_;
<span class="lineNum">    2401 </span>            : };
<span class="lineNum">    2402 </span>            : 
<span class="lineNum">    2403 </span>            : /**
<span class="lineNum">    2404 </span>            :  * CompartmentBehaviors specifies behaviors of a compartment that can be
<span class="lineNum">    2405 </span>            :  * changed after the compartment's been created.
<span class="lineNum">    2406 </span>            :  */
<span class="lineNum">    2407 </span>            : class JS_PUBLIC_API(CompartmentBehaviors)
<span class="lineNum">    2408 </span>            : {
<span class="lineNum">    2409 </span>            :   public:
<span class="lineNum">    2410 </span>            :     class Override {
<span class="lineNum">    2411 </span>            :       public:
<span class="lineNum">    2412 </span><span class="lineCov">          1 :         Override() : mode_(Default) {}</span>
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span>            :         bool get(bool defaultValue) const {
<span class="lineNum">    2415 </span><span class="lineCov">          1 :             if (mode_ == Default)</span>
<span class="lineNum">    2416 </span>            :                 return defaultValue;
<span class="lineNum">    2417 </span><span class="lineCov">          1 :             return mode_ == ForceTrue;</span>
<span class="lineNum">    2418 </span>            :         }
<span class="lineNum">    2419 </span>            : 
<span class="lineNum">    2420 </span>            :         void set(bool overrideValue) {
<span class="lineNum">    2421 </span>            :             mode_ = overrideValue ? ForceTrue : ForceFalse;
<span class="lineNum">    2422 </span>            :         }
<span class="lineNum">    2423 </span>            : 
<span class="lineNum">    2424 </span>            :         void reset() {
<span class="lineNum">    2425 </span>            :             mode_ = Default;
<span class="lineNum">    2426 </span>            :         }
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span>            :       private:
<span class="lineNum">    2429 </span>            :         enum Mode {
<span class="lineNum">    2430 </span>            :             Default,
<span class="lineNum">    2431 </span>            :             ForceTrue,
<span class="lineNum">    2432 </span>            :             ForceFalse
<span class="lineNum">    2433 </span>            :         };
<span class="lineNum">    2434 </span>            : 
<span class="lineNum">    2435 </span>            :         Mode mode_;
<span class="lineNum">    2436 </span>            :     };
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span>            :     CompartmentBehaviors()
<span class="lineNum">    2439 </span>            :       : version_(JSVERSION_UNKNOWN)
<span class="lineNum">    2440 </span>            :       , discardSource_(false)
<span class="lineNum">    2441 </span>            :       , disableLazyParsing_(false)
<span class="lineNum">    2442 </span><span class="lineCov">          1 :       , singletonsAsTemplates_(true)</span>
<span class="lineNum">    2443 </span>            :     {
<span class="lineNum">    2444 </span>            :     }
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span>            :     JSVersion version() const { return version_; }
<span class="lineNum">    2447 </span>            :     CompartmentBehaviors&amp; setVersion(JSVersion aVersion) {
<span class="lineNum">    2448 </span>            :         MOZ_ASSERT(aVersion != JSVERSION_UNKNOWN);
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :         version_ = aVersion;</span>
<span class="lineNum">    2450 </span>            :         return *this;
<span class="lineNum">    2451 </span>            :     }
<span class="lineNum">    2452 </span>            : 
<span class="lineNum">    2453 </span>            :     // For certain globals, we know enough about the code that will run in them
<span class="lineNum">    2454 </span>            :     // that we can discard script source entirely.
<span class="lineNum">    2455 </span>            :     bool discardSource() const { return discardSource_; }
<span class="lineNum">    2456 </span>            :     CompartmentBehaviors&amp; setDiscardSource(bool flag) {
<span class="lineNum">    2457 </span><span class="lineCov">          1 :         discardSource_ = flag;</span>
<span class="lineNum">    2458 </span>            :         return *this;
<span class="lineNum">    2459 </span>            :     }
<span class="lineNum">    2460 </span>            : 
<span class="lineNum">    2461 </span>            :     bool disableLazyParsing() const { return disableLazyParsing_; }
<span class="lineNum">    2462 </span>            :     CompartmentBehaviors&amp; setDisableLazyParsing(bool flag) {
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :         disableLazyParsing_ = flag;</span>
<span class="lineNum">    2464 </span>            :         return *this;
<span class="lineNum">    2465 </span>            :     }
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span>            :     bool extraWarnings(JSContext* cx) const;
<span class="lineNum">    2468 </span>            :     Override&amp; extraWarningsOverride() { return extraWarningsOverride_; }
<span class="lineNum">    2469 </span>            : 
<span class="lineNum">    2470 </span>            :     bool getSingletonsAsTemplates() const {
<span class="lineNum">    2471 </span>            :         return singletonsAsTemplates_;
<span class="lineNum">    2472 </span>            :     }
<span class="lineNum">    2473 </span>            :     CompartmentBehaviors&amp; setSingletonsAsValues() {
<span class="lineNum">    2474 </span><span class="lineCov">          1 :         singletonsAsTemplates_ = false;</span>
<span class="lineNum">    2475 </span>            :         return *this;
<span class="lineNum">    2476 </span>            :     }
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span>            :   private:
<span class="lineNum">    2479 </span>            :     JSVersion version_;
<span class="lineNum">    2480 </span>            :     bool discardSource_;
<span class="lineNum">    2481 </span>            :     bool disableLazyParsing_;
<span class="lineNum">    2482 </span>            :     Override extraWarningsOverride_;
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span>            :     // To XDR singletons, we need to ensure that all singletons are all used as
<span class="lineNum">    2485 </span>            :     // templates, by making JSOP_OBJECT return a clone of the JSScript
<span class="lineNum">    2486 </span>            :     // singleton, instead of returning the value which is baked in the JSScript.
<span class="lineNum">    2487 </span>            :     bool singletonsAsTemplates_;
<span class="lineNum">    2488 </span>            : };
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span>            : /**
<span class="lineNum">    2491 </span>            :  * CompartmentOptions specifies compartment characteristics: both those that
<span class="lineNum">    2492 </span>            :  * can't be changed on a compartment once it's been created
<span class="lineNum">    2493 </span>            :  * (CompartmentCreationOptions), and those that can be changed on an existing
<span class="lineNum">    2494 </span>            :  * compartment (CompartmentBehaviors).
<span class="lineNum">    2495 </span>            :  */
<span class="lineNum">    2496 </span>            : class JS_PUBLIC_API(CompartmentOptions)
<span class="lineNum">    2497 </span>            : {
<span class="lineNum">    2498 </span>            :   public:
<span class="lineNum">    2499 </span>            :     explicit CompartmentOptions()
<span class="lineNum">    2500 </span>            :       : creationOptions_(),
<span class="lineNum">    2501 </span><span class="lineCov">          1 :         behaviors_()</span>
<span class="lineNum">    2502 </span>            :     {}
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span>            :     CompartmentOptions(const CompartmentCreationOptions&amp; compartmentCreation,
<span class="lineNum">    2505 </span>            :                        const CompartmentBehaviors&amp; compartmentBehaviors)
<span class="lineNum">    2506 </span>            :       : creationOptions_(compartmentCreation),
<span class="lineNum">    2507 </span><span class="lineCov">          1 :         behaviors_(compartmentBehaviors)</span>
<span class="lineNum">    2508 </span>            :     {}
<span class="lineNum">    2509 </span>            : 
<span class="lineNum">    2510 </span>            :     // CompartmentCreationOptions specify fundamental compartment
<span class="lineNum">    2511 </span>            :     // characteristics that must be specified when the compartment is created,
<span class="lineNum">    2512 </span>            :     // that can't be changed after the compartment is created.
<span class="lineNum">    2513 </span>            :     CompartmentCreationOptions&amp; creationOptions() {
<span class="lineNum">    2514 </span>            :         return creationOptions_;
<span class="lineNum">    2515 </span>            :     }
<span class="lineNum">    2516 </span>            :     const CompartmentCreationOptions&amp; creationOptions() const {
<span class="lineNum">    2517 </span>            :         return creationOptions_;
<span class="lineNum">    2518 </span>            :     }
<span class="lineNum">    2519 </span>            : 
<span class="lineNum">    2520 </span>            :     // CompartmentBehaviors specify compartment characteristics that can be
<span class="lineNum">    2521 </span>            :     // changed after the compartment is created.
<span class="lineNum">    2522 </span>            :     CompartmentBehaviors&amp; behaviors() {
<span class="lineNum">    2523 </span>            :         return behaviors_;
<span class="lineNum">    2524 </span>            :     }
<span class="lineNum">    2525 </span>            :     const CompartmentBehaviors&amp; behaviors() const {
<span class="lineNum">    2526 </span>            :         return behaviors_;
<span class="lineNum">    2527 </span>            :     }
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span>            :   private:
<span class="lineNum">    2530 </span>            :     CompartmentCreationOptions creationOptions_;
<span class="lineNum">    2531 </span>            :     CompartmentBehaviors behaviors_;
<span class="lineNum">    2532 </span>            : };
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span>            : JS_PUBLIC_API(const CompartmentCreationOptions&amp;)
<span class="lineNum">    2535 </span>            : CompartmentCreationOptionsRef(JSCompartment* compartment);
<span class="lineNum">    2536 </span>            : 
<span class="lineNum">    2537 </span>            : JS_PUBLIC_API(const CompartmentCreationOptions&amp;)
<span class="lineNum">    2538 </span>            : CompartmentCreationOptionsRef(JSObject* obj);
<span class="lineNum">    2539 </span>            : 
<span class="lineNum">    2540 </span>            : JS_PUBLIC_API(const CompartmentCreationOptions&amp;)
<span class="lineNum">    2541 </span>            : CompartmentCreationOptionsRef(JSContext* cx);
<span class="lineNum">    2542 </span>            : 
<span class="lineNum">    2543 </span>            : JS_PUBLIC_API(CompartmentBehaviors&amp;)
<span class="lineNum">    2544 </span>            : CompartmentBehaviorsRef(JSCompartment* compartment);
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span>            : JS_PUBLIC_API(CompartmentBehaviors&amp;)
<span class="lineNum">    2547 </span>            : CompartmentBehaviorsRef(JSObject* obj);
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span>            : JS_PUBLIC_API(CompartmentBehaviors&amp;)
<span class="lineNum">    2550 </span>            : CompartmentBehaviorsRef(JSContext* cx);
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            : /**
<span class="lineNum">    2553 </span>            :  * During global creation, we fire notifications to callbacks registered
<span class="lineNum">    2554 </span>            :  * via the Debugger API. These callbacks are arbitrary script, and can touch
<span class="lineNum">    2555 </span>            :  * the global in arbitrary ways. When that happens, the global should not be
<span class="lineNum">    2556 </span>            :  * in a half-baked state. But this creates a problem for consumers that need
<span class="lineNum">    2557 </span>            :  * to set slots on the global to put it in a consistent state.
<span class="lineNum">    2558 </span>            :  *
<span class="lineNum">    2559 </span>            :  * This API provides a way for consumers to set slots atomically (immediately
<span class="lineNum">    2560 </span>            :  * after the global is created), before any debugger hooks are fired. It's
<span class="lineNum">    2561 </span>            :  * unfortunately on the clunky side, but that's the way the cookie crumbles.
<span class="lineNum">    2562 </span>            :  *
<span class="lineNum">    2563 </span>            :  * If callers have no additional state on the global to set up, they may pass
<span class="lineNum">    2564 </span>            :  * |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to
<span class="lineNum">    2565 </span>            :  * fire the hook as its final act before returning. Otherwise, callers should
<span class="lineNum">    2566 </span>            :  * pass |DontFireOnNewGlobalHook|, which means that they are responsible for
<span class="lineNum">    2567 </span>            :  * invoking JS_FireOnNewGlobalObject upon successfully creating the global. If
<span class="lineNum">    2568 </span>            :  * an error occurs and the operation aborts, callers should skip firing the
<span class="lineNum">    2569 </span>            :  * hook. But otherwise, callers must take care to fire the hook exactly once
<span class="lineNum">    2570 </span>            :  * before compiling any script in the global's scope (we have assertions in
<span class="lineNum">    2571 </span>            :  * place to enforce this). This lets us be sure that debugger clients never miss
<span class="lineNum">    2572 </span>            :  * breakpoints.
<span class="lineNum">    2573 </span>            :  */
<span class="lineNum">    2574 </span>            : enum OnNewGlobalHookOption {
<span class="lineNum">    2575 </span>            :     FireOnNewGlobalHook,
<span class="lineNum">    2576 </span>            :     DontFireOnNewGlobalHook
<span class="lineNum">    2577 </span>            : };
<span class="lineNum">    2578 </span>            : 
<span class="lineNum">    2579 </span>            : } /* namespace JS */
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    2582 </span>            : JS_NewGlobalObject(JSContext* cx, const JSClass* clasp, JSPrincipals* principals,
<span class="lineNum">    2583 </span>            :                    JS::OnNewGlobalHookOption hookOption,
<span class="lineNum">    2584 </span>            :                    const JS::CompartmentOptions&amp; options);
<span class="lineNum">    2585 </span>            : /**
<span class="lineNum">    2586 </span>            :  * Spidermonkey does not have a good way of keeping track of what compartments should be marked on
<span class="lineNum">    2587 </span>            :  * their own. We can mark the roots unconditionally, but marking GC things only relevant in live
<span class="lineNum">    2588 </span>            :  * compartments is hard. To mitigate this, we create a static trace hook, installed on each global
<span class="lineNum">    2589 </span>            :  * object, from which we can be sure the compartment is relevant, and mark it.
<span class="lineNum">    2590 </span>            :  *
<span class="lineNum">    2591 </span>            :  * It is still possible to specify custom trace hooks for global object classes. They can be
<span class="lineNum">    2592 </span>            :  * provided via the CompartmentOptions passed to JS_NewGlobalObject.
<span class="lineNum">    2593 </span>            :  */
<span class="lineNum">    2594 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    2595 </span>            : JS_GlobalObjectTraceHook(JSTracer* trc, JSObject* global);
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    2598 </span>            : JS_FireOnNewGlobalObject(JSContext* cx, JS::HandleObject global);
<span class="lineNum">    2599 </span>            : 
<span class="lineNum">    2600 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    2601 </span>            : JS_NewObject(JSContext* cx, const JSClass* clasp);
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2604 </span>            : JS_IsNative(JSObject* obj);
<span class="lineNum">    2605 </span>            : 
<span class="lineNum">    2606 </span>            : /**
<span class="lineNum">    2607 </span>            :  * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
<span class="lineNum">    2608 </span>            :  * proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].
<span class="lineNum">    2609 </span>            :  */
<span class="lineNum">    2610 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    2611 </span>            : JS_NewObjectWithGivenProto(JSContext* cx, const JSClass* clasp, JS::Handle&lt;JSObject*&gt; proto);
<span class="lineNum">    2612 </span>            : 
<span class="lineNum">    2613 </span>            : /** Creates a new plain object, like `new Object()`, with Object.prototype as [[Prototype]]. */
<span class="lineNum">    2614 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    2615 </span>            : JS_NewPlainObject(JSContext* cx);
<span class="lineNum">    2616 </span>            : 
<span class="lineNum">    2617 </span>            : /**
<span class="lineNum">    2618 </span>            :  * Freeze obj, and all objects it refers to, recursively. This will not recurse
<span class="lineNum">    2619 </span>            :  * through non-extensible objects, on the assumption that those are already
<span class="lineNum">    2620 </span>            :  * deep-frozen.
<span class="lineNum">    2621 </span>            :  */
<span class="lineNum">    2622 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2623 </span>            : JS_DeepFreezeObject(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj);
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span>            : /**
<span class="lineNum">    2626 </span>            :  * Freezes an object; see ES5's Object.freeze(obj) method.
<span class="lineNum">    2627 </span>            :  */
<span class="lineNum">    2628 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2629 </span>            : JS_FreezeObject(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj);
<span class="lineNum">    2630 </span>            : 
<span class="lineNum">    2631 </span>            : 
<span class="lineNum">    2632 </span>            : /*** Property descriptors ************************************************************************/
<span class="lineNum">    2633 </span>            : 
<span class="lineNum">    2634 </span>            : namespace JS {
<span class="lineNum">    2635 </span>            : 
<span class="lineNum">    2636 </span>            : struct JS_PUBLIC_API(PropertyDescriptor) {
<span class="lineNum">    2637 </span>            :     JSObject* obj;
<span class="lineNum">    2638 </span>            :     unsigned attrs;
<span class="lineNum">    2639 </span>            :     JSGetterOp getter;
<span class="lineNum">    2640 </span>            :     JSSetterOp setter;
<a name="2641"><span class="lineNum">    2641 </span>            :     JS::Value value;</a>
<span class="lineNum">    2642 </span>            : 
<span class="lineNum">    2643 </span><span class="lineCov">          1 :     PropertyDescriptor()</span>
<span class="lineNum">    2644 </span><span class="lineCov">          1 :       : obj(nullptr), attrs(0), getter(nullptr), setter(nullptr), value(JS::UndefinedValue())</span>
<span class="lineNum">    2645 </span><span class="lineCov">          1 :     {}</span>
<span class="lineNum">    2646 </span>            : 
<span class="lineNum">    2647 </span>            :     static void trace(PropertyDescriptor* self, JSTracer* trc) { self-&gt;trace(trc); }
<span class="lineNum">    2648 </span>            :     void trace(JSTracer* trc);
<span class="lineNum">    2649 </span>            : };
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span>            : } // namespace JS
<span class="lineNum">    2652 </span>            : 
<span class="lineNum">    2653 </span>            : namespace js {
<span class="lineNum">    2654 </span>            : 
<span class="lineNum">    2655 </span>            : template &lt;typename Wrapper&gt;
<span class="lineNum">    2656 </span>            : class WrappedPtrOperations&lt;JS::PropertyDescriptor, Wrapper&gt;
<span class="lineNum">    2657 </span>            : {
<span class="lineNum">    2658 </span>            :     const JS::PropertyDescriptor&amp; desc() const { return static_cast&lt;const Wrapper*&gt;(this)-&gt;get(); }
<span class="lineNum">    2659 </span>            : 
<span class="lineNum">    2660 </span>            :     bool has(unsigned bit) const {
<span class="lineNum">    2661 </span>            :         MOZ_ASSERT(bit != 0);
<span class="lineNum">    2662 </span>            :         MOZ_ASSERT((bit &amp; (bit - 1)) == 0);  // only a single bit
<span class="lineNum">    2663 </span><span class="lineCov">          1 :         return (desc().attrs &amp; bit) != 0;</span>
<span class="lineNum">    2664 </span>            :     }
<span class="lineNum">    2665 </span>            : 
<span class="lineNum">    2666 </span>            :     bool hasAny(unsigned bits) const {
<span class="lineNum">    2667 </span><span class="lineCov">          1 :         return (desc().attrs &amp; bits) != 0;</span>
<span class="lineNum">    2668 </span>            :     }
<span class="lineNum">    2669 </span>            : 
<span class="lineNum">    2670 </span>            :     bool hasAll(unsigned bits) const {
<span class="lineNum">    2671 </span>            :         return (desc().attrs &amp; bits) == bits;
<span class="lineNum">    2672 </span>            :     }
<span class="lineNum">    2673 </span>            : 
<span class="lineNum">    2674 </span>            :     // Non-API attributes bit used internally for arguments objects.
<span class="lineNum">    2675 </span>            :     enum { SHADOWABLE = JSPROP_INTERNAL_USE_BIT };
<span class="lineNum">    2676 </span>            : 
<span class="lineNum">    2677 </span>            :   public:
<span class="lineNum">    2678 </span>            :     // Descriptors with JSGetterOp/JSSetterOp are considered data
<span class="lineNum">    2679 </span>            :     // descriptors. It's complicated.
<span class="lineNum">    2680 </span>            :     bool isAccessorDescriptor() const { return hasAny(JSPROP_GETTER | JSPROP_SETTER); }
<span class="lineNum">    2681 </span>            :     bool isGenericDescriptor() const {
<span class="lineNum">    2682 </span>            :         return (desc().attrs&amp;
<span class="lineNum">    2683 </span>            :                 (JSPROP_GETTER | JSPROP_SETTER | JSPROP_IGNORE_READONLY | JSPROP_IGNORE_VALUE)) ==
<span class="lineNum">    2684 </span><span class="lineCov">          1 :                (JSPROP_IGNORE_READONLY | JSPROP_IGNORE_VALUE);</span>
<span class="lineNum">    2685 </span>            :     }
<span class="lineNum">    2686 </span><span class="lineCov">          1 :     bool isDataDescriptor() const { return !isAccessorDescriptor() &amp;&amp; !isGenericDescriptor(); }</span>
<span class="lineNum">    2687 </span>            : 
<span class="lineNum">    2688 </span>            :     bool hasConfigurable() const { return !has(JSPROP_IGNORE_PERMANENT); }
<span class="lineNum">    2689 </span><span class="lineCov">          1 :     bool configurable() const { MOZ_ASSERT(hasConfigurable()); return !has(JSPROP_PERMANENT); }</span>
<span class="lineNum">    2690 </span>            : 
<span class="lineNum">    2691 </span>            :     bool hasEnumerable() const { return !has(JSPROP_IGNORE_ENUMERATE); }
<span class="lineNum">    2692 </span>            :     bool enumerable() const { MOZ_ASSERT(hasEnumerable()); return has(JSPROP_ENUMERATE); }
<a name="2693"><span class="lineNum">    2693 </span>            : </a>
<span class="lineNum">    2694 </span><span class="lineCov">          1 :     bool hasValue() const { return !isAccessorDescriptor() &amp;&amp; !has(JSPROP_IGNORE_VALUE); }</span>
<span class="lineNum">    2695 </span><span class="lineCov">          1 :     JS::HandleValue value() const {</span>
<span class="lineNum">    2696 </span><span class="lineCov">          1 :         return JS::HandleValue::fromMarkedLocation(&amp;desc().value);</span>
<span class="lineNum">    2697 </span>            :     }
<span class="lineNum">    2698 </span>            : 
<span class="lineNum">    2699 </span><span class="lineCov">          1 :     bool hasWritable() const { return !isAccessorDescriptor() &amp;&amp; !has(JSPROP_IGNORE_READONLY); }</span>
<a name="2700"><span class="lineNum">    2700 </span><span class="lineCov">          1 :     bool writable() const { MOZ_ASSERT(hasWritable()); return !has(JSPROP_READONLY); }</span></a>
<span class="lineNum">    2701 </span>            : 
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :     bool hasGetterObject() const { return has(JSPROP_GETTER); }</span>
<span class="lineNum">    2703 </span>            :     JS::HandleObject getterObject() const {
<span class="lineNum">    2704 </span>            :         MOZ_ASSERT(hasGetterObject());
<span class="lineNum">    2705 </span>            :         return JS::HandleObject::fromMarkedLocation(
<a name="2706"><span class="lineNum">    2706 </span><span class="lineCov">          1 :                 reinterpret_cast&lt;JSObject* const*&gt;(&amp;desc().getter));</span></a>
<span class="lineNum">    2707 </span>            :     }
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :     bool hasSetterObject() const { return has(JSPROP_SETTER); }</span>
<span class="lineNum">    2709 </span>            :     JS::HandleObject setterObject() const {
<span class="lineNum">    2710 </span>            :         MOZ_ASSERT(hasSetterObject());
<span class="lineNum">    2711 </span>            :         return JS::HandleObject::fromMarkedLocation(
<span class="lineNum">    2712 </span><span class="lineCov">          1 :                 reinterpret_cast&lt;JSObject* const*&gt;(&amp;desc().setter));</span>
<span class="lineNum">    2713 </span>            :     }
<span class="lineNum">    2714 </span>            : 
<span class="lineNum">    2715 </span>            :     bool hasGetterOrSetter() const { return desc().getter || desc().setter; }
<span class="lineNum">    2716 </span>            :     bool isShared() const { return has(JSPROP_SHARED); }
<span class="lineNum">    2717 </span>            : 
<span class="lineNum">    2718 </span>            :     JS::HandleObject object() const {
<a name="2719"><span class="lineNum">    2719 </span><span class="lineCov">          1 :         return JS::HandleObject::fromMarkedLocation(&amp;desc().obj);</span></a>
<a name="2720"><span class="lineNum">    2720 </span>            :     }</a>
<a name="2721"><span class="lineNum">    2721 </span><span class="lineCov">          1 :     unsigned attributes() const { return desc().attrs; }</span></a>
<span class="lineNum">    2722 </span><span class="lineCov">          1 :     JSGetterOp getter() const { return desc().getter; }</span>
<span class="lineNum">    2723 </span><span class="lineCov">          1 :     JSSetterOp setter() const { return desc().setter; }</span>
<span class="lineNum">    2724 </span>            : 
<span class="lineNum">    2725 </span>            :     void assertValid() const {
<span class="lineNum">    2726 </span>            : #ifdef DEBUG
<span class="lineNum">    2727 </span>            :         MOZ_ASSERT((attributes() &amp; ~(JSPROP_ENUMERATE | JSPROP_IGNORE_ENUMERATE |
<span class="lineNum">    2728 </span>            :                                      JSPROP_PERMANENT | JSPROP_IGNORE_PERMANENT |
<span class="lineNum">    2729 </span>            :                                      JSPROP_READONLY | JSPROP_IGNORE_READONLY |
<span class="lineNum">    2730 </span>            :                                      JSPROP_IGNORE_VALUE |
<span class="lineNum">    2731 </span>            :                                      JSPROP_GETTER |
<span class="lineNum">    2732 </span>            :                                      JSPROP_SETTER |
<span class="lineNum">    2733 </span>            :                                      JSPROP_SHARED |
<span class="lineNum">    2734 </span>            :                                      JSPROP_REDEFINE_NONCONFIGURABLE |
<span class="lineNum">    2735 </span>            :                                      JSPROP_RESOLVING |
<span class="lineNum">    2736 </span>            :                                      SHADOWABLE)) == 0);
<span class="lineNum">    2737 </span>            :         MOZ_ASSERT(!hasAll(JSPROP_IGNORE_ENUMERATE | JSPROP_ENUMERATE));
<span class="lineNum">    2738 </span>            :         MOZ_ASSERT(!hasAll(JSPROP_IGNORE_PERMANENT | JSPROP_PERMANENT));
<span class="lineNum">    2739 </span>            :         if (isAccessorDescriptor()) {
<span class="lineNum">    2740 </span>            :             MOZ_ASSERT(has(JSPROP_SHARED));
<span class="lineNum">    2741 </span>            :             MOZ_ASSERT(!has(JSPROP_READONLY));
<span class="lineNum">    2742 </span>            :             MOZ_ASSERT(!has(JSPROP_IGNORE_READONLY));
<span class="lineNum">    2743 </span>            :             MOZ_ASSERT(!has(JSPROP_IGNORE_VALUE));
<span class="lineNum">    2744 </span>            :             MOZ_ASSERT(!has(SHADOWABLE));
<span class="lineNum">    2745 </span>            :             MOZ_ASSERT(value().isUndefined());
<span class="lineNum">    2746 </span>            :             MOZ_ASSERT_IF(!has(JSPROP_GETTER), !getter());
<span class="lineNum">    2747 </span>            :             MOZ_ASSERT_IF(!has(JSPROP_SETTER), !setter());
<span class="lineNum">    2748 </span>            :         } else {
<span class="lineNum">    2749 </span>            :             MOZ_ASSERT(!hasAll(JSPROP_IGNORE_READONLY | JSPROP_READONLY));
<span class="lineNum">    2750 </span>            :             MOZ_ASSERT_IF(has(JSPROP_IGNORE_VALUE), value().isUndefined());
<span class="lineNum">    2751 </span>            :         }
<span class="lineNum">    2752 </span>            :         MOZ_ASSERT(getter() != JS_PropertyStub);
<span class="lineNum">    2753 </span>            :         MOZ_ASSERT(setter() != JS_StrictPropertyStub);
<span class="lineNum">    2754 </span>            : 
<span class="lineNum">    2755 </span>            :         MOZ_ASSERT_IF(has(JSPROP_RESOLVING), !has(JSPROP_IGNORE_ENUMERATE));
<span class="lineNum">    2756 </span>            :         MOZ_ASSERT_IF(has(JSPROP_RESOLVING), !has(JSPROP_IGNORE_PERMANENT));
<span class="lineNum">    2757 </span>            :         MOZ_ASSERT_IF(has(JSPROP_RESOLVING), !has(JSPROP_IGNORE_READONLY));
<span class="lineNum">    2758 </span>            :         MOZ_ASSERT_IF(has(JSPROP_RESOLVING), !has(JSPROP_IGNORE_VALUE));
<span class="lineNum">    2759 </span>            :         MOZ_ASSERT_IF(has(JSPROP_RESOLVING), !has(JSPROP_REDEFINE_NONCONFIGURABLE));
<span class="lineNum">    2760 </span>            : #endif
<a name="2761"><span class="lineNum">    2761 </span>            :     }</a>
<span class="lineNum">    2762 </span>            : 
<span class="lineNum">    2763 </span><span class="lineCov">          1 :     void assertComplete() const {</span>
<span class="lineNum">    2764 </span>            : #ifdef DEBUG
<span class="lineNum">    2765 </span>            :         assertValid();
<span class="lineNum">    2766 </span>            :         MOZ_ASSERT((attributes() &amp; ~(JSPROP_ENUMERATE |
<span class="lineNum">    2767 </span>            :                                      JSPROP_PERMANENT |
<span class="lineNum">    2768 </span>            :                                      JSPROP_READONLY |
<span class="lineNum">    2769 </span>            :                                      JSPROP_GETTER |
<span class="lineNum">    2770 </span>            :                                      JSPROP_SETTER |
<span class="lineNum">    2771 </span>            :                                      JSPROP_SHARED |
<span class="lineNum">    2772 </span>            :                                      JSPROP_REDEFINE_NONCONFIGURABLE |
<span class="lineNum">    2773 </span>            :                                      JSPROP_RESOLVING |
<span class="lineNum">    2774 </span>            :                                      SHADOWABLE)) == 0);
<span class="lineNum">    2775 </span>            :         MOZ_ASSERT_IF(isAccessorDescriptor(), has(JSPROP_GETTER) &amp;&amp; has(JSPROP_SETTER));
<span class="lineNum">    2776 </span>            : #endif
<span class="lineNum">    2777 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span>            :     void assertCompleteIfFound() const {
<span class="lineNum">    2780 </span>            : #ifdef DEBUG
<span class="lineNum">    2781 </span>            :         if (object())
<span class="lineNum">    2782 </span>            :             assertComplete();
<span class="lineNum">    2783 </span>            : #endif
<span class="lineNum">    2784 </span>            :     }
<span class="lineNum">    2785 </span>            : };
<span class="lineNum">    2786 </span>            : 
<span class="lineNum">    2787 </span>            : template &lt;typename Wrapper&gt;
<span class="lineNum">    2788 </span>            : class MutableWrappedPtrOperations&lt;JS::PropertyDescriptor, Wrapper&gt;
<span class="lineNum">    2789 </span>            :     : public js::WrappedPtrOperations&lt;JS::PropertyDescriptor, Wrapper&gt;
<span class="lineNum">    2790 </span>            : {
<span class="lineNum">    2791 </span>            :     JS::PropertyDescriptor&amp; desc() { return static_cast&lt;Wrapper*&gt;(this)-&gt;get(); }
<span class="lineNum">    2792 </span>            : 
<span class="lineNum">    2793 </span>            :   public:
<span class="lineNum">    2794 </span>            :     void clear() {
<span class="lineNum">    2795 </span><span class="lineCov">          1 :         object().set(nullptr);</span>
<span class="lineNum">    2796 </span>            :         setAttributes(0);
<span class="lineNum">    2797 </span>            :         setGetter(nullptr);
<span class="lineNum">    2798 </span>            :         setSetter(nullptr);
<span class="lineNum">    2799 </span><span class="lineCov">          1 :         value().setUndefined();</span>
<span class="lineNum">    2800 </span>            :     }
<span class="lineNum">    2801 </span>            : 
<span class="lineNum">    2802 </span>            :     void initFields(JS::HandleObject obj, JS::HandleValue v, unsigned attrs,
<span class="lineNum">    2803 </span>            :                     JSGetterOp getterOp, JSSetterOp setterOp) {
<span class="lineNum">    2804 </span>            :         MOZ_ASSERT(getterOp != JS_PropertyStub);
<span class="lineNum">    2805 </span>            :         MOZ_ASSERT(setterOp != JS_StrictPropertyStub);
<span class="lineNum">    2806 </span>            : 
<span class="lineNum">    2807 </span><span class="lineCov">          1 :         object().set(obj);</span>
<span class="lineNum">    2808 </span><span class="lineCov">          1 :         value().set(v);</span>
<span class="lineNum">    2809 </span>            :         setAttributes(attrs);
<span class="lineNum">    2810 </span>            :         setGetter(getterOp);
<span class="lineNum">    2811 </span>            :         setSetter(setterOp);
<span class="lineNum">    2812 </span>            :     }
<span class="lineNum">    2813 </span>            : 
<span class="lineNum">    2814 </span>            :     void assign(JS::PropertyDescriptor&amp; other) {
<span class="lineNum">    2815 </span>            :         object().set(other.obj);
<span class="lineNum">    2816 </span>            :         setAttributes(other.attrs);
<span class="lineNum">    2817 </span>            :         setGetter(other.getter);
<span class="lineNum">    2818 </span>            :         setSetter(other.setter);
<span class="lineNum">    2819 </span>            :         value().set(other.value);
<span class="lineNum">    2820 </span>            :     }
<span class="lineNum">    2821 </span>            : 
<span class="lineNum">    2822 </span>            :     void setDataDescriptor(JS::HandleValue v, unsigned attrs) {
<span class="lineNum">    2823 </span>            :         MOZ_ASSERT((attrs &amp; ~(JSPROP_ENUMERATE |
<span class="lineNum">    2824 </span>            :                               JSPROP_PERMANENT |
<span class="lineNum">    2825 </span>            :                               JSPROP_READONLY |
<span class="lineNum">    2826 </span>            :                               JSPROP_IGNORE_ENUMERATE |
<span class="lineNum">    2827 </span>            :                               JSPROP_IGNORE_PERMANENT |
<span class="lineNum">    2828 </span>            :                               JSPROP_IGNORE_READONLY)) == 0);
<span class="lineNum">    2829 </span><span class="lineCov">          1 :         object().set(nullptr);</span>
<span class="lineNum">    2830 </span>            :         setAttributes(attrs);
<span class="lineNum">    2831 </span>            :         setGetter(nullptr);
<span class="lineNum">    2832 </span>            :         setSetter(nullptr);
<span class="lineNum">    2833 </span><span class="lineCov">          1 :         value().set(v);</span>
<span class="lineNum">    2834 </span>            :     }
<span class="lineNum">    2835 </span>            : 
<span class="lineNum">    2836 </span>            :     JS::MutableHandleObject object() {
<span class="lineNum">    2837 </span><span class="lineCov">          1 :         return JS::MutableHandleObject::fromMarkedLocation(&amp;desc().obj);</span>
<span class="lineNum">    2838 </span>            :     }
<span class="lineNum">    2839 </span>            :     unsigned&amp; attributesRef() { return desc().attrs; }
<span class="lineNum">    2840 </span>            :     JSGetterOp&amp; getter() { return desc().getter; }
<span class="lineNum">    2841 </span>            :     JSSetterOp&amp; setter() { return desc().setter; }
<span class="lineNum">    2842 </span>            :     JS::MutableHandleValue value() {
<span class="lineNum">    2843 </span><span class="lineCov">          1 :         return JS::MutableHandleValue::fromMarkedLocation(&amp;desc().value);</span>
<span class="lineNum">    2844 </span>            :     }
<span class="lineNum">    2845 </span>            :     void setValue(JS::HandleValue v) {
<span class="lineNum">    2846 </span>            :         MOZ_ASSERT(!(desc().attrs &amp; (JSPROP_GETTER | JSPROP_SETTER)));
<span class="lineNum">    2847 </span><span class="lineCov">          1 :         attributesRef() &amp;= ~JSPROP_IGNORE_VALUE;</span>
<span class="lineNum">    2848 </span><span class="lineCov">          1 :         value().set(v);</span>
<span class="lineNum">    2849 </span>            :     }
<span class="lineNum">    2850 </span>            : 
<span class="lineNum">    2851 </span>            :     void setConfigurable(bool configurable) {
<span class="lineNum">    2852 </span>            :         setAttributes((desc().attrs &amp; ~(JSPROP_IGNORE_PERMANENT | JSPROP_PERMANENT)) |
<span class="lineNum">    2853 </span><span class="lineCov">          1 :                       (configurable ? 0 : JSPROP_PERMANENT));</span>
<span class="lineNum">    2854 </span>            :     }
<span class="lineNum">    2855 </span>            :     void setEnumerable(bool enumerable) {
<span class="lineNum">    2856 </span>            :         setAttributes((desc().attrs &amp; ~(JSPROP_IGNORE_ENUMERATE | JSPROP_ENUMERATE)) |
<span class="lineNum">    2857 </span><span class="lineCov">          1 :                       (enumerable ? JSPROP_ENUMERATE : 0));</span>
<span class="lineNum">    2858 </span>            :     }
<span class="lineNum">    2859 </span>            :     void setWritable(bool writable) {
<span class="lineNum">    2860 </span>            :         MOZ_ASSERT(!(desc().attrs &amp; (JSPROP_GETTER | JSPROP_SETTER)));
<span class="lineNum">    2861 </span>            :         setAttributes((desc().attrs &amp; ~(JSPROP_IGNORE_READONLY | JSPROP_READONLY)) |
<span class="lineNum">    2862 </span><span class="lineCov">          1 :                       (writable ? 0 : JSPROP_READONLY));</span>
<span class="lineNum">    2863 </span>            :     }
<span class="lineNum">    2864 </span><span class="lineCov">          1 :     void setAttributes(unsigned attrs) { desc().attrs = attrs; }</span>
<span class="lineNum">    2865 </span>            : 
<span class="lineNum">    2866 </span>            :     void setGetter(JSGetterOp op) {
<span class="lineNum">    2867 </span>            :         MOZ_ASSERT(op != JS_PropertyStub);
<span class="lineNum">    2868 </span><span class="lineCov">          1 :         desc().getter = op;</span>
<span class="lineNum">    2869 </span>            :     }
<span class="lineNum">    2870 </span>            :     void setSetter(JSSetterOp op) {
<span class="lineNum">    2871 </span>            :         MOZ_ASSERT(op != JS_StrictPropertyStub);
<span class="lineNum">    2872 </span><span class="lineCov">          1 :         desc().setter = op;</span>
<span class="lineNum">    2873 </span>            :     }
<span class="lineNum">    2874 </span>            :     void setGetterObject(JSObject* obj) {
<span class="lineNum">    2875 </span><span class="lineCov">          1 :         desc().getter = reinterpret_cast&lt;JSGetterOp&gt;(obj);</span>
<span class="lineNum">    2876 </span><span class="lineCov">          1 :         desc().attrs &amp;= ~(JSPROP_IGNORE_VALUE | JSPROP_IGNORE_READONLY | JSPROP_READONLY);</span>
<span class="lineNum">    2877 </span><span class="lineCov">          1 :         desc().attrs |= JSPROP_GETTER | JSPROP_SHARED;</span>
<span class="lineNum">    2878 </span>            :     }
<span class="lineNum">    2879 </span>            :     void setSetterObject(JSObject* obj) {
<span class="lineNum">    2880 </span><span class="lineCov">          1 :         desc().setter = reinterpret_cast&lt;JSSetterOp&gt;(obj);</span>
<span class="lineNum">    2881 </span><span class="lineCov">          1 :         desc().attrs &amp;= ~(JSPROP_IGNORE_VALUE | JSPROP_IGNORE_READONLY | JSPROP_READONLY);</span>
<span class="lineNum">    2882 </span><span class="lineCov">          1 :         desc().attrs |= JSPROP_SETTER | JSPROP_SHARED;</span>
<span class="lineNum">    2883 </span>            :     }
<span class="lineNum">    2884 </span>            : 
<span class="lineNum">    2885 </span>            :     JS::MutableHandleObject getterObject() {
<span class="lineNum">    2886 </span>            :         MOZ_ASSERT(this-&gt;hasGetterObject());
<span class="lineNum">    2887 </span>            :         return JS::MutableHandleObject::fromMarkedLocation(
<span class="lineNum">    2888 </span><span class="lineCov">          1 :                 reinterpret_cast&lt;JSObject**&gt;(&amp;desc().getter));</span>
<span class="lineNum">    2889 </span>            :     }
<span class="lineNum">    2890 </span>            :     JS::MutableHandleObject setterObject() {
<span class="lineNum">    2891 </span>            :         MOZ_ASSERT(this-&gt;hasSetterObject());
<span class="lineNum">    2892 </span>            :         return JS::MutableHandleObject::fromMarkedLocation(
<span class="lineNum">    2893 </span><span class="lineCov">          1 :                 reinterpret_cast&lt;JSObject**&gt;(&amp;desc().setter));</span>
<span class="lineNum">    2894 </span>            :     }
<span class="lineNum">    2895 </span>            : };
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span>            : } // namespace js
<span class="lineNum">    2898 </span>            : 
<span class="lineNum">    2899 </span>            : namespace JS {
<span class="lineNum">    2900 </span>            : 
<span class="lineNum">    2901 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2902 </span>            : ObjectToCompletePropertyDescriptor(JSContext* cx,
<span class="lineNum">    2903 </span>            :                                    JS::HandleObject obj,
<span class="lineNum">    2904 </span>            :                                    JS::HandleValue descriptor,
<span class="lineNum">    2905 </span>            :                                    JS::MutableHandle&lt;PropertyDescriptor&gt; desc);
<span class="lineNum">    2906 </span>            : 
<span class="lineNum">    2907 </span>            : /*
<span class="lineNum">    2908 </span>            :  * ES6 draft rev 32 (2015 Feb 2) 6.2.4.4 FromPropertyDescriptor(Desc).
<span class="lineNum">    2909 </span>            :  *
<span class="lineNum">    2910 </span>            :  * If desc.object() is null, then vp is set to undefined.
<span class="lineNum">    2911 </span>            :  */
<span class="lineNum">    2912 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2913 </span>            : FromPropertyDescriptor(JSContext* cx,
<span class="lineNum">    2914 </span>            :                        JS::Handle&lt;JS::PropertyDescriptor&gt; desc,
<span class="lineNum">    2915 </span>            :                        JS::MutableHandleValue vp);
<span class="lineNum">    2916 </span>            : 
<span class="lineNum">    2917 </span>            : } // namespace JS
<span class="lineNum">    2918 </span>            : 
<span class="lineNum">    2919 </span>            : 
<span class="lineNum">    2920 </span>            : /*** Standard internal methods ********************************************************************
<span class="lineNum">    2921 </span>            :  *
<span class="lineNum">    2922 </span>            :  * The functions below are the fundamental operations on objects.
<span class="lineNum">    2923 </span>            :  *
<span class="lineNum">    2924 </span>            :  * ES6 specifies 14 internal methods that define how objects behave.  The
<span class="lineNum">    2925 </span>            :  * standard is actually quite good on this topic, though you may have to read
<span class="lineNum">    2926 </span>            :  * it a few times. See ES6 sections 6.1.7.2 and 6.1.7.3.
<span class="lineNum">    2927 </span>            :  *
<span class="lineNum">    2928 </span>            :  * When 'obj' is an ordinary object, these functions have boring standard
<span class="lineNum">    2929 </span>            :  * behavior as specified by ES6 section 9.1; see the section about internal
<span class="lineNum">    2930 </span>            :  * methods in js/src/vm/NativeObject.h.
<span class="lineNum">    2931 </span>            :  *
<span class="lineNum">    2932 </span>            :  * Proxies override the behavior of internal methods. So when 'obj' is a proxy,
<span class="lineNum">    2933 </span>            :  * any one of the functions below could do just about anything. See
<span class="lineNum">    2934 </span>            :  * js/public/Proxy.h.
<span class="lineNum">    2935 </span>            :  */
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span>            : /**
<span class="lineNum">    2938 </span>            :  * Get the prototype of obj, storing it in result.
<span class="lineNum">    2939 </span>            :  *
<span class="lineNum">    2940 </span>            :  * Implements: ES6 [[GetPrototypeOf]] internal method.
<span class="lineNum">    2941 </span>            :  */
<span class="lineNum">    2942 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2943 </span>            : JS_GetPrototype(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject result);
<span class="lineNum">    2944 </span>            : 
<span class="lineNum">    2945 </span>            : /**
<span class="lineNum">    2946 </span>            :  * If |obj| (underneath any functionally-transparent wrapper proxies) has as
<span class="lineNum">    2947 </span>            :  * its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined
<span class="lineNum">    2948 </span>            :  * for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype
<span class="lineNum">    2949 </span>            :  * in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both
<span class="lineNum">    2950 </span>            :  * outparams have unspecified value.
<span class="lineNum">    2951 </span>            :  */
<span class="lineNum">    2952 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2953 </span>            : JS_GetPrototypeIfOrdinary(JSContext* cx, JS::HandleObject obj, bool* isOrdinary,
<span class="lineNum">    2954 </span>            :                           JS::MutableHandleObject result);
<span class="lineNum">    2955 </span>            : 
<span class="lineNum">    2956 </span>            : /**
<span class="lineNum">    2957 </span>            :  * Change the prototype of obj.
<span class="lineNum">    2958 </span>            :  *
<span class="lineNum">    2959 </span>            :  * Implements: ES6 [[SetPrototypeOf]] internal method.
<span class="lineNum">    2960 </span>            :  *
<span class="lineNum">    2961 </span>            :  * In cases where ES6 [[SetPrototypeOf]] returns false without an exception,
<span class="lineNum">    2962 </span>            :  * JS_SetPrototype throws a TypeError and returns false.
<span class="lineNum">    2963 </span>            :  *
<span class="lineNum">    2964 </span>            :  * Performance warning: JS_SetPrototype is very bad for performance. It may
<span class="lineNum">    2965 </span>            :  * cause compiled jit-code to be invalidated. It also causes not only obj but
<span class="lineNum">    2966 </span>            :  * all other objects in the same &quot;group&quot; as obj to be permanently deoptimized.
<span class="lineNum">    2967 </span>            :  * It's better to create the object with the right prototype from the start.
<span class="lineNum">    2968 </span>            :  */
<span class="lineNum">    2969 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2970 </span>            : JS_SetPrototype(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);
<span class="lineNum">    2971 </span>            : 
<span class="lineNum">    2972 </span>            : /**
<span class="lineNum">    2973 </span>            :  * Determine whether obj is extensible. Extensible objects can have new
<span class="lineNum">    2974 </span>            :  * properties defined on them. Inextensible objects can't, and their
<span class="lineNum">    2975 </span>            :  * [[Prototype]] slot is fixed as well.
<span class="lineNum">    2976 </span>            :  *
<span class="lineNum">    2977 </span>            :  * Implements: ES6 [[IsExtensible]] internal method.
<span class="lineNum">    2978 </span>            :  */
<span class="lineNum">    2979 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2980 </span>            : JS_IsExtensible(JSContext* cx, JS::HandleObject obj, bool* extensible);
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span>            : /**
<span class="lineNum">    2983 </span>            :  * Attempt to make |obj| non-extensible.
<span class="lineNum">    2984 </span>            :  *
<span class="lineNum">    2985 </span>            :  * Not all failures are treated as errors. See the comment on
<span class="lineNum">    2986 </span>            :  * JS::ObjectOpResult in js/public/Class.h.
<span class="lineNum">    2987 </span>            :  *
<span class="lineNum">    2988 </span>            :  * Implements: ES6 [[PreventExtensions]] internal method.
<span class="lineNum">    2989 </span>            :  */
<span class="lineNum">    2990 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    2991 </span>            : JS_PreventExtensions(JSContext* cx, JS::HandleObject obj, JS::ObjectOpResult&amp; result);
<span class="lineNum">    2992 </span>            : 
<span class="lineNum">    2993 </span>            : /**
<span class="lineNum">    2994 </span>            :  * Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt
<span class="lineNum">    2995 </span>            :  * to modify it will fail.  If an error occurs during the attempt, return false
<span class="lineNum">    2996 </span>            :  * (with a pending exception set, depending upon the nature of the error).  If
<span class="lineNum">    2997 </span>            :  * no error occurs, return true with |*succeeded| set to indicate whether the
<span class="lineNum">    2998 </span>            :  * attempt successfully made the [[Prototype]] immutable.
<span class="lineNum">    2999 </span>            :  *
<span class="lineNum">    3000 </span>            :  * This is a nonstandard internal method.
<span class="lineNum">    3001 </span>            :  */
<span class="lineNum">    3002 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3003 </span>            : JS_SetImmutablePrototype(JSContext* cx, JS::HandleObject obj, bool* succeeded);
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span>            : /**
<span class="lineNum">    3006 </span>            :  * Get a description of one of obj's own properties. If no such property exists
<span class="lineNum">    3007 </span>            :  * on obj, return true with desc.object() set to null.
<span class="lineNum">    3008 </span>            :  *
<span class="lineNum">    3009 </span>            :  * Implements: ES6 [[GetOwnProperty]] internal method.
<span class="lineNum">    3010 </span>            :  */
<span class="lineNum">    3011 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3012 </span>            : JS_GetOwnPropertyDescriptorById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3013 </span>            :                                 JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3014 </span>            : 
<span class="lineNum">    3015 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3016 </span>            : JS_GetOwnPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char* name,
<span class="lineNum">    3017 </span>            :                             JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3018 </span>            : 
<span class="lineNum">    3019 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3020 </span>            : JS_GetOwnUCPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char16_t* name,
<span class="lineNum">    3021 </span>            :                               JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3022 </span>            : 
<span class="lineNum">    3023 </span>            : /**
<span class="lineNum">    3024 </span>            :  * Like JS_GetOwnPropertyDescriptorById, but also searches the prototype chain
<span class="lineNum">    3025 </span>            :  * if no own property is found directly on obj. The object on which the
<span class="lineNum">    3026 </span>            :  * property is found is returned in desc.object(). If the property is not found
<span class="lineNum">    3027 </span>            :  * on the prototype chain, this returns true with desc.object() set to null.
<span class="lineNum">    3028 </span>            :  */
<span class="lineNum">    3029 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3030 </span>            : JS_GetPropertyDescriptorById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3031 </span>            :                              JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3034 </span>            : JS_GetPropertyDescriptor(JSContext* cx, JS::HandleObject obj, const char* name,
<span class="lineNum">    3035 </span>            :                          JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3036 </span>            : 
<span class="lineNum">    3037 </span>            : /**
<span class="lineNum">    3038 </span>            :  * Define a property on obj.
<span class="lineNum">    3039 </span>            :  *
<span class="lineNum">    3040 </span>            :  * This function uses JS::ObjectOpResult to indicate conditions that ES6
<span class="lineNum">    3041 </span>            :  * specifies as non-error failures. This is inconvenient at best, so use this
<span class="lineNum">    3042 </span>            :  * function only if you are implementing a proxy handler's defineProperty()
<span class="lineNum">    3043 </span>            :  * method. For all other purposes, use one of the many DefineProperty functions
<span class="lineNum">    3044 </span>            :  * below that throw an exception in all failure cases.
<span class="lineNum">    3045 </span>            :  *
<span class="lineNum">    3046 </span>            :  * Implements: ES6 [[DefineOwnProperty]] internal method.
<span class="lineNum">    3047 </span>            :  */
<span class="lineNum">    3048 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3049 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3050 </span>            :                       JS::Handle&lt;JS::PropertyDescriptor&gt; desc,
<span class="lineNum">    3051 </span>            :                       JS::ObjectOpResult&amp; result);
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span>            : /**
<span class="lineNum">    3054 </span>            :  * Define a property on obj, throwing a TypeError if the attempt fails.
<span class="lineNum">    3055 </span>            :  * This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`.
<span class="lineNum">    3056 </span>            :  */
<span class="lineNum">    3057 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3058 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3059 </span>            :                       JS::Handle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3060 </span>            : 
<span class="lineNum">    3061 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3062 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue value,
<span class="lineNum">    3063 </span>            :                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3064 </span>            : 
<span class="lineNum">    3065 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3066 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleObject value,
<span class="lineNum">    3067 </span>            :                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3068 </span>            : 
<span class="lineNum">    3069 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3070 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleString value,
<span class="lineNum">    3071 </span>            :                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3074 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, int32_t value,
<span class="lineNum">    3075 </span>            :                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3076 </span>            : 
<span class="lineNum">    3077 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3078 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, uint32_t value,
<span class="lineNum">    3079 </span>            :                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3080 </span>            : 
<span class="lineNum">    3081 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3082 </span>            : JS_DefinePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, double value,
<span class="lineNum">    3083 </span>            :                       unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3084 </span>            : 
<span class="lineNum">    3085 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3086 </span>            : JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleValue value,
<span class="lineNum">    3087 </span>            :                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3090 </span>            : JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleObject value,
<span class="lineNum">    3091 </span>            :                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3092 </span>            : 
<span class="lineNum">    3093 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3094 </span>            : JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleString value,
<span class="lineNum">    3095 </span>            :                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3096 </span>            : 
<span class="lineNum">    3097 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3098 </span>            : JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, int32_t value,
<span class="lineNum">    3099 </span>            :                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3100 </span>            : 
<span class="lineNum">    3101 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3102 </span>            : JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, uint32_t value,
<span class="lineNum">    3103 </span>            :                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3104 </span>            : 
<span class="lineNum">    3105 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3106 </span>            : JS_DefineProperty(JSContext* cx, JS::HandleObject obj, const char* name, double value,
<span class="lineNum">    3107 </span>            :                   unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3108 </span>            : 
<span class="lineNum">    3109 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3110 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3111 </span>            :                     JS::Handle&lt;JS::PropertyDescriptor&gt; desc,
<span class="lineNum">    3112 </span>            :                     JS::ObjectOpResult&amp; result);
<span class="lineNum">    3113 </span>            : 
<span class="lineNum">    3114 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3115 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3116 </span>            :                     JS::Handle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3119 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3120 </span>            :                     JS::HandleValue value, unsigned attrs,
<span class="lineNum">    3121 </span>            :                     JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3122 </span>            : 
<span class="lineNum">    3123 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3124 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3125 </span>            :                     JS::HandleObject value, unsigned attrs,
<span class="lineNum">    3126 </span>            :                     JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3129 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3130 </span>            :                     JS::HandleString value, unsigned attrs,
<span class="lineNum">    3131 </span>            :                     JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3132 </span>            : 
<span class="lineNum">    3133 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3134 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3135 </span>            :                     int32_t value, unsigned attrs,
<span class="lineNum">    3136 </span>            :                     JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3139 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3140 </span>            :                     uint32_t value, unsigned attrs,
<span class="lineNum">    3141 </span>            :                     JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3142 </span>            : 
<span class="lineNum">    3143 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3144 </span>            : JS_DefineUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3145 </span>            :                     double value, unsigned attrs,
<span class="lineNum">    3146 </span>            :                     JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3149 </span>            : JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleValue value,
<span class="lineNum">    3150 </span>            :                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3153 </span>            : JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleObject value,
<span class="lineNum">    3154 </span>            :                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3157 </span>            : JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleString value,
<span class="lineNum">    3158 </span>            :                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3159 </span>            : 
<span class="lineNum">    3160 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3161 </span>            : JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, int32_t value,
<span class="lineNum">    3162 </span>            :                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3163 </span>            : 
<span class="lineNum">    3164 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3165 </span>            : JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, uint32_t value,
<span class="lineNum">    3166 </span>            :                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3167 </span>            : 
<span class="lineNum">    3168 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3169 </span>            : JS_DefineElement(JSContext* cx, JS::HandleObject obj, uint32_t index, double value,
<span class="lineNum">    3170 </span>            :                  unsigned attrs, JSNative getter = nullptr, JSNative setter = nullptr);
<span class="lineNum">    3171 </span>            : 
<span class="lineNum">    3172 </span>            : /**
<span class="lineNum">    3173 </span>            :  * Compute the expression `id in obj`.
<span class="lineNum">    3174 </span>            :  *
<span class="lineNum">    3175 </span>            :  * If obj has an own or inherited property obj[id], set *foundp = true and
<span class="lineNum">    3176 </span>            :  * return true. If not, set *foundp = false and return true. On error, return
<span class="lineNum">    3177 </span>            :  * false with an exception pending.
<span class="lineNum">    3178 </span>            :  *
<span class="lineNum">    3179 </span>            :  * Implements: ES6 [[Has]] internal method.
<span class="lineNum">    3180 </span>            :  */
<span class="lineNum">    3181 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3182 </span>            : JS_HasPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3185 </span>            : JS_HasProperty(JSContext* cx, JS::HandleObject obj, const char* name, bool* foundp);
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3188 </span>            : JS_HasUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3189 </span>            :                  bool* vp);
<span class="lineNum">    3190 </span>            : 
<span class="lineNum">    3191 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3192 </span>            : JS_HasElement(JSContext* cx, JS::HandleObject obj, uint32_t index, bool* foundp);
<span class="lineNum">    3193 </span>            : 
<span class="lineNum">    3194 </span>            : /**
<span class="lineNum">    3195 </span>            :  * Determine whether obj has an own property with the key `id`.
<span class="lineNum">    3196 </span>            :  *
<span class="lineNum">    3197 </span>            :  * Implements: ES6 7.3.11 HasOwnProperty(O, P).
<span class="lineNum">    3198 </span>            :  */
<span class="lineNum">    3199 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3200 </span>            : JS_HasOwnPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, bool* foundp);
<span class="lineNum">    3201 </span>            : 
<span class="lineNum">    3202 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3203 </span>            : JS_HasOwnProperty(JSContext* cx, JS::HandleObject obj, const char* name, bool* foundp);
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span>            : /**
<span class="lineNum">    3206 </span>            :  * Get the value of the property `obj[id]`, or undefined if no such property
<span class="lineNum">    3207 </span>            :  * exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.
<span class="lineNum">    3208 </span>            :  *
<span class="lineNum">    3209 </span>            :  * Most callers don't need the `receiver` argument. Consider using
<span class="lineNum">    3210 </span>            :  * JS_GetProperty instead. (But if you're implementing a proxy handler's set()
<span class="lineNum">    3211 </span>            :  * method, it's often correct to call this function and pass the receiver
<span class="lineNum">    3212 </span>            :  * through.)
<span class="lineNum">    3213 </span>            :  *
<span class="lineNum">    3214 </span>            :  * Implements: ES6 [[Get]] internal method.
<span class="lineNum">    3215 </span>            :  */
<span class="lineNum">    3216 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3217 </span>            : JS_ForwardGetPropertyTo(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3218 </span>            :                         JS::HandleValue receiver, JS::MutableHandleValue vp);
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3221 </span>            : JS_ForwardGetElementTo(JSContext* cx, JS::HandleObject obj, uint32_t index,
<span class="lineNum">    3222 </span>            :                        JS::HandleObject receiver, JS::MutableHandleValue vp);
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span>            : /**
<span class="lineNum">    3225 </span>            :  * Get the value of the property `obj[id]`, or undefined if no such property
<span class="lineNum">    3226 </span>            :  * exists. The result is stored in vp.
<span class="lineNum">    3227 </span>            :  *
<span class="lineNum">    3228 </span>            :  * Implements: ES6 7.3.1 Get(O, P).
<span class="lineNum">    3229 </span>            :  */
<span class="lineNum">    3230 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3231 </span>            : JS_GetPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3232 </span>            :                    JS::MutableHandleValue vp);
<span class="lineNum">    3233 </span>            : 
<span class="lineNum">    3234 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3235 </span>            : JS_GetProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::MutableHandleValue vp);
<span class="lineNum">    3236 </span>            : 
<span class="lineNum">    3237 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3238 </span>            : JS_GetUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3239 </span>            :                  JS::MutableHandleValue vp);
<span class="lineNum">    3240 </span>            : 
<span class="lineNum">    3241 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3242 </span>            : JS_GetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::MutableHandleValue vp);
<span class="lineNum">    3243 </span>            : 
<span class="lineNum">    3244 </span>            : /**
<span class="lineNum">    3245 </span>            :  * Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.
<span class="lineNum">    3246 </span>            :  *
<span class="lineNum">    3247 </span>            :  * This function has a `receiver` argument that most callers don't need.
<span class="lineNum">    3248 </span>            :  * Consider using JS_SetProperty instead.
<span class="lineNum">    3249 </span>            :  *
<span class="lineNum">    3250 </span>            :  * Implements: ES6 [[Set]] internal method.
<span class="lineNum">    3251 </span>            :  */
<span class="lineNum">    3252 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3253 </span>            : JS_ForwardSetPropertyTo(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v,
<span class="lineNum">    3254 </span>            :                         JS::HandleValue receiver, JS::ObjectOpResult&amp; result);
<span class="lineNum">    3255 </span>            : 
<span class="lineNum">    3256 </span>            : /**
<span class="lineNum">    3257 </span>            :  * Perform the assignment `obj[id] = v`.
<span class="lineNum">    3258 </span>            :  *
<span class="lineNum">    3259 </span>            :  * This function performs non-strict assignment, so if the property is
<span class="lineNum">    3260 </span>            :  * read-only, nothing happens and no error is thrown.
<span class="lineNum">    3261 </span>            :  */
<span class="lineNum">    3262 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3263 </span>            : JS_SetPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id, JS::HandleValue v);
<span class="lineNum">    3264 </span>            : 
<span class="lineNum">    3265 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3266 </span>            : JS_SetProperty(JSContext* cx, JS::HandleObject obj, const char* name, JS::HandleValue v);
<span class="lineNum">    3267 </span>            : 
<span class="lineNum">    3268 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3269 </span>            : JS_SetUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3270 </span>            :                  JS::HandleValue v);
<span class="lineNum">    3271 </span>            : 
<span class="lineNum">    3272 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3273 </span>            : JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleValue v);
<span class="lineNum">    3274 </span>            : 
<span class="lineNum">    3275 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3276 </span>            : JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleObject v);
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3279 </span>            : JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::HandleString v);
<span class="lineNum">    3280 </span>            : 
<span class="lineNum">    3281 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3282 </span>            : JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, int32_t v);
<span class="lineNum">    3283 </span>            : 
<span class="lineNum">    3284 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3285 </span>            : JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, uint32_t v);
<span class="lineNum">    3286 </span>            : 
<span class="lineNum">    3287 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3288 </span>            : JS_SetElement(JSContext* cx, JS::HandleObject obj, uint32_t index, double v);
<span class="lineNum">    3289 </span>            : 
<span class="lineNum">    3290 </span>            : /**
<span class="lineNum">    3291 </span>            :  * Delete a property. This is the C++ equivalent of
<span class="lineNum">    3292 </span>            :  * `result = Reflect.deleteProperty(obj, id)`.
<span class="lineNum">    3293 </span>            :  *
<span class="lineNum">    3294 </span>            :  * This function has a `result` out parameter that most callers don't need.
<span class="lineNum">    3295 </span>            :  * Unless you can pass through an ObjectOpResult provided by your caller, it's
<span class="lineNum">    3296 </span>            :  * probably best to use the JS_DeletePropertyById signature with just 3
<span class="lineNum">    3297 </span>            :  * arguments.
<span class="lineNum">    3298 </span>            :  *
<span class="lineNum">    3299 </span>            :  * Implements: ES6 [[Delete]] internal method.
<span class="lineNum">    3300 </span>            :  */
<span class="lineNum">    3301 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3302 </span>            : JS_DeletePropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3303 </span>            :                       JS::ObjectOpResult&amp; result);
<span class="lineNum">    3304 </span>            : 
<span class="lineNum">    3305 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3306 </span>            : JS_DeleteProperty(JSContext* cx, JS::HandleObject obj, const char* name,
<span class="lineNum">    3307 </span>            :                   JS::ObjectOpResult&amp; result);
<span class="lineNum">    3308 </span>            : 
<span class="lineNum">    3309 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3310 </span>            : JS_DeleteUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name, size_t namelen,
<span class="lineNum">    3311 </span>            :                     JS::ObjectOpResult&amp; result);
<span class="lineNum">    3312 </span>            : 
<span class="lineNum">    3313 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3314 </span>            : JS_DeleteElement(JSContext* cx, JS::HandleObject obj, uint32_t index, JS::ObjectOpResult&amp; result);
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span>            : /**
<span class="lineNum">    3317 </span>            :  * Delete a property, ignoring strict failures. This is the C++ equivalent of
<span class="lineNum">    3318 </span>            :  * the JS `delete obj[id]` in non-strict mode code.
<span class="lineNum">    3319 </span>            :  */
<span class="lineNum">    3320 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3321 </span>            : JS_DeletePropertyById(JSContext* cx, JS::HandleObject obj, jsid id);
<span class="lineNum">    3322 </span>            : 
<span class="lineNum">    3323 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3324 </span>            : JS_DeleteProperty(JSContext* cx, JS::HandleObject obj, const char* name);
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3327 </span>            : JS_DeleteElement(JSContext* cx, JS::HandleObject obj, uint32_t index);
<span class="lineNum">    3328 </span>            : 
<span class="lineNum">    3329 </span>            : /**
<span class="lineNum">    3330 </span>            :  * Get an array of the non-symbol enumerable properties of obj.
<span class="lineNum">    3331 </span>            :  * This function is roughly equivalent to:
<span class="lineNum">    3332 </span>            :  *
<span class="lineNum">    3333 </span>            :  *     var result = [];
<span class="lineNum">    3334 </span>            :  *     for (key in obj)
<span class="lineNum">    3335 </span>            :  *         result.push(key);
<span class="lineNum">    3336 </span>            :  *     return result;
<span class="lineNum">    3337 </span>            :  *
<span class="lineNum">    3338 </span>            :  * This is the closest thing we currently have to the ES6 [[Enumerate]]
<span class="lineNum">    3339 </span>            :  * internal method.
<span class="lineNum">    3340 </span>            :  *
<span class="lineNum">    3341 </span>            :  * The array of ids returned by JS_Enumerate must be rooted to protect its
<span class="lineNum">    3342 </span>            :  * contents from garbage collection. Use JS::Rooted&lt;JS::IdVector&gt;.
<span class="lineNum">    3343 </span>            :  */
<span class="lineNum">    3344 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3345 </span>            : JS_Enumerate(JSContext* cx, JS::HandleObject obj, JS::MutableHandle&lt;JS::IdVector&gt; props);
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span>            : /*
<span class="lineNum">    3348 </span>            :  * API for determining callability and constructability. [[Call]] and
<span class="lineNum">    3349 </span>            :  * [[Construct]] are internal methods that aren't present on all objects, so it
<span class="lineNum">    3350 </span>            :  * is useful to ask if they are there or not. The standard itself asks these
<span class="lineNum">    3351 </span>            :  * questions routinely.
<span class="lineNum">    3352 </span>            :  */
<span class="lineNum">    3353 </span>            : namespace JS {
<span class="lineNum">    3354 </span>            : 
<span class="lineNum">    3355 </span>            : /**
<span class="lineNum">    3356 </span>            :  * Return true if the given object is callable. In ES6 terms, an object is
<span class="lineNum">    3357 </span>            :  * callable if it has a [[Call]] internal method.
<span class="lineNum">    3358 </span>            :  *
<span class="lineNum">    3359 </span>            :  * Implements: ES6 7.2.3 IsCallable(argument).
<span class="lineNum">    3360 </span>            :  *
<span class="lineNum">    3361 </span>            :  * Functions are callable. A scripted proxy or wrapper is callable if its
<span class="lineNum">    3362 </span>            :  * target is callable. Most other objects aren't callable.
<span class="lineNum">    3363 </span>            :  */
<span class="lineNum">    3364 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3365 </span>            : IsCallable(JSObject* obj);
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span>            : /**
<span class="lineNum">    3368 </span>            :  * Return true if the given object is a constructor. In ES6 terms, an object is
<span class="lineNum">    3369 </span>            :  * a constructor if it has a [[Construct]] internal method. The expression
<span class="lineNum">    3370 </span>            :  * `new obj()` throws a TypeError if obj is not a constructor.
<span class="lineNum">    3371 </span>            :  *
<span class="lineNum">    3372 </span>            :  * Implements: ES6 7.2.4 IsConstructor(argument).
<span class="lineNum">    3373 </span>            :  *
<span class="lineNum">    3374 </span>            :  * JS functions and classes are constructors. Arrow functions and most builtin
<span class="lineNum">    3375 </span>            :  * functions are not. A scripted proxy or wrapper is a constructor if its
<span class="lineNum">    3376 </span>            :  * target is a constructor.
<span class="lineNum">    3377 </span>            :  */
<span class="lineNum">    3378 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3379 </span>            : IsConstructor(JSObject* obj);
<span class="lineNum">    3380 </span>            : 
<span class="lineNum">    3381 </span>            : } /* namespace JS */
<span class="lineNum">    3382 </span>            : 
<span class="lineNum">    3383 </span>            : /**
<span class="lineNum">    3384 </span>            :  * Call a function, passing a this-value and arguments. This is the C++
<span class="lineNum">    3385 </span>            :  * equivalent of `rval = Reflect.apply(fun, obj, args)`.
<span class="lineNum">    3386 </span>            :  *
<span class="lineNum">    3387 </span>            :  * Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
<span class="lineNum">    3388 </span>            :  * Use this function to invoke the [[Call]] internal method.
<span class="lineNum">    3389 </span>            :  */
<span class="lineNum">    3390 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3391 </span>            : JS_CallFunctionValue(JSContext* cx, JS::HandleObject obj, JS::HandleValue fval,
<span class="lineNum">    3392 </span>            :                      const JS::HandleValueArray&amp; args, JS::MutableHandleValue rval);
<span class="lineNum">    3393 </span>            : 
<span class="lineNum">    3394 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3395 </span>            : JS_CallFunction(JSContext* cx, JS::HandleObject obj, JS::HandleFunction fun,
<span class="lineNum">    3396 </span>            :                 const JS::HandleValueArray&amp; args, JS::MutableHandleValue rval);
<span class="lineNum">    3397 </span>            : 
<span class="lineNum">    3398 </span>            : /**
<span class="lineNum">    3399 </span>            :  * Perform the method call `rval = obj[name](args)`.
<span class="lineNum">    3400 </span>            :  */
<span class="lineNum">    3401 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3402 </span>            : JS_CallFunctionName(JSContext* cx, JS::HandleObject obj, const char* name,
<span class="lineNum">    3403 </span>            :                     const JS::HandleValueArray&amp; args, JS::MutableHandleValue rval);
<span class="lineNum">    3404 </span>            : 
<span class="lineNum">    3405 </span>            : namespace JS {
<span class="lineNum">    3406 </span>            : 
<span class="lineNum">    3407 </span>            : static inline bool
<span class="lineNum">    3408 </span>            : Call(JSContext* cx, JS::HandleObject thisObj, JS::HandleFunction fun,
<span class="lineNum">    3409 </span>            :      const JS::HandleValueArray&amp; args, MutableHandleValue rval)
<span class="lineNum">    3410 </span>            : {
<span class="lineNum">    3411 </span>            :     return !!JS_CallFunction(cx, thisObj, fun, args, rval);
<span class="lineNum">    3412 </span>            : }
<span class="lineNum">    3413 </span>            : 
<span class="lineNum">    3414 </span>            : static inline bool
<span class="lineNum">    3415 </span>            : Call(JSContext* cx, JS::HandleObject thisObj, JS::HandleValue fun, const JS::HandleValueArray&amp; args,
<span class="lineNum">    3416 </span>            :      MutableHandleValue rval)
<span class="lineNum">    3417 </span>            : {
<span class="lineNum">    3418 </span>            :     return !!JS_CallFunctionValue(cx, thisObj, fun, args, rval);
<span class="lineNum">    3419 </span>            : }
<span class="lineNum">    3420 </span>            : 
<span class="lineNum">    3421 </span>            : static inline bool
<span class="lineNum">    3422 </span>            : Call(JSContext* cx, JS::HandleObject thisObj, const char* name, const JS::HandleValueArray&amp; args,
<span class="lineNum">    3423 </span>            :      MutableHandleValue rval)
<span class="lineNum">    3424 </span>            : {
<span class="lineNum">    3425 </span>            :     return !!JS_CallFunctionName(cx, thisObj, name, args, rval);
<span class="lineNum">    3426 </span>            : }
<span class="lineNum">    3427 </span>            : 
<span class="lineNum">    3428 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3429 </span>            : Call(JSContext* cx, JS::HandleValue thisv, JS::HandleValue fun, const JS::HandleValueArray&amp; args,
<span class="lineNum">    3430 </span>            :      MutableHandleValue rval);
<a name="3431"><span class="lineNum">    3431 </span>            : </a>
<span class="lineNum">    3432 </span>            : static inline bool
<span class="lineNum">    3433 </span><span class="lineNoCov">          0 : Call(JSContext* cx, JS::HandleValue thisv, JS::HandleObject funObj, const JS::HandleValueArray&amp; args,</span>
<span class="lineNum">    3434 </span>            :      MutableHandleValue rval)
<span class="lineNum">    3435 </span>            : {
<span class="lineNum">    3436 </span>            :     MOZ_ASSERT(funObj);
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 :     JS::RootedValue fun(cx, JS::ObjectValue(*funObj));</span>
<span class="lineNum">    3438 </span><span class="lineNoCov">          0 :     return Call(cx, thisv, fun, args, rval);</span>
<span class="lineNum">    3439 </span>            : }
<span class="lineNum">    3440 </span>            : 
<span class="lineNum">    3441 </span>            : /**
<span class="lineNum">    3442 </span>            :  * Invoke a constructor. This is the C++ equivalent of
<span class="lineNum">    3443 </span>            :  * `rval = Reflect.construct(fun, args, newTarget)`.
<span class="lineNum">    3444 </span>            :  *
<span class="lineNum">    3445 </span>            :  * JS::Construct() takes a `newTarget` argument that most callers don't need.
<span class="lineNum">    3446 </span>            :  * Consider using the four-argument Construct signature instead. (But if you're
<span class="lineNum">    3447 </span>            :  * implementing a subclass or a proxy handler's construct() method, this is the
<span class="lineNum">    3448 </span>            :  * right function to call.)
<span class="lineNum">    3449 </span>            :  *
<span class="lineNum">    3450 </span>            :  * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).
<span class="lineNum">    3451 </span>            :  * Use this function to invoke the [[Construct]] internal method.
<span class="lineNum">    3452 </span>            :  */
<span class="lineNum">    3453 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3454 </span>            : Construct(JSContext* cx, JS::HandleValue fun, HandleObject newTarget,
<span class="lineNum">    3455 </span>            :           const JS::HandleValueArray &amp;args, MutableHandleObject objp);
<span class="lineNum">    3456 </span>            : 
<span class="lineNum">    3457 </span>            : /**
<span class="lineNum">    3458 </span>            :  * Invoke a constructor. This is the C++ equivalent of
<span class="lineNum">    3459 </span>            :  * `rval = new fun(...args)`.
<span class="lineNum">    3460 </span>            :  *
<span class="lineNum">    3461 </span>            :  * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when
<span class="lineNum">    3462 </span>            :  * newTarget is omitted.
<span class="lineNum">    3463 </span>            :  */
<span class="lineNum">    3464 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3465 </span>            : Construct(JSContext* cx, JS::HandleValue fun, const JS::HandleValueArray&amp; args,
<span class="lineNum">    3466 </span>            :           MutableHandleObject objp);
<span class="lineNum">    3467 </span>            : 
<span class="lineNum">    3468 </span>            : } /* namespace JS */
<span class="lineNum">    3469 </span>            : 
<span class="lineNum">    3470 </span>            : /**
<span class="lineNum">    3471 </span>            :  * Invoke a constructor, like the JS expression `new ctor(...args)`. Returns
<span class="lineNum">    3472 </span>            :  * the new object, or null on error.
<span class="lineNum">    3473 </span>            :  */
<span class="lineNum">    3474 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3475 </span>            : JS_New(JSContext* cx, JS::HandleObject ctor, const JS::HandleValueArray&amp; args);
<span class="lineNum">    3476 </span>            : 
<span class="lineNum">    3477 </span>            : 
<span class="lineNum">    3478 </span>            : /*** Other property-defining functions ***********************************************************/
<span class="lineNum">    3479 </span>            : 
<span class="lineNum">    3480 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3481 </span>            : JS_DefineObject(JSContext* cx, JS::HandleObject obj, const char* name,
<span class="lineNum">    3482 </span>            :                 const JSClass* clasp = nullptr, unsigned attrs = 0);
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3485 </span>            : JS_DefineConstDoubles(JSContext* cx, JS::HandleObject obj, const JSConstDoubleSpec* cds);
<span class="lineNum">    3486 </span>            : 
<span class="lineNum">    3487 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3488 </span>            : JS_DefineConstIntegers(JSContext* cx, JS::HandleObject obj, const JSConstIntegerSpec* cis);
<span class="lineNum">    3489 </span>            : 
<span class="lineNum">    3490 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3491 </span>            : JS_DefineProperties(JSContext* cx, JS::HandleObject obj, const JSPropertySpec* ps);
<span class="lineNum">    3492 </span>            : 
<span class="lineNum">    3493 </span>            : 
<span class="lineNum">    3494 </span>            : /* * */
<span class="lineNum">    3495 </span>            : 
<span class="lineNum">    3496 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3497 </span>            : JS_AlreadyHasOwnPropertyById(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    3498 </span>            :                              bool* foundp);
<span class="lineNum">    3499 </span>            : 
<span class="lineNum">    3500 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3501 </span>            : JS_AlreadyHasOwnProperty(JSContext* cx, JS::HandleObject obj, const char* name,
<span class="lineNum">    3502 </span>            :                          bool* foundp);
<span class="lineNum">    3503 </span>            : 
<span class="lineNum">    3504 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3505 </span>            : JS_AlreadyHasOwnUCProperty(JSContext* cx, JS::HandleObject obj, const char16_t* name,
<span class="lineNum">    3506 </span>            :                            size_t namelen, bool* foundp);
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3509 </span>            : JS_AlreadyHasOwnElement(JSContext* cx, JS::HandleObject obj, uint32_t index, bool* foundp);
<span class="lineNum">    3510 </span>            : 
<span class="lineNum">    3511 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3512 </span>            : JS_NewArrayObject(JSContext* cx, const JS::HandleValueArray&amp; contents);
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3515 </span>            : JS_NewArrayObject(JSContext* cx, size_t length);
<span class="lineNum">    3516 </span>            : 
<span class="lineNum">    3517 </span>            : /**
<span class="lineNum">    3518 </span>            :  * Returns true and sets |*isArray| indicating whether |value| is an Array
<span class="lineNum">    3519 </span>            :  * object or a wrapper around one, otherwise returns false on failure.
<span class="lineNum">    3520 </span>            :  *
<span class="lineNum">    3521 </span>            :  * This method returns true with |*isArray == false| when passed a proxy whose
<span class="lineNum">    3522 </span>            :  * target is an Array, or when passed a revoked proxy.
<span class="lineNum">    3523 </span>            :  */
<span class="lineNum">    3524 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3525 </span>            : JS_IsArrayObject(JSContext* cx, JS::HandleValue value, bool* isArray);
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span>            : /**
<span class="lineNum">    3528 </span>            :  * Returns true and sets |*isArray| indicating whether |obj| is an Array object
<span class="lineNum">    3529 </span>            :  * or a wrapper around one, otherwise returns false on failure.
<span class="lineNum">    3530 </span>            :  *
<span class="lineNum">    3531 </span>            :  * This method returns true with |*isArray == false| when passed a proxy whose
<span class="lineNum">    3532 </span>            :  * target is an Array, or when passed a revoked proxy.
<span class="lineNum">    3533 </span>            :  */
<span class="lineNum">    3534 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3535 </span>            : JS_IsArrayObject(JSContext* cx, JS::HandleObject obj, bool* isArray);
<span class="lineNum">    3536 </span>            : 
<span class="lineNum">    3537 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3538 </span>            : JS_GetArrayLength(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, uint32_t* lengthp);
<span class="lineNum">    3539 </span>            : 
<span class="lineNum">    3540 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3541 </span>            : JS_SetArrayLength(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, uint32_t length);
<span class="lineNum">    3542 </span>            : 
<span class="lineNum">    3543 </span>            : namespace JS {
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span>            : /**
<span class="lineNum">    3546 </span>            :  * Returns true and sets |*isMap| indicating whether |obj| is an Map object
<span class="lineNum">    3547 </span>            :  * or a wrapper around one, otherwise returns false on failure.
<span class="lineNum">    3548 </span>            :  *
<span class="lineNum">    3549 </span>            :  * This method returns true with |*isMap == false| when passed a proxy whose
<span class="lineNum">    3550 </span>            :  * target is an Map, or when passed a revoked proxy.
<span class="lineNum">    3551 </span>            :  */
<span class="lineNum">    3552 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3553 </span>            : IsMapObject(JSContext* cx, JS::HandleObject obj, bool* isMap);
<span class="lineNum">    3554 </span>            : 
<span class="lineNum">    3555 </span>            : /**
<span class="lineNum">    3556 </span>            :  * Returns true and sets |*isSet| indicating whether |obj| is an Set object
<span class="lineNum">    3557 </span>            :  * or a wrapper around one, otherwise returns false on failure.
<span class="lineNum">    3558 </span>            :  *
<span class="lineNum">    3559 </span>            :  * This method returns true with |*isSet == false| when passed a proxy whose
<span class="lineNum">    3560 </span>            :  * target is an Set, or when passed a revoked proxy.
<span class="lineNum">    3561 </span>            :  */
<span class="lineNum">    3562 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3563 </span>            : IsSetObject(JSContext* cx, JS::HandleObject obj, bool* isSet);
<span class="lineNum">    3564 </span>            : 
<span class="lineNum">    3565 </span>            : } /* namespace JS */
<span class="lineNum">    3566 </span>            : 
<span class="lineNum">    3567 </span>            : /**
<span class="lineNum">    3568 </span>            :  * Assign 'undefined' to all of the object's non-reserved slots. Note: this is
<span class="lineNum">    3569 </span>            :  * done for all slots, regardless of the associated property descriptor.
<span class="lineNum">    3570 </span>            :  */
<span class="lineNum">    3571 </span>            : JS_PUBLIC_API(void)
<span class="lineNum">    3572 </span>            : JS_SetAllNonReservedSlotsToUndefined(JSContext* cx, JSObject* objArg);
<span class="lineNum">    3573 </span>            : 
<span class="lineNum">    3574 </span>            : /**
<span class="lineNum">    3575 </span>            :  * Create a new array buffer with the given contents. It must be legal to pass
<span class="lineNum">    3576 </span>            :  * these contents to free(). On success, the ownership is transferred to the
<span class="lineNum">    3577 </span>            :  * new array buffer.
<span class="lineNum">    3578 </span>            :  */
<span class="lineNum">    3579 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3580 </span>            : JS_NewArrayBufferWithContents(JSContext* cx, size_t nbytes, void* contents);
<span class="lineNum">    3581 </span>            : 
<span class="lineNum">    3582 </span>            : /**
<span class="lineNum">    3583 </span>            :  * Create a new array buffer with the given contents.  The array buffer does not take ownership of
<span class="lineNum">    3584 </span>            :  * contents, and JS_DetachArrayBuffer must be called before the contents are disposed of.
<span class="lineNum">    3585 </span>            :  */
<span class="lineNum">    3586 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3587 </span>            : JS_NewArrayBufferWithExternalContents(JSContext* cx, size_t nbytes, void* contents);
<span class="lineNum">    3588 </span>            : 
<span class="lineNum">    3589 </span>            : /**
<span class="lineNum">    3590 </span>            :  * Steal the contents of the given array buffer. The array buffer has its
<span class="lineNum">    3591 </span>            :  * length set to 0 and its contents array cleared. The caller takes ownership
<span class="lineNum">    3592 </span>            :  * of the return value and must free it or transfer ownership via
<span class="lineNum">    3593 </span>            :  * JS_NewArrayBufferWithContents when done using it.
<span class="lineNum">    3594 </span>            :  */
<span class="lineNum">    3595 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    3596 </span>            : JS_StealArrayBufferContents(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    3597 </span>            : 
<span class="lineNum">    3598 </span>            : /**
<span class="lineNum">    3599 </span>            :  * Returns a pointer to the ArrayBuffer |obj|'s data.  |obj| and its views will store and expose
<span class="lineNum">    3600 </span>            :  * the data in the returned pointer: assigning into the returned pointer will affect values exposed
<span class="lineNum">    3601 </span>            :  * by views of |obj| and vice versa.
<span class="lineNum">    3602 </span>            :  *
<span class="lineNum">    3603 </span>            :  * The caller must ultimately deallocate the returned pointer to avoid leaking.  The memory is
<span class="lineNum">    3604 </span>            :  * *not* garbage-collected with |obj|.  These steps must be followed to deallocate:
<span class="lineNum">    3605 </span>            :  *
<span class="lineNum">    3606 </span>            :  * 1. The ArrayBuffer |obj| must be detached using JS_DetachArrayBuffer.
<span class="lineNum">    3607 </span>            :  * 2. The returned pointer must be freed using JS_free.
<span class="lineNum">    3608 </span>            :  *
<span class="lineNum">    3609 </span>            :  * To perform step 1, callers *must* hold a reference to |obj| until they finish using the returned
<span class="lineNum">    3610 </span>            :  * pointer.  They *must not* attempt to let |obj| be GC'd, then JS_free the pointer.
<span class="lineNum">    3611 </span>            :  *
<span class="lineNum">    3612 </span>            :  * If |obj| isn't an ArrayBuffer, this function returns null and reports an error.
<span class="lineNum">    3613 </span>            :  */
<span class="lineNum">    3614 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    3615 </span>            : JS_ExternalizeArrayBufferContents(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    3616 </span>            : 
<span class="lineNum">    3617 </span>            : /**
<span class="lineNum">    3618 </span>            :  * Create a new mapped array buffer with the given memory mapped contents. It
<span class="lineNum">    3619 </span>            :  * must be legal to free the contents pointer by unmapping it. On success,
<span class="lineNum">    3620 </span>            :  * ownership is transferred to the new mapped array buffer.
<span class="lineNum">    3621 </span>            :  */
<span class="lineNum">    3622 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3623 </span>            : JS_NewMappedArrayBufferWithContents(JSContext* cx, size_t nbytes, void* contents);
<span class="lineNum">    3624 </span>            : 
<span class="lineNum">    3625 </span>            : /**
<span class="lineNum">    3626 </span>            :  * Create memory mapped array buffer contents.
<span class="lineNum">    3627 </span>            :  * Caller must take care of closing fd after calling this function.
<span class="lineNum">    3628 </span>            :  */
<span class="lineNum">    3629 </span>            : extern JS_PUBLIC_API(void*)
<span class="lineNum">    3630 </span>            : JS_CreateMappedArrayBufferContents(int fd, size_t offset, size_t length);
<span class="lineNum">    3631 </span>            : 
<span class="lineNum">    3632 </span>            : /**
<span class="lineNum">    3633 </span>            :  * Release the allocated resource of mapped array buffer contents before the
<span class="lineNum">    3634 </span>            :  * object is created.
<span class="lineNum">    3635 </span>            :  * If a new object has been created by JS_NewMappedArrayBufferWithContents()
<span class="lineNum">    3636 </span>            :  * with this content, then JS_DetachArrayBuffer() should be used instead to
<span class="lineNum">    3637 </span>            :  * release the resource used by the object.
<span class="lineNum">    3638 </span>            :  */
<span class="lineNum">    3639 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    3640 </span>            : JS_ReleaseMappedArrayBufferContents(void* contents, size_t length);
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">    3643 </span>            : JS_GetReservedSlot(JSObject* obj, uint32_t index);
<span class="lineNum">    3644 </span>            : 
<span class="lineNum">    3645 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    3646 </span>            : JS_SetReservedSlot(JSObject* obj, uint32_t index, const JS::Value&amp; v);
<span class="lineNum">    3647 </span>            : 
<span class="lineNum">    3648 </span>            : 
<span class="lineNum">    3649 </span>            : /************************************************************************/
<span class="lineNum">    3650 </span>            : 
<span class="lineNum">    3651 </span>            : /*
<span class="lineNum">    3652 </span>            :  * Functions and scripts.
<span class="lineNum">    3653 </span>            :  */
<span class="lineNum">    3654 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    3655 </span>            : JS_NewFunction(JSContext* cx, JSNative call, unsigned nargs, unsigned flags,
<span class="lineNum">    3656 </span>            :                const char* name);
<span class="lineNum">    3657 </span>            : 
<span class="lineNum">    3658 </span>            : namespace JS {
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    3661 </span>            : GetSelfHostedFunction(JSContext* cx, const char* selfHostedName, HandleId id,
<span class="lineNum">    3662 </span>            :                       unsigned nargs);
<span class="lineNum">    3663 </span>            : 
<span class="lineNum">    3664 </span>            : /**
<span class="lineNum">    3665 </span>            :  * Create a new function based on the given JSFunctionSpec, *fs.
<span class="lineNum">    3666 </span>            :  * id is the result of a successful call to
<span class="lineNum">    3667 </span>            :  * `PropertySpecNameToPermanentId(cx, fs-&gt;name, &amp;id)`.
<span class="lineNum">    3668 </span>            :  *
<span class="lineNum">    3669 </span>            :  * Unlike JS_DefineFunctions, this does not treat fs as an array.
<span class="lineNum">    3670 </span>            :  * *fs must not be JS_FS_END.
<span class="lineNum">    3671 </span>            :  */
<span class="lineNum">    3672 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    3673 </span>            : NewFunctionFromSpec(JSContext* cx, const JSFunctionSpec* fs, HandleId id);
<span class="lineNum">    3674 </span>            : 
<span class="lineNum">    3675 </span>            : } /* namespace JS */
<span class="lineNum">    3676 </span>            : 
<span class="lineNum">    3677 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3678 </span>            : JS_GetFunctionObject(JSFunction* fun);
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span>            : /**
<span class="lineNum">    3681 </span>            :  * Return the function's identifier as a JSString, or null if fun is unnamed.
<span class="lineNum">    3682 </span>            :  * The returned string lives as long as fun, so you don't need to root a saved
<span class="lineNum">    3683 </span>            :  * reference to it if fun is well-connected or rooted, and provided you bound
<span class="lineNum">    3684 </span>            :  * the use of the saved reference by fun's lifetime.
<span class="lineNum">    3685 </span>            :  */
<span class="lineNum">    3686 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    3687 </span>            : JS_GetFunctionId(JSFunction* fun);
<span class="lineNum">    3688 </span>            : 
<span class="lineNum">    3689 </span>            : /**
<span class="lineNum">    3690 </span>            :  * Return a function's display name. This is the defined name if one was given
<span class="lineNum">    3691 </span>            :  * where the function was defined, or it could be an inferred name by the JS
<span class="lineNum">    3692 </span>            :  * engine in the case that the function was defined to be anonymous. This can
<span class="lineNum">    3693 </span>            :  * still return nullptr if a useful display name could not be inferred. The
<span class="lineNum">    3694 </span>            :  * same restrictions on rooting as those in JS_GetFunctionId apply.
<span class="lineNum">    3695 </span>            :  */
<span class="lineNum">    3696 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    3697 </span>            : JS_GetFunctionDisplayId(JSFunction* fun);
<span class="lineNum">    3698 </span>            : 
<span class="lineNum">    3699 </span>            : /*
<span class="lineNum">    3700 </span>            :  * Return the arity (length) of fun.
<span class="lineNum">    3701 </span>            :  */
<span class="lineNum">    3702 </span>            : extern JS_PUBLIC_API(uint16_t)
<span class="lineNum">    3703 </span>            : JS_GetFunctionArity(JSFunction* fun);
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span>            : /**
<span class="lineNum">    3706 </span>            :  * Infallible predicate to test whether obj is a function object (faster than
<span class="lineNum">    3707 </span>            :  * comparing obj's class name to &quot;Function&quot;, but equivalent unless someone has
<span class="lineNum">    3708 </span>            :  * overwritten the &quot;Function&quot; identifier with a different constructor and then
<span class="lineNum">    3709 </span>            :  * created instances using that constructor that might be passed in as obj).
<span class="lineNum">    3710 </span>            :  */
<span class="lineNum">    3711 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3712 </span>            : JS_ObjectIsFunction(JSContext* cx, JSObject* obj);
<span class="lineNum">    3713 </span>            : 
<span class="lineNum">    3714 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3715 </span>            : JS_IsNativeFunction(JSObject* funobj, JSNative call);
<span class="lineNum">    3716 </span>            : 
<span class="lineNum">    3717 </span>            : /** Return whether the given function is a valid constructor. */
<span class="lineNum">    3718 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3719 </span>            : JS_IsConstructor(JSFunction* fun);
<span class="lineNum">    3720 </span>            : 
<span class="lineNum">    3721 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3722 </span>            : JS_DefineFunctions(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, const JSFunctionSpec* fs);
<span class="lineNum">    3723 </span>            : 
<span class="lineNum">    3724 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    3725 </span>            : JS_DefineFunction(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, const char* name, JSNative call,
<span class="lineNum">    3726 </span>            :                   unsigned nargs, unsigned attrs);
<span class="lineNum">    3727 </span>            : 
<span class="lineNum">    3728 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    3729 </span>            : JS_DefineUCFunction(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj,
<span class="lineNum">    3730 </span>            :                     const char16_t* name, size_t namelen, JSNative call,
<span class="lineNum">    3731 </span>            :                     unsigned nargs, unsigned attrs);
<span class="lineNum">    3732 </span>            : 
<span class="lineNum">    3733 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    3734 </span>            : JS_DefineFunctionById(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, JS::Handle&lt;jsid&gt; id, JSNative call,
<span class="lineNum">    3735 </span>            :                       unsigned nargs, unsigned attrs);
<span class="lineNum">    3736 </span>            : 
<span class="lineNum">    3737 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3738 </span>            : JS_IsFunctionBound(JSFunction* fun);
<span class="lineNum">    3739 </span>            : 
<span class="lineNum">    3740 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3741 </span>            : JS_GetBoundFunctionTarget(JSFunction* fun);
<span class="lineNum">    3742 </span>            : 
<span class="lineNum">    3743 </span>            : namespace JS {
<span class="lineNum">    3744 </span>            : 
<span class="lineNum">    3745 </span>            : /**
<span class="lineNum">    3746 </span>            :  * Clone a top-level function into cx's global. This function will dynamically
<span class="lineNum">    3747 </span>            :  * fail if funobj was lexically nested inside some other function.
<span class="lineNum">    3748 </span>            :  */
<span class="lineNum">    3749 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3750 </span>            : CloneFunctionObject(JSContext* cx, HandleObject funobj);
<span class="lineNum">    3751 </span>            : 
<span class="lineNum">    3752 </span>            : /**
<span class="lineNum">    3753 </span>            :  * As above, but providing an explicit scope chain.  scopeChain must not include
<span class="lineNum">    3754 </span>            :  * the global object on it; that's implicit.  It needs to contain the other
<span class="lineNum">    3755 </span>            :  * objects that should end up on the clone's scope chain.
<span class="lineNum">    3756 </span>            :  */
<span class="lineNum">    3757 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3758 </span>            : CloneFunctionObject(JSContext* cx, HandleObject funobj, AutoObjectVector&amp; scopeChain);
<span class="lineNum">    3759 </span>            : 
<span class="lineNum">    3760 </span>            : } // namespace JS
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span>            : /**
<span class="lineNum">    3763 </span>            :  * Given a buffer, return false if the buffer might become a valid
<span class="lineNum">    3764 </span>            :  * javascript statement with the addition of more lines.  Otherwise return
<span class="lineNum">    3765 </span>            :  * true.  The intent is to support interactive compilation - accumulate
<span class="lineNum">    3766 </span>            :  * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
<span class="lineNum">    3767 </span>            :  * the compiler.
<span class="lineNum">    3768 </span>            :  */
<span class="lineNum">    3769 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3770 </span>            : JS_BufferIsCompilableUnit(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj, const char* utf8,
<span class="lineNum">    3771 </span>            :                           size_t length);
<span class="lineNum">    3772 </span>            : 
<span class="lineNum">    3773 </span>            : /**
<span class="lineNum">    3774 </span>            :  * |script| will always be set. On failure, it will be set to nullptr.
<span class="lineNum">    3775 </span>            :  */
<span class="lineNum">    3776 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3777 </span>            : JS_CompileScript(JSContext* cx, const char* ascii, size_t length,
<span class="lineNum">    3778 </span>            :                  const JS::CompileOptions&amp; options,
<span class="lineNum">    3779 </span>            :                  JS::MutableHandleScript script);
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span>            : /**
<span class="lineNum">    3782 </span>            :  * |script| will always be set. On failure, it will be set to nullptr.
<span class="lineNum">    3783 </span>            :  */
<span class="lineNum">    3784 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    3785 </span>            : JS_CompileUCScript(JSContext* cx, const char16_t* chars, size_t length,
<span class="lineNum">    3786 </span>            :                    const JS::CompileOptions&amp; options,
<span class="lineNum">    3787 </span>            :                    JS::MutableHandleScript script);
<span class="lineNum">    3788 </span>            : 
<span class="lineNum">    3789 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    3790 </span>            : JS_GetGlobalFromScript(JSScript* script);
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            : extern JS_PUBLIC_API(const char*)
<span class="lineNum">    3793 </span>            : JS_GetScriptFilename(JSScript* script);
<span class="lineNum">    3794 </span>            : 
<span class="lineNum">    3795 </span>            : extern JS_PUBLIC_API(unsigned)
<span class="lineNum">    3796 </span>            : JS_GetScriptBaseLineNumber(JSContext* cx, JSScript* script);
<span class="lineNum">    3797 </span>            : 
<span class="lineNum">    3798 </span>            : extern JS_PUBLIC_API(JSScript*)
<span class="lineNum">    3799 </span>            : JS_GetFunctionScript(JSContext* cx, JS::HandleFunction fun);
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span>            : namespace JS {
<span class="lineNum">    3802 </span>            : 
<span class="lineNum">    3803 </span>            : /* Options for JavaScript compilation. */
<span class="lineNum">    3804 </span>            : 
<span class="lineNum">    3805 </span>            : /*
<span class="lineNum">    3806 </span>            :  * In the most common use case, a CompileOptions instance is allocated on the
<span class="lineNum">    3807 </span>            :  * stack, and holds non-owning references to non-POD option values: strings;
<span class="lineNum">    3808 </span>            :  * principals; objects; and so on. The code declaring the instance guarantees
<span class="lineNum">    3809 </span>            :  * that such option values will outlive the CompileOptions itself: objects are
<span class="lineNum">    3810 </span>            :  * otherwise rooted; principals have had their reference counts bumped; strings
<span class="lineNum">    3811 </span>            :  * will not be freed until the CompileOptions goes out of scope. In this
<span class="lineNum">    3812 </span>            :  * situation, CompileOptions only refers to things others own, so it can be
<span class="lineNum">    3813 </span>            :  * lightweight.
<span class="lineNum">    3814 </span>            :  *
<span class="lineNum">    3815 </span>            :  * In some cases, however, we need to hold compilation options with a
<span class="lineNum">    3816 </span>            :  * non-stack-like lifetime. For example, JS::CompileOffThread needs to save
<span class="lineNum">    3817 </span>            :  * compilation options where a worker thread can find them, and then return
<span class="lineNum">    3818 </span>            :  * immediately. The worker thread will come along at some later point, and use
<span class="lineNum">    3819 </span>            :  * the options.
<span class="lineNum">    3820 </span>            :  *
<span class="lineNum">    3821 </span>            :  * The compiler itself just needs to be able to access a collection of options;
<span class="lineNum">    3822 </span>            :  * it doesn't care who owns them, or what's keeping them alive. It does its own
<span class="lineNum">    3823 </span>            :  * addrefs/copies/tracing/etc.
<span class="lineNum">    3824 </span>            :  *
<span class="lineNum">    3825 </span>            :  * Furthermore, in some cases compile options are propagated from one entity to
<span class="lineNum">    3826 </span>            :  * another (e.g. from a script to a function defined in that script).  This
<span class="lineNum">    3827 </span>            :  * involves copying over some, but not all, of the options.
<span class="lineNum">    3828 </span>            :  *
<span class="lineNum">    3829 </span>            :  * So, we have a class hierarchy that reflects these four use cases:
<span class="lineNum">    3830 </span>            :  *
<span class="lineNum">    3831 </span>            :  * - TransitiveCompileOptions is the common base class, representing options
<span class="lineNum">    3832 </span>            :  *   that should get propagated from a script to functions defined in that
<span class="lineNum">    3833 </span>            :  *   script.  This is never instantiated directly.
<span class="lineNum">    3834 </span>            :  *
<span class="lineNum">    3835 </span>            :  * - ReadOnlyCompileOptions is the only subclass of TransitiveCompileOptions,
<span class="lineNum">    3836 </span>            :  *   representing a full set of compile options.  It can be used by code that
<span class="lineNum">    3837 </span>            :  *   simply needs to access options set elsewhere, like the compiler.  This,
<span class="lineNum">    3838 </span>            :  *   again, is never instantiated directly.
<span class="lineNum">    3839 </span>            :  *
<span class="lineNum">    3840 </span>            :  * - The usual CompileOptions class must be stack-allocated, and holds
<span class="lineNum">    3841 </span>            :  *   non-owning references to the filename, element, and so on. It's derived
<span class="lineNum">    3842 </span>            :  *   from ReadOnlyCompileOptions, so the compiler can use it.
<span class="lineNum">    3843 </span>            :  *
<span class="lineNum">    3844 </span>            :  * - OwningCompileOptions roots / copies / reference counts of all its values,
<span class="lineNum">    3845 </span>            :  *   and unroots / frees / releases them when it is destructed. It too is
<span class="lineNum">    3846 </span>            :  *   derived from ReadOnlyCompileOptions, so the compiler accepts it.
<span class="lineNum">    3847 </span>            :  */
<span class="lineNum">    3848 </span>            : 
<span class="lineNum">    3849 </span>            : enum class AsmJSOption : uint8_t { Enabled, Disabled, DisabledByDebugger };
<span class="lineNum">    3850 </span>            : 
<span class="lineNum">    3851 </span>            : /**
<span class="lineNum">    3852 </span>            :  * The common base class for the CompileOptions hierarchy.
<span class="lineNum">    3853 </span>            :  *
<span class="lineNum">    3854 </span>            :  * Use this in code that needs to propagate compile options from one compilation
<span class="lineNum">    3855 </span>            :  * unit to another.
<span class="lineNum">    3856 </span>            :  */
<span class="lineNum">    3857 </span>            : class JS_FRIEND_API(TransitiveCompileOptions)
<span class="lineNum">    3858 </span>            : {
<span class="lineNum">    3859 </span>            :   protected:
<span class="lineNum">    3860 </span>            :     // The Web Platform allows scripts to be loaded from arbitrary cross-origin
<span class="lineNum">    3861 </span>            :     // sources. This allows an attack by which a malicious website loads a
<span class="lineNum">    3862 </span>            :     // sensitive file (say, a bank statement) cross-origin (using the user's
<span class="lineNum">    3863 </span>            :     // cookies), and sniffs the generated syntax errors (via a window.onerror
<span class="lineNum">    3864 </span>            :     // handler) for juicy morsels of its contents.
<span class="lineNum">    3865 </span>            :     //
<span class="lineNum">    3866 </span>            :     // To counter this attack, HTML5 specifies that script errors should be
<span class="lineNum">    3867 </span>            :     // sanitized (&quot;muted&quot;) when the script is not same-origin with the global
<span class="lineNum">    3868 </span>            :     // for which it is loaded. Callers should set this flag for cross-origin
<span class="lineNum">    3869 </span>            :     // scripts, and it will be propagated appropriately to child scripts and
<span class="lineNum">    3870 </span>            :     // passed back in JSErrorReports.
<span class="lineNum">    3871 </span>            :     bool mutedErrors_;
<span class="lineNum">    3872 </span>            :     const char* filename_;
<span class="lineNum">    3873 </span>            :     const char* introducerFilename_;
<span class="lineNum">    3874 </span>            :     const char16_t* sourceMapURL_;
<span class="lineNum">    3875 </span>            : 
<span class="lineNum">    3876 </span>            :     // This constructor leaves 'version' set to JSVERSION_UNKNOWN. The structure
<span class="lineNum">    3877 </span>            :     // is unusable until that's set to something more specific; the derived
<span class="lineNum">    3878 </span>            :     // classes' constructors take care of that, in ways appropriate to their
<span class="lineNum">    3879 </span>            :     // purpose.
<span class="lineNum">    3880 </span>            :     TransitiveCompileOptions()
<span class="lineNum">    3881 </span>            :       : mutedErrors_(false),
<span class="lineNum">    3882 </span>            :         filename_(nullptr),
<span class="lineNum">    3883 </span>            :         introducerFilename_(nullptr),
<span class="lineNum">    3884 </span>            :         sourceMapURL_(nullptr),
<span class="lineNum">    3885 </span>            :         version(JSVERSION_UNKNOWN),
<span class="lineNum">    3886 </span>            :         versionSet(false),
<span class="lineNum">    3887 </span>            :         utf8(false),
<span class="lineNum">    3888 </span>            :         selfHostingMode(false),
<span class="lineNum">    3889 </span>            :         canLazilyParse(true),
<span class="lineNum">    3890 </span>            :         strictOption(false),
<span class="lineNum">    3891 </span>            :         extraWarningsOption(false),
<span class="lineNum">    3892 </span>            :         forEachStatementOption(false),
<span class="lineNum">    3893 </span>            :         werrorOption(false),
<span class="lineNum">    3894 </span>            :         asmJSOption(AsmJSOption::Disabled),
<span class="lineNum">    3895 </span>            :         throwOnAsmJSValidationFailureOption(false),
<span class="lineNum">    3896 </span>            :         forceAsync(false),
<span class="lineNum">    3897 </span>            :         sourceIsLazy(false),
<span class="lineNum">    3898 </span>            :         allowHTMLComments(true),
<span class="lineNum">    3899 </span>            :         isProbablySystemOrAddonCode(false),
<span class="lineNum">    3900 </span>            :         introductionType(nullptr),
<span class="lineNum">    3901 </span>            :         introductionLineno(0),
<span class="lineNum">    3902 </span>            :         introductionOffset(0),
<span class="lineNum">    3903 </span><span class="lineCov">          1 :         hasIntroductionInfo(false)</span>
<span class="lineNum">    3904 </span>            :     { }
<span class="lineNum">    3905 </span>            : 
<span class="lineNum">    3906 </span>            :     // Set all POD options (those not requiring reference counts, copies,
<span class="lineNum">    3907 </span>            :     // rooting, or other hand-holding) to their values in |rhs|.
<span class="lineNum">    3908 </span>            :     void copyPODTransitiveOptions(const TransitiveCompileOptions&amp; rhs);
<span class="lineNum">    3909 </span>            : 
<span class="lineNum">    3910 </span>            :   public:
<span class="lineNum">    3911 </span>            :     // Read-only accessors for non-POD options. The proper way to set these
<span class="lineNum">    3912 </span>            :     // depends on the derived type.
<span class="lineNum">    3913 </span>            :     bool mutedErrors() const { return mutedErrors_; }
<span class="lineNum">    3914 </span>            :     const char* filename() const { return filename_; }
<span class="lineNum">    3915 </span>            :     const char* introducerFilename() const { return introducerFilename_; }
<span class="lineNum">    3916 </span>            :     const char16_t* sourceMapURL() const { return sourceMapURL_; }
<span class="lineNum">    3917 </span>            :     virtual JSObject* element() const = 0;
<span class="lineNum">    3918 </span>            :     virtual JSString* elementAttributeName() const = 0;
<span class="lineNum">    3919 </span>            :     virtual JSScript* introductionScript() const = 0;
<span class="lineNum">    3920 </span>            : 
<span class="lineNum">    3921 </span>            :     // POD options.
<span class="lineNum">    3922 </span>            :     JSVersion version;
<span class="lineNum">    3923 </span>            :     bool versionSet;
<span class="lineNum">    3924 </span>            :     bool utf8;
<span class="lineNum">    3925 </span>            :     bool selfHostingMode;
<span class="lineNum">    3926 </span>            :     bool canLazilyParse;
<span class="lineNum">    3927 </span>            :     bool strictOption;
<span class="lineNum">    3928 </span>            :     bool extraWarningsOption;
<span class="lineNum">    3929 </span>            :     bool forEachStatementOption;
<span class="lineNum">    3930 </span>            :     bool werrorOption;
<span class="lineNum">    3931 </span>            :     AsmJSOption asmJSOption;
<span class="lineNum">    3932 </span>            :     bool throwOnAsmJSValidationFailureOption;
<span class="lineNum">    3933 </span>            :     bool forceAsync;
<span class="lineNum">    3934 </span>            :     bool sourceIsLazy;
<span class="lineNum">    3935 </span>            :     bool allowHTMLComments;
<span class="lineNum">    3936 </span>            :     bool isProbablySystemOrAddonCode;
<span class="lineNum">    3937 </span>            : 
<span class="lineNum">    3938 </span>            :     // |introductionType| is a statically allocated C string:
<span class="lineNum">    3939 </span>            :     // one of &quot;eval&quot;, &quot;Function&quot;, or &quot;GeneratorFunction&quot;.
<span class="lineNum">    3940 </span>            :     const char* introductionType;
<span class="lineNum">    3941 </span>            :     unsigned introductionLineno;
<span class="lineNum">    3942 </span>            :     uint32_t introductionOffset;
<span class="lineNum">    3943 </span>            :     bool hasIntroductionInfo;
<span class="lineNum">    3944 </span>            : 
<span class="lineNum">    3945 </span>            :   private:
<span class="lineNum">    3946 </span>            :     void operator=(const TransitiveCompileOptions&amp;) = delete;
<span class="lineNum">    3947 </span>            : };
<span class="lineNum">    3948 </span>            : 
<span class="lineNum">    3949 </span>            : /**
<span class="lineNum">    3950 </span>            :  * The class representing a full set of compile options.
<span class="lineNum">    3951 </span>            :  *
<span class="lineNum">    3952 </span>            :  * Use this in code that only needs to access compilation options created
<span class="lineNum">    3953 </span>            :  * elsewhere, like the compiler. Don't instantiate this class (the constructor
<span class="lineNum">    3954 </span>            :  * is protected anyway); instead, create instances only of the derived classes:
<span class="lineNum">    3955 </span>            :  * CompileOptions and OwningCompileOptions.
<span class="lineNum">    3956 </span>            :  */
<span class="lineNum">    3957 </span>            : class JS_FRIEND_API(ReadOnlyCompileOptions) : public TransitiveCompileOptions
<span class="lineNum">    3958 </span>            : {
<span class="lineNum">    3959 </span>            :     friend class CompileOptions;
<a name="3960"><span class="lineNum">    3960 </span>            : </a>
<span class="lineNum">    3961 </span>            :   protected:
<span class="lineNum">    3962 </span><span class="lineCov">          1 :     ReadOnlyCompileOptions()</span>
<span class="lineNum">    3963 </span>            :       : TransitiveCompileOptions(),
<span class="lineNum">    3964 </span>            :         lineno(1),
<span class="lineNum">    3965 </span>            :         column(0),
<span class="lineNum">    3966 </span>            :         isRunOnce(false),
<span class="lineNum">    3967 </span><span class="lineCov">          1 :         noScriptRval(false)</span>
<span class="lineNum">    3968 </span><span class="lineCov">          1 :     { }</span>
<span class="lineNum">    3969 </span>            : 
<span class="lineNum">    3970 </span>            :     // Set all POD options (those not requiring reference counts, copies,
<span class="lineNum">    3971 </span>            :     // rooting, or other hand-holding) to their values in |rhs|.
<span class="lineNum">    3972 </span>            :     void copyPODOptions(const ReadOnlyCompileOptions&amp; rhs);
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span>            :   public:
<span class="lineNum">    3975 </span>            :     // Read-only accessors for non-POD options. The proper way to set these
<span class="lineNum">    3976 </span>            :     // depends on the derived type.
<span class="lineNum">    3977 </span>            :     bool mutedErrors() const { return mutedErrors_; }
<span class="lineNum">    3978 </span>            :     const char* filename() const { return filename_; }
<span class="lineNum">    3979 </span>            :     const char* introducerFilename() const { return introducerFilename_; }
<span class="lineNum">    3980 </span>            :     const char16_t* sourceMapURL() const { return sourceMapURL_; }
<span class="lineNum">    3981 </span>            :     virtual JSObject* element() const = 0;
<span class="lineNum">    3982 </span>            :     virtual JSString* elementAttributeName() const = 0;
<span class="lineNum">    3983 </span>            :     virtual JSScript* introductionScript() const = 0;
<span class="lineNum">    3984 </span>            : 
<span class="lineNum">    3985 </span>            :     // POD options.
<span class="lineNum">    3986 </span>            :     unsigned lineno;
<span class="lineNum">    3987 </span>            :     unsigned column;
<span class="lineNum">    3988 </span>            :     // isRunOnce only applies to non-function scripts.
<span class="lineNum">    3989 </span>            :     bool isRunOnce;
<span class="lineNum">    3990 </span>            :     bool noScriptRval;
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span>            :   private:
<span class="lineNum">    3993 </span>            :     void operator=(const ReadOnlyCompileOptions&amp;) = delete;
<span class="lineNum">    3994 </span>            : };
<span class="lineNum">    3995 </span>            : 
<span class="lineNum">    3996 </span>            : /**
<span class="lineNum">    3997 </span>            :  * Compilation options, with dynamic lifetime. An instance of this type
<span class="lineNum">    3998 </span>            :  * makes a copy of / holds / roots all dynamically allocated resources
<span class="lineNum">    3999 </span>            :  * (principals; elements; strings) that it refers to. Its destructor frees
<span class="lineNum">    4000 </span>            :  * / drops / unroots them. This is heavier than CompileOptions, below, but
<span class="lineNum">    4001 </span>            :  * unlike CompileOptions, it can outlive any given stack frame.
<span class="lineNum">    4002 </span>            :  *
<span class="lineNum">    4003 </span>            :  * Note that this *roots* any JS values it refers to - they're live
<span class="lineNum">    4004 </span>            :  * unconditionally. Thus, instances of this type can't be owned, directly
<span class="lineNum">    4005 </span>            :  * or indirectly, by a JavaScript object: if any value that this roots ever
<span class="lineNum">    4006 </span>            :  * comes to refer to the object that owns this, then the whole cycle, and
<span class="lineNum">    4007 </span>            :  * anything else it entrains, will never be freed.
<span class="lineNum">    4008 </span>            :  */
<span class="lineNum">    4009 </span>            : class JS_FRIEND_API(OwningCompileOptions) : public ReadOnlyCompileOptions
<span class="lineNum">    4010 </span>            : {
<span class="lineNum">    4011 </span>            :     PersistentRootedObject elementRoot;
<span class="lineNum">    4012 </span>            :     PersistentRootedString elementAttributeNameRoot;
<span class="lineNum">    4013 </span>            :     PersistentRootedScript introductionScriptRoot;
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span>            :   public:
<span class="lineNum">    4016 </span>            :     // A minimal constructor, for use with OwningCompileOptions::copy. This
<span class="lineNum">    4017 </span>            :     // leaves |this.version| set to JSVERSION_UNKNOWN; the instance
<span class="lineNum">    4018 </span>            :     // shouldn't be used until we've set that to something real (as |copy|
<span class="lineNum">    4019 </span>            :     // will).
<span class="lineNum">    4020 </span>            :     explicit OwningCompileOptions(JSContext* cx);
<a name="4021"><span class="lineNum">    4021 </span>            :     ~OwningCompileOptions();</a>
<a name="4022"><span class="lineNum">    4022 </span>            : </a>
<a name="4023"><span class="lineNum">    4023 </span><span class="lineCov">          1 :     JSObject* element() const override { return elementRoot; }</span></a>
<span class="lineNum">    4024 </span><span class="lineCov">          1 :     JSString* elementAttributeName() const override { return elementAttributeNameRoot; }</span>
<span class="lineNum">    4025 </span><span class="lineCov">          1 :     JSScript* introductionScript() const override { return introductionScriptRoot; }</span>
<span class="lineNum">    4026 </span>            : 
<span class="lineNum">    4027 </span>            :     // Set this to a copy of |rhs|. Return false on OOM.
<span class="lineNum">    4028 </span>            :     bool copy(JSContext* cx, const ReadOnlyCompileOptions&amp; rhs);
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span>            :     /* These setters make copies of their string arguments, and are fallible. */
<span class="lineNum">    4031 </span>            :     bool setFile(JSContext* cx, const char* f);
<span class="lineNum">    4032 </span>            :     bool setFileAndLine(JSContext* cx, const char* f, unsigned l);
<span class="lineNum">    4033 </span>            :     bool setSourceMapURL(JSContext* cx, const char16_t* s);
<span class="lineNum">    4034 </span>            :     bool setIntroducerFilename(JSContext* cx, const char* s);
<span class="lineNum">    4035 </span>            : 
<span class="lineNum">    4036 </span>            :     /* These setters are infallible, and can be chained. */
<span class="lineNum">    4037 </span>            :     OwningCompileOptions&amp; setLine(unsigned l)             { lineno = l; return *this; }
<span class="lineNum">    4038 </span>            :     OwningCompileOptions&amp; setElement(JSObject* e) {
<span class="lineNum">    4039 </span><span class="lineCov">          1 :         elementRoot = e;</span>
<span class="lineNum">    4040 </span>            :         return *this;
<span class="lineNum">    4041 </span>            :     }
<span class="lineNum">    4042 </span>            :     OwningCompileOptions&amp; setElementAttributeName(JSString* p) {
<span class="lineNum">    4043 </span><span class="lineCov">          1 :         elementAttributeNameRoot = p;</span>
<span class="lineNum">    4044 </span>            :         return *this;
<span class="lineNum">    4045 </span>            :     }
<span class="lineNum">    4046 </span>            :     OwningCompileOptions&amp; setIntroductionScript(JSScript* s) {
<span class="lineNum">    4047 </span><span class="lineCov">          1 :         introductionScriptRoot = s;</span>
<span class="lineNum">    4048 </span>            :         return *this;
<span class="lineNum">    4049 </span>            :     }
<span class="lineNum">    4050 </span>            :     OwningCompileOptions&amp; setMutedErrors(bool mute) {
<span class="lineNum">    4051 </span>            :         mutedErrors_ = mute;
<span class="lineNum">    4052 </span>            :         return *this;
<span class="lineNum">    4053 </span>            :     }
<span class="lineNum">    4054 </span>            :     OwningCompileOptions&amp; setVersion(JSVersion v) {
<span class="lineNum">    4055 </span>            :         version = v;
<span class="lineNum">    4056 </span>            :         versionSet = true;
<span class="lineNum">    4057 </span>            :         return *this;
<span class="lineNum">    4058 </span>            :     }
<span class="lineNum">    4059 </span>            :     OwningCompileOptions&amp; setUTF8(bool u) { utf8 = u; return *this; }
<span class="lineNum">    4060 </span>            :     OwningCompileOptions&amp; setColumn(unsigned c) { column = c; return *this; }
<span class="lineNum">    4061 </span>            :     OwningCompileOptions&amp; setIsRunOnce(bool once) { isRunOnce = once; return *this; }
<span class="lineNum">    4062 </span>            :     OwningCompileOptions&amp; setNoScriptRval(bool nsr) { noScriptRval = nsr; return *this; }
<span class="lineNum">    4063 </span>            :     OwningCompileOptions&amp; setSelfHostingMode(bool shm) { selfHostingMode = shm; return *this; }
<span class="lineNum">    4064 </span>            :     OwningCompileOptions&amp; setCanLazilyParse(bool clp) { canLazilyParse = clp; return *this; }
<span class="lineNum">    4065 </span>            :     OwningCompileOptions&amp; setSourceIsLazy(bool l) { sourceIsLazy = l; return *this; }
<span class="lineNum">    4066 </span>            :     OwningCompileOptions&amp; setIntroductionType(const char* t) { introductionType = t; return *this; }
<span class="lineNum">    4067 </span>            :     bool setIntroductionInfo(JSContext* cx, const char* introducerFn, const char* intro,
<span class="lineNum">    4068 </span>            :                              unsigned line, JSScript* script, uint32_t offset)
<span class="lineNum">    4069 </span>            :     {
<span class="lineNum">    4070 </span>            :         if (!setIntroducerFilename(cx, introducerFn))
<span class="lineNum">    4071 </span>            :             return false;
<span class="lineNum">    4072 </span>            :         introductionType = intro;
<span class="lineNum">    4073 </span>            :         introductionLineno = line;
<span class="lineNum">    4074 </span>            :         introductionScriptRoot = script;
<span class="lineNum">    4075 </span>            :         introductionOffset = offset;
<span class="lineNum">    4076 </span>            :         hasIntroductionInfo = true;
<span class="lineNum">    4077 </span>            :         return true;
<span class="lineNum">    4078 </span>            :     }
<span class="lineNum">    4079 </span>            : 
<span class="lineNum">    4080 </span>            :   private:
<span class="lineNum">    4081 </span>            :     void operator=(const CompileOptions&amp; rhs) = delete;
<span class="lineNum">    4082 </span>            : };
<span class="lineNum">    4083 </span>            : 
<span class="lineNum">    4084 </span>            : /**
<span class="lineNum">    4085 </span>            :  * Compilation options stored on the stack. An instance of this type
<span class="lineNum">    4086 </span>            :  * simply holds references to dynamically allocated resources (element;
<span class="lineNum">    4087 </span>            :  * filename; source map URL) that are owned by something else. If you
<span class="lineNum">    4088 </span>            :  * create an instance of this type, it's up to you to guarantee that
<span class="lineNum">    4089 </span>            :  * everything you store in it will outlive it.
<span class="lineNum">    4090 </span>            :  */
<span class="lineNum">    4091 </span><span class="lineCov">          1 : class MOZ_STACK_CLASS JS_FRIEND_API(CompileOptions) final : public ReadOnlyCompileOptions</span>
<span class="lineNum">    4092 </span>            : {
<span class="lineNum">    4093 </span>            :     RootedObject elementRoot;
<span class="lineNum">    4094 </span>            :     RootedString elementAttributeNameRoot;
<span class="lineNum">    4095 </span>            :     RootedScript introductionScriptRoot;
<span class="lineNum">    4096 </span>            : 
<a name="4097"><span class="lineNum">    4097 </span>            :   public:</a>
<span class="lineNum">    4098 </span>            :     explicit CompileOptions(JSContext* cx, JSVersion version = JSVERSION_UNKNOWN);
<span class="lineNum">    4099 </span><span class="lineCov">          1 :     CompileOptions(JSContext* cx, const ReadOnlyCompileOptions&amp; rhs)</span>
<span class="lineNum">    4100 </span>            :       : ReadOnlyCompileOptions(), elementRoot(cx), elementAttributeNameRoot(cx),
<span class="lineNum">    4101 </span><span class="lineCov">          1 :         introductionScriptRoot(cx)</span>
<span class="lineNum">    4102 </span>            :     {
<span class="lineNum">    4103 </span><span class="lineCov">          1 :         copyPODOptions(rhs);</span>
<span class="lineNum">    4104 </span>            : 
<span class="lineNum">    4105 </span><span class="lineCov">          1 :         filename_ = rhs.filename();</span>
<span class="lineNum">    4106 </span><span class="lineCov">          1 :         introducerFilename_ = rhs.introducerFilename();</span>
<span class="lineNum">    4107 </span><span class="lineCov">          1 :         sourceMapURL_ = rhs.sourceMapURL();</span>
<span class="lineNum">    4108 </span><span class="lineCov">          1 :         elementRoot = rhs.element();</span>
<span class="lineNum">    4109 </span><span class="lineCov">          1 :         elementAttributeNameRoot = rhs.elementAttributeName();</span>
<span class="lineNum">    4110 </span><span class="lineCov">          1 :         introductionScriptRoot = rhs.introductionScript();</span>
<a name="4111"><span class="lineNum">    4111 </span><span class="lineCov">          1 :     }</span></a>
<span class="lineNum">    4112 </span>            : 
<span class="lineNum">    4113 </span><span class="lineCov">          1 :     CompileOptions(JSContext* cx, const TransitiveCompileOptions&amp; rhs)</span>
<span class="lineNum">    4114 </span>            :       : ReadOnlyCompileOptions(), elementRoot(cx), elementAttributeNameRoot(cx),
<span class="lineNum">    4115 </span><span class="lineCov">          1 :         introductionScriptRoot(cx)</span>
<span class="lineNum">    4116 </span>            :     {
<span class="lineNum">    4117 </span><span class="lineCov">          1 :         copyPODTransitiveOptions(rhs);</span>
<span class="lineNum">    4118 </span>            : 
<span class="lineNum">    4119 </span><span class="lineCov">          1 :         filename_ = rhs.filename();</span>
<span class="lineNum">    4120 </span><span class="lineCov">          1 :         introducerFilename_ = rhs.introducerFilename();</span>
<span class="lineNum">    4121 </span><span class="lineCov">          1 :         sourceMapURL_ = rhs.sourceMapURL();</span>
<span class="lineNum">    4122 </span><span class="lineCov">          1 :         elementRoot = rhs.element();</span>
<span class="lineNum">    4123 </span><span class="lineCov">          1 :         elementAttributeNameRoot = rhs.elementAttributeName();</span>
<span class="lineNum">    4124 </span><span class="lineCov">          1 :         introductionScriptRoot = rhs.introductionScript();</span>
<a name="4125"><span class="lineNum">    4125 </span><span class="lineCov">          1 :     }</span></a>
<a name="4126"><span class="lineNum">    4126 </span>            : </a>
<a name="4127"><span class="lineNum">    4127 </span><span class="lineCov">          1 :     JSObject* element() const override { return elementRoot; }</span></a>
<span class="lineNum">    4128 </span><span class="lineCov">          1 :     JSString* elementAttributeName() const override { return elementAttributeNameRoot; }</span>
<span class="lineNum">    4129 </span><span class="lineCov">          1 :     JSScript* introductionScript() const override { return introductionScriptRoot; }</span>
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span><span class="lineNoCov">          0 :     CompileOptions&amp; setFile(const char* f) { filename_ = f; return *this; }</span>
<span class="lineNum">    4132 </span>            :     CompileOptions&amp; setLine(unsigned l) { lineno = l; return *this; }
<span class="lineNum">    4133 </span>            :     CompileOptions&amp; setFileAndLine(const char* f, unsigned l) {
<span class="lineNum">    4134 </span><span class="lineCov">          1 :         filename_ = f; lineno = l; return *this;</span>
<span class="lineNum">    4135 </span>            :     }
<span class="lineNum">    4136 </span>            :     CompileOptions&amp; setSourceMapURL(const char16_t* s) { sourceMapURL_ = s; return *this; }
<span class="lineNum">    4137 </span>            :     CompileOptions&amp; setElement(JSObject* e)          { elementRoot = e; return *this; }
<span class="lineNum">    4138 </span>            :     CompileOptions&amp; setElementAttributeName(JSString* p) {
<span class="lineNum">    4139 </span>            :         elementAttributeNameRoot = p;
<span class="lineNum">    4140 </span>            :         return *this;
<span class="lineNum">    4141 </span>            :     }
<span class="lineNum">    4142 </span>            :     CompileOptions&amp; setIntroductionScript(JSScript* s) {
<span class="lineNum">    4143 </span>            :         introductionScriptRoot = s;
<span class="lineNum">    4144 </span>            :         return *this;
<span class="lineNum">    4145 </span>            :     }
<span class="lineNum">    4146 </span>            :     CompileOptions&amp; setMutedErrors(bool mute) {
<span class="lineNum">    4147 </span><span class="lineCov">          1 :         mutedErrors_ = mute;</span>
<span class="lineNum">    4148 </span>            :         return *this;
<span class="lineNum">    4149 </span>            :     }
<span class="lineNum">    4150 </span>            :     CompileOptions&amp; setVersion(JSVersion v) {
<span class="lineNum">    4151 </span><span class="lineCov">          1 :         version = v;</span>
<span class="lineNum">    4152 </span><span class="lineCov">          1 :         versionSet = true;</span>
<span class="lineNum">    4153 </span>            :         return *this;
<span class="lineNum">    4154 </span>            :     }
<span class="lineNum">    4155 </span>            :     CompileOptions&amp; setUTF8(bool u) { utf8 = u; return *this; }
<span class="lineNum">    4156 </span><span class="lineCov">          1 :     CompileOptions&amp; setColumn(unsigned c) { column = c; return *this; }</span>
<span class="lineNum">    4157 </span><span class="lineCov">          1 :     CompileOptions&amp; setIsRunOnce(bool once) { isRunOnce = once; return *this; }</span>
<span class="lineNum">    4158 </span><span class="lineCov">          1 :     CompileOptions&amp; setNoScriptRval(bool nsr) { noScriptRval = nsr; return *this; }</span>
<span class="lineNum">    4159 </span><span class="lineCov">          1 :     CompileOptions&amp; setSelfHostingMode(bool shm) { selfHostingMode = shm; return *this; }</span>
<span class="lineNum">    4160 </span><span class="lineCov">          1 :     CompileOptions&amp; setCanLazilyParse(bool clp) { canLazilyParse = clp; return *this; }</span>
<span class="lineNum">    4161 </span>            :     CompileOptions&amp; setSourceIsLazy(bool l) { sourceIsLazy = l; return *this; }
<span class="lineNum">    4162 </span><span class="lineCov">          1 :     CompileOptions&amp; setIntroductionType(const char* t) { introductionType = t; return *this; }</span>
<span class="lineNum">    4163 </span>            :     CompileOptions&amp; setIntroductionInfo(const char* introducerFn, const char* intro,
<span class="lineNum">    4164 </span>            :                                         unsigned line, JSScript* script, uint32_t offset)
<span class="lineNum">    4165 </span>            :     {
<span class="lineNum">    4166 </span><span class="lineCov">          1 :         introducerFilename_ = introducerFn;</span>
<span class="lineNum">    4167 </span><span class="lineCov">          1 :         introductionType = intro;</span>
<span class="lineNum">    4168 </span><span class="lineCov">          1 :         introductionLineno = line;</span>
<span class="lineNum">    4169 </span><span class="lineCov">          1 :         introductionScriptRoot = script;</span>
<span class="lineNum">    4170 </span><span class="lineCov">          1 :         introductionOffset = offset;</span>
<span class="lineNum">    4171 </span><span class="lineCov">          1 :         hasIntroductionInfo = true;</span>
<span class="lineNum">    4172 </span>            :         return *this;
<span class="lineNum">    4173 </span>            :     }
<span class="lineNum">    4174 </span>            :     CompileOptions&amp; maybeMakeStrictMode(bool strict) {
<span class="lineNum">    4175 </span><span class="lineCov">          1 :         strictOption = strictOption || strict;</span>
<span class="lineNum">    4176 </span>            :         return *this;
<span class="lineNum">    4177 </span>            :     }
<span class="lineNum">    4178 </span>            : 
<span class="lineNum">    4179 </span>            :   private:
<span class="lineNum">    4180 </span>            :     void operator=(const CompileOptions&amp; rhs) = delete;
<span class="lineNum">    4181 </span>            : };
<span class="lineNum">    4182 </span>            : 
<span class="lineNum">    4183 </span>            : /**
<span class="lineNum">    4184 </span>            :  * |script| will always be set. On failure, it will be set to nullptr.
<span class="lineNum">    4185 </span>            :  */
<span class="lineNum">    4186 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4187 </span>            : Compile(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4188 </span>            :         SourceBufferHolder&amp; srcBuf, JS::MutableHandleScript script);
<span class="lineNum">    4189 </span>            : 
<span class="lineNum">    4190 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4191 </span>            : Compile(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4192 </span>            :         const char* bytes, size_t length, JS::MutableHandleScript script);
<span class="lineNum">    4193 </span>            : 
<span class="lineNum">    4194 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4195 </span>            : Compile(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4196 </span>            :         const char16_t* chars, size_t length, JS::MutableHandleScript script);
<span class="lineNum">    4197 </span>            : 
<span class="lineNum">    4198 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4199 </span>            : Compile(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4200 </span>            :         FILE* file, JS::MutableHandleScript script);
<span class="lineNum">    4201 </span>            : 
<span class="lineNum">    4202 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4203 </span>            : Compile(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4204 </span>            :         const char* filename, JS::MutableHandleScript script);
<span class="lineNum">    4205 </span>            : 
<span class="lineNum">    4206 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4207 </span>            : CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4208 </span>            :                             SourceBufferHolder&amp; srcBuf, JS::MutableHandleScript script);
<span class="lineNum">    4209 </span>            : 
<span class="lineNum">    4210 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4211 </span>            : CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4212 </span>            :                             const char* bytes, size_t length, JS::MutableHandleScript script);
<span class="lineNum">    4213 </span>            : 
<span class="lineNum">    4214 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4215 </span>            : CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4216 </span>            :                             const char16_t* chars, size_t length, JS::MutableHandleScript script);
<span class="lineNum">    4217 </span>            : 
<span class="lineNum">    4218 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4219 </span>            : CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4220 </span>            :                             FILE* file, JS::MutableHandleScript script);
<span class="lineNum">    4221 </span>            : 
<span class="lineNum">    4222 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4223 </span>            : CompileForNonSyntacticScope(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4224 </span>            :                             const char* filename, JS::MutableHandleScript script);
<span class="lineNum">    4225 </span>            : 
<span class="lineNum">    4226 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4227 </span>            : CanCompileOffThread(JSContext* cx, const ReadOnlyCompileOptions&amp; options, size_t length);
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span>            : /*
<span class="lineNum">    4230 </span>            :  * Off thread compilation control flow.
<span class="lineNum">    4231 </span>            :  *
<span class="lineNum">    4232 </span>            :  * After successfully triggering an off thread compile of a script, the
<span class="lineNum">    4233 </span>            :  * callback will eventually be invoked with the specified data and a token
<span class="lineNum">    4234 </span>            :  * for the compilation. The callback will be invoked while off thread,
<span class="lineNum">    4235 </span>            :  * so must ensure that its operations are thread safe. Afterwards, one of the
<span class="lineNum">    4236 </span>            :  * following functions must be invoked on the runtime's active thread:
<span class="lineNum">    4237 </span>            :  *
<span class="lineNum">    4238 </span>            :  * - FinishOffThreadScript, to get the result script (or nullptr on failure).
<span class="lineNum">    4239 </span>            :  * - CancelOffThreadScript, to free the resources without creating a script.
<span class="lineNum">    4240 </span>            :  *
<span class="lineNum">    4241 </span>            :  * The characters passed in to CompileOffThread must remain live until the
<span class="lineNum">    4242 </span>            :  * callback is invoked, and the resulting script will be rooted until the call
<span class="lineNum">    4243 </span>            :  * to FinishOffThreadScript.
<span class="lineNum">    4244 </span>            :  */
<span class="lineNum">    4245 </span>            : 
<span class="lineNum">    4246 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4247 </span>            : CompileOffThread(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4248 </span>            :                  const char16_t* chars, size_t length,
<span class="lineNum">    4249 </span>            :                  OffThreadCompileCallback callback, void* callbackData);
<span class="lineNum">    4250 </span>            : 
<span class="lineNum">    4251 </span>            : extern JS_PUBLIC_API(JSScript*)
<span class="lineNum">    4252 </span>            : FinishOffThreadScript(JSContext* cx, void* token);
<span class="lineNum">    4253 </span>            : 
<span class="lineNum">    4254 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4255 </span>            : CancelOffThreadScript(JSContext* cx, void* token);
<span class="lineNum">    4256 </span>            : 
<span class="lineNum">    4257 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4258 </span>            : CompileOffThreadModule(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4259 </span>            :                        const char16_t* chars, size_t length,
<span class="lineNum">    4260 </span>            :                        OffThreadCompileCallback callback, void* callbackData);
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4263 </span>            : FinishOffThreadModule(JSContext* cx, void* token);
<span class="lineNum">    4264 </span>            : 
<span class="lineNum">    4265 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4266 </span>            : CancelOffThreadModule(JSContext* cx, void* token);
<span class="lineNum">    4267 </span>            : 
<span class="lineNum">    4268 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4269 </span>            : DecodeOffThreadScript(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4270 </span>            :                       mozilla::Vector&lt;uint8_t&gt;&amp; buffer /* TranscodeBuffer&amp; */, size_t cursor,
<span class="lineNum">    4271 </span>            :                       OffThreadCompileCallback callback, void* callbackData);
<span class="lineNum">    4272 </span>            : 
<span class="lineNum">    4273 </span>            : extern JS_PUBLIC_API(JSScript*)
<span class="lineNum">    4274 </span>            : FinishOffThreadScriptDecoder(JSContext* cx, void* token);
<span class="lineNum">    4275 </span>            : 
<span class="lineNum">    4276 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4277 </span>            : CancelOffThreadScriptDecoder(JSContext* cx, void* token);
<span class="lineNum">    4278 </span>            : 
<span class="lineNum">    4279 </span>            : /**
<span class="lineNum">    4280 </span>            :  * Compile a function with envChain plus the global as its scope chain.
<span class="lineNum">    4281 </span>            :  * envChain must contain objects in the current compartment of cx.  The actual
<span class="lineNum">    4282 </span>            :  * scope chain used for the function will consist of With wrappers for those
<span class="lineNum">    4283 </span>            :  * objects, followed by the current global of the compartment cx is in.  This
<span class="lineNum">    4284 </span>            :  * global must not be explicitly included in the scope chain.
<span class="lineNum">    4285 </span>            :  */
<span class="lineNum">    4286 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4287 </span>            : CompileFunction(JSContext* cx, AutoObjectVector&amp; envChain,
<span class="lineNum">    4288 </span>            :                 const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4289 </span>            :                 const char* name, unsigned nargs, const char* const* argnames,
<span class="lineNum">    4290 </span>            :                 const char16_t* chars, size_t length, JS::MutableHandleFunction fun);
<span class="lineNum">    4291 </span>            : 
<span class="lineNum">    4292 </span>            : /**
<span class="lineNum">    4293 </span>            :  * Same as above, but taking a SourceBufferHolder for the function body.
<span class="lineNum">    4294 </span>            :  */
<span class="lineNum">    4295 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4296 </span>            : CompileFunction(JSContext* cx, AutoObjectVector&amp; envChain,
<span class="lineNum">    4297 </span>            :                 const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4298 </span>            :                 const char* name, unsigned nargs, const char* const* argnames,
<span class="lineNum">    4299 </span>            :                 SourceBufferHolder&amp; srcBuf, JS::MutableHandleFunction fun);
<span class="lineNum">    4300 </span>            : 
<span class="lineNum">    4301 </span>            : /**
<span class="lineNum">    4302 </span>            :  * Same as above, but taking a const char * for the function body.
<span class="lineNum">    4303 </span>            :  */
<span class="lineNum">    4304 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4305 </span>            : CompileFunction(JSContext* cx, AutoObjectVector&amp; envChain,
<span class="lineNum">    4306 </span>            :                 const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4307 </span>            :                 const char* name, unsigned nargs, const char* const* argnames,
<span class="lineNum">    4308 </span>            :                 const char* bytes, size_t length, JS::MutableHandleFunction fun);
<span class="lineNum">    4309 </span>            : 
<span class="lineNum">    4310 </span>            : } /* namespace JS */
<span class="lineNum">    4311 </span>            : 
<span class="lineNum">    4312 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4313 </span>            : JS_DecompileScript(JSContext* cx, JS::Handle&lt;JSScript*&gt; script, const char* name, unsigned indent);
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span>            : /*
<span class="lineNum">    4316 </span>            :  * API extension: OR this into indent to avoid pretty-printing the decompiled
<span class="lineNum">    4317 </span>            :  * source resulting from JS_DecompileFunction.
<span class="lineNum">    4318 </span>            :  */
<span class="lineNum">    4319 </span>            : #define JS_DONT_PRETTY_PRINT    ((unsigned)0x8000)
<span class="lineNum">    4320 </span>            : 
<span class="lineNum">    4321 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4322 </span>            : JS_DecompileFunction(JSContext* cx, JS::Handle&lt;JSFunction*&gt; fun, unsigned indent);
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span>            : 
<span class="lineNum">    4325 </span>            : /*
<span class="lineNum">    4326 </span>            :  * NB: JS_ExecuteScript and the JS::Evaluate APIs come in two flavors: either
<span class="lineNum">    4327 </span>            :  * they use the global as the scope, or they take an AutoObjectVector of objects
<span class="lineNum">    4328 </span>            :  * to use as the scope chain.  In the former case, the global is also used as
<span class="lineNum">    4329 </span>            :  * the &quot;this&quot; keyword value and the variables object (ECMA parlance for where
<span class="lineNum">    4330 </span>            :  * 'var' and 'function' bind names) of the execution context for script.  In the
<span class="lineNum">    4331 </span>            :  * latter case, the first object in the provided list is used, unless the list
<span class="lineNum">    4332 </span>            :  * is empty, in which case the global is used.
<span class="lineNum">    4333 </span>            :  *
<span class="lineNum">    4334 </span>            :  * Why a runtime option?  The alternative is to add APIs duplicating those
<span class="lineNum">    4335 </span>            :  * for the other value of flags, and that doesn't seem worth the code bloat
<span class="lineNum">    4336 </span>            :  * cost.  Such new entry points would probably have less obvious names, too, so
<span class="lineNum">    4337 </span>            :  * would not tend to be used.  The ContextOptionsRef adjustment, OTOH, can be
<span class="lineNum">    4338 </span>            :  * more easily hacked into existing code that does not depend on the bug; such
<span class="lineNum">    4339 </span>            :  * code can continue to use the familiar JS::Evaluate, etc., entry points.
<span class="lineNum">    4340 </span>            :  */
<span class="lineNum">    4341 </span>            : 
<span class="lineNum">    4342 </span>            : /**
<span class="lineNum">    4343 </span>            :  * Evaluate a script in the scope of the current global of cx.
<span class="lineNum">    4344 </span>            :  */
<span class="lineNum">    4345 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4346 </span>            : JS_ExecuteScript(JSContext* cx, JS::HandleScript script, JS::MutableHandleValue rval);
<span class="lineNum">    4347 </span>            : 
<span class="lineNum">    4348 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4349 </span>            : JS_ExecuteScript(JSContext* cx, JS::HandleScript script);
<span class="lineNum">    4350 </span>            : 
<span class="lineNum">    4351 </span>            : /**
<span class="lineNum">    4352 </span>            :  * As above, but providing an explicit scope chain.  envChain must not include
<span class="lineNum">    4353 </span>            :  * the global object on it; that's implicit.  It needs to contain the other
<span class="lineNum">    4354 </span>            :  * objects that should end up on the script's scope chain.
<span class="lineNum">    4355 </span>            :  */
<span class="lineNum">    4356 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4357 </span>            : JS_ExecuteScript(JSContext* cx, JS::AutoObjectVector&amp; envChain,
<span class="lineNum">    4358 </span>            :                  JS::HandleScript script, JS::MutableHandleValue rval);
<span class="lineNum">    4359 </span>            : 
<span class="lineNum">    4360 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4361 </span>            : JS_ExecuteScript(JSContext* cx, JS::AutoObjectVector&amp; envChain, JS::HandleScript script);
<span class="lineNum">    4362 </span>            : 
<span class="lineNum">    4363 </span>            : namespace JS {
<span class="lineNum">    4364 </span>            : 
<span class="lineNum">    4365 </span>            : /**
<span class="lineNum">    4366 </span>            :  * Like the above, but handles a cross-compartment script. If the script is
<span class="lineNum">    4367 </span>            :  * cross-compartment, it is cloned into the current compartment before executing.
<span class="lineNum">    4368 </span>            :  */
<span class="lineNum">    4369 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4370 </span>            : CloneAndExecuteScript(JSContext* cx, JS::Handle&lt;JSScript*&gt; script,
<span class="lineNum">    4371 </span>            :                       JS::MutableHandleValue rval);
<span class="lineNum">    4372 </span>            : 
<span class="lineNum">    4373 </span>            : } /* namespace JS */
<span class="lineNum">    4374 </span>            : 
<span class="lineNum">    4375 </span>            : namespace JS {
<span class="lineNum">    4376 </span>            : 
<span class="lineNum">    4377 </span>            : /**
<span class="lineNum">    4378 </span>            :  * Evaluate the given source buffer in the scope of the current global of cx.
<span class="lineNum">    4379 </span>            :  */
<span class="lineNum">    4380 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4381 </span>            : Evaluate(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4382 </span>            :          SourceBufferHolder&amp; srcBuf, JS::MutableHandleValue rval);
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span>            : /**
<span class="lineNum">    4385 </span>            :  * As above, but providing an explicit scope chain.  envChain must not include
<span class="lineNum">    4386 </span>            :  * the global object on it; that's implicit.  It needs to contain the other
<span class="lineNum">    4387 </span>            :  * objects that should end up on the script's scope chain.
<span class="lineNum">    4388 </span>            :  */
<span class="lineNum">    4389 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4390 </span>            : Evaluate(JSContext* cx, AutoObjectVector&amp; envChain, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4391 </span>            :          SourceBufferHolder&amp; srcBuf, JS::MutableHandleValue rval);
<span class="lineNum">    4392 </span>            : 
<span class="lineNum">    4393 </span>            : /**
<span class="lineNum">    4394 </span>            :  * Evaluate the given character buffer in the scope of the current global of cx.
<span class="lineNum">    4395 </span>            :  */
<span class="lineNum">    4396 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4397 </span>            : Evaluate(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4398 </span>            :          const char16_t* chars, size_t length, JS::MutableHandleValue rval);
<span class="lineNum">    4399 </span>            : 
<span class="lineNum">    4400 </span>            : /**
<span class="lineNum">    4401 </span>            :  * As above, but providing an explicit scope chain.  envChain must not include
<span class="lineNum">    4402 </span>            :  * the global object on it; that's implicit.  It needs to contain the other
<span class="lineNum">    4403 </span>            :  * objects that should end up on the script's scope chain.
<span class="lineNum">    4404 </span>            :  */
<span class="lineNum">    4405 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4406 </span>            : Evaluate(JSContext* cx, AutoObjectVector&amp; envChain, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4407 </span>            :          const char16_t* chars, size_t length, JS::MutableHandleValue rval);
<span class="lineNum">    4408 </span>            : 
<span class="lineNum">    4409 </span>            : /**
<span class="lineNum">    4410 </span>            :  * Evaluate the given byte buffer in the scope of the current global of cx.
<span class="lineNum">    4411 </span>            :  */
<span class="lineNum">    4412 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4413 </span>            : Evaluate(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4414 </span>            :          const char* bytes, size_t length, JS::MutableHandleValue rval);
<span class="lineNum">    4415 </span>            : 
<span class="lineNum">    4416 </span>            : /**
<span class="lineNum">    4417 </span>            :  * Evaluate the given file in the scope of the current global of cx.
<span class="lineNum">    4418 </span>            :  */
<span class="lineNum">    4419 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4420 </span>            : Evaluate(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4421 </span>            :          const char* filename, JS::MutableHandleValue rval);
<span class="lineNum">    4422 </span>            : 
<span class="lineNum">    4423 </span>            : /**
<span class="lineNum">    4424 </span>            :  * Get the HostResolveImportedModule hook for a global.
<span class="lineNum">    4425 </span>            :  */
<span class="lineNum">    4426 </span>            : extern JS_PUBLIC_API(JSFunction*)
<span class="lineNum">    4427 </span>            : GetModuleResolveHook(JSContext* cx);
<span class="lineNum">    4428 </span>            : 
<span class="lineNum">    4429 </span>            : /**
<span class="lineNum">    4430 </span>            :  * Set the HostResolveImportedModule hook for a global to the given function.
<span class="lineNum">    4431 </span>            :  */
<span class="lineNum">    4432 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4433 </span>            : SetModuleResolveHook(JSContext* cx, JS::HandleFunction func);
<span class="lineNum">    4434 </span>            : 
<span class="lineNum">    4435 </span>            : /**
<span class="lineNum">    4436 </span>            :  * Parse the given source buffer as a module in the scope of the current global
<span class="lineNum">    4437 </span>            :  * of cx and return a source text module record.
<span class="lineNum">    4438 </span>            :  */
<span class="lineNum">    4439 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4440 </span>            : CompileModule(JSContext* cx, const ReadOnlyCompileOptions&amp; options,
<span class="lineNum">    4441 </span>            :               SourceBufferHolder&amp; srcBuf, JS::MutableHandleObject moduleRecord);
<span class="lineNum">    4442 </span>            : 
<span class="lineNum">    4443 </span>            : /**
<span class="lineNum">    4444 </span>            :  * Set the [[HostDefined]] field of a source text module record to the given
<span class="lineNum">    4445 </span>            :  * value.
<span class="lineNum">    4446 </span>            :  */
<span class="lineNum">    4447 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4448 </span>            : SetModuleHostDefinedField(JSObject* module, const JS::Value&amp; value);
<span class="lineNum">    4449 </span>            : 
<span class="lineNum">    4450 </span>            : /**
<span class="lineNum">    4451 </span>            :  * Get the [[HostDefined]] field of a source text module record.
<span class="lineNum">    4452 </span>            :  */
<span class="lineNum">    4453 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">    4454 </span>            : GetModuleHostDefinedField(JSObject* module);
<span class="lineNum">    4455 </span>            : 
<span class="lineNum">    4456 </span>            : /*
<span class="lineNum">    4457 </span>            :  * Perform the ModuleDeclarationInstantiation operation on on the give source
<span class="lineNum">    4458 </span>            :  * text module record.
<span class="lineNum">    4459 </span>            :  *
<span class="lineNum">    4460 </span>            :  * This transitively resolves all module dependencies (calling the
<span class="lineNum">    4461 </span>            :  * HostResolveImportedModule hook) and initializes the environment record for
<span class="lineNum">    4462 </span>            :  * the module.
<span class="lineNum">    4463 </span>            :  */
<span class="lineNum">    4464 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4465 </span>            : ModuleDeclarationInstantiation(JSContext* cx, JS::HandleObject moduleRecord);
<span class="lineNum">    4466 </span>            : 
<span class="lineNum">    4467 </span>            : /*
<span class="lineNum">    4468 </span>            :  * Perform the ModuleEvaluation operation on on the give source text module
<span class="lineNum">    4469 </span>            :  * record.
<span class="lineNum">    4470 </span>            :  *
<span class="lineNum">    4471 </span>            :  * This does nothing if this module has already been evaluated. Otherwise, it
<span class="lineNum">    4472 </span>            :  * transitively evaluates all dependences of this module and then evaluates this
<span class="lineNum">    4473 </span>            :  * module.
<span class="lineNum">    4474 </span>            :  *
<span class="lineNum">    4475 </span>            :  * ModuleDeclarationInstantiation must have completed prior to calling this.
<span class="lineNum">    4476 </span>            :  */
<span class="lineNum">    4477 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4478 </span>            : ModuleEvaluation(JSContext* cx, JS::HandleObject moduleRecord);
<span class="lineNum">    4479 </span>            : 
<span class="lineNum">    4480 </span>            : /*
<span class="lineNum">    4481 </span>            :  * Get a list of the module specifiers used by a source text module
<span class="lineNum">    4482 </span>            :  * record to request importation of modules.
<span class="lineNum">    4483 </span>            :  *
<span class="lineNum">    4484 </span>            :  * The result is a JavaScript array of string values.  To extract the individual
<span class="lineNum">    4485 </span>            :  * values use only JS_GetArrayLength and JS_GetElement with indices 0 to
<span class="lineNum">    4486 </span>            :  * length - 1.
<span class="lineNum">    4487 </span>            :  */
<span class="lineNum">    4488 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4489 </span>            : GetRequestedModules(JSContext* cx, JS::HandleObject moduleRecord);
<span class="lineNum">    4490 </span>            : 
<span class="lineNum">    4491 </span>            : /*
<span class="lineNum">    4492 </span>            :  * Get the script associated with a module.
<span class="lineNum">    4493 </span>            :  */
<span class="lineNum">    4494 </span>            : extern JS_PUBLIC_API(JSScript*)
<span class="lineNum">    4495 </span>            : GetModuleScript(JSContext* cx, JS::HandleObject moduleRecord);
<span class="lineNum">    4496 </span>            : 
<span class="lineNum">    4497 </span>            : } /* namespace JS */
<span class="lineNum">    4498 </span>            : 
<span class="lineNum">    4499 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4500 </span>            : JS_CheckForInterrupt(JSContext* cx);
<span class="lineNum">    4501 </span>            : 
<span class="lineNum">    4502 </span>            : /*
<span class="lineNum">    4503 </span>            :  * These functions allow setting an interrupt callback that will be called
<span class="lineNum">    4504 </span>            :  * from the JS thread some time after any thread triggered the callback using
<span class="lineNum">    4505 </span>            :  * JS_RequestInterruptCallback(cx).
<span class="lineNum">    4506 </span>            :  *
<span class="lineNum">    4507 </span>            :  * To schedule the GC and for other activities the engine internally triggers
<span class="lineNum">    4508 </span>            :  * interrupt callbacks. The embedding should thus not rely on callbacks being
<span class="lineNum">    4509 </span>            :  * triggered through the external API only.
<span class="lineNum">    4510 </span>            :  *
<span class="lineNum">    4511 </span>            :  * Important note: Additional callbacks can occur inside the callback handler
<span class="lineNum">    4512 </span>            :  * if it re-enters the JS engine. The embedding must ensure that the callback
<span class="lineNum">    4513 </span>            :  * is disconnected before attempting such re-entry.
<span class="lineNum">    4514 </span>            :  */
<span class="lineNum">    4515 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4516 </span>            : JS_AddInterruptCallback(JSContext* cx, JSInterruptCallback callback);
<span class="lineNum">    4517 </span>            : 
<span class="lineNum">    4518 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4519 </span>            : JS_DisableInterruptCallback(JSContext* cx);
<span class="lineNum">    4520 </span>            : 
<span class="lineNum">    4521 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4522 </span>            : JS_ResetInterruptCallback(JSContext* cx, bool enable);
<span class="lineNum">    4523 </span>            : 
<span class="lineNum">    4524 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4525 </span>            : JS_RequestInterruptCallback(JSContext* cx);
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span>            : namespace JS {
<span class="lineNum">    4528 </span>            : 
<span class="lineNum">    4529 </span>            : /**
<span class="lineNum">    4530 </span>            :  * Sets the callback that's invoked whenever an incumbent global is required.
<span class="lineNum">    4531 </span>            :  *
<span class="lineNum">    4532 </span>            :  * SpiderMonkey doesn't itself have a notion of incumbent globals as defined
<span class="lineNum">    4533 </span>            :  * by the html spec, so we need the embedding to provide this.
<span class="lineNum">    4534 </span>            :  * See dom/base/ScriptSettings.h for details.
<span class="lineNum">    4535 </span>            :  */
<span class="lineNum">    4536 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4537 </span>            : SetGetIncumbentGlobalCallback(JSContext* cx, JSGetIncumbentGlobalCallback callback);
<span class="lineNum">    4538 </span>            : 
<span class="lineNum">    4539 </span>            : /**
<span class="lineNum">    4540 </span>            :  * Sets the callback that's invoked whenever a Promise job should be enqeued.
<span class="lineNum">    4541 </span>            :  *
<span class="lineNum">    4542 </span>            :  * SpiderMonkey doesn't schedule Promise resolution jobs itself; instead,
<span class="lineNum">    4543 </span>            :  * using this function the embedding can provide a callback to do that
<span class="lineNum">    4544 </span>            :  * scheduling. The provided `callback` is invoked with the promise job,
<span class="lineNum">    4545 </span>            :  * the corresponding Promise's allocation stack, and the `data` pointer
<span class="lineNum">    4546 </span>            :  * passed here as arguments.
<span class="lineNum">    4547 </span>            :  */
<span class="lineNum">    4548 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4549 </span>            : SetEnqueuePromiseJobCallback(JSContext* cx, JSEnqueuePromiseJobCallback callback,
<span class="lineNum">    4550 </span>            :                              void* data = nullptr);
<span class="lineNum">    4551 </span>            : 
<span class="lineNum">    4552 </span>            : /**
<span class="lineNum">    4553 </span>            :  * Sets the callback that's invoked whenever a Promise is rejected without
<span class="lineNum">    4554 </span>            :  * a rejection handler, and when a Promise that was previously rejected
<span class="lineNum">    4555 </span>            :  * without a handler gets a handler attached.
<span class="lineNum">    4556 </span>            :  */
<span class="lineNum">    4557 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4558 </span>            : SetPromiseRejectionTrackerCallback(JSContext* cx, JSPromiseRejectionTrackerCallback callback,
<span class="lineNum">    4559 </span>            :                                    void* data = nullptr);
<span class="lineNum">    4560 </span>            : 
<span class="lineNum">    4561 </span>            : /**
<span class="lineNum">    4562 </span>            :  * Returns a new instance of the Promise builtin class in the current
<span class="lineNum">    4563 </span>            :  * compartment, with the right slot layout. If a `proto` is passed, that gets
<span class="lineNum">    4564 </span>            :  * set as the instance's [[Prototype]] instead of the original value of
<span class="lineNum">    4565 </span>            :  * `Promise.prototype`.
<span class="lineNum">    4566 </span>            :  */
<span class="lineNum">    4567 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4568 </span>            : NewPromiseObject(JSContext* cx, JS::HandleObject executor, JS::HandleObject proto = nullptr);
<span class="lineNum">    4569 </span>            : 
<span class="lineNum">    4570 </span>            : /**
<span class="lineNum">    4571 </span>            :  * Returns true if the given object is an unwrapped PromiseObject, false
<span class="lineNum">    4572 </span>            :  * otherwise.
<span class="lineNum">    4573 </span>            :  */
<span class="lineNum">    4574 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4575 </span>            : IsPromiseObject(JS::HandleObject obj);
<span class="lineNum">    4576 </span>            : 
<span class="lineNum">    4577 </span>            : /**
<span class="lineNum">    4578 </span>            :  * Returns the current compartment's original Promise constructor.
<span class="lineNum">    4579 </span>            :  */
<span class="lineNum">    4580 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4581 </span>            : GetPromiseConstructor(JSContext* cx);
<span class="lineNum">    4582 </span>            : 
<span class="lineNum">    4583 </span>            : /**
<span class="lineNum">    4584 </span>            :  * Returns the current compartment's original Promise.prototype.
<span class="lineNum">    4585 </span>            :  */
<span class="lineNum">    4586 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4587 </span>            : GetPromisePrototype(JSContext* cx);
<span class="lineNum">    4588 </span>            : 
<span class="lineNum">    4589 </span>            : // Keep this in sync with the PROMISE_STATE defines in SelfHostingDefines.h.
<span class="lineNum">    4590 </span>            : enum class PromiseState {
<span class="lineNum">    4591 </span>            :     Pending,
<span class="lineNum">    4592 </span>            :     Fulfilled,
<span class="lineNum">    4593 </span>            :     Rejected
<span class="lineNum">    4594 </span>            : };
<span class="lineNum">    4595 </span>            : 
<span class="lineNum">    4596 </span>            : /**
<span class="lineNum">    4597 </span>            :  * Returns the given Promise's state as a JS::PromiseState enum value.
<span class="lineNum">    4598 </span>            :  */
<span class="lineNum">    4599 </span>            : extern JS_PUBLIC_API(PromiseState)
<span class="lineNum">    4600 </span>            : GetPromiseState(JS::HandleObject promise);
<span class="lineNum">    4601 </span>            : 
<span class="lineNum">    4602 </span>            : /**
<span class="lineNum">    4603 </span>            :  * Returns the given Promise's process-unique ID.
<span class="lineNum">    4604 </span>            :  */
<span class="lineNum">    4605 </span>            : JS_PUBLIC_API(uint64_t)
<span class="lineNum">    4606 </span>            : GetPromiseID(JS::HandleObject promise);
<span class="lineNum">    4607 </span>            : 
<span class="lineNum">    4608 </span>            : /**
<span class="lineNum">    4609 </span>            :  * Returns the given Promise's result: either the resolution value for
<span class="lineNum">    4610 </span>            :  * fulfilled promises, or the rejection reason for rejected ones.
<span class="lineNum">    4611 </span>            :  */
<span class="lineNum">    4612 </span>            : extern JS_PUBLIC_API(JS::Value)
<span class="lineNum">    4613 </span>            : GetPromiseResult(JS::HandleObject promise);
<span class="lineNum">    4614 </span>            : 
<span class="lineNum">    4615 </span>            : /**
<span class="lineNum">    4616 </span>            :  * Returns a js::SavedFrame linked list of the stack that lead to the given
<span class="lineNum">    4617 </span>            :  * Promise's allocation.
<span class="lineNum">    4618 </span>            :  */
<span class="lineNum">    4619 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4620 </span>            : GetPromiseAllocationSite(JS::HandleObject promise);
<span class="lineNum">    4621 </span>            : 
<span class="lineNum">    4622 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4623 </span>            : GetPromiseResolutionSite(JS::HandleObject promise);
<span class="lineNum">    4624 </span>            : 
<span class="lineNum">    4625 </span>            : #ifdef DEBUG
<span class="lineNum">    4626 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4627 </span>            : DumpPromiseAllocationSite(JSContext* cx, JS::HandleObject promise);
<span class="lineNum">    4628 </span>            : 
<span class="lineNum">    4629 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4630 </span>            : DumpPromiseResolutionSite(JSContext* cx, JS::HandleObject promise);
<span class="lineNum">    4631 </span>            : #endif
<span class="lineNum">    4632 </span>            : 
<span class="lineNum">    4633 </span>            : /**
<span class="lineNum">    4634 </span>            :  * Calls the current compartment's original Promise.resolve on the original
<span class="lineNum">    4635 </span>            :  * Promise constructor, with `resolutionValue` passed as an argument.
<span class="lineNum">    4636 </span>            :  */
<span class="lineNum">    4637 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4638 </span>            : CallOriginalPromiseResolve(JSContext* cx, JS::HandleValue resolutionValue);
<span class="lineNum">    4639 </span>            : 
<span class="lineNum">    4640 </span>            : /**
<span class="lineNum">    4641 </span>            :  * Calls the current compartment's original Promise.reject on the original
<span class="lineNum">    4642 </span>            :  * Promise constructor, with `resolutionValue` passed as an argument.
<span class="lineNum">    4643 </span>            :  */
<span class="lineNum">    4644 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4645 </span>            : CallOriginalPromiseReject(JSContext* cx, JS::HandleValue rejectionValue);
<span class="lineNum">    4646 </span>            : 
<span class="lineNum">    4647 </span>            : /**
<span class="lineNum">    4648 </span>            :  * Resolves the given Promise with the given `resolutionValue`.
<span class="lineNum">    4649 </span>            :  *
<span class="lineNum">    4650 </span>            :  * Calls the `resolve` function that was passed to the executor function when
<span class="lineNum">    4651 </span>            :  * the Promise was created.
<span class="lineNum">    4652 </span>            :  */
<span class="lineNum">    4653 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4654 </span>            : ResolvePromise(JSContext* cx, JS::HandleObject promiseObj, JS::HandleValue resolutionValue);
<span class="lineNum">    4655 </span>            : 
<span class="lineNum">    4656 </span>            : /**
<span class="lineNum">    4657 </span>            :  * Rejects the given `promise` with the given `rejectionValue`.
<span class="lineNum">    4658 </span>            :  *
<span class="lineNum">    4659 </span>            :  * Calls the `reject` function that was passed to the executor function when
<span class="lineNum">    4660 </span>            :  * the Promise was created.
<span class="lineNum">    4661 </span>            :  */
<span class="lineNum">    4662 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4663 </span>            : RejectPromise(JSContext* cx, JS::HandleObject promiseObj, JS::HandleValue rejectionValue);
<span class="lineNum">    4664 </span>            : 
<span class="lineNum">    4665 </span>            : /**
<span class="lineNum">    4666 </span>            :  * Calls the current compartment's original Promise.prototype.then on the
<span class="lineNum">    4667 </span>            :  * given `promise`, with `onResolve` and `onReject` passed as arguments.
<span class="lineNum">    4668 </span>            :  *
<span class="lineNum">    4669 </span>            :  * Asserts if the passed-in `promise` object isn't an unwrapped instance of
<span class="lineNum">    4670 </span>            :  * `Promise` or a subclass or `onResolve` and `onReject` aren't both either
<span class="lineNum">    4671 </span>            :  * `nullptr` or callable objects.
<span class="lineNum">    4672 </span>            :  */
<span class="lineNum">    4673 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4674 </span>            : CallOriginalPromiseThen(JSContext* cx, JS::HandleObject promise,
<span class="lineNum">    4675 </span>            :                         JS::HandleObject onResolve, JS::HandleObject onReject);
<span class="lineNum">    4676 </span>            : 
<span class="lineNum">    4677 </span>            : /**
<span class="lineNum">    4678 </span>            :  * Unforgeable, optimized version of the JS builtin Promise.prototype.then.
<span class="lineNum">    4679 </span>            :  *
<span class="lineNum">    4680 </span>            :  * Takes a Promise instance and `onResolve`, `onReject` callables to enqueue
<span class="lineNum">    4681 </span>            :  * as reactions for that promise. In difference to Promise.prototype.then,
<span class="lineNum">    4682 </span>            :  * this doesn't create and return a new Promise instance.
<span class="lineNum">    4683 </span>            :  *
<span class="lineNum">    4684 </span>            :  * Asserts if the passed-in `promise` object isn't an unwrapped instance of
<span class="lineNum">    4685 </span>            :  * `Promise` or a subclass or `onResolve` and `onReject` aren't both callable
<span class="lineNum">    4686 </span>            :  * objects.
<span class="lineNum">    4687 </span>            :  */
<span class="lineNum">    4688 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4689 </span>            : AddPromiseReactions(JSContext* cx, JS::HandleObject promise,
<span class="lineNum">    4690 </span>            :                     JS::HandleObject onResolve, JS::HandleObject onReject);
<span class="lineNum">    4691 </span>            : 
<span class="lineNum">    4692 </span>            : /**
<span class="lineNum">    4693 </span>            :  * Unforgeable version of the JS builtin Promise.all.
<span class="lineNum">    4694 </span>            :  *
<span class="lineNum">    4695 </span>            :  * Takes an AutoObjectVector of Promise objects and returns a promise that's
<span class="lineNum">    4696 </span>            :  * resolved with an array of resolution values when all those promises ahve
<span class="lineNum">    4697 </span>            :  * been resolved, or rejected with the rejection value of the first rejected
<span class="lineNum">    4698 </span>            :  * promise.
<span class="lineNum">    4699 </span>            :  *
<span class="lineNum">    4700 </span>            :  * Asserts if the array isn't dense or one of the entries isn't an unwrapped
<span class="lineNum">    4701 </span>            :  * instance of Promise or a subclass.
<span class="lineNum">    4702 </span>            :  */
<span class="lineNum">    4703 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    4704 </span>            : GetWaitForAllPromise(JSContext* cx, const JS::AutoObjectVector&amp; promises);
<span class="lineNum">    4705 </span>            : 
<span class="lineNum">    4706 </span>            : /**
<span class="lineNum">    4707 </span>            :  * An AsyncTask represents a SpiderMonkey-internal operation that starts on a
<span class="lineNum">    4708 </span>            :  * JSContext's owner thread, possibly executes on other threads, completes, and
<span class="lineNum">    4709 </span>            :  * then needs to be scheduled to run again on the JSContext's owner thread. The
<span class="lineNum">    4710 </span>            :  * embedding provides for this final dispatch back to the JSContext's owner
<span class="lineNum">    4711 </span>            :  * thread by calling methods on this interface when requested.
<span class="lineNum">    4712 </span>            :  */
<span class="lineNum">    4713 </span>            : struct JS_PUBLIC_API(AsyncTask)
<span class="lineNum">    4714 </span>            : {
<span class="lineNum">    4715 </span><span class="lineCov">          1 :     AsyncTask() : user(nullptr) {}</span>
<span class="lineNum">    4716 </span><span class="lineCov">          1 :     virtual ~AsyncTask() {}</span>
<span class="lineNum">    4717 </span>            : 
<span class="lineNum">    4718 </span>            :     /**
<span class="lineNum">    4719 </span>            :      * After the FinishAsyncTaskCallback is called and succeeds, one of these
<span class="lineNum">    4720 </span>            :      * two functions will be called on the original JSContext's owner thread.
<span class="lineNum">    4721 </span>            :      */
<span class="lineNum">    4722 </span>            :     virtual void finish(JSContext* cx) = 0;
<span class="lineNum">    4723 </span>            :     virtual void cancel(JSContext* cx) = 0;
<span class="lineNum">    4724 </span>            : 
<span class="lineNum">    4725 </span>            :     /* The embedding may use this field to attach arbitrary data to a task. */
<span class="lineNum">    4726 </span>            :     void* user;
<span class="lineNum">    4727 </span>            : };
<span class="lineNum">    4728 </span>            : 
<span class="lineNum">    4729 </span>            : /**
<span class="lineNum">    4730 </span>            :  * A new AsyncTask object, created inside SpiderMonkey on the JSContext's owner
<span class="lineNum">    4731 </span>            :  * thread, will be passed to the StartAsyncTaskCallback before it is dispatched
<span class="lineNum">    4732 </span>            :  * to another thread. The embedding may use the AsyncTask::user field to attach
<span class="lineNum">    4733 </span>            :  * additional task state.
<span class="lineNum">    4734 </span>            :  *
<span class="lineNum">    4735 </span>            :  * If this function succeeds, SpiderMonkey will call the FinishAsyncTaskCallback
<span class="lineNum">    4736 </span>            :  * at some point in the future. Otherwise, FinishAsyncTaskCallback will *not*
<span class="lineNum">    4737 </span>            :  * be called. SpiderMonkey assumes that, if StartAsyncTaskCallback fails, it is
<span class="lineNum">    4738 </span>            :  * because the JSContext is being shut down.
<span class="lineNum">    4739 </span>            :  */
<span class="lineNum">    4740 </span>            : typedef bool
<span class="lineNum">    4741 </span>            : (*StartAsyncTaskCallback)(JSContext* cx, AsyncTask* task);
<span class="lineNum">    4742 </span>            : 
<span class="lineNum">    4743 </span>            : /**
<span class="lineNum">    4744 </span>            :  * The FinishAsyncTaskCallback may be called from any thread and will only be
<span class="lineNum">    4745 </span>            :  * passed AsyncTasks that have already been started via StartAsyncTaskCallback.
<span class="lineNum">    4746 </span>            :  * If the embedding returns 'true', indicating success, the embedding must call
<span class="lineNum">    4747 </span>            :  * either task-&gt;finish() or task-&gt;cancel() on the JSContext's owner thread at
<span class="lineNum">    4748 </span>            :  * some point in the future.
<span class="lineNum">    4749 </span>            :  */
<span class="lineNum">    4750 </span>            : typedef bool
<span class="lineNum">    4751 </span>            : (*FinishAsyncTaskCallback)(AsyncTask* task);
<span class="lineNum">    4752 </span>            : 
<span class="lineNum">    4753 </span>            : /**
<span class="lineNum">    4754 </span>            :  * Set the above callbacks for the given context.
<span class="lineNum">    4755 </span>            :  */
<span class="lineNum">    4756 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    4757 </span>            : SetAsyncTaskCallbacks(JSContext* cx, StartAsyncTaskCallback start, FinishAsyncTaskCallback finish);
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span>            : /**
<span class="lineNum">    4760 </span>            :  * This class can be used to store a pointer to the youngest frame of a saved
<span class="lineNum">    4761 </span>            :  * stack in the specified JSContext. This reference will be picked up by any new
<span class="lineNum">    4762 </span>            :  * calls performed until the class is destroyed, with the specified asyncCause,
<span class="lineNum">    4763 </span>            :  * that must not be empty.
<span class="lineNum">    4764 </span>            :  *
<span class="lineNum">    4765 </span>            :  * Any stack capture initiated during these new calls will go through the async
<span class="lineNum">    4766 </span>            :  * stack instead of the current stack.
<span class="lineNum">    4767 </span>            :  *
<span class="lineNum">    4768 </span>            :  * Capturing the stack before a new call is performed will not be affected.
<span class="lineNum">    4769 </span>            :  *
<span class="lineNum">    4770 </span>            :  * The provided chain of SavedFrame objects can live in any compartment,
<span class="lineNum">    4771 </span>            :  * although it will be copied to the compartment where the stack is captured.
<span class="lineNum">    4772 </span>            :  *
<span class="lineNum">    4773 </span>            :  * See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
<span class="lineNum">    4774 </span>            :  * stack frames.
<span class="lineNum">    4775 </span>            :  */
<span class="lineNum">    4776 </span>            : class MOZ_STACK_CLASS JS_PUBLIC_API(AutoSetAsyncStackForNewCalls)
<span class="lineNum">    4777 </span>            : {
<span class="lineNum">    4778 </span>            :     JSContext* cx;
<span class="lineNum">    4779 </span>            :     RootedObject oldAsyncStack;
<span class="lineNum">    4780 </span>            :     const char* oldAsyncCause;
<span class="lineNum">    4781 </span>            :     bool oldAsyncCallIsExplicit;
<span class="lineNum">    4782 </span>            : 
<span class="lineNum">    4783 </span>            :   public:
<span class="lineNum">    4784 </span>            :     enum class AsyncCallKind {
<span class="lineNum">    4785 </span>            :         // The ordinary kind of call, where we may apply an async
<span class="lineNum">    4786 </span>            :         // parent if there is no ordinary parent.
<span class="lineNum">    4787 </span>            :         IMPLICIT,
<span class="lineNum">    4788 </span>            :         // An explicit async parent, e.g., callFunctionWithAsyncStack,
<span class="lineNum">    4789 </span>            :         // where we always want to override any ordinary parent.
<span class="lineNum">    4790 </span>            :         EXPLICIT
<span class="lineNum">    4791 </span>            :     };
<span class="lineNum">    4792 </span>            : 
<span class="lineNum">    4793 </span>            :     // The stack parameter cannot be null by design, because it would be
<span class="lineNum">    4794 </span>            :     // ambiguous whether that would clear any scheduled async stack and make the
<span class="lineNum">    4795 </span>            :     // normal stack reappear in the new call, or just keep the async stack
<span class="lineNum">    4796 </span>            :     // already scheduled for the new call, if any.
<span class="lineNum">    4797 </span>            :     //
<span class="lineNum">    4798 </span>            :     // asyncCause is owned by the caller and its lifetime must outlive the
<span class="lineNum">    4799 </span>            :     // lifetime of the AutoSetAsyncStackForNewCalls object. It is strongly
<span class="lineNum">    4800 </span>            :     // encouraged that asyncCause be a string constant or similar statically
<span class="lineNum">    4801 </span>            :     // allocated string.
<span class="lineNum">    4802 </span>            :     AutoSetAsyncStackForNewCalls(JSContext* cx, HandleObject stack,
<span class="lineNum">    4803 </span>            :                                  const char* asyncCause,
<span class="lineNum">    4804 </span>            :                                  AsyncCallKind kind = AsyncCallKind::IMPLICIT);
<span class="lineNum">    4805 </span>            :     ~AutoSetAsyncStackForNewCalls();
<span class="lineNum">    4806 </span>            : };
<span class="lineNum">    4807 </span>            : 
<span class="lineNum">    4808 </span>            : } // namespace JS
<span class="lineNum">    4809 </span>            : 
<span class="lineNum">    4810 </span>            : /************************************************************************/
<span class="lineNum">    4811 </span>            : 
<span class="lineNum">    4812 </span>            : /*
<span class="lineNum">    4813 </span>            :  * Strings.
<span class="lineNum">    4814 </span>            :  *
<span class="lineNum">    4815 </span>            :  * NB: JS_NewUCString takes ownership of bytes on success, avoiding a copy;
<span class="lineNum">    4816 </span>            :  * but on error (signified by null return), it leaves chars owned by the
<span class="lineNum">    4817 </span>            :  * caller. So the caller must free bytes in the error case, if it has no use
<span class="lineNum">    4818 </span>            :  * for them. In contrast, all the JS_New*StringCopy* functions do not take
<span class="lineNum">    4819 </span>            :  * ownership of the character memory passed to them -- they copy it.
<span class="lineNum">    4820 </span>            :  */
<span class="lineNum">    4821 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4822 </span>            : JS_NewStringCopyN(JSContext* cx, const char* s, size_t n);
<span class="lineNum">    4823 </span>            : 
<span class="lineNum">    4824 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4825 </span>            : JS_NewStringCopyZ(JSContext* cx, const char* s);
<span class="lineNum">    4826 </span>            : 
<span class="lineNum">    4827 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4828 </span>            : JS_NewStringCopyUTF8Z(JSContext* cx, const JS::ConstUTF8CharsZ s);
<span class="lineNum">    4829 </span>            : 
<span class="lineNum">    4830 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4831 </span>            : JS_NewStringCopyUTF8N(JSContext* cx, const JS::UTF8Chars s);
<span class="lineNum">    4832 </span>            : 
<span class="lineNum">    4833 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4834 </span>            : JS_AtomizeAndPinJSString(JSContext* cx, JS::HandleString str);
<span class="lineNum">    4835 </span>            : 
<span class="lineNum">    4836 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4837 </span>            : JS_AtomizeStringN(JSContext* cx, const char* s, size_t length);
<span class="lineNum">    4838 </span>            : 
<span class="lineNum">    4839 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4840 </span>            : JS_AtomizeString(JSContext* cx, const char* s);
<span class="lineNum">    4841 </span>            : 
<span class="lineNum">    4842 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4843 </span>            : JS_AtomizeAndPinStringN(JSContext* cx, const char* s, size_t length);
<span class="lineNum">    4844 </span>            : 
<span class="lineNum">    4845 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4846 </span>            : JS_AtomizeAndPinString(JSContext* cx, const char* s);
<span class="lineNum">    4847 </span>            : 
<span class="lineNum">    4848 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4849 </span>            : JS_NewUCString(JSContext* cx, char16_t* chars, size_t length);
<span class="lineNum">    4850 </span>            : 
<span class="lineNum">    4851 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4852 </span>            : JS_NewUCStringCopyN(JSContext* cx, const char16_t* s, size_t n);
<span class="lineNum">    4853 </span>            : 
<span class="lineNum">    4854 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4855 </span>            : JS_NewUCStringCopyZ(JSContext* cx, const char16_t* s);
<span class="lineNum">    4856 </span>            : 
<span class="lineNum">    4857 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4858 </span>            : JS_AtomizeUCStringN(JSContext* cx, const char16_t* s, size_t length);
<span class="lineNum">    4859 </span>            : 
<span class="lineNum">    4860 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4861 </span>            : JS_AtomizeUCString(JSContext* cx, const char16_t* s);
<span class="lineNum">    4862 </span>            : 
<span class="lineNum">    4863 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4864 </span>            : JS_AtomizeAndPinUCStringN(JSContext* cx, const char16_t* s, size_t length);
<span class="lineNum">    4865 </span>            : 
<span class="lineNum">    4866 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4867 </span>            : JS_AtomizeAndPinUCString(JSContext* cx, const char16_t* s);
<span class="lineNum">    4868 </span>            : 
<span class="lineNum">    4869 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4870 </span>            : JS_CompareStrings(JSContext* cx, JSString* str1, JSString* str2, int32_t* result);
<span class="lineNum">    4871 </span>            : 
<span class="lineNum">    4872 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4873 </span>            : JS_StringEqualsAscii(JSContext* cx, JSString* str, const char* asciiBytes, bool* match);
<span class="lineNum">    4874 </span>            : 
<span class="lineNum">    4875 </span>            : extern JS_PUBLIC_API(size_t)
<span class="lineNum">    4876 </span>            : JS_PutEscapedString(JSContext* cx, char* buffer, size_t size, JSString* str, char quote);
<span class="lineNum">    4877 </span>            : 
<span class="lineNum">    4878 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4879 </span>            : JS_FileEscapedString(FILE* fp, JSString* str, char quote);
<span class="lineNum">    4880 </span>            : 
<span class="lineNum">    4881 </span>            : /*
<span class="lineNum">    4882 </span>            :  * Extracting string characters and length.
<span class="lineNum">    4883 </span>            :  *
<span class="lineNum">    4884 </span>            :  * While getting the length of a string is infallible, getting the chars can
<span class="lineNum">    4885 </span>            :  * fail. As indicated by the lack of a JSContext parameter, there are two
<span class="lineNum">    4886 </span>            :  * special cases where getting the chars is infallible:
<span class="lineNum">    4887 </span>            :  *
<span class="lineNum">    4888 </span>            :  * The first case is for strings that have been atomized, e.g. directly by
<span class="lineNum">    4889 </span>            :  * JS_AtomizeAndPinString or implicitly because it is stored in a jsid.
<span class="lineNum">    4890 </span>            :  *
<span class="lineNum">    4891 </span>            :  * The second case is &quot;flat&quot; strings that have been explicitly prepared in a
<span class="lineNum">    4892 </span>            :  * fallible context by JS_FlattenString. To catch errors, a separate opaque
<span class="lineNum">    4893 </span>            :  * JSFlatString type is returned by JS_FlattenString and expected by
<span class="lineNum">    4894 </span>            :  * JS_GetFlatStringChars. Note, though, that this is purely a syntactic
<span class="lineNum">    4895 </span>            :  * distinction: the input and output of JS_FlattenString are the same actual
<span class="lineNum">    4896 </span>            :  * GC-thing. If a JSString is known to be flat, JS_ASSERT_STRING_IS_FLAT can be
<span class="lineNum">    4897 </span>            :  * used to make a debug-checked cast. Example:
<span class="lineNum">    4898 </span>            :  *
<span class="lineNum">    4899 </span>            :  *   // in a fallible context
<span class="lineNum">    4900 </span>            :  *   JSFlatString* fstr = JS_FlattenString(cx, str);
<span class="lineNum">    4901 </span>            :  *   if (!fstr)
<span class="lineNum">    4902 </span>            :  *     return false;
<span class="lineNum">    4903 </span>            :  *   MOZ_ASSERT(fstr == JS_ASSERT_STRING_IS_FLAT(str));
<span class="lineNum">    4904 </span>            :  *
<span class="lineNum">    4905 </span>            :  *   // in an infallible context, for the same 'str'
<span class="lineNum">    4906 </span>            :  *   AutoCheckCannotGC nogc;
<span class="lineNum">    4907 </span>            :  *   const char16_t* chars = JS_GetTwoByteFlatStringChars(nogc, fstr)
<span class="lineNum">    4908 </span>            :  *   MOZ_ASSERT(chars);
<span class="lineNum">    4909 </span>            :  *
<span class="lineNum">    4910 </span>            :  * Flat strings and interned strings are always null-terminated, so
<span class="lineNum">    4911 </span>            :  * JS_FlattenString can be used to get a null-terminated string.
<span class="lineNum">    4912 </span>            :  *
<span class="lineNum">    4913 </span>            :  * Additionally, string characters are stored as either Latin1Char (8-bit)
<span class="lineNum">    4914 </span>            :  * or char16_t (16-bit). Clients can use JS_StringHasLatin1Chars and can then
<span class="lineNum">    4915 </span>            :  * call either the Latin1* or TwoByte* functions. Some functions like
<span class="lineNum">    4916 </span>            :  * JS_CopyStringChars and JS_GetStringCharAt accept both Latin1 and TwoByte
<span class="lineNum">    4917 </span>            :  * strings.
<span class="lineNum">    4918 </span>            :  */
<span class="lineNum">    4919 </span>            : 
<span class="lineNum">    4920 </span>            : extern JS_PUBLIC_API(size_t)
<span class="lineNum">    4921 </span>            : JS_GetStringLength(JSString* str);
<span class="lineNum">    4922 </span>            : 
<span class="lineNum">    4923 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4924 </span>            : JS_StringIsFlat(JSString* str);
<span class="lineNum">    4925 </span>            : 
<span class="lineNum">    4926 </span>            : /** Returns true iff the string's characters are stored as Latin1. */
<span class="lineNum">    4927 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4928 </span>            : JS_StringHasLatin1Chars(JSString* str);
<span class="lineNum">    4929 </span>            : 
<span class="lineNum">    4930 </span>            : extern JS_PUBLIC_API(const JS::Latin1Char*)
<span class="lineNum">    4931 </span>            : JS_GetLatin1StringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC&amp; nogc, JSString* str,
<span class="lineNum">    4932 </span>            :                                  size_t* length);
<span class="lineNum">    4933 </span>            : 
<span class="lineNum">    4934 </span>            : extern JS_PUBLIC_API(const char16_t*)
<span class="lineNum">    4935 </span>            : JS_GetTwoByteStringCharsAndLength(JSContext* cx, const JS::AutoCheckCannotGC&amp; nogc, JSString* str,
<span class="lineNum">    4936 </span>            :                                   size_t* length);
<span class="lineNum">    4937 </span>            : 
<span class="lineNum">    4938 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4939 </span>            : JS_GetStringCharAt(JSContext* cx, JSString* str, size_t index, char16_t* res);
<span class="lineNum">    4940 </span>            : 
<span class="lineNum">    4941 </span>            : extern JS_PUBLIC_API(char16_t)
<span class="lineNum">    4942 </span>            : JS_GetFlatStringCharAt(JSFlatString* str, size_t index);
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span>            : extern JS_PUBLIC_API(const char16_t*)
<span class="lineNum">    4945 </span>            : JS_GetTwoByteExternalStringChars(JSString* str);
<span class="lineNum">    4946 </span>            : 
<span class="lineNum">    4947 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4948 </span>            : JS_CopyStringChars(JSContext* cx, mozilla::Range&lt;char16_t&gt; dest, JSString* str);
<span class="lineNum">    4949 </span>            : 
<span class="lineNum">    4950 </span>            : extern JS_PUBLIC_API(JSFlatString*)
<span class="lineNum">    4951 </span>            : JS_FlattenString(JSContext* cx, JSString* str);
<span class="lineNum">    4952 </span>            : 
<span class="lineNum">    4953 </span>            : extern JS_PUBLIC_API(const JS::Latin1Char*)
<span class="lineNum">    4954 </span>            : JS_GetLatin1FlatStringChars(const JS::AutoCheckCannotGC&amp; nogc, JSFlatString* str);
<span class="lineNum">    4955 </span>            : 
<span class="lineNum">    4956 </span>            : extern JS_PUBLIC_API(const char16_t*)
<span class="lineNum">    4957 </span>            : JS_GetTwoByteFlatStringChars(const JS::AutoCheckCannotGC&amp; nogc, JSFlatString* str);
<span class="lineNum">    4958 </span>            : 
<span class="lineNum">    4959 </span>            : static MOZ_ALWAYS_INLINE JSFlatString*
<span class="lineNum">    4960 </span>            : JSID_TO_FLAT_STRING(jsid id)
<span class="lineNum">    4961 </span>            : {
<span class="lineNum">    4962 </span>            :     MOZ_ASSERT(JSID_IS_STRING(id));
<span class="lineNum">    4963 </span><span class="lineCov">          1 :     return (JSFlatString*)(JSID_BITS(id));</span>
<span class="lineNum">    4964 </span>            : }
<span class="lineNum">    4965 </span>            : 
<span class="lineNum">    4966 </span>            : static MOZ_ALWAYS_INLINE JSFlatString*
<span class="lineNum">    4967 </span>            : JS_ASSERT_STRING_IS_FLAT(JSString* str)
<span class="lineNum">    4968 </span>            : {
<span class="lineNum">    4969 </span>            :     MOZ_ASSERT(JS_StringIsFlat(str));
<span class="lineNum">    4970 </span>            :     return (JSFlatString*)str;
<span class="lineNum">    4971 </span>            : }
<span class="lineNum">    4972 </span>            : 
<span class="lineNum">    4973 </span>            : static MOZ_ALWAYS_INLINE JSString*
<span class="lineNum">    4974 </span>            : JS_FORGET_STRING_FLATNESS(JSFlatString* fstr)
<span class="lineNum">    4975 </span>            : {
<span class="lineNum">    4976 </span>            :     return (JSString*)fstr;
<span class="lineNum">    4977 </span>            : }
<span class="lineNum">    4978 </span>            : 
<span class="lineNum">    4979 </span>            : /*
<span class="lineNum">    4980 </span>            :  * Additional APIs that avoid fallibility when given a flat string.
<span class="lineNum">    4981 </span>            :  */
<span class="lineNum">    4982 </span>            : 
<span class="lineNum">    4983 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    4984 </span>            : JS_FlatStringEqualsAscii(JSFlatString* str, const char* asciiBytes);
<span class="lineNum">    4985 </span>            : 
<span class="lineNum">    4986 </span>            : extern JS_PUBLIC_API(size_t)
<span class="lineNum">    4987 </span>            : JS_PutEscapedFlatString(char* buffer, size_t size, JSFlatString* str, char quote);
<span class="lineNum">    4988 </span>            : 
<span class="lineNum">    4989 </span>            : /**
<span class="lineNum">    4990 </span>            :  * Create a dependent string, i.e., a string that owns no character storage,
<span class="lineNum">    4991 </span>            :  * but that refers to a slice of another string's chars.  Dependent strings
<span class="lineNum">    4992 </span>            :  * are mutable by definition, so the thread safety comments above apply.
<span class="lineNum">    4993 </span>            :  */
<span class="lineNum">    4994 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    4995 </span>            : JS_NewDependentString(JSContext* cx, JS::HandleString str, size_t start,
<span class="lineNum">    4996 </span>            :                       size_t length);
<span class="lineNum">    4997 </span>            : 
<span class="lineNum">    4998 </span>            : /**
<span class="lineNum">    4999 </span>            :  * Concatenate two strings, possibly resulting in a rope.
<span class="lineNum">    5000 </span>            :  * See above for thread safety comments.
<span class="lineNum">    5001 </span>            :  */
<span class="lineNum">    5002 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    5003 </span>            : JS_ConcatStrings(JSContext* cx, JS::HandleString left, JS::HandleString right);
<span class="lineNum">    5004 </span>            : 
<span class="lineNum">    5005 </span>            : /**
<span class="lineNum">    5006 </span>            :  * For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before
<span class="lineNum">    5007 </span>            :  * the call; on return, *dstlenp contains the number of characters actually
<span class="lineNum">    5008 </span>            :  * stored. To determine the necessary destination buffer size, make a sizing
<span class="lineNum">    5009 </span>            :  * call that passes nullptr for dst.
<span class="lineNum">    5010 </span>            :  *
<span class="lineNum">    5011 </span>            :  * On errors, the functions report the error. In that case, *dstlenp contains
<span class="lineNum">    5012 </span>            :  * the number of characters or bytes transferred so far.  If cx is nullptr, no
<span class="lineNum">    5013 </span>            :  * error is reported on failure, and the functions simply return false.
<span class="lineNum">    5014 </span>            :  *
<span class="lineNum">    5015 </span>            :  * NB: This function does not store an additional zero byte or char16_t after the
<span class="lineNum">    5016 </span>            :  * transcoded string.
<span class="lineNum">    5017 </span>            :  */
<span class="lineNum">    5018 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5019 </span>            : JS_DecodeBytes(JSContext* cx, const char* src, size_t srclen, char16_t* dst,
<span class="lineNum">    5020 </span>            :                size_t* dstlenp);
<span class="lineNum">    5021 </span>            : 
<span class="lineNum">    5022 </span>            : /**
<span class="lineNum">    5023 </span>            :  * A variation on JS_EncodeCharacters where a null terminated string is
<span class="lineNum">    5024 </span>            :  * returned that you are expected to call JS_free on when done.
<span class="lineNum">    5025 </span>            :  */
<span class="lineNum">    5026 </span>            : JS_PUBLIC_API(char*)
<span class="lineNum">    5027 </span>            : JS_EncodeString(JSContext* cx, JSString* str);
<span class="lineNum">    5028 </span>            : 
<span class="lineNum">    5029 </span>            : /**
<span class="lineNum">    5030 </span>            :  * Same behavior as JS_EncodeString(), but encode into UTF-8 string
<span class="lineNum">    5031 </span>            :  */
<span class="lineNum">    5032 </span>            : JS_PUBLIC_API(char*)
<span class="lineNum">    5033 </span>            : JS_EncodeStringToUTF8(JSContext* cx, JS::HandleString str);
<span class="lineNum">    5034 </span>            : 
<span class="lineNum">    5035 </span>            : /**
<span class="lineNum">    5036 </span>            :  * Get number of bytes in the string encoding (without accounting for a
<span class="lineNum">    5037 </span>            :  * terminating zero bytes. The function returns (size_t) -1 if the string
<span class="lineNum">    5038 </span>            :  * can not be encoded into bytes and reports an error using cx accordingly.
<span class="lineNum">    5039 </span>            :  */
<span class="lineNum">    5040 </span>            : JS_PUBLIC_API(size_t)
<span class="lineNum">    5041 </span>            : JS_GetStringEncodingLength(JSContext* cx, JSString* str);
<span class="lineNum">    5042 </span>            : 
<span class="lineNum">    5043 </span>            : /**
<span class="lineNum">    5044 </span>            :  * Encode string into a buffer. The function does not stores an additional
<span class="lineNum">    5045 </span>            :  * zero byte. The function returns (size_t) -1 if the string can not be
<span class="lineNum">    5046 </span>            :  * encoded into bytes with no error reported. Otherwise it returns the number
<span class="lineNum">    5047 </span>            :  * of bytes that are necessary to encode the string. If that exceeds the
<span class="lineNum">    5048 </span>            :  * length parameter, the string will be cut and only length bytes will be
<span class="lineNum">    5049 </span>            :  * written into the buffer.
<span class="lineNum">    5050 </span>            :  */
<span class="lineNum">    5051 </span>            : JS_PUBLIC_API(size_t)
<span class="lineNum">    5052 </span>            : JS_EncodeStringToBuffer(JSContext* cx, JSString* str, char* buffer, size_t length);
<span class="lineNum">    5053 </span>            : 
<span class="lineNum">    5054 </span>            : class MOZ_RAII JSAutoByteString
<a name="5055"><span class="lineNum">    5055 </span>            : {</a>
<span class="lineNum">    5056 </span>            :   public:
<span class="lineNum">    5057 </span><span class="lineNoCov">          0 :     JSAutoByteString(JSContext* cx, JSString* str</span>
<span class="lineNum">    5058 </span>            :                      MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">    5059 </span><span class="lineCov">          1 :       : mBytes(JS_EncodeString(cx, str))</span>
<span class="lineNum">    5060 </span>            :     {
<span class="lineNum">    5061 </span>            :         MOZ_ASSERT(cx);
<span class="lineNum">    5062 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">    5063 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    5064 </span>            : 
<span class="lineNum">    5065 </span>            :     explicit JSAutoByteString(MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM)
<span class="lineNum">    5066 </span><span class="lineCov">          1 :       : mBytes(nullptr)</span>
<span class="lineNum">    5067 </span>            :     {
<span class="lineNum">    5068 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<a name="5069"><span class="lineNum">    5069 </span>            :     }</a>
<span class="lineNum">    5070 </span>            : 
<span class="lineNum">    5071 </span><span class="lineNoCov">          0 :     ~JSAutoByteString() {</span>
<span class="lineNum">    5072 </span><span class="lineCov">          1 :         JS_free(nullptr, mBytes);</span>
<span class="lineNum">    5073 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    5074 </span>            : 
<span class="lineNum">    5075 </span>            :     /* Take ownership of the given byte array. */
<span class="lineNum">    5076 </span>            :     void initBytes(char* bytes) {
<span class="lineNum">    5077 </span>            :         MOZ_ASSERT(!mBytes);
<span class="lineNum">    5078 </span><span class="lineNoCov">          0 :         mBytes = bytes;</span>
<span class="lineNum">    5079 </span>            :     }
<span class="lineNum">    5080 </span>            : 
<span class="lineNum">    5081 </span>            :     char* encodeLatin1(JSContext* cx, JSString* str) {
<span class="lineNum">    5082 </span>            :         MOZ_ASSERT(!mBytes);
<span class="lineNum">    5083 </span>            :         MOZ_ASSERT(cx);
<span class="lineNum">    5084 </span><span class="lineCov">          1 :         mBytes = JS_EncodeString(cx, str);</span>
<span class="lineNum">    5085 </span>            :         return mBytes;
<span class="lineNum">    5086 </span>            :     }
<span class="lineNum">    5087 </span>            : 
<span class="lineNum">    5088 </span>            :     char* encodeUtf8(JSContext* cx, JS::HandleString str) {
<span class="lineNum">    5089 </span>            :         MOZ_ASSERT(!mBytes);
<span class="lineNum">    5090 </span>            :         MOZ_ASSERT(cx);
<span class="lineNum">    5091 </span><span class="lineCov">          1 :         mBytes = JS_EncodeStringToUTF8(cx, str);</span>
<span class="lineNum">    5092 </span>            :         return mBytes;
<span class="lineNum">    5093 </span>            :     }
<span class="lineNum">    5094 </span>            : 
<span class="lineNum">    5095 </span>            :     void clear() {
<span class="lineNum">    5096 </span><span class="lineNoCov">          0 :         js_free(mBytes);</span>
<span class="lineNum">    5097 </span><span class="lineNoCov">          0 :         mBytes = nullptr;</span>
<a name="5098"><span class="lineNum">    5098 </span>            :     }</a>
<span class="lineNum">    5099 </span>            : 
<span class="lineNum">    5100 </span><span class="lineNoCov">          0 :     char* ptr() const {</span>
<span class="lineNum">    5101 </span><span class="lineCov">          1 :         return mBytes;</span>
<a name="5102"><span class="lineNum">    5102 </span>            :     }</a>
<span class="lineNum">    5103 </span>            : 
<span class="lineNum">    5104 </span><span class="lineNoCov">          0 :     bool operator!() const {</span>
<span class="lineNum">    5105 </span><span class="lineNoCov">          0 :         return !mBytes;</span>
<span class="lineNum">    5106 </span>            :     }
<span class="lineNum">    5107 </span>            : 
<span class="lineNum">    5108 </span>            :     size_t length() const {
<span class="lineNum">    5109 </span>            :         if (!mBytes)
<span class="lineNum">    5110 </span>            :             return 0;
<span class="lineNum">    5111 </span>            :         return strlen(mBytes);
<span class="lineNum">    5112 </span>            :     }
<span class="lineNum">    5113 </span>            : 
<span class="lineNum">    5114 </span>            :   private:
<span class="lineNum">    5115 </span>            :     char* mBytes;
<span class="lineNum">    5116 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    5117 </span>            : 
<span class="lineNum">    5118 </span>            :     /* Copy and assignment are not supported. */
<span class="lineNum">    5119 </span>            :     JSAutoByteString(const JSAutoByteString&amp; another);
<span class="lineNum">    5120 </span>            :     JSAutoByteString&amp; operator=(const JSAutoByteString&amp; another);
<span class="lineNum">    5121 </span>            : };
<span class="lineNum">    5122 </span>            : 
<span class="lineNum">    5123 </span>            : namespace JS {
<span class="lineNum">    5124 </span>            : 
<span class="lineNum">    5125 </span>            : extern JS_PUBLIC_API(JSAddonId*)
<span class="lineNum">    5126 </span>            : NewAddonId(JSContext* cx, JS::HandleString str);
<span class="lineNum">    5127 </span>            : 
<span class="lineNum">    5128 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    5129 </span>            : StringOfAddonId(JSAddonId* id);
<span class="lineNum">    5130 </span>            : 
<span class="lineNum">    5131 </span>            : extern JS_PUBLIC_API(JSAddonId*)
<span class="lineNum">    5132 </span>            : AddonIdOfObject(JSObject* obj);
<span class="lineNum">    5133 </span>            : 
<span class="lineNum">    5134 </span>            : } // namespace JS
<span class="lineNum">    5135 </span>            : 
<span class="lineNum">    5136 </span>            : /************************************************************************/
<span class="lineNum">    5137 </span>            : /*
<span class="lineNum">    5138 </span>            :  * Symbols
<span class="lineNum">    5139 </span>            :  */
<span class="lineNum">    5140 </span>            : 
<span class="lineNum">    5141 </span>            : namespace JS {
<span class="lineNum">    5142 </span>            : 
<span class="lineNum">    5143 </span>            : /**
<span class="lineNum">    5144 </span>            :  * Create a new Symbol with the given description. This function never returns
<span class="lineNum">    5145 </span>            :  * a Symbol that is in the Runtime-wide symbol registry.
<span class="lineNum">    5146 </span>            :  *
<span class="lineNum">    5147 </span>            :  * If description is null, the new Symbol's [[Description]] attribute is
<span class="lineNum">    5148 </span>            :  * undefined.
<span class="lineNum">    5149 </span>            :  */
<span class="lineNum">    5150 </span>            : JS_PUBLIC_API(Symbol*)
<span class="lineNum">    5151 </span>            : NewSymbol(JSContext* cx, HandleString description);
<span class="lineNum">    5152 </span>            : 
<span class="lineNum">    5153 </span>            : /**
<span class="lineNum">    5154 </span>            :  * Symbol.for as specified in ES6.
<span class="lineNum">    5155 </span>            :  *
<span class="lineNum">    5156 </span>            :  * Get a Symbol with the description 'key' from the Runtime-wide symbol registry.
<span class="lineNum">    5157 </span>            :  * If there is not already a Symbol with that description in the registry, a new
<span class="lineNum">    5158 </span>            :  * Symbol is created and registered. 'key' must not be null.
<span class="lineNum">    5159 </span>            :  */
<span class="lineNum">    5160 </span>            : JS_PUBLIC_API(Symbol*)
<span class="lineNum">    5161 </span>            : GetSymbolFor(JSContext* cx, HandleString key);
<span class="lineNum">    5162 </span>            : 
<span class="lineNum">    5163 </span>            : /**
<span class="lineNum">    5164 </span>            :  * Get the [[Description]] attribute of the given symbol.
<span class="lineNum">    5165 </span>            :  *
<span class="lineNum">    5166 </span>            :  * This function is infallible. If it returns null, that means the symbol's
<span class="lineNum">    5167 </span>            :  * [[Description]] is undefined.
<span class="lineNum">    5168 </span>            :  */
<span class="lineNum">    5169 </span>            : JS_PUBLIC_API(JSString*)
<span class="lineNum">    5170 </span>            : GetSymbolDescription(HandleSymbol symbol);
<span class="lineNum">    5171 </span>            : 
<span class="lineNum">    5172 </span>            : /* Well-known symbols. */
<span class="lineNum">    5173 </span>            : #define JS_FOR_EACH_WELL_KNOWN_SYMBOL(macro) \
<span class="lineNum">    5174 </span>            :     macro(isConcatSpreadable) \
<span class="lineNum">    5175 </span>            :     macro(iterator) \
<span class="lineNum">    5176 </span>            :     macro(match) \
<span class="lineNum">    5177 </span>            :     macro(replace) \
<span class="lineNum">    5178 </span>            :     macro(search) \
<span class="lineNum">    5179 </span>            :     macro(species) \
<span class="lineNum">    5180 </span>            :     macro(hasInstance) \
<span class="lineNum">    5181 </span>            :     macro(split) \
<span class="lineNum">    5182 </span>            :     macro(toPrimitive) \
<span class="lineNum">    5183 </span>            :     macro(toStringTag) \
<span class="lineNum">    5184 </span>            :     macro(unscopables) \
<span class="lineNum">    5185 </span>            :     macro(asyncIterator)
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span>            : enum class SymbolCode : uint32_t {
<span class="lineNum">    5188 </span>            :     // There is one SymbolCode for each well-known symbol.
<span class="lineNum">    5189 </span>            : #define JS_DEFINE_SYMBOL_ENUM(name) name,
<span class="lineNum">    5190 </span>            :     JS_FOR_EACH_WELL_KNOWN_SYMBOL(JS_DEFINE_SYMBOL_ENUM)  // SymbolCode::iterator, etc.
<span class="lineNum">    5191 </span>            : #undef JS_DEFINE_SYMBOL_ENUM
<span class="lineNum">    5192 </span>            :     Limit,
<span class="lineNum">    5193 </span>            :     InSymbolRegistry = 0xfffffffe,  // created by Symbol.for() or JS::GetSymbolFor()
<span class="lineNum">    5194 </span>            :     UniqueSymbol = 0xffffffff       // created by Symbol() or JS::NewSymbol()
<span class="lineNum">    5195 </span>            : };
<span class="lineNum">    5196 </span>            : 
<span class="lineNum">    5197 </span>            : /* For use in loops that iterate over the well-known symbols. */
<span class="lineNum">    5198 </span>            : const size_t WellKnownSymbolLimit = size_t(SymbolCode::Limit);
<span class="lineNum">    5199 </span>            : 
<span class="lineNum">    5200 </span>            : /**
<span class="lineNum">    5201 </span>            :  * Return the SymbolCode telling what sort of symbol `symbol` is.
<span class="lineNum">    5202 </span>            :  *
<span class="lineNum">    5203 </span>            :  * A symbol's SymbolCode never changes once it is created.
<span class="lineNum">    5204 </span>            :  */
<span class="lineNum">    5205 </span>            : JS_PUBLIC_API(SymbolCode)
<span class="lineNum">    5206 </span>            : GetSymbolCode(Handle&lt;Symbol*&gt; symbol);
<span class="lineNum">    5207 </span>            : 
<span class="lineNum">    5208 </span>            : /**
<span class="lineNum">    5209 </span>            :  * Get one of the well-known symbols defined by ES6. A single set of well-known
<span class="lineNum">    5210 </span>            :  * symbols is shared by all compartments in a JSRuntime.
<span class="lineNum">    5211 </span>            :  *
<span class="lineNum">    5212 </span>            :  * `which` must be in the range [0, WellKnownSymbolLimit).
<span class="lineNum">    5213 </span>            :  */
<span class="lineNum">    5214 </span>            : JS_PUBLIC_API(Symbol*)
<span class="lineNum">    5215 </span>            : GetWellKnownSymbol(JSContext* cx, SymbolCode which);
<span class="lineNum">    5216 </span>            : 
<span class="lineNum">    5217 </span>            : /**
<span class="lineNum">    5218 </span>            :  * Return true if the given JSPropertySpec::name or JSFunctionSpec::name value
<span class="lineNum">    5219 </span>            :  * is actually a symbol code and not a string. See JS_SYM_FN.
<span class="lineNum">    5220 </span>            :  */
<span class="lineNum">    5221 </span>            : inline bool
<span class="lineNum">    5222 </span>            : PropertySpecNameIsSymbol(const char* name)
<span class="lineNum">    5223 </span>            : {
<span class="lineNum">    5224 </span><span class="lineCov">          1 :     uintptr_t u = reinterpret_cast&lt;uintptr_t&gt;(name);</span>
<span class="lineNum">    5225 </span><span class="lineCov">          1 :     return u != 0 &amp;&amp; u - 1 &lt; WellKnownSymbolLimit;</span>
<span class="lineNum">    5226 </span>            : }
<span class="lineNum">    5227 </span>            : 
<span class="lineNum">    5228 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5229 </span>            : PropertySpecNameEqualsId(const char* name, HandleId id);
<span class="lineNum">    5230 </span>            : 
<span class="lineNum">    5231 </span>            : /**
<span class="lineNum">    5232 </span>            :  * Create a jsid that does not need to be marked for GC.
<span class="lineNum">    5233 </span>            :  *
<span class="lineNum">    5234 </span>            :  * 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The
<span class="lineNum">    5235 </span>            :  * resulting jsid, on success, is either an interned string or a well-known
<span class="lineNum">    5236 </span>            :  * symbol; either way it is immune to GC so there is no need to visit *idp
<span class="lineNum">    5237 </span>            :  * during GC marking.
<span class="lineNum">    5238 </span>            :  */
<span class="lineNum">    5239 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5240 </span>            : PropertySpecNameToPermanentId(JSContext* cx, const char* name, jsid* idp);
<span class="lineNum">    5241 </span>            : 
<span class="lineNum">    5242 </span>            : } /* namespace JS */
<span class="lineNum">    5243 </span>            : 
<span class="lineNum">    5244 </span>            : /************************************************************************/
<span class="lineNum">    5245 </span>            : /*
<span class="lineNum">    5246 </span>            :  * JSON functions
<span class="lineNum">    5247 </span>            :  */
<span class="lineNum">    5248 </span>            : typedef bool (* JSONWriteCallback)(const char16_t* buf, uint32_t len, void* data);
<span class="lineNum">    5249 </span>            : 
<span class="lineNum">    5250 </span>            : /**
<span class="lineNum">    5251 </span>            :  * JSON.stringify as specified by ES5.
<span class="lineNum">    5252 </span>            :  */
<span class="lineNum">    5253 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5254 </span>            : JS_Stringify(JSContext* cx, JS::MutableHandleValue value, JS::HandleObject replacer,
<span class="lineNum">    5255 </span>            :              JS::HandleValue space, JSONWriteCallback callback, void* data);
<span class="lineNum">    5256 </span>            : 
<span class="lineNum">    5257 </span>            : namespace JS {
<span class="lineNum">    5258 </span>            : 
<span class="lineNum">    5259 </span>            : /**
<span class="lineNum">    5260 </span>            :  * An API akin to JS_Stringify but with the goal of not having observable
<span class="lineNum">    5261 </span>            :  * side-effects when the stringification is performed.  This means it does not
<span class="lineNum">    5262 </span>            :  * allow a replacer or a custom space, and has the following constraints on its
<span class="lineNum">    5263 </span>            :  * input:
<span class="lineNum">    5264 </span>            :  *
<span class="lineNum">    5265 </span>            :  * 1) The input must be a plain object or array, not an abitrary value.
<span class="lineNum">    5266 </span>            :  * 2) Every value in the graph reached by the algorithm starting with this
<span class="lineNum">    5267 </span>            :  *    object must be one of the following: null, undefined, a string (NOT a
<span class="lineNum">    5268 </span>            :  *    string object!), a boolean, a finite number (i.e. no NaN or Infinity or
<span class="lineNum">    5269 </span>            :  *    -Infinity), a plain object with no accessor properties, or an Array with
<span class="lineNum">    5270 </span>            :  *    no holes.
<span class="lineNum">    5271 </span>            :  *
<span class="lineNum">    5272 </span>            :  * The actual behavior differs from JS_Stringify only in asserting the above and
<span class="lineNum">    5273 </span>            :  * NOT attempting to get the &quot;toJSON&quot; property from things, since that could
<span class="lineNum">    5274 </span>            :  * clearly have side-effects.
<span class="lineNum">    5275 </span>            :  */
<span class="lineNum">    5276 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5277 </span>            : ToJSONMaybeSafely(JSContext* cx, JS::HandleObject input,
<span class="lineNum">    5278 </span>            :                   JSONWriteCallback callback, void* data);
<span class="lineNum">    5279 </span>            : 
<span class="lineNum">    5280 </span>            : } /* namespace JS */
<span class="lineNum">    5281 </span>            : 
<span class="lineNum">    5282 </span>            : /**
<span class="lineNum">    5283 </span>            :  * JSON.parse as specified by ES5.
<span class="lineNum">    5284 </span>            :  */
<span class="lineNum">    5285 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5286 </span>            : JS_ParseJSON(JSContext* cx, const char16_t* chars, uint32_t len, JS::MutableHandleValue vp);
<span class="lineNum">    5287 </span>            : 
<span class="lineNum">    5288 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5289 </span>            : JS_ParseJSON(JSContext* cx, JS::HandleString str, JS::MutableHandleValue vp);
<span class="lineNum">    5290 </span>            : 
<span class="lineNum">    5291 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5292 </span>            : JS_ParseJSONWithReviver(JSContext* cx, const char16_t* chars, uint32_t len, JS::HandleValue reviver,
<span class="lineNum">    5293 </span>            :                         JS::MutableHandleValue vp);
<span class="lineNum">    5294 </span>            : 
<span class="lineNum">    5295 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    5296 </span>            : JS_ParseJSONWithReviver(JSContext* cx, JS::HandleString str, JS::HandleValue reviver,
<span class="lineNum">    5297 </span>            :                         JS::MutableHandleValue vp);
<span class="lineNum">    5298 </span>            : 
<span class="lineNum">    5299 </span>            : /************************************************************************/
<span class="lineNum">    5300 </span>            : 
<span class="lineNum">    5301 </span>            : /**
<span class="lineNum">    5302 </span>            :  * The default locale for the ECMAScript Internationalization API
<span class="lineNum">    5303 </span>            :  * (Intl.Collator, Intl.NumberFormat, Intl.DateTimeFormat).
<span class="lineNum">    5304 </span>            :  * Note that the Internationalization API encourages clients to
<span class="lineNum">    5305 </span>            :  * specify their own locales.
<span class="lineNum">    5306 </span>            :  * The locale string remains owned by the caller.
<span class="lineNum">    5307 </span>            :  */
<span class="lineNum">    5308 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5309 </span>            : JS_SetDefaultLocale(JSContext* cx, const char* locale);
<span class="lineNum">    5310 </span>            : 
<span class="lineNum">    5311 </span>            : /**
<span class="lineNum">    5312 </span>            :  * Look up the default locale for the ECMAScript Internationalization API.
<span class="lineNum">    5313 </span>            :  */
<span class="lineNum">    5314 </span>            : extern JS_PUBLIC_API(JS::UniqueChars)
<span class="lineNum">    5315 </span>            : JS_GetDefaultLocale(JSContext* cx);
<span class="lineNum">    5316 </span>            : 
<span class="lineNum">    5317 </span>            : /**
<span class="lineNum">    5318 </span>            :  * Reset the default locale to OS defaults.
<span class="lineNum">    5319 </span>            :  */
<span class="lineNum">    5320 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5321 </span>            : JS_ResetDefaultLocale(JSContext* cx);
<span class="lineNum">    5322 </span>            : 
<span class="lineNum">    5323 </span>            : /**
<span class="lineNum">    5324 </span>            :  * Locale specific string conversion and error message callbacks.
<span class="lineNum">    5325 </span>            :  */
<span class="lineNum">    5326 </span>            : struct JSLocaleCallbacks {
<span class="lineNum">    5327 </span>            :     JSLocaleToUpperCase     localeToUpperCase; // not used #if EXPOSE_INTL_API
<span class="lineNum">    5328 </span>            :     JSLocaleToLowerCase     localeToLowerCase; // not used #if EXPOSE_INTL_API
<span class="lineNum">    5329 </span>            :     JSLocaleCompare         localeCompare; // not used #if EXPOSE_INTL_API
<span class="lineNum">    5330 </span>            :     JSLocaleToUnicode       localeToUnicode;
<span class="lineNum">    5331 </span>            : };
<span class="lineNum">    5332 </span>            : 
<span class="lineNum">    5333 </span>            : /**
<span class="lineNum">    5334 </span>            :  * Establish locale callbacks. The pointer must persist as long as the
<span class="lineNum">    5335 </span>            :  * JSContext.  Passing nullptr restores the default behaviour.
<span class="lineNum">    5336 </span>            :  */
<span class="lineNum">    5337 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5338 </span>            : JS_SetLocaleCallbacks(JSContext* cx, const JSLocaleCallbacks* callbacks);
<span class="lineNum">    5339 </span>            : 
<span class="lineNum">    5340 </span>            : /**
<span class="lineNum">    5341 </span>            :  * Return the address of the current locale callbacks struct, which may
<span class="lineNum">    5342 </span>            :  * be nullptr.
<span class="lineNum">    5343 </span>            :  */
<span class="lineNum">    5344 </span>            : extern JS_PUBLIC_API(const JSLocaleCallbacks*)
<span class="lineNum">    5345 </span>            : JS_GetLocaleCallbacks(JSContext* cx);
<span class="lineNum">    5346 </span>            : 
<span class="lineNum">    5347 </span>            : /************************************************************************/
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span>            : /*
<span class="lineNum">    5350 </span>            :  * Error reporting.
<span class="lineNum">    5351 </span>            :  */
<span class="lineNum">    5352 </span>            : 
<span class="lineNum">    5353 </span>            : namespace JS {
<span class="lineNum">    5354 </span>            : const uint16_t MaxNumErrorArguments = 10;
<span class="lineNum">    5355 </span>            : };
<span class="lineNum">    5356 </span>            : 
<span class="lineNum">    5357 </span>            : /**
<span class="lineNum">    5358 </span>            :  * Report an exception represented by the sprintf-like conversion of format
<span class="lineNum">    5359 </span>            :  * and its arguments.
<span class="lineNum">    5360 </span>            :  */
<span class="lineNum">    5361 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5362 </span>            : JS_ReportErrorASCII(JSContext* cx, const char* format, ...)
<span class="lineNum">    5363 </span>            :     MOZ_FORMAT_PRINTF(2, 3);
<span class="lineNum">    5364 </span>            : 
<span class="lineNum">    5365 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5366 </span>            : JS_ReportErrorLatin1(JSContext* cx, const char* format, ...)
<span class="lineNum">    5367 </span>            :     MOZ_FORMAT_PRINTF(2, 3);
<span class="lineNum">    5368 </span>            : 
<span class="lineNum">    5369 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5370 </span>            : JS_ReportErrorUTF8(JSContext* cx, const char* format, ...)
<span class="lineNum">    5371 </span>            :     MOZ_FORMAT_PRINTF(2, 3);
<span class="lineNum">    5372 </span>            : 
<span class="lineNum">    5373 </span>            : /*
<span class="lineNum">    5374 </span>            :  * Use an errorNumber to retrieve the format string, args are char*
<span class="lineNum">    5375 </span>            :  */
<span class="lineNum">    5376 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5377 </span>            : JS_ReportErrorNumberASCII(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5378 </span>            :                           void* userRef, const unsigned errorNumber, ...);
<span class="lineNum">    5379 </span>            : 
<span class="lineNum">    5380 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5381 </span>            : JS_ReportErrorNumberASCIIVA(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5382 </span>            :                             void* userRef, const unsigned errorNumber, va_list ap);
<span class="lineNum">    5383 </span>            : 
<span class="lineNum">    5384 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5385 </span>            : JS_ReportErrorNumberLatin1(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5386 </span>            :                            void* userRef, const unsigned errorNumber, ...);
<span class="lineNum">    5387 </span>            : 
<span class="lineNum">    5388 </span>            : #ifdef va_start
<span class="lineNum">    5389 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5390 </span>            : JS_ReportErrorNumberLatin1VA(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5391 </span>            :                              void* userRef, const unsigned errorNumber, va_list ap);
<span class="lineNum">    5392 </span>            : #endif
<span class="lineNum">    5393 </span>            : 
<span class="lineNum">    5394 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5395 </span>            : JS_ReportErrorNumberUTF8(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5396 </span>            :                            void* userRef, const unsigned errorNumber, ...);
<span class="lineNum">    5397 </span>            : 
<span class="lineNum">    5398 </span>            : #ifdef va_start
<span class="lineNum">    5399 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5400 </span>            : JS_ReportErrorNumberUTF8VA(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5401 </span>            :                            void* userRef, const unsigned errorNumber, va_list ap);
<span class="lineNum">    5402 </span>            : #endif
<span class="lineNum">    5403 </span>            : 
<span class="lineNum">    5404 </span>            : /*
<span class="lineNum">    5405 </span>            :  * Use an errorNumber to retrieve the format string, args are char16_t*
<span class="lineNum">    5406 </span>            :  */
<span class="lineNum">    5407 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5408 </span>            : JS_ReportErrorNumberUC(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5409 </span>            :                      void* userRef, const unsigned errorNumber, ...);
<span class="lineNum">    5410 </span>            : 
<span class="lineNum">    5411 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5412 </span>            : JS_ReportErrorNumberUCArray(JSContext* cx, JSErrorCallback errorCallback,
<span class="lineNum">    5413 </span>            :                             void* userRef, const unsigned errorNumber,
<span class="lineNum">    5414 </span>            :                             const char16_t** args);
<span class="lineNum">    5415 </span>            : 
<span class="lineNum">    5416 </span>            : /**
<span class="lineNum">    5417 </span>            :  * As above, but report a warning instead (JSREPORT_IS_WARNING(report.flags)).
<span class="lineNum">    5418 </span>            :  * Return true if there was no error trying to issue the warning, and if the
<span class="lineNum">    5419 </span>            :  * warning was not converted into an error due to the JSOPTION_WERROR option
<span class="lineNum">    5420 </span>            :  * being set, false otherwise.
<span class="lineNum">    5421 </span>            :  */
<span class="lineNum">    5422 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5423 </span>            : JS_ReportWarningASCII(JSContext* cx, const char* format, ...)
<span class="lineNum">    5424 </span>            :     MOZ_FORMAT_PRINTF(2, 3);
<span class="lineNum">    5425 </span>            : 
<span class="lineNum">    5426 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5427 </span>            : JS_ReportWarningLatin1(JSContext* cx, const char* format, ...)
<span class="lineNum">    5428 </span>            :     MOZ_FORMAT_PRINTF(2, 3);
<span class="lineNum">    5429 </span>            : 
<span class="lineNum">    5430 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5431 </span>            : JS_ReportWarningUTF8(JSContext* cx, const char* format, ...)
<span class="lineNum">    5432 </span>            :     MOZ_FORMAT_PRINTF(2, 3);
<span class="lineNum">    5433 </span>            : 
<span class="lineNum">    5434 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5435 </span>            : JS_ReportErrorFlagsAndNumberASCII(JSContext* cx, unsigned flags,
<span class="lineNum">    5436 </span>            :                                   JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5437 </span>            :                                   const unsigned errorNumber, ...);
<span class="lineNum">    5438 </span>            : 
<span class="lineNum">    5439 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5440 </span>            : JS_ReportErrorFlagsAndNumberLatin1(JSContext* cx, unsigned flags,
<span class="lineNum">    5441 </span>            :                                    JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5442 </span>            :                                    const unsigned errorNumber, ...);
<span class="lineNum">    5443 </span>            : 
<span class="lineNum">    5444 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5445 </span>            : JS_ReportErrorFlagsAndNumberUTF8(JSContext* cx, unsigned flags,
<span class="lineNum">    5446 </span>            :                                  JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5447 </span>            :                                  const unsigned errorNumber, ...);
<span class="lineNum">    5448 </span>            : 
<span class="lineNum">    5449 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5450 </span>            : JS_ReportErrorFlagsAndNumberUC(JSContext* cx, unsigned flags,
<span class="lineNum">    5451 </span>            :                                JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5452 </span>            :                                const unsigned errorNumber, ...);
<span class="lineNum">    5453 </span>            : 
<span class="lineNum">    5454 </span>            : /**
<span class="lineNum">    5455 </span>            :  * Complain when out of memory.
<span class="lineNum">    5456 </span>            :  */
<span class="lineNum">    5457 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5458 </span>            : JS_ReportOutOfMemory(JSContext* cx);
<span class="lineNum">    5459 </span>            : 
<span class="lineNum">    5460 </span>            : /**
<span class="lineNum">    5461 </span>            :  * Complain when an allocation size overflows the maximum supported limit.
<span class="lineNum">    5462 </span>            :  */
<span class="lineNum">    5463 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5464 </span>            : JS_ReportAllocationOverflow(JSContext* cx);
<span class="lineNum">    5465 </span>            : 
<span class="lineNum">    5466 </span>            : /**
<span class="lineNum">    5467 </span>            :  * Base class that implements parts shared by JSErrorReport and
<span class="lineNum">    5468 </span>            :  * JSErrorNotes::Note.
<span class="lineNum">    5469 </span>            :  */
<span class="lineNum">    5470 </span>            : class JSErrorBase
<span class="lineNum">    5471 </span>            : {
<span class="lineNum">    5472 </span>            :     // The (default) error message.
<span class="lineNum">    5473 </span>            :     // If ownsMessage_ is true, the it is freed in destructor.
<span class="lineNum">    5474 </span>            :     JS::ConstUTF8CharsZ message_;
<span class="lineNum">    5475 </span>            : 
<span class="lineNum">    5476 </span>            :   public:
<span class="lineNum">    5477 </span>            :     JSErrorBase()
<span class="lineNum">    5478 </span>            :       : filename(nullptr), lineno(0), column(0),
<span class="lineNum">    5479 </span>            :         errorNumber(0),
<span class="lineNum">    5480 </span><span class="lineCov">          1 :         ownsMessage_(false)</span>
<span class="lineNum">    5481 </span>            :     {}
<span class="lineNum">    5482 </span>            : 
<span class="lineNum">    5483 </span>            :     ~JSErrorBase() {
<span class="lineNum">    5484 </span><span class="lineCov">          1 :         freeMessage();</span>
<span class="lineNum">    5485 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    5486 </span>            : 
<span class="lineNum">    5487 </span>            :     // Source file name, URL, etc., or null.
<span class="lineNum">    5488 </span>            :     const char* filename;
<span class="lineNum">    5489 </span>            : 
<span class="lineNum">    5490 </span>            :     // Source line number.
<span class="lineNum">    5491 </span>            :     unsigned lineno;
<span class="lineNum">    5492 </span>            : 
<span class="lineNum">    5493 </span>            :     // Zero-based column index in line.
<span class="lineNum">    5494 </span>            :     unsigned column;
<span class="lineNum">    5495 </span>            : 
<span class="lineNum">    5496 </span>            :     // the error number, e.g. see js.msg.
<span class="lineNum">    5497 </span>            :     unsigned errorNumber;
<span class="lineNum">    5498 </span>            : 
<span class="lineNum">    5499 </span>            :   private:
<span class="lineNum">    5500 </span>            :     bool ownsMessage_ : 1;
<span class="lineNum">    5501 </span>            : 
<span class="lineNum">    5502 </span>            :   public:
<span class="lineNum">    5503 </span>            :     const JS::ConstUTF8CharsZ message() const {
<span class="lineNum">    5504 </span>            :         return message_;
<span class="lineNum">    5505 </span>            :     }
<span class="lineNum">    5506 </span>            : 
<span class="lineNum">    5507 </span>            :     void initOwnedMessage(const char* messageArg) {
<span class="lineNum">    5508 </span>            :         initBorrowedMessage(messageArg);
<span class="lineNum">    5509 </span><span class="lineCov">          1 :         ownsMessage_ = true;</span>
<span class="lineNum">    5510 </span>            :     }
<span class="lineNum">    5511 </span>            :     void initBorrowedMessage(const char* messageArg) {
<span class="lineNum">    5512 </span>            :         MOZ_ASSERT(!message_);
<span class="lineNum">    5513 </span><span class="lineCov">          1 :         message_ = JS::ConstUTF8CharsZ(messageArg, strlen(messageArg));</span>
<span class="lineNum">    5514 </span>            :     }
<span class="lineNum">    5515 </span>            : 
<span class="lineNum">    5516 </span>            :     JSString* newMessageString(JSContext* cx);
<span class="lineNum">    5517 </span>            : 
<span class="lineNum">    5518 </span>            :   private:
<span class="lineNum">    5519 </span>            :     void freeMessage();
<span class="lineNum">    5520 </span>            : };
<span class="lineNum">    5521 </span>            : 
<span class="lineNum">    5522 </span>            : /**
<span class="lineNum">    5523 </span>            :  * Notes associated with JSErrorReport.
<span class="lineNum">    5524 </span>            :  */
<span class="lineNum">    5525 </span>            : class JSErrorNotes
<a name="5526"><span class="lineNum">    5526 </span>            : {</a>
<span class="lineNum">    5527 </span>            :   public:
<span class="lineNum">    5528 </span><span class="lineCov">          1 :     class Note : public JSErrorBase</span>
<span class="lineNum">    5529 </span>            :     {};
<span class="lineNum">    5530 </span>            : 
<span class="lineNum">    5531 </span>            :   private:
<span class="lineNum">    5532 </span>            :     // Stores pointers to each note.
<span class="lineNum">    5533 </span>            :     js::Vector&lt;js::UniquePtr&lt;Note&gt;, 1, js::SystemAllocPolicy&gt; notes_;
<span class="lineNum">    5534 </span>            : 
<span class="lineNum">    5535 </span>            :   public:
<span class="lineNum">    5536 </span>            :     JSErrorNotes();
<span class="lineNum">    5537 </span>            :     ~JSErrorNotes();
<span class="lineNum">    5538 </span>            : 
<span class="lineNum">    5539 </span>            :     // Add an note to the given position.
<span class="lineNum">    5540 </span>            :     bool addNoteASCII(JSContext* cx,
<span class="lineNum">    5541 </span>            :                       const char* filename, unsigned lineno, unsigned column,
<span class="lineNum">    5542 </span>            :                       JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5543 </span>            :                       const unsigned errorNumber, ...);
<span class="lineNum">    5544 </span>            :     bool addNoteLatin1(JSContext* cx,
<span class="lineNum">    5545 </span>            :                        const char* filename, unsigned lineno, unsigned column,
<span class="lineNum">    5546 </span>            :                        JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5547 </span>            :                        const unsigned errorNumber, ...);
<span class="lineNum">    5548 </span>            :     bool addNoteUTF8(JSContext* cx,
<span class="lineNum">    5549 </span>            :                      const char* filename, unsigned lineno, unsigned column,
<span class="lineNum">    5550 </span>            :                      JSErrorCallback errorCallback, void* userRef,
<span class="lineNum">    5551 </span>            :                      const unsigned errorNumber, ...);
<span class="lineNum">    5552 </span>            : 
<span class="lineNum">    5553 </span>            :     JS_PUBLIC_API(size_t) length();
<span class="lineNum">    5554 </span>            : 
<span class="lineNum">    5555 </span>            :     // Create a deep copy of notes.
<span class="lineNum">    5556 </span>            :     js::UniquePtr&lt;JSErrorNotes&gt; copy(JSContext* cx);
<span class="lineNum">    5557 </span>            : 
<span class="lineNum">    5558 </span>            :     class iterator : public std::iterator&lt;std::input_iterator_tag, js::UniquePtr&lt;Note&gt;&gt;
<span class="lineNum">    5559 </span>            :     {
<span class="lineNum">    5560 </span>            :         js::UniquePtr&lt;Note&gt;* note_;
<span class="lineNum">    5561 </span>            :       public:
<span class="lineNum">    5562 </span>            :         explicit iterator(js::UniquePtr&lt;Note&gt;* note = nullptr) : note_(note)
<span class="lineNum">    5563 </span>            :         {}
<span class="lineNum">    5564 </span>            : 
<span class="lineNum">    5565 </span>            :         bool operator==(iterator other) const {
<span class="lineNum">    5566 </span>            :             return note_ == other.note_;
<span class="lineNum">    5567 </span>            :         }
<span class="lineNum">    5568 </span>            :         bool operator!=(iterator other) const {
<span class="lineNum">    5569 </span>            :             return !(*this == other);
<span class="lineNum">    5570 </span>            :         }
<span class="lineNum">    5571 </span>            :         iterator&amp; operator++() {
<span class="lineNum">    5572 </span><span class="lineCov">          1 :             note_++;</span>
<span class="lineNum">    5573 </span>            :             return *this;
<span class="lineNum">    5574 </span>            :         }
<span class="lineNum">    5575 </span>            :         reference operator*() {
<span class="lineNum">    5576 </span>            :             return *note_;
<span class="lineNum">    5577 </span>            :         }
<span class="lineNum">    5578 </span>            :     };
<span class="lineNum">    5579 </span>            :     JS_PUBLIC_API(iterator) begin();
<span class="lineNum">    5580 </span>            :     JS_PUBLIC_API(iterator) end();
<span class="lineNum">    5581 </span>            : };
<span class="lineNum">    5582 </span>            : 
<span class="lineNum">    5583 </span>            : /**
<span class="lineNum">    5584 </span>            :  * Describes a single error or warning that occurs in the execution of script.
<span class="lineNum">    5585 </span>            :  */
<span class="lineNum">    5586 </span>            : class JSErrorReport : public JSErrorBase
<span class="lineNum">    5587 </span>            : {
<span class="lineNum">    5588 </span>            :     // Offending source line without final '\n'.
<span class="lineNum">    5589 </span>            :     // If ownsLinebuf_ is true, the buffer is freed in destructor.
<span class="lineNum">    5590 </span>            :     const char16_t* linebuf_;
<span class="lineNum">    5591 </span>            : 
<span class="lineNum">    5592 </span>            :     // Number of chars in linebuf_. Does not include trailing '\0'.
<span class="lineNum">    5593 </span>            :     size_t linebufLength_;
<span class="lineNum">    5594 </span>            : 
<span class="lineNum">    5595 </span>            :     // The 0-based offset of error token in linebuf_.
<span class="lineNum">    5596 </span>            :     size_t tokenOffset_;
<span class="lineNum">    5597 </span>            : 
<span class="lineNum">    5598 </span>            :   public:
<span class="lineNum">    5599 </span>            :     JSErrorReport()
<span class="lineNum">    5600 </span>            :       : linebuf_(nullptr), linebufLength_(0), tokenOffset_(0),
<span class="lineNum">    5601 </span>            :         notes(nullptr),
<span class="lineNum">    5602 </span>            :         flags(0), exnType(0), isMuted(false),
<span class="lineNum">    5603 </span><span class="lineCov">          1 :         ownsLinebuf_(false)</span>
<a name="5604"><span class="lineNum">    5604 </span>            :     {}</a>
<span class="lineNum">    5605 </span>            : 
<span class="lineNum">    5606 </span><span class="lineCov">          1 :     ~JSErrorReport() {</span>
<span class="lineNum">    5607 </span><span class="lineCov">          1 :         freeLinebuf();</span>
<span class="lineNum">    5608 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    5609 </span>            : 
<span class="lineNum">    5610 </span>            :     // Associated notes, or nullptr if there's no note.
<span class="lineNum">    5611 </span>            :     js::UniquePtr&lt;JSErrorNotes&gt; notes;
<span class="lineNum">    5612 </span>            : 
<span class="lineNum">    5613 </span>            :     // error/warning, etc.
<span class="lineNum">    5614 </span>            :     unsigned flags;
<span class="lineNum">    5615 </span>            : 
<span class="lineNum">    5616 </span>            :     // One of the JSExnType constants.
<span class="lineNum">    5617 </span>            :     int16_t exnType;
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span>            :     // See the comment in TransitiveCompileOptions.
<span class="lineNum">    5620 </span>            :     bool isMuted : 1;
<span class="lineNum">    5621 </span>            : 
<span class="lineNum">    5622 </span>            :   private:
<span class="lineNum">    5623 </span>            :     bool ownsLinebuf_ : 1;
<span class="lineNum">    5624 </span>            : 
<span class="lineNum">    5625 </span>            :   public:
<span class="lineNum">    5626 </span>            :     const char16_t* linebuf() const {
<span class="lineNum">    5627 </span>            :         return linebuf_;
<span class="lineNum">    5628 </span>            :     }
<span class="lineNum">    5629 </span>            :     size_t linebufLength() const {
<span class="lineNum">    5630 </span>            :         return linebufLength_;
<span class="lineNum">    5631 </span>            :     }
<span class="lineNum">    5632 </span>            :     size_t tokenOffset() const {
<span class="lineNum">    5633 </span>            :         return tokenOffset_;
<span class="lineNum">    5634 </span>            :     }
<span class="lineNum">    5635 </span>            :     void initOwnedLinebuf(const char16_t* linebufArg, size_t linebufLengthArg,
<span class="lineNum">    5636 </span>            :                           size_t tokenOffsetArg) {
<span class="lineNum">    5637 </span><span class="lineCov">          1 :         initBorrowedLinebuf(linebufArg, linebufLengthArg, tokenOffsetArg);</span>
<span class="lineNum">    5638 </span><span class="lineCov">          1 :         ownsLinebuf_ = true;</span>
<span class="lineNum">    5639 </span>            :     }
<span class="lineNum">    5640 </span>            :     void initBorrowedLinebuf(const char16_t* linebufArg, size_t linebufLengthArg,
<span class="lineNum">    5641 </span>            :                              size_t tokenOffsetArg);
<span class="lineNum">    5642 </span>            : 
<span class="lineNum">    5643 </span>            :   private:
<span class="lineNum">    5644 </span>            :     void freeLinebuf();
<span class="lineNum">    5645 </span>            : };
<span class="lineNum">    5646 </span>            : 
<span class="lineNum">    5647 </span>            : /*
<span class="lineNum">    5648 </span>            :  * JSErrorReport flag values.  These may be freely composed.
<span class="lineNum">    5649 </span>            :  */
<span class="lineNum">    5650 </span>            : #define JSREPORT_ERROR      0x0     /* pseudo-flag for default case */
<span class="lineNum">    5651 </span>            : #define JSREPORT_WARNING    0x1     /* reported via JS_ReportWarning */
<span class="lineNum">    5652 </span>            : #define JSREPORT_EXCEPTION  0x2     /* exception was thrown */
<span class="lineNum">    5653 </span>            : #define JSREPORT_STRICT     0x4     /* error or warning due to strict option */
<span class="lineNum">    5654 </span>            : 
<span class="lineNum">    5655 </span>            : #define JSREPORT_USER_1     0x8     /* user-defined flag */
<span class="lineNum">    5656 </span>            : 
<span class="lineNum">    5657 </span>            : /*
<span class="lineNum">    5658 </span>            :  * If JSREPORT_EXCEPTION is set, then a JavaScript-catchable exception
<span class="lineNum">    5659 </span>            :  * has been thrown for this runtime error, and the host should ignore it.
<span class="lineNum">    5660 </span>            :  * Exception-aware hosts should also check for JS_IsExceptionPending if
<span class="lineNum">    5661 </span>            :  * JS_ExecuteScript returns failure, and signal or propagate the exception, as
<span class="lineNum">    5662 </span>            :  * appropriate.
<span class="lineNum">    5663 </span>            :  */
<span class="lineNum">    5664 </span>            : #define JSREPORT_IS_WARNING(flags)      (((flags) &amp; JSREPORT_WARNING) != 0)
<span class="lineNum">    5665 </span>            : #define JSREPORT_IS_EXCEPTION(flags)    (((flags) &amp; JSREPORT_EXCEPTION) != 0)
<span class="lineNum">    5666 </span>            : #define JSREPORT_IS_STRICT(flags)       (((flags) &amp; JSREPORT_STRICT) != 0)
<span class="lineNum">    5667 </span>            : 
<span class="lineNum">    5668 </span>            : namespace JS {
<span class="lineNum">    5669 </span>            : 
<span class="lineNum">    5670 </span>            : using WarningReporter = void (*)(JSContext* cx, JSErrorReport* report);
<span class="lineNum">    5671 </span>            : 
<span class="lineNum">    5672 </span>            : extern JS_PUBLIC_API(WarningReporter)
<span class="lineNum">    5673 </span>            : SetWarningReporter(JSContext* cx, WarningReporter reporter);
<span class="lineNum">    5674 </span>            : 
<span class="lineNum">    5675 </span>            : extern JS_PUBLIC_API(WarningReporter)
<span class="lineNum">    5676 </span>            : GetWarningReporter(JSContext* cx);
<span class="lineNum">    5677 </span>            : 
<span class="lineNum">    5678 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5679 </span>            : CreateError(JSContext* cx, JSExnType type, HandleObject stack,
<span class="lineNum">    5680 </span>            :             HandleString fileName, uint32_t lineNumber, uint32_t columnNumber,
<span class="lineNum">    5681 </span>            :             JSErrorReport* report, HandleString message, MutableHandleValue rval);
<span class="lineNum">    5682 </span>            : 
<span class="lineNum">    5683 </span>            : /************************************************************************/
<span class="lineNum">    5684 </span>            : 
<span class="lineNum">    5685 </span>            : /*
<span class="lineNum">    5686 </span>            :  * Weak Maps.
<span class="lineNum">    5687 </span>            :  */
<span class="lineNum">    5688 </span>            : 
<span class="lineNum">    5689 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5690 </span>            : NewWeakMapObject(JSContext* cx);
<span class="lineNum">    5691 </span>            : 
<span class="lineNum">    5692 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5693 </span>            : IsWeakMapObject(JSObject* obj);
<span class="lineNum">    5694 </span>            : 
<span class="lineNum">    5695 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5696 </span>            : GetWeakMapEntry(JSContext* cx, JS::HandleObject mapObj, JS::HandleObject key,
<span class="lineNum">    5697 </span>            :                 JS::MutableHandleValue val);
<span class="lineNum">    5698 </span>            : 
<span class="lineNum">    5699 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5700 </span>            : SetWeakMapEntry(JSContext* cx, JS::HandleObject mapObj, JS::HandleObject key,
<span class="lineNum">    5701 </span>            :                 JS::HandleValue val);
<span class="lineNum">    5702 </span>            : 
<span class="lineNum">    5703 </span>            : /*
<span class="lineNum">    5704 </span>            :  * Map
<span class="lineNum">    5705 </span>            :  */
<span class="lineNum">    5706 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5707 </span>            : NewMapObject(JSContext* cx);
<span class="lineNum">    5708 </span>            : 
<span class="lineNum">    5709 </span>            : extern JS_PUBLIC_API(uint32_t)
<span class="lineNum">    5710 </span>            : MapSize(JSContext* cx, HandleObject obj);
<span class="lineNum">    5711 </span>            : 
<span class="lineNum">    5712 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5713 </span>            : MapGet(JSContext* cx, HandleObject obj,
<span class="lineNum">    5714 </span>            :        HandleValue key, MutableHandleValue rval);
<span class="lineNum">    5715 </span>            : 
<span class="lineNum">    5716 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5717 </span>            : MapHas(JSContext* cx, HandleObject obj, HandleValue key, bool* rval);
<span class="lineNum">    5718 </span>            : 
<span class="lineNum">    5719 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5720 </span>            : MapSet(JSContext* cx, HandleObject obj, HandleValue key, HandleValue val);
<span class="lineNum">    5721 </span>            : 
<span class="lineNum">    5722 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5723 </span>            : MapDelete(JSContext *cx, HandleObject obj, HandleValue key, bool *rval);
<span class="lineNum">    5724 </span>            : 
<span class="lineNum">    5725 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5726 </span>            : MapClear(JSContext* cx, HandleObject obj);
<span class="lineNum">    5727 </span>            : 
<span class="lineNum">    5728 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5729 </span>            : MapKeys(JSContext* cx, HandleObject obj, MutableHandleValue rval);
<span class="lineNum">    5730 </span>            : 
<span class="lineNum">    5731 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5732 </span>            : MapValues(JSContext* cx, HandleObject obj, MutableHandleValue rval);
<span class="lineNum">    5733 </span>            : 
<span class="lineNum">    5734 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5735 </span>            : MapEntries(JSContext* cx, HandleObject obj, MutableHandleValue rval);
<span class="lineNum">    5736 </span>            : 
<span class="lineNum">    5737 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5738 </span>            : MapForEach(JSContext *cx, HandleObject obj, HandleValue callbackFn, HandleValue thisVal);
<span class="lineNum">    5739 </span>            : 
<span class="lineNum">    5740 </span>            : /*
<span class="lineNum">    5741 </span>            :  * Set
<span class="lineNum">    5742 </span>            :  */
<span class="lineNum">    5743 </span>            : extern JS_PUBLIC_API(JSObject *)
<span class="lineNum">    5744 </span>            : NewSetObject(JSContext *cx);
<span class="lineNum">    5745 </span>            : 
<span class="lineNum">    5746 </span>            : extern JS_PUBLIC_API(uint32_t)
<span class="lineNum">    5747 </span>            : SetSize(JSContext *cx, HandleObject obj);
<span class="lineNum">    5748 </span>            : 
<span class="lineNum">    5749 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5750 </span>            : SetHas(JSContext *cx, HandleObject obj, HandleValue key, bool *rval);
<span class="lineNum">    5751 </span>            : 
<span class="lineNum">    5752 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5753 </span>            : SetDelete(JSContext *cx, HandleObject obj, HandleValue key, bool *rval);
<span class="lineNum">    5754 </span>            : 
<span class="lineNum">    5755 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5756 </span>            : SetAdd(JSContext *cx, HandleObject obj, HandleValue key);
<span class="lineNum">    5757 </span>            : 
<span class="lineNum">    5758 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5759 </span>            : SetClear(JSContext *cx, HandleObject obj);
<span class="lineNum">    5760 </span>            : 
<span class="lineNum">    5761 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5762 </span>            : SetKeys(JSContext *cx, HandleObject obj, MutableHandleValue rval);
<span class="lineNum">    5763 </span>            : 
<span class="lineNum">    5764 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5765 </span>            : SetValues(JSContext *cx, HandleObject obj, MutableHandleValue rval);
<span class="lineNum">    5766 </span>            : 
<span class="lineNum">    5767 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5768 </span>            : SetEntries(JSContext *cx, HandleObject obj, MutableHandleValue rval);
<span class="lineNum">    5769 </span>            : 
<span class="lineNum">    5770 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5771 </span>            : SetForEach(JSContext *cx, HandleObject obj, HandleValue callbackFn, HandleValue thisVal);
<span class="lineNum">    5772 </span>            : 
<span class="lineNum">    5773 </span>            : } /* namespace JS */
<span class="lineNum">    5774 </span>            : 
<span class="lineNum">    5775 </span>            : /*
<span class="lineNum">    5776 </span>            :  * Dates.
<span class="lineNum">    5777 </span>            :  */
<span class="lineNum">    5778 </span>            : 
<span class="lineNum">    5779 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5780 </span>            : JS_NewDateObject(JSContext* cx, int year, int mon, int mday, int hour, int min, int sec);
<span class="lineNum">    5781 </span>            : 
<span class="lineNum">    5782 </span>            : /**
<span class="lineNum">    5783 </span>            :  * Returns true and sets |*isDate| indicating whether |obj| is a Date object or
<span class="lineNum">    5784 </span>            :  * a wrapper around one, otherwise returns false on failure.
<span class="lineNum">    5785 </span>            :  *
<span class="lineNum">    5786 </span>            :  * This method returns true with |*isDate == false| when passed a proxy whose
<span class="lineNum">    5787 </span>            :  * target is a Date, or when passed a revoked proxy.
<span class="lineNum">    5788 </span>            :  */
<span class="lineNum">    5789 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5790 </span>            : JS_ObjectIsDate(JSContext* cx, JS::HandleObject obj, bool* isDate);
<span class="lineNum">    5791 </span>            : 
<span class="lineNum">    5792 </span>            : /************************************************************************/
<span class="lineNum">    5793 </span>            : 
<span class="lineNum">    5794 </span>            : /*
<span class="lineNum">    5795 </span>            :  * Regular Expressions.
<span class="lineNum">    5796 </span>            :  */
<span class="lineNum">    5797 </span>            : #define JSREG_FOLD      0x01u   /* fold uppercase to lowercase */
<span class="lineNum">    5798 </span>            : #define JSREG_GLOB      0x02u   /* global exec, creates array of matches */
<span class="lineNum">    5799 </span>            : #define JSREG_MULTILINE 0x04u   /* treat ^ and $ as begin and end of line */
<span class="lineNum">    5800 </span>            : #define JSREG_STICKY    0x08u   /* only match starting at lastIndex */
<span class="lineNum">    5801 </span>            : #define JSREG_UNICODE   0x10u   /* unicode */
<span class="lineNum">    5802 </span>            : 
<span class="lineNum">    5803 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5804 </span>            : JS_NewRegExpObject(JSContext* cx, const char* bytes, size_t length, unsigned flags);
<span class="lineNum">    5805 </span>            : 
<span class="lineNum">    5806 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5807 </span>            : JS_NewUCRegExpObject(JSContext* cx, const char16_t* chars, size_t length, unsigned flags);
<span class="lineNum">    5808 </span>            : 
<span class="lineNum">    5809 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5810 </span>            : JS_SetRegExpInput(JSContext* cx, JS::HandleObject obj, JS::HandleString input);
<span class="lineNum">    5811 </span>            : 
<span class="lineNum">    5812 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5813 </span>            : JS_ClearRegExpStatics(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    5814 </span>            : 
<span class="lineNum">    5815 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5816 </span>            : JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj, JS::HandleObject reobj,
<span class="lineNum">    5817 </span>            :                  char16_t* chars, size_t length, size_t* indexp, bool test,
<span class="lineNum">    5818 </span>            :                  JS::MutableHandleValue rval);
<span class="lineNum">    5819 </span>            : 
<span class="lineNum">    5820 </span>            : /* RegExp interface for clients without a global object. */
<span class="lineNum">    5821 </span>            : 
<span class="lineNum">    5822 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5823 </span>            : JS_ExecuteRegExpNoStatics(JSContext* cx, JS::HandleObject reobj, char16_t* chars, size_t length,
<span class="lineNum">    5824 </span>            :                           size_t* indexp, bool test, JS::MutableHandleValue rval);
<span class="lineNum">    5825 </span>            : 
<span class="lineNum">    5826 </span>            : /**
<span class="lineNum">    5827 </span>            :  * Returns true and sets |*isRegExp| indicating whether |obj| is a RegExp
<span class="lineNum">    5828 </span>            :  * object or a wrapper around one, otherwise returns false on failure.
<span class="lineNum">    5829 </span>            :  *
<span class="lineNum">    5830 </span>            :  * This method returns true with |*isRegExp == false| when passed a proxy whose
<span class="lineNum">    5831 </span>            :  * target is a RegExp, or when passed a revoked proxy.
<span class="lineNum">    5832 </span>            :  */
<span class="lineNum">    5833 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5834 </span>            : JS_ObjectIsRegExp(JSContext* cx, JS::HandleObject obj, bool* isRegExp);
<span class="lineNum">    5835 </span>            : 
<span class="lineNum">    5836 </span>            : extern JS_PUBLIC_API(unsigned)
<span class="lineNum">    5837 </span>            : JS_GetRegExpFlags(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    5838 </span>            : 
<span class="lineNum">    5839 </span>            : extern JS_PUBLIC_API(JSString*)
<span class="lineNum">    5840 </span>            : JS_GetRegExpSource(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    5841 </span>            : 
<span class="lineNum">    5842 </span>            : /************************************************************************/
<span class="lineNum">    5843 </span>            : 
<span class="lineNum">    5844 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5845 </span>            : JS_IsExceptionPending(JSContext* cx);
<span class="lineNum">    5846 </span>            : 
<span class="lineNum">    5847 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5848 </span>            : JS_GetPendingException(JSContext* cx, JS::MutableHandleValue vp);
<span class="lineNum">    5849 </span>            : 
<span class="lineNum">    5850 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5851 </span>            : JS_SetPendingException(JSContext* cx, JS::HandleValue v);
<span class="lineNum">    5852 </span>            : 
<span class="lineNum">    5853 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5854 </span>            : JS_ClearPendingException(JSContext* cx);
<span class="lineNum">    5855 </span>            : 
<span class="lineNum">    5856 </span>            : namespace JS {
<span class="lineNum">    5857 </span>            : 
<span class="lineNum">    5858 </span>            : /**
<span class="lineNum">    5859 </span>            :  * Save and later restore the current exception state of a given JSContext.
<span class="lineNum">    5860 </span>            :  * This is useful for implementing behavior in C++ that's like try/catch
<span class="lineNum">    5861 </span>            :  * or try/finally in JS.
<span class="lineNum">    5862 </span>            :  *
<span class="lineNum">    5863 </span>            :  * Typical usage:
<span class="lineNum">    5864 </span>            :  *
<span class="lineNum">    5865 </span>            :  *     bool ok = JS::Evaluate(cx, ...);
<span class="lineNum">    5866 </span>            :  *     AutoSaveExceptionState savedExc(cx);
<span class="lineNum">    5867 </span>            :  *     ... cleanup that might re-enter JS ...
<span class="lineNum">    5868 </span>            :  *     return ok;
<span class="lineNum">    5869 </span>            :  */
<span class="lineNum">    5870 </span>            : class JS_PUBLIC_API(AutoSaveExceptionState)
<span class="lineNum">    5871 </span>            : {
<span class="lineNum">    5872 </span>            :   private:
<span class="lineNum">    5873 </span>            :     JSContext* context;
<span class="lineNum">    5874 </span>            :     bool wasPropagatingForcedReturn;
<span class="lineNum">    5875 </span>            :     bool wasOverRecursed;
<span class="lineNum">    5876 </span>            :     bool wasThrowing;
<span class="lineNum">    5877 </span>            :     RootedValue exceptionValue;
<span class="lineNum">    5878 </span>            : 
<span class="lineNum">    5879 </span>            :   public:
<span class="lineNum">    5880 </span>            :     /*
<span class="lineNum">    5881 </span>            :      * Take a snapshot of cx's current exception state. Then clear any current
<span class="lineNum">    5882 </span>            :      * pending exception in cx.
<span class="lineNum">    5883 </span>            :      */
<span class="lineNum">    5884 </span>            :     explicit AutoSaveExceptionState(JSContext* cx);
<span class="lineNum">    5885 </span>            : 
<span class="lineNum">    5886 </span>            :     /*
<span class="lineNum">    5887 </span>            :      * If neither drop() nor restore() was called, restore the exception
<span class="lineNum">    5888 </span>            :      * state only if no exception is currently pending on cx.
<span class="lineNum">    5889 </span>            :      */
<span class="lineNum">    5890 </span>            :     ~AutoSaveExceptionState();
<span class="lineNum">    5891 </span>            : 
<span class="lineNum">    5892 </span>            :     /*
<span class="lineNum">    5893 </span>            :      * Discard any stored exception state.
<span class="lineNum">    5894 </span>            :      * If this is called, the destructor is a no-op.
<span class="lineNum">    5895 </span>            :      */
<span class="lineNum">    5896 </span>            :     void drop() {
<span class="lineNum">    5897 </span><span class="lineCov">          1 :         wasPropagatingForcedReturn = false;</span>
<span class="lineNum">    5898 </span><span class="lineCov">          1 :         wasOverRecursed = false;</span>
<span class="lineNum">    5899 </span><span class="lineCov">          1 :         wasThrowing = false;</span>
<span class="lineNum">    5900 </span><span class="lineCov">          1 :         exceptionValue.setUndefined();</span>
<span class="lineNum">    5901 </span>            :     }
<span class="lineNum">    5902 </span>            : 
<span class="lineNum">    5903 </span>            :     /*
<span class="lineNum">    5904 </span>            :      * Replace cx's exception state with the stored exception state. Then
<span class="lineNum">    5905 </span>            :      * discard the stored exception state. If this is called, the
<span class="lineNum">    5906 </span>            :      * destructor is a no-op.
<span class="lineNum">    5907 </span>            :      */
<span class="lineNum">    5908 </span>            :     void restore();
<span class="lineNum">    5909 </span>            : };
<span class="lineNum">    5910 </span>            : 
<span class="lineNum">    5911 </span>            : } /* namespace JS */
<span class="lineNum">    5912 </span>            : 
<span class="lineNum">    5913 </span>            : /* Deprecated API. Use AutoSaveExceptionState instead. */
<span class="lineNum">    5914 </span>            : extern JS_PUBLIC_API(JSExceptionState*)
<span class="lineNum">    5915 </span>            : JS_SaveExceptionState(JSContext* cx);
<span class="lineNum">    5916 </span>            : 
<span class="lineNum">    5917 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5918 </span>            : JS_RestoreExceptionState(JSContext* cx, JSExceptionState* state);
<span class="lineNum">    5919 </span>            : 
<span class="lineNum">    5920 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5921 </span>            : JS_DropExceptionState(JSContext* cx, JSExceptionState* state);
<span class="lineNum">    5922 </span>            : 
<span class="lineNum">    5923 </span>            : /**
<span class="lineNum">    5924 </span>            :  * If the given object is an exception object, the exception will have (or be
<span class="lineNum">    5925 </span>            :  * able to lazily create) an error report struct, and this function will return
<span class="lineNum">    5926 </span>            :  * the address of that struct.  Otherwise, it returns nullptr. The lifetime
<span class="lineNum">    5927 </span>            :  * of the error report struct that might be returned is the same as the
<span class="lineNum">    5928 </span>            :  * lifetime of the exception object.
<span class="lineNum">    5929 </span>            :  */
<span class="lineNum">    5930 </span>            : extern JS_PUBLIC_API(JSErrorReport*)
<span class="lineNum">    5931 </span>            : JS_ErrorFromException(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    5932 </span>            : 
<span class="lineNum">    5933 </span>            : /**
<span class="lineNum">    5934 </span>            :  * If the given object is an exception object (or an unwrappable
<span class="lineNum">    5935 </span>            :  * cross-compartment wrapper for one), return the stack for that exception, if
<span class="lineNum">    5936 </span>            :  * any.  Will return null if the given object is not an exception object
<span class="lineNum">    5937 </span>            :  * (including if it's null or a security wrapper that can't be unwrapped) or if
<span class="lineNum">    5938 </span>            :  * the exception has no stack.
<span class="lineNum">    5939 </span>            :  */
<span class="lineNum">    5940 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5941 </span>            : ExceptionStackOrNull(JS::HandleObject obj);
<span class="lineNum">    5942 </span>            : 
<span class="lineNum">    5943 </span>            : /*
<span class="lineNum">    5944 </span>            :  * Throws a StopIteration exception on cx.
<span class="lineNum">    5945 </span>            :  */
<span class="lineNum">    5946 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5947 </span>            : JS_ThrowStopIteration(JSContext* cx);
<span class="lineNum">    5948 </span>            : 
<span class="lineNum">    5949 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    5950 </span>            : JS_IsStopIteration(const JS::Value&amp; v);
<span class="lineNum">    5951 </span>            : 
<span class="lineNum">    5952 </span>            : /**
<span class="lineNum">    5953 </span>            :  * A JS context always has an &quot;owner thread&quot;. The owner thread is set when the
<span class="lineNum">    5954 </span>            :  * context is created (to the current thread) and practically all entry points
<span class="lineNum">    5955 </span>            :  * into the JS engine check that a context (or anything contained in the
<span class="lineNum">    5956 </span>            :  * context: runtime, compartment, object, etc) is only touched by its owner
<span class="lineNum">    5957 </span>            :  * thread. Embeddings may check this invariant outside the JS engine by calling
<span class="lineNum">    5958 </span>            :  * JS_AbortIfWrongThread (which will abort if not on the owner thread, even for
<span class="lineNum">    5959 </span>            :  * non-debug builds).
<span class="lineNum">    5960 </span>            :  */
<span class="lineNum">    5961 </span>            : 
<span class="lineNum">    5962 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5963 </span>            : JS_AbortIfWrongThread(JSContext* cx);
<span class="lineNum">    5964 </span>            : 
<span class="lineNum">    5965 </span>            : /************************************************************************/
<span class="lineNum">    5966 </span>            : 
<span class="lineNum">    5967 </span>            : /**
<span class="lineNum">    5968 </span>            :  * A constructor can request that the JS engine create a default new 'this'
<span class="lineNum">    5969 </span>            :  * object of the given class, using the callee to determine parentage and
<span class="lineNum">    5970 </span>            :  * [[Prototype]].
<span class="lineNum">    5971 </span>            :  */
<span class="lineNum">    5972 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    5973 </span>            : JS_NewObjectForConstructor(JSContext* cx, const JSClass* clasp, const JS::CallArgs&amp; args);
<span class="lineNum">    5974 </span>            : 
<span class="lineNum">    5975 </span>            : /************************************************************************/
<span class="lineNum">    5976 </span>            : 
<span class="lineNum">    5977 </span>            : #ifdef JS_GC_ZEAL
<span class="lineNum">    5978 </span>            : #define JS_DEFAULT_ZEAL_FREQ 100
<span class="lineNum">    5979 </span>            : 
<span class="lineNum">    5980 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5981 </span>            : JS_GetGCZealBits(JSContext* cx, uint32_t* zealBits, uint32_t* frequency, uint32_t* nextScheduled);
<span class="lineNum">    5982 </span>            : 
<span class="lineNum">    5983 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5984 </span>            : JS_SetGCZeal(JSContext* cx, uint8_t zeal, uint32_t frequency);
<span class="lineNum">    5985 </span>            : 
<span class="lineNum">    5986 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5987 </span>            : JS_ScheduleGC(JSContext* cx, uint32_t count);
<span class="lineNum">    5988 </span>            : #endif
<span class="lineNum">    5989 </span>            : 
<span class="lineNum">    5990 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5991 </span>            : JS_SetParallelParsingEnabled(JSContext* cx, bool enabled);
<span class="lineNum">    5992 </span>            : 
<span class="lineNum">    5993 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    5994 </span>            : JS_SetOffthreadIonCompilationEnabled(JSContext* cx, bool enabled);
<span class="lineNum">    5995 </span>            : 
<span class="lineNum">    5996 </span>            : #define JIT_COMPILER_OPTIONS(Register)                                     \
<span class="lineNum">    5997 </span>            :     Register(BASELINE_WARMUP_TRIGGER, &quot;baseline.warmup.trigger&quot;)           \
<span class="lineNum">    5998 </span>            :     Register(ION_WARMUP_TRIGGER, &quot;ion.warmup.trigger&quot;)                     \
<span class="lineNum">    5999 </span>            :     Register(ION_GVN_ENABLE, &quot;ion.gvn.enable&quot;)                             \
<span class="lineNum">    6000 </span>            :     Register(ION_FORCE_IC, &quot;ion.forceinlineCaches&quot;)                        \
<span class="lineNum">    6001 </span>            :     Register(ION_ENABLE, &quot;ion.enable&quot;)                                     \
<span class="lineNum">    6002 </span>            :     Register(ION_INTERRUPT_WITHOUT_SIGNAL, &quot;ion.interrupt-without-signals&quot;) \
<span class="lineNum">    6003 </span>            :     Register(ION_CHECK_RANGE_ANALYSIS, &quot;ion.check-range-analysis&quot;)         \
<span class="lineNum">    6004 </span>            :     Register(BASELINE_ENABLE, &quot;baseline.enable&quot;)                           \
<span class="lineNum">    6005 </span>            :     Register(OFFTHREAD_COMPILATION_ENABLE, &quot;offthread-compilation.enable&quot;) \
<span class="lineNum">    6006 </span>            :     Register(FULL_DEBUG_CHECKS, &quot;jit.full-debug-checks&quot;)                   \
<span class="lineNum">    6007 </span>            :     Register(JUMP_THRESHOLD, &quot;jump-threshold&quot;)                             \
<span class="lineNum">    6008 </span>            :     Register(ASMJS_ATOMICS_ENABLE, &quot;asmjs.atomics.enable&quot;)                 \
<span class="lineNum">    6009 </span>            :     Register(WASM_TEST_MODE, &quot;wasm.test-mode&quot;)                             \
<span class="lineNum">    6010 </span>            :     Register(WASM_FOLD_OFFSETS, &quot;wasm.fold-offsets&quot;)
<span class="lineNum">    6011 </span>            : 
<span class="lineNum">    6012 </span>            : typedef enum JSJitCompilerOption {
<span class="lineNum">    6013 </span>            : #define JIT_COMPILER_DECLARE(key, str) \
<span class="lineNum">    6014 </span>            :     JSJITCOMPILER_ ## key,
<span class="lineNum">    6015 </span>            : 
<span class="lineNum">    6016 </span>            :     JIT_COMPILER_OPTIONS(JIT_COMPILER_DECLARE)
<span class="lineNum">    6017 </span>            : #undef JIT_COMPILER_DECLARE
<span class="lineNum">    6018 </span>            : 
<span class="lineNum">    6019 </span>            :     JSJITCOMPILER_NOT_AN_OPTION
<span class="lineNum">    6020 </span>            : } JSJitCompilerOption;
<span class="lineNum">    6021 </span>            : 
<span class="lineNum">    6022 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6023 </span>            : JS_SetGlobalJitCompilerOption(JSContext* cx, JSJitCompilerOption opt, uint32_t value);
<span class="lineNum">    6024 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6025 </span>            : JS_GetGlobalJitCompilerOption(JSContext* cx, JSJitCompilerOption opt, uint32_t* valueOut);
<span class="lineNum">    6026 </span>            : 
<span class="lineNum">    6027 </span>            : /**
<span class="lineNum">    6028 </span>            :  * Convert a uint32_t index into a jsid.
<span class="lineNum">    6029 </span>            :  */
<span class="lineNum">    6030 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6031 </span>            : JS_IndexToId(JSContext* cx, uint32_t index, JS::MutableHandleId);
<span class="lineNum">    6032 </span>            : 
<span class="lineNum">    6033 </span>            : /**
<span class="lineNum">    6034 </span>            :  * Convert chars into a jsid.
<span class="lineNum">    6035 </span>            :  *
<span class="lineNum">    6036 </span>            :  * |chars| may not be an index.
<span class="lineNum">    6037 </span>            :  */
<span class="lineNum">    6038 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6039 </span>            : JS_CharsToId(JSContext* cx, JS::TwoByteChars chars, JS::MutableHandleId);
<span class="lineNum">    6040 </span>            : 
<span class="lineNum">    6041 </span>            : /**
<span class="lineNum">    6042 </span>            :  *  Test if the given string is a valid ECMAScript identifier
<span class="lineNum">    6043 </span>            :  */
<span class="lineNum">    6044 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6045 </span>            : JS_IsIdentifier(JSContext* cx, JS::HandleString str, bool* isIdentifier);
<span class="lineNum">    6046 </span>            : 
<span class="lineNum">    6047 </span>            : /**
<span class="lineNum">    6048 </span>            :  * Test whether the given chars + length are a valid ECMAScript identifier.
<span class="lineNum">    6049 </span>            :  * This version is infallible, so just returns whether the chars are an
<span class="lineNum">    6050 </span>            :  * identifier.
<span class="lineNum">    6051 </span>            :  */
<span class="lineNum">    6052 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6053 </span>            : JS_IsIdentifier(const char16_t* chars, size_t length);
<span class="lineNum">    6054 </span>            : 
<span class="lineNum">    6055 </span>            : namespace js {
<span class="lineNum">    6056 </span>            : class ScriptSource;
<span class="lineNum">    6057 </span>            : } // namespace js
<span class="lineNum">    6058 </span>            : 
<span class="lineNum">    6059 </span>            : namespace JS {
<span class="lineNum">    6060 </span>            : 
<span class="lineNum">    6061 </span>            : class MOZ_RAII JS_PUBLIC_API(AutoFilename)
<span class="lineNum">    6062 </span>            : {
<span class="lineNum">    6063 </span>            :   private:
<span class="lineNum">    6064 </span>            :     js::ScriptSource* ss_;
<span class="lineNum">    6065 </span>            :     mozilla::Variant&lt;const char*, UniqueChars&gt; filename_;
<span class="lineNum">    6066 </span>            : 
<span class="lineNum">    6067 </span>            :     AutoFilename(const AutoFilename&amp;) = delete;
<span class="lineNum">    6068 </span>            :     AutoFilename&amp; operator=(const AutoFilename&amp;) = delete;
<span class="lineNum">    6069 </span>            : 
<span class="lineNum">    6070 </span>            :   public:
<span class="lineNum">    6071 </span>            :     AutoFilename()
<span class="lineNum">    6072 </span>            :       : ss_(nullptr),
<span class="lineNum">    6073 </span><span class="lineCov">          1 :         filename_(mozilla::AsVariant&lt;const char*&gt;(nullptr))</span>
<span class="lineNum">    6074 </span>            :     {}
<span class="lineNum">    6075 </span>            : 
<span class="lineNum">    6076 </span><span class="lineCov">          1 :     ~AutoFilename() {</span>
<span class="lineNum">    6077 </span><span class="lineCov">          1 :         reset();</span>
<span class="lineNum">    6078 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    6079 </span>            : 
<span class="lineNum">    6080 </span>            :     void reset();
<span class="lineNum">    6081 </span>            : 
<span class="lineNum">    6082 </span>            :     void setOwned(UniqueChars&amp;&amp; filename);
<span class="lineNum">    6083 </span>            :     void setUnowned(const char* filename);
<span class="lineNum">    6084 </span>            :     void setScriptSource(js::ScriptSource* ss);
<span class="lineNum">    6085 </span>            : 
<span class="lineNum">    6086 </span>            :     const char* get() const;
<span class="lineNum">    6087 </span>            : };
<span class="lineNum">    6088 </span>            : 
<span class="lineNum">    6089 </span>            : /**
<span class="lineNum">    6090 </span>            :  * Return the current filename, line number and column number of the most
<span class="lineNum">    6091 </span>            :  * currently running frame. Returns true if a scripted frame was found, false
<span class="lineNum">    6092 </span>            :  * otherwise.
<span class="lineNum">    6093 </span>            :  *
<span class="lineNum">    6094 </span>            :  * If a the embedding has hidden the scripted caller for the topmost activation
<span class="lineNum">    6095 </span>            :  * record, this will also return false.
<span class="lineNum">    6096 </span>            :  */
<span class="lineNum">    6097 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6098 </span>            : DescribeScriptedCaller(JSContext* cx, AutoFilename* filename = nullptr,
<span class="lineNum">    6099 </span>            :                        unsigned* lineno = nullptr, unsigned* column = nullptr);
<span class="lineNum">    6100 </span>            : 
<span class="lineNum">    6101 </span>            : extern JS_PUBLIC_API(JSObject*)
<span class="lineNum">    6102 </span>            : GetScriptedCallerGlobal(JSContext* cx);
<span class="lineNum">    6103 </span>            : 
<span class="lineNum">    6104 </span>            : /**
<span class="lineNum">    6105 </span>            :  * Informs the JS engine that the scripted caller should be hidden. This can be
<span class="lineNum">    6106 </span>            :  * used by the embedding to maintain an override of the scripted caller in its
<span class="lineNum">    6107 </span>            :  * calculations, by hiding the scripted caller in the JS engine and pushing data
<span class="lineNum">    6108 </span>            :  * onto a separate stack, which it inspects when DescribeScriptedCaller returns
<span class="lineNum">    6109 </span>            :  * null.
<span class="lineNum">    6110 </span>            :  *
<span class="lineNum">    6111 </span>            :  * We maintain a counter on each activation record. Add() increments the counter
<span class="lineNum">    6112 </span>            :  * of the topmost activation, and Remove() decrements it. The count may never
<span class="lineNum">    6113 </span>            :  * drop below zero, and must always be exactly zero when the activation is
<span class="lineNum">    6114 </span>            :  * popped from the stack.
<span class="lineNum">    6115 </span>            :  */
<span class="lineNum">    6116 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6117 </span>            : HideScriptedCaller(JSContext* cx);
<span class="lineNum">    6118 </span>            : 
<span class="lineNum">    6119 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6120 </span>            : UnhideScriptedCaller(JSContext* cx);
<span class="lineNum">    6121 </span>            : 
<span class="lineNum">    6122 </span>            : class MOZ_RAII AutoHideScriptedCaller
<span class="lineNum">    6123 </span>            : {
<span class="lineNum">    6124 </span>            :   public:
<span class="lineNum">    6125 </span>            :     explicit AutoHideScriptedCaller(JSContext* cx
<span class="lineNum">    6126 </span>            :                                     MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">    6127 </span>            :       : mContext(cx)
<span class="lineNum">    6128 </span>            :     {
<span class="lineNum">    6129 </span>            :         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">    6130 </span>            :         HideScriptedCaller(mContext);
<span class="lineNum">    6131 </span>            :     }
<span class="lineNum">    6132 </span>            :     ~AutoHideScriptedCaller() {
<span class="lineNum">    6133 </span>            :         UnhideScriptedCaller(mContext);
<span class="lineNum">    6134 </span>            :     }
<span class="lineNum">    6135 </span>            : 
<span class="lineNum">    6136 </span>            :   protected:
<span class="lineNum">    6137 </span>            :     JSContext* mContext;
<span class="lineNum">    6138 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    6139 </span>            : };
<span class="lineNum">    6140 </span>            : 
<span class="lineNum">    6141 </span>            : /*
<span class="lineNum">    6142 </span>            :  * Encode/Decode interpreted scripts and functions to/from memory.
<span class="lineNum">    6143 </span>            :  */
<span class="lineNum">    6144 </span>            : 
<span class="lineNum">    6145 </span>            : typedef mozilla::Vector&lt;uint8_t&gt; TranscodeBuffer;
<span class="lineNum">    6146 </span>            : 
<span class="lineNum">    6147 </span>            : enum TranscodeResult
<span class="lineNum">    6148 </span>            : {
<span class="lineNum">    6149 </span>            :     // Successful encoding / decoding.
<span class="lineNum">    6150 </span>            :     TranscodeResult_Ok = 0,
<span class="lineNum">    6151 </span>            : 
<span class="lineNum">    6152 </span>            :     // A warning message, is set to the message out-param.
<span class="lineNum">    6153 </span>            :     TranscodeResult_Failure = 0x100,
<span class="lineNum">    6154 </span>            :     TranscodeResult_Failure_BadBuildId =          TranscodeResult_Failure | 0x1,
<span class="lineNum">    6155 </span>            :     TranscodeResult_Failure_RunOnceNotSupported = TranscodeResult_Failure | 0x2,
<span class="lineNum">    6156 </span>            :     TranscodeResult_Failure_AsmJSNotSupported =   TranscodeResult_Failure | 0x3,
<span class="lineNum">    6157 </span>            :     TranscodeResult_Failure_UnknownClassKind =    TranscodeResult_Failure | 0x4,
<span class="lineNum">    6158 </span>            :     TranscodeResult_Failure_WrongCompileOption =  TranscodeResult_Failure | 0x5,
<span class="lineNum">    6159 </span>            :     TranscodeResult_Failure_NotInterpretedFun =   TranscodeResult_Failure | 0x6,
<span class="lineNum">    6160 </span>            : 
<span class="lineNum">    6161 </span>            :     // There is a pending exception on the context.
<span class="lineNum">    6162 </span>            :     TranscodeResult_Throw = 0x200
<span class="lineNum">    6163 </span>            : };
<span class="lineNum">    6164 </span>            : 
<span class="lineNum">    6165 </span>            : extern JS_PUBLIC_API(TranscodeResult)
<span class="lineNum">    6166 </span>            : EncodeScript(JSContext* cx, TranscodeBuffer&amp; buffer, JS::HandleScript script);
<span class="lineNum">    6167 </span>            : 
<span class="lineNum">    6168 </span>            : extern JS_PUBLIC_API(TranscodeResult)
<span class="lineNum">    6169 </span>            : EncodeInterpretedFunction(JSContext* cx, TranscodeBuffer&amp; buffer, JS::HandleObject funobj);
<span class="lineNum">    6170 </span>            : 
<span class="lineNum">    6171 </span>            : extern JS_PUBLIC_API(TranscodeResult)
<span class="lineNum">    6172 </span>            : DecodeScript(JSContext* cx, TranscodeBuffer&amp; buffer, JS::MutableHandleScript scriptp,
<span class="lineNum">    6173 </span>            :              size_t cursorIndex = 0);
<span class="lineNum">    6174 </span>            : 
<span class="lineNum">    6175 </span>            : extern JS_PUBLIC_API(TranscodeResult)
<span class="lineNum">    6176 </span>            : DecodeInterpretedFunction(JSContext* cx, TranscodeBuffer&amp; buffer, JS::MutableHandleFunction funp,
<span class="lineNum">    6177 </span>            :                           size_t cursorIndex = 0);
<span class="lineNum">    6178 </span>            : 
<span class="lineNum">    6179 </span>            : // Register an encoder on the given script source, such that all functions can
<span class="lineNum">    6180 </span>            : // be encoded as they are parsed. This strategy is used to avoid blocking the
<span class="lineNum">    6181 </span>            : // active thread in a non-interruptible way.
<span class="lineNum">    6182 </span>            : //
<span class="lineNum">    6183 </span>            : // The |script| argument of |StartIncrementalEncoding| and
<span class="lineNum">    6184 </span>            : // |FinishIncrementalEncoding| should be the top-level script returned either as
<span class="lineNum">    6185 </span>            : // an out-param of any of the |Compile| functions, or the result of
<span class="lineNum">    6186 </span>            : // |FinishOffThreadScript|.
<span class="lineNum">    6187 </span>            : //
<span class="lineNum">    6188 </span>            : // The |buffer| argument should not be used before until
<span class="lineNum">    6189 </span>            : // |FinishIncrementalEncoding| is called on the same script, and returns
<span class="lineNum">    6190 </span>            : // successfully. If any of these functions failed, the |buffer| content is
<span class="lineNum">    6191 </span>            : // undefined.
<span class="lineNum">    6192 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6193 </span>            : StartIncrementalEncoding(JSContext* cx, TranscodeBuffer&amp; buffer, JS::HandleScript script);
<span class="lineNum">    6194 </span>            : 
<span class="lineNum">    6195 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6196 </span>            : FinishIncrementalEncoding(JSContext* cx, JS::HandleScript script);
<span class="lineNum">    6197 </span>            : 
<span class="lineNum">    6198 </span>            : } /* namespace JS */
<span class="lineNum">    6199 </span>            : 
<span class="lineNum">    6200 </span>            : namespace js {
<span class="lineNum">    6201 </span>            : 
<span class="lineNum">    6202 </span>            : enum class StackFormat { SpiderMonkey, V8, Default };
<span class="lineNum">    6203 </span>            : 
<span class="lineNum">    6204 </span>            : /*
<span class="lineNum">    6205 </span>            :  * Sets the format used for stringifying Error stacks.
<span class="lineNum">    6206 </span>            :  *
<span class="lineNum">    6207 </span>            :  * The default format is StackFormat::SpiderMonkey.  Use StackFormat::V8
<span class="lineNum">    6208 </span>            :  * in order to emulate V8's stack formatting.  StackFormat::Default can't be
<span class="lineNum">    6209 </span>            :  * used here.
<span class="lineNum">    6210 </span>            :  */
<span class="lineNum">    6211 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6212 </span>            : SetStackFormat(JSContext* cx, StackFormat format);
<span class="lineNum">    6213 </span>            : 
<span class="lineNum">    6214 </span>            : extern JS_PUBLIC_API(StackFormat)
<span class="lineNum">    6215 </span>            : GetStackFormat(JSContext* cx);
<span class="lineNum">    6216 </span>            : 
<span class="lineNum">    6217 </span>            : }
<span class="lineNum">    6218 </span>            : 
<span class="lineNum">    6219 </span>            : namespace JS {
<span class="lineNum">    6220 </span>            : 
<span class="lineNum">    6221 </span>            : /*
<span class="lineNum">    6222 </span>            :  * This callback represents a request by the JS engine to open for reading the
<span class="lineNum">    6223 </span>            :  * existing cache entry for the given global and char range that may contain a
<span class="lineNum">    6224 </span>            :  * module. If a cache entry exists, the callback shall return 'true' and return
<span class="lineNum">    6225 </span>            :  * the size, base address and an opaque file handle as outparams. If the
<span class="lineNum">    6226 </span>            :  * callback returns 'true', the JS engine guarantees a call to
<span class="lineNum">    6227 </span>            :  * CloseAsmJSCacheEntryForReadOp, passing the same base address, size and
<span class="lineNum">    6228 </span>            :  * handle.
<span class="lineNum">    6229 </span>            :  */
<span class="lineNum">    6230 </span>            : typedef bool
<span class="lineNum">    6231 </span>            : (* OpenAsmJSCacheEntryForReadOp)(HandleObject global, const char16_t* begin, const char16_t* limit,
<span class="lineNum">    6232 </span>            :                                  size_t* size, const uint8_t** memory, intptr_t* handle);
<span class="lineNum">    6233 </span>            : typedef void
<span class="lineNum">    6234 </span>            : (* CloseAsmJSCacheEntryForReadOp)(size_t size, const uint8_t* memory, intptr_t handle);
<span class="lineNum">    6235 </span>            : 
<span class="lineNum">    6236 </span>            : /** The list of reasons why an asm.js module may not be stored in the cache. */
<span class="lineNum">    6237 </span>            : enum AsmJSCacheResult
<span class="lineNum">    6238 </span>            : {
<span class="lineNum">    6239 </span>            :     AsmJSCache_Success,
<span class="lineNum">    6240 </span>            :     AsmJSCache_MIN = AsmJSCache_Success,
<span class="lineNum">    6241 </span>            :     AsmJSCache_ModuleTooSmall,
<span class="lineNum">    6242 </span>            :     AsmJSCache_SynchronousScript,
<span class="lineNum">    6243 </span>            :     AsmJSCache_QuotaExceeded,
<span class="lineNum">    6244 </span>            :     AsmJSCache_StorageInitFailure,
<span class="lineNum">    6245 </span>            :     AsmJSCache_Disabled_Internal,
<span class="lineNum">    6246 </span>            :     AsmJSCache_Disabled_ShellFlags,
<span class="lineNum">    6247 </span>            :     AsmJSCache_Disabled_JitInspector,
<span class="lineNum">    6248 </span>            :     AsmJSCache_InternalError,
<span class="lineNum">    6249 </span>            :     AsmJSCache_Disabled_PrivateBrowsing,
<span class="lineNum">    6250 </span>            :     AsmJSCache_LIMIT
<span class="lineNum">    6251 </span>            : };
<span class="lineNum">    6252 </span>            : 
<span class="lineNum">    6253 </span>            : /*
<span class="lineNum">    6254 </span>            :  * This callback represents a request by the JS engine to open for writing a
<span class="lineNum">    6255 </span>            :  * cache entry of the given size for the given global and char range containing
<span class="lineNum">    6256 </span>            :  * the just-compiled module. If cache entry space is available, the callback
<span class="lineNum">    6257 </span>            :  * shall return 'true' and return the base address and an opaque file handle as
<span class="lineNum">    6258 </span>            :  * outparams. If the callback returns 'true', the JS engine guarantees a call
<span class="lineNum">    6259 </span>            :  * to CloseAsmJSCacheEntryForWriteOp passing the same base address, size and
<span class="lineNum">    6260 </span>            :  * handle.
<span class="lineNum">    6261 </span>            :  */
<span class="lineNum">    6262 </span>            : typedef AsmJSCacheResult
<span class="lineNum">    6263 </span>            : (* OpenAsmJSCacheEntryForWriteOp)(HandleObject global, const char16_t* begin,
<span class="lineNum">    6264 </span>            :                                   const char16_t* end, size_t size,
<span class="lineNum">    6265 </span>            :                                   uint8_t** memory, intptr_t* handle);
<span class="lineNum">    6266 </span>            : typedef void
<span class="lineNum">    6267 </span>            : (* CloseAsmJSCacheEntryForWriteOp)(size_t size, uint8_t* memory, intptr_t handle);
<span class="lineNum">    6268 </span>            : 
<span class="lineNum">    6269 </span>            : struct AsmJSCacheOps
<span class="lineNum">    6270 </span>            : {
<span class="lineNum">    6271 </span>            :     OpenAsmJSCacheEntryForReadOp openEntryForRead;
<span class="lineNum">    6272 </span>            :     CloseAsmJSCacheEntryForReadOp closeEntryForRead;
<span class="lineNum">    6273 </span>            :     OpenAsmJSCacheEntryForWriteOp openEntryForWrite;
<span class="lineNum">    6274 </span>            :     CloseAsmJSCacheEntryForWriteOp closeEntryForWrite;
<span class="lineNum">    6275 </span>            : };
<span class="lineNum">    6276 </span>            : 
<span class="lineNum">    6277 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6278 </span>            : SetAsmJSCacheOps(JSContext* cx, const AsmJSCacheOps* callbacks);
<span class="lineNum">    6279 </span>            : 
<span class="lineNum">    6280 </span>            : /**
<span class="lineNum">    6281 </span>            :  * Return the buildId (represented as a sequence of characters) associated with
<span class="lineNum">    6282 </span>            :  * the currently-executing build. If the JS engine is embedded such that a
<span class="lineNum">    6283 </span>            :  * single cache entry can be observed by different compiled versions of the JS
<span class="lineNum">    6284 </span>            :  * engine, it is critical that the buildId shall change for each new build of
<span class="lineNum">    6285 </span>            :  * the JS engine.
<span class="lineNum">    6286 </span>            :  */
<span class="lineNum">    6287 </span>            : typedef js::Vector&lt;char, 0, js::SystemAllocPolicy&gt; BuildIdCharVector;
<span class="lineNum">    6288 </span>            : 
<span class="lineNum">    6289 </span>            : typedef bool
<span class="lineNum">    6290 </span>            : (* BuildIdOp)(BuildIdCharVector* buildId);
<span class="lineNum">    6291 </span>            : 
<span class="lineNum">    6292 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6293 </span>            : SetBuildIdOp(JSContext* cx, BuildIdOp buildIdOp);
<span class="lineNum">    6294 </span>            : 
<span class="lineNum">    6295 </span>            : /**
<span class="lineNum">    6296 </span>            :  * The WasmModule interface allows the embedding to hold a reference to the
<span class="lineNum">    6297 </span>            :  * underying C++ implementation of a JS WebAssembly.Module object for purposes
<span class="lineNum">    6298 </span>            :  * of (de)serialization off the object's JSRuntime's thread.
<span class="lineNum">    6299 </span>            :  *
<span class="lineNum">    6300 </span>            :  * - Serialization starts when WebAssembly.Module is passed to the
<span class="lineNum">    6301 </span>            :  * structured-clone algorithm. JS::GetWasmModule is called on the JSRuntime
<span class="lineNum">    6302 </span>            :  * thread that initiated the structured clone to get the JS::WasmModule.
<span class="lineNum">    6303 </span>            :  * This interface is then taken to a background thread where serializedSize()
<span class="lineNum">    6304 </span>            :  * and serialize() are called to write the object to two files: a bytecode file
<span class="lineNum">    6305 </span>            :  * that always allows successful deserialization and a compiled-code file keyed
<span class="lineNum">    6306 </span>            :  * on cpu- and build-id that may become invalid if either of these change between
<span class="lineNum">    6307 </span>            :  * serialization and deserialization. After serialization, the reference is
<span class="lineNum">    6308 </span>            :  * dropped from the background thread.
<span class="lineNum">    6309 </span>            :  *
<span class="lineNum">    6310 </span>            :  * - Deserialization starts when the structured clone algorithm encounters a
<span class="lineNum">    6311 </span>            :  * serialized WebAssembly.Module. On a background thread, the compiled-code file
<span class="lineNum">    6312 </span>            :  * is opened and CompiledWasmModuleAssumptionsMatch is called to see if it is
<span class="lineNum">    6313 </span>            :  * still valid (as described above). DeserializeWasmModule is then called to
<span class="lineNum">    6314 </span>            :  * construct a JS::WasmModule (also on the background thread), passing the
<span class="lineNum">    6315 </span>            :  * bytecode file descriptor and, if valid, the compiled-code file descriptor.
<span class="lineNum">    6316 </span>            :  * The JS::WasmObject is then transported to the JSRuntime thread (which
<span class="lineNum">    6317 </span>            :  * originated the request) and the wrapping WebAssembly.Module object is created
<span class="lineNum">    6318 </span>            :  * by calling createObject().
<span class="lineNum">    6319 </span>            :  */
<span class="lineNum">    6320 </span>            : 
<span class="lineNum">    6321 </span><span class="lineCov">          1 : struct WasmModule : js::AtomicRefCounted&lt;WasmModule&gt;</span>
<span class="lineNum">    6322 </span>            : {
<span class="lineNum">    6323 </span><span class="lineCov">          1 :     virtual ~WasmModule() {}</span>
<span class="lineNum">    6324 </span>            : 
<span class="lineNum">    6325 </span>            :     virtual void serializedSize(size_t* maybeBytecodeSize, size_t* maybeCompiledSize) const = 0;
<span class="lineNum">    6326 </span>            :     virtual void serialize(uint8_t* maybeBytecodeBegin, size_t maybeBytecodeSize,
<span class="lineNum">    6327 </span>            :                            uint8_t* maybeCompiledBegin, size_t maybeCompiledSize) const = 0;
<span class="lineNum">    6328 </span>            : 
<span class="lineNum">    6329 </span>            :     virtual JSObject* createObject(JSContext* cx) = 0;
<span class="lineNum">    6330 </span>            : };
<span class="lineNum">    6331 </span>            : 
<span class="lineNum">    6332 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6333 </span>            : IsWasmModuleObject(HandleObject obj);
<span class="lineNum">    6334 </span>            : 
<span class="lineNum">    6335 </span>            : extern JS_PUBLIC_API(RefPtr&lt;WasmModule&gt;)
<span class="lineNum">    6336 </span>            : GetWasmModule(HandleObject obj);
<span class="lineNum">    6337 </span>            : 
<span class="lineNum">    6338 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6339 </span>            : CompiledWasmModuleAssumptionsMatch(PRFileDesc* compiled, BuildIdCharVector&amp;&amp; buildId);
<span class="lineNum">    6340 </span>            : 
<span class="lineNum">    6341 </span>            : extern JS_PUBLIC_API(RefPtr&lt;WasmModule&gt;)
<span class="lineNum">    6342 </span>            : DeserializeWasmModule(PRFileDesc* bytecode, PRFileDesc* maybeCompiled, BuildIdCharVector&amp;&amp; buildId,
<span class="lineNum">    6343 </span>            :                       JS::UniqueChars filename, unsigned line, unsigned column);
<span class="lineNum">    6344 </span>            : 
<span class="lineNum">    6345 </span>            : /**
<span class="lineNum">    6346 </span>            :  * Convenience class for imitating a JS level for-of loop. Typical usage:
<span class="lineNum">    6347 </span>            :  *
<span class="lineNum">    6348 </span>            :  *     ForOfIterator it(cx);
<span class="lineNum">    6349 </span>            :  *     if (!it.init(iterable))
<span class="lineNum">    6350 </span>            :  *       return false;
<span class="lineNum">    6351 </span>            :  *     RootedValue val(cx);
<span class="lineNum">    6352 </span>            :  *     while (true) {
<span class="lineNum">    6353 </span>            :  *       bool done;
<span class="lineNum">    6354 </span>            :  *       if (!it.next(&amp;val, &amp;done))
<span class="lineNum">    6355 </span>            :  *         return false;
<span class="lineNum">    6356 </span>            :  *       if (done)
<span class="lineNum">    6357 </span>            :  *         break;
<span class="lineNum">    6358 </span>            :  *       if (!DoStuff(cx, val))
<span class="lineNum">    6359 </span>            :  *         return false;
<span class="lineNum">    6360 </span>            :  *     }
<span class="lineNum">    6361 </span>            :  */
<span class="lineNum">    6362 </span><span class="lineCov">          1 : class MOZ_STACK_CLASS JS_PUBLIC_API(ForOfIterator) {</span>
<span class="lineNum">    6363 </span>            :   protected:
<span class="lineNum">    6364 </span>            :     JSContext* cx_;
<span class="lineNum">    6365 </span>            :     /*
<span class="lineNum">    6366 </span>            :      * Use the ForOfPIC on the global object (see vm/GlobalObject.h) to try
<span class="lineNum">    6367 </span>            :      * to optimize iteration across arrays.
<span class="lineNum">    6368 </span>            :      *
<span class="lineNum">    6369 </span>            :      *  Case 1: Regular Iteration
<span class="lineNum">    6370 </span>            :      *      iterator - pointer to the iterator object.
<span class="lineNum">    6371 </span>            :      *      index - fixed to NOT_ARRAY (== UINT32_MAX)
<span class="lineNum">    6372 </span>            :      *
<span class="lineNum">    6373 </span>            :      *  Case 2: Optimized Array Iteration
<span class="lineNum">    6374 </span>            :      *      iterator - pointer to the array object.
<span class="lineNum">    6375 </span>            :      *      index - current position in array.
<span class="lineNum">    6376 </span>            :      *
<span class="lineNum">    6377 </span>            :      * The cases are distinguished by whether or not |index| is equal to NOT_ARRAY.
<span class="lineNum">    6378 </span>            :      */
<span class="lineNum">    6379 </span>            :     JS::RootedObject iterator;
<span class="lineNum">    6380 </span>            :     uint32_t index;
<span class="lineNum">    6381 </span>            : 
<span class="lineNum">    6382 </span>            :     static const uint32_t NOT_ARRAY = UINT32_MAX;
<span class="lineNum">    6383 </span>            : 
<span class="lineNum">    6384 </span>            :     ForOfIterator(const ForOfIterator&amp;) = delete;
<span class="lineNum">    6385 </span>            :     ForOfIterator&amp; operator=(const ForOfIterator&amp;) = delete;
<span class="lineNum">    6386 </span>            : 
<span class="lineNum">    6387 </span>            :   public:
<span class="lineNum">    6388 </span><span class="lineCov">          1 :     explicit ForOfIterator(JSContext* cx) : cx_(cx), iterator(cx_), index(NOT_ARRAY) { }</span>
<span class="lineNum">    6389 </span>            : 
<span class="lineNum">    6390 </span>            :     enum NonIterableBehavior {
<span class="lineNum">    6391 </span>            :         ThrowOnNonIterable,
<span class="lineNum">    6392 </span>            :         AllowNonIterable
<span class="lineNum">    6393 </span>            :     };
<span class="lineNum">    6394 </span>            : 
<span class="lineNum">    6395 </span>            :     /**
<span class="lineNum">    6396 </span>            :      * Initialize the iterator.  If AllowNonIterable is passed then if getting
<span class="lineNum">    6397 </span>            :      * the @@iterator property from iterable returns undefined init() will just
<span class="lineNum">    6398 </span>            :      * return true instead of throwing.  Callers must then check
<span class="lineNum">    6399 </span>            :      * valueIsIterable() before continuing with the iteration.
<span class="lineNum">    6400 </span>            :      */
<span class="lineNum">    6401 </span>            :     bool init(JS::HandleValue iterable,
<span class="lineNum">    6402 </span>            :               NonIterableBehavior nonIterableBehavior = ThrowOnNonIterable);
<span class="lineNum">    6403 </span>            : 
<span class="lineNum">    6404 </span>            :     /**
<span class="lineNum">    6405 </span>            :      * Get the next value from the iterator.  If false *done is true
<span class="lineNum">    6406 </span>            :      * after this call, do not examine val.
<span class="lineNum">    6407 </span>            :      */
<span class="lineNum">    6408 </span>            :     bool next(JS::MutableHandleValue val, bool* done);
<span class="lineNum">    6409 </span>            : 
<span class="lineNum">    6410 </span>            :     /**
<span class="lineNum">    6411 </span>            :      * Close the iterator.
<span class="lineNum">    6412 </span>            :      * For the case that completion type is throw.
<span class="lineNum">    6413 </span>            :      */
<span class="lineNum">    6414 </span>            :     void closeThrow();
<span class="lineNum">    6415 </span>            : 
<span class="lineNum">    6416 </span>            :     /**
<span class="lineNum">    6417 </span>            :      * If initialized with throwOnNonCallable = false, check whether
<span class="lineNum">    6418 </span>            :      * the value is iterable.
<span class="lineNum">    6419 </span>            :      */
<span class="lineNum">    6420 </span>            :     bool valueIsIterable() const {
<span class="lineNum">    6421 </span><span class="lineCov">          1 :         return iterator;</span>
<span class="lineNum">    6422 </span>            :     }
<span class="lineNum">    6423 </span>            : 
<span class="lineNum">    6424 </span>            :   private:
<span class="lineNum">    6425 </span>            :     inline bool nextFromOptimizedArray(MutableHandleValue val, bool* done);
<span class="lineNum">    6426 </span>            :     bool materializeArrayIterator();
<span class="lineNum">    6427 </span>            : };
<span class="lineNum">    6428 </span>            : 
<span class="lineNum">    6429 </span>            : 
<span class="lineNum">    6430 </span>            : /**
<span class="lineNum">    6431 </span>            :  * If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS
<span class="lineNum">    6432 </span>            :  * engine may call the large-allocation-failure callback, if set, to allow the
<span class="lineNum">    6433 </span>            :  * embedding to flush caches, possibly perform shrinking GCs, etc. to make some
<span class="lineNum">    6434 </span>            :  * room. The allocation will then be retried (and may still fail.) This callback
<span class="lineNum">    6435 </span>            :  * can be called on any thread and must be set at most once in a process.
<span class="lineNum">    6436 </span>            :  */
<span class="lineNum">    6437 </span>            : 
<span class="lineNum">    6438 </span>            : typedef void
<span class="lineNum">    6439 </span>            : (* LargeAllocationFailureCallback)();
<span class="lineNum">    6440 </span>            : 
<span class="lineNum">    6441 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6442 </span>            : SetProcessLargeAllocationFailureCallback(LargeAllocationFailureCallback afc);
<span class="lineNum">    6443 </span>            : 
<span class="lineNum">    6444 </span>            : /**
<span class="lineNum">    6445 </span>            :  * Unlike the error reporter, which is only called if the exception for an OOM
<span class="lineNum">    6446 </span>            :  * bubbles up and is not caught, the OutOfMemoryCallback is called immediately
<span class="lineNum">    6447 </span>            :  * at the OOM site to allow the embedding to capture the current state of heap
<span class="lineNum">    6448 </span>            :  * allocation before anything is freed. If the large-allocation-failure callback
<span class="lineNum">    6449 </span>            :  * is called at all (not all allocation sites call the large-allocation-failure
<span class="lineNum">    6450 </span>            :  * callback on failure), it is called before the out-of-memory callback; the
<span class="lineNum">    6451 </span>            :  * out-of-memory callback is only called if the allocation still fails after the
<span class="lineNum">    6452 </span>            :  * large-allocation-failure callback has returned.
<span class="lineNum">    6453 </span>            :  */
<span class="lineNum">    6454 </span>            : 
<span class="lineNum">    6455 </span>            : typedef void
<span class="lineNum">    6456 </span>            : (* OutOfMemoryCallback)(JSContext* cx, void* data);
<span class="lineNum">    6457 </span>            : 
<span class="lineNum">    6458 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6459 </span>            : SetOutOfMemoryCallback(JSContext* cx, OutOfMemoryCallback cb, void* data);
<span class="lineNum">    6460 </span>            : 
<span class="lineNum">    6461 </span>            : /**
<span class="lineNum">    6462 </span>            :  * Capture all frames.
<span class="lineNum">    6463 </span>            :  */
<span class="lineNum">    6464 </span>            : struct AllFrames { };
<span class="lineNum">    6465 </span>            : 
<span class="lineNum">    6466 </span>            : /**
<span class="lineNum">    6467 </span>            :  * Capture at most this many frames.
<span class="lineNum">    6468 </span>            :  */
<span class="lineNum">    6469 </span>            : struct MaxFrames
<span class="lineNum">    6470 </span>            : {
<span class="lineNum">    6471 </span>            :     uint32_t maxFrames;
<span class="lineNum">    6472 </span>            : 
<span class="lineNum">    6473 </span>            :     explicit MaxFrames(uint32_t max)
<span class="lineNum">    6474 </span>            :       : maxFrames(max)
<span class="lineNum">    6475 </span>            :     {
<span class="lineNum">    6476 </span>            :         MOZ_ASSERT(max &gt; 0);
<span class="lineNum">    6477 </span>            :     }
<span class="lineNum">    6478 </span>            : };
<span class="lineNum">    6479 </span>            : 
<span class="lineNum">    6480 </span>            : /**
<span class="lineNum">    6481 </span>            :  * Capture the first frame with the given principals. By default, do not
<span class="lineNum">    6482 </span>            :  * consider self-hosted frames with the given principals as satisfying the stack
<span class="lineNum">    6483 </span>            :  * capture.
<span class="lineNum">    6484 </span>            :  */
<span class="lineNum">    6485 </span>            : struct JS_PUBLIC_API(FirstSubsumedFrame)
<span class="lineNum">    6486 </span>            : {
<span class="lineNum">    6487 </span>            :     JSContext* cx;
<span class="lineNum">    6488 </span>            :     JSPrincipals* principals;
<span class="lineNum">    6489 </span>            :     bool ignoreSelfHosted;
<span class="lineNum">    6490 </span>            : 
<span class="lineNum">    6491 </span>            :     /**
<span class="lineNum">    6492 </span>            :      * Use the cx's current compartment's principals.
<span class="lineNum">    6493 </span>            :      */
<span class="lineNum">    6494 </span>            :     explicit FirstSubsumedFrame(JSContext* cx, bool ignoreSelfHostedFrames = true);
<span class="lineNum">    6495 </span>            : 
<span class="lineNum">    6496 </span>            :     explicit FirstSubsumedFrame(JSContext* ctx, JSPrincipals* p, bool ignoreSelfHostedFrames = true)
<span class="lineNum">    6497 </span>            :       : cx(ctx)
<span class="lineNum">    6498 </span>            :       , principals(p)
<span class="lineNum">    6499 </span><span class="lineCov">          1 :       , ignoreSelfHosted(ignoreSelfHostedFrames)</span>
<span class="lineNum">    6500 </span>            :     {
<span class="lineNum">    6501 </span><span class="lineCov">          1 :         if (principals)</span>
<span class="lineNum">    6502 </span><span class="lineCov">          1 :             JS_HoldPrincipals(principals);</span>
<span class="lineNum">    6503 </span>            :     }
<span class="lineNum">    6504 </span>            : 
<span class="lineNum">    6505 </span>            :     // No copying because we want to avoid holding and dropping principals
<span class="lineNum">    6506 </span>            :     // unnecessarily.
<span class="lineNum">    6507 </span>            :     FirstSubsumedFrame(const FirstSubsumedFrame&amp;) = delete;
<span class="lineNum">    6508 </span>            :     FirstSubsumedFrame&amp; operator=(const FirstSubsumedFrame&amp;) = delete;
<span class="lineNum">    6509 </span>            : 
<span class="lineNum">    6510 </span>            :     FirstSubsumedFrame(FirstSubsumedFrame&amp;&amp; rhs)
<span class="lineNum">    6511 </span>            :       : principals(rhs.principals)
<span class="lineNum">    6512 </span><span class="lineNoCov">          0 :       , ignoreSelfHosted(rhs.ignoreSelfHosted)</span>
<span class="lineNum">    6513 </span>            :     {
<span class="lineNum">    6514 </span>            :         MOZ_ASSERT(this != &amp;rhs, &quot;self move disallowed&quot;);
<span class="lineNum">    6515 </span><span class="lineNoCov">          0 :         rhs.principals = nullptr;</span>
<span class="lineNum">    6516 </span>            :     }
<span class="lineNum">    6517 </span>            : 
<span class="lineNum">    6518 </span>            :     FirstSubsumedFrame&amp; operator=(FirstSubsumedFrame&amp;&amp; rhs) {
<span class="lineNum">    6519 </span>            :         new (this) FirstSubsumedFrame(mozilla::Move(rhs));
<span class="lineNum">    6520 </span>            :         return *this;
<span class="lineNum">    6521 </span>            :     }
<span class="lineNum">    6522 </span>            : 
<span class="lineNum">    6523 </span>            :     ~FirstSubsumedFrame() {
<span class="lineNum">    6524 </span><span class="lineNoCov">          0 :         if (principals)</span>
<span class="lineNum">    6525 </span><span class="lineNoCov">          0 :             JS_DropPrincipals(cx, principals);</span>
<span class="lineNum">    6526 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    6527 </span>            : };
<span class="lineNum">    6528 </span>            : 
<span class="lineNum">    6529 </span>            : using StackCapture = mozilla::Variant&lt;AllFrames, MaxFrames, FirstSubsumedFrame&gt;;
<span class="lineNum">    6530 </span>            : 
<span class="lineNum">    6531 </span>            : /**
<span class="lineNum">    6532 </span>            :  * Capture the current call stack as a chain of SavedFrame JSObjects, and set
<span class="lineNum">    6533 </span>            :  * |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there
<span class="lineNum">    6534 </span>            :  * are no JS frames on the stack.
<span class="lineNum">    6535 </span>            :  *
<span class="lineNum">    6536 </span>            :  * The |capture| parameter describes the portion of the JS stack to capture:
<span class="lineNum">    6537 </span>            :  *
<span class="lineNum">    6538 </span>            :  *   * |JS::AllFrames|: Capture all frames on the stack.
<span class="lineNum">    6539 </span>            :  *
<span class="lineNum">    6540 </span>            :  *   * |JS::MaxFrames|: Capture no more than |JS::MaxFrames::maxFrames| from the
<span class="lineNum">    6541 </span>            :  *      stack.
<span class="lineNum">    6542 </span>            :  *
<span class="lineNum">    6543 </span>            :  *   * |JS::FirstSubsumedFrame|: Capture the first frame whose principals are
<span class="lineNum">    6544 </span>            :  *     subsumed by |JS::FirstSubsumedFrame::principals|. By default, do not
<span class="lineNum">    6545 </span>            :  *     consider self-hosted frames; this can be controlled via the
<span class="lineNum">    6546 </span>            :  *     |JS::FirstSubsumedFrame::ignoreSelfHosted| flag. Do not capture any async
<span class="lineNum">    6547 </span>            :  *     stack.
<span class="lineNum">    6548 </span>            :  */
<span class="lineNum">    6549 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6550 </span>            : CaptureCurrentStack(JSContext* cx, MutableHandleObject stackp,
<span class="lineNum">    6551 </span>            :                     StackCapture&amp;&amp; capture = StackCapture(AllFrames()));
<span class="lineNum">    6552 </span>            : 
<span class="lineNum">    6553 </span>            : /*
<span class="lineNum">    6554 </span>            :  * This is a utility function for preparing an async stack to be used
<span class="lineNum">    6555 </span>            :  * by some other object.  This may be used when you need to treat a
<span class="lineNum">    6556 </span>            :  * given stack trace as an async parent.  If you just need to capture
<span class="lineNum">    6557 </span>            :  * the current stack, async parents and all, use CaptureCurrentStack
<span class="lineNum">    6558 </span>            :  * instead.
<span class="lineNum">    6559 </span>            :  *
<span class="lineNum">    6560 </span>            :  * Here |asyncStack| is the async stack to prepare.  It is copied into
<span class="lineNum">    6561 </span>            :  * |cx|'s current compartment, and the newest frame is given
<span class="lineNum">    6562 </span>            :  * |asyncCause| as its asynchronous cause.  If |maxFrameCount| is
<span class="lineNum">    6563 </span>            :  * non-zero, capture at most the youngest |maxFrameCount| frames.  The
<span class="lineNum">    6564 </span>            :  * new stack object is written to |stackp|.  Returns true on success,
<span class="lineNum">    6565 </span>            :  * or sets an exception and returns |false| on error.
<span class="lineNum">    6566 </span>            :  */
<span class="lineNum">    6567 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6568 </span>            : CopyAsyncStack(JSContext* cx, HandleObject asyncStack,
<span class="lineNum">    6569 </span>            :                HandleString asyncCause, MutableHandleObject stackp,
<span class="lineNum">    6570 </span>            :                unsigned maxFrameCount);
<span class="lineNum">    6571 </span>            : 
<span class="lineNum">    6572 </span>            : /*
<span class="lineNum">    6573 </span>            :  * Accessors for working with SavedFrame JSObjects
<span class="lineNum">    6574 </span>            :  *
<span class="lineNum">    6575 </span>            :  * Each of these functions assert that if their `HandleObject savedFrame`
<span class="lineNum">    6576 </span>            :  * argument is non-null, its JSClass is the SavedFrame class (or it is a
<span class="lineNum">    6577 </span>            :  * cross-compartment or Xray wrapper around an object with the SavedFrame class)
<span class="lineNum">    6578 </span>            :  * and the object is not the SavedFrame.prototype object.
<span class="lineNum">    6579 </span>            :  *
<span class="lineNum">    6580 </span>            :  * Each of these functions will find the first SavedFrame object in the chain
<span class="lineNum">    6581 </span>            :  * whose underlying stack frame principals are subsumed by the cx's current
<span class="lineNum">    6582 </span>            :  * compartment's principals, and operate on that SavedFrame object. This
<span class="lineNum">    6583 </span>            :  * prevents leaking information about privileged frames to un-privileged
<span class="lineNum">    6584 </span>            :  * callers. As a result, the SavedFrame in parameters do _NOT_ need to be in the
<span class="lineNum">    6585 </span>            :  * same compartment as the cx, and the various out parameters are _NOT_
<span class="lineNum">    6586 </span>            :  * guaranteed to be in the same compartment as cx.
<span class="lineNum">    6587 </span>            :  *
<span class="lineNum">    6588 </span>            :  * You may consider or skip over self-hosted frames by passing
<span class="lineNum">    6589 </span>            :  * `SavedFrameSelfHosted::Include` or `SavedFrameSelfHosted::Exclude`
<span class="lineNum">    6590 </span>            :  * respectively.
<span class="lineNum">    6591 </span>            :  *
<span class="lineNum">    6592 </span>            :  * Additionally, it may be the case that there is no such SavedFrame object
<span class="lineNum">    6593 </span>            :  * whose captured frame's principals are subsumed by the caller's compartment's
<span class="lineNum">    6594 </span>            :  * principals! If the `HandleObject savedFrame` argument is null, or the
<span class="lineNum">    6595 </span>            :  * caller's principals do not subsume any of the chained SavedFrame object's
<span class="lineNum">    6596 </span>            :  * principals, `SavedFrameResult::AccessDenied` is returned and a (hopefully)
<span class="lineNum">    6597 </span>            :  * sane default value is chosen for the out param.
<span class="lineNum">    6598 </span>            :  *
<span class="lineNum">    6599 </span>            :  * See also `js/src/doc/SavedFrame/SavedFrame.md`.
<span class="lineNum">    6600 </span>            :  */
<span class="lineNum">    6601 </span>            : 
<span class="lineNum">    6602 </span>            : enum class SavedFrameResult {
<span class="lineNum">    6603 </span>            :     Ok,
<span class="lineNum">    6604 </span>            :     AccessDenied
<span class="lineNum">    6605 </span>            : };
<span class="lineNum">    6606 </span>            : 
<span class="lineNum">    6607 </span>            : enum class SavedFrameSelfHosted {
<span class="lineNum">    6608 </span>            :     Include,
<span class="lineNum">    6609 </span>            :     Exclude
<span class="lineNum">    6610 </span>            : };
<span class="lineNum">    6611 </span>            : 
<span class="lineNum">    6612 </span>            : /**
<span class="lineNum">    6613 </span>            :  * Given a SavedFrame JSObject, get its source property. Defaults to the empty
<span class="lineNum">    6614 </span>            :  * string.
<span class="lineNum">    6615 </span>            :  */
<span class="lineNum">    6616 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6617 </span>            : GetSavedFrameSource(JSContext* cx, HandleObject savedFrame, MutableHandleString sourcep,
<span class="lineNum">    6618 </span>            :                     SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6619 </span>            : 
<span class="lineNum">    6620 </span>            : /**
<span class="lineNum">    6621 </span>            :  * Given a SavedFrame JSObject, get its line property. Defaults to 0.
<span class="lineNum">    6622 </span>            :  */
<span class="lineNum">    6623 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6624 </span>            : GetSavedFrameLine(JSContext* cx, HandleObject savedFrame, uint32_t* linep,
<span class="lineNum">    6625 </span>            :                   SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6626 </span>            : 
<span class="lineNum">    6627 </span>            : /**
<span class="lineNum">    6628 </span>            :  * Given a SavedFrame JSObject, get its column property. Defaults to 0.
<span class="lineNum">    6629 </span>            :  */
<span class="lineNum">    6630 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6631 </span>            : GetSavedFrameColumn(JSContext* cx, HandleObject savedFrame, uint32_t* columnp,
<span class="lineNum">    6632 </span>            :                     SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6633 </span>            : 
<span class="lineNum">    6634 </span>            : /**
<span class="lineNum">    6635 </span>            :  * Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr
<span class="lineNum">    6636 </span>            :  * if SpiderMonkey was unable to infer a name for the captured frame's
<span class="lineNum">    6637 </span>            :  * function. Defaults to nullptr.
<span class="lineNum">    6638 </span>            :  */
<span class="lineNum">    6639 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6640 </span>            : GetSavedFrameFunctionDisplayName(JSContext* cx, HandleObject savedFrame, MutableHandleString namep,
<span class="lineNum">    6641 </span>            :                                  SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6642 </span>            : 
<span class="lineNum">    6643 </span>            : /**
<span class="lineNum">    6644 </span>            :  * Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr.
<span class="lineNum">    6645 </span>            :  */
<span class="lineNum">    6646 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6647 </span>            : GetSavedFrameAsyncCause(JSContext* cx, HandleObject savedFrame, MutableHandleString asyncCausep,
<span class="lineNum">    6648 </span>            :                         SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6649 </span>            : 
<span class="lineNum">    6650 </span>            : /**
<span class="lineNum">    6651 </span>            :  * Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr
<span class="lineNum">    6652 </span>            :  * if there is no asyncParent. The `asyncParentp` out parameter is _NOT_
<span class="lineNum">    6653 </span>            :  * guaranteed to be in the cx's compartment. Defaults to nullptr.
<span class="lineNum">    6654 </span>            :  */
<span class="lineNum">    6655 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6656 </span>            : GetSavedFrameAsyncParent(JSContext* cx, HandleObject savedFrame, MutableHandleObject asyncParentp,
<span class="lineNum">    6657 </span>            :                 SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6658 </span>            : 
<span class="lineNum">    6659 </span>            : /**
<span class="lineNum">    6660 </span>            :  * Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if
<span class="lineNum">    6661 </span>            :  * it is the oldest frame in the stack. The `parentp` out parameter is _NOT_
<span class="lineNum">    6662 </span>            :  * guaranteed to be in the cx's compartment. Defaults to nullptr.
<span class="lineNum">    6663 </span>            :  */
<span class="lineNum">    6664 </span>            : extern JS_PUBLIC_API(SavedFrameResult)
<span class="lineNum">    6665 </span>            : GetSavedFrameParent(JSContext* cx, HandleObject savedFrame, MutableHandleObject parentp,
<span class="lineNum">    6666 </span>            :                     SavedFrameSelfHosted selfHosted = SavedFrameSelfHosted::Include);
<span class="lineNum">    6667 </span>            : 
<span class="lineNum">    6668 </span>            : /**
<span class="lineNum">    6669 </span>            :  * Given a SavedFrame JSObject stack, stringify it in the same format as
<span class="lineNum">    6670 </span>            :  * Error.prototype.stack. The stringified stack out parameter is placed in the
<span class="lineNum">    6671 </span>            :  * cx's compartment. Defaults to the empty string.
<span class="lineNum">    6672 </span>            :  *
<span class="lineNum">    6673 </span>            :  * The same notes above about SavedFrame accessors applies here as well: cx
<span class="lineNum">    6674 </span>            :  * doesn't need to be in stack's compartment, and stack can be null, a
<span class="lineNum">    6675 </span>            :  * SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.
<span class="lineNum">    6676 </span>            :  *
<span class="lineNum">    6677 </span>            :  * Optional indent parameter specifies the number of white spaces to indent
<span class="lineNum">    6678 </span>            :  * each line.
<span class="lineNum">    6679 </span>            :  */
<span class="lineNum">    6680 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6681 </span>            : BuildStackString(JSContext* cx, HandleObject stack, MutableHandleString stringp,
<span class="lineNum">    6682 </span>            :                  size_t indent = 0, js::StackFormat stackFormat = js::StackFormat::Default);
<span class="lineNum">    6683 </span>            : 
<span class="lineNum">    6684 </span>            : /**
<span class="lineNum">    6685 </span>            :  * Return true iff the given object is either a SavedFrame object or wrapper
<span class="lineNum">    6686 </span>            :  * around a SavedFrame object, and it is not the SavedFrame.prototype object.
<span class="lineNum">    6687 </span>            :  */
<span class="lineNum">    6688 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6689 </span>            : IsSavedFrame(JSObject* obj);
<span class="lineNum">    6690 </span>            : 
<span class="lineNum">    6691 </span>            : } /* namespace JS */
<span class="lineNum">    6692 </span>            : 
<span class="lineNum">    6693 </span>            : 
<span class="lineNum">    6694 </span>            : /* Stopwatch-based performance monitoring. */
<span class="lineNum">    6695 </span>            : 
<span class="lineNum">    6696 </span>            : namespace js {
<span class="lineNum">    6697 </span>            : 
<span class="lineNum">    6698 </span>            : class AutoStopwatch;
<span class="lineNum">    6699 </span>            : 
<span class="lineNum">    6700 </span>            : /**
<span class="lineNum">    6701 </span>            :  * Abstract base class for a representation of the performance of a
<span class="lineNum">    6702 </span>            :  * component. Embeddings interested in performance monitoring should
<span class="lineNum">    6703 </span>            :  * provide a concrete implementation of this class, as well as the
<span class="lineNum">    6704 </span>            :  * relevant callbacks (see below).
<span class="lineNum">    6705 </span>            :  */
<span class="lineNum">    6706 </span>            : struct JS_PUBLIC_API(PerformanceGroup) {
<span class="lineNum">    6707 </span>            :     PerformanceGroup();
<span class="lineNum">    6708 </span>            : 
<span class="lineNum">    6709 </span>            :     // The current iteration of the event loop.
<span class="lineNum">    6710 </span>            :     uint64_t iteration() const;
<span class="lineNum">    6711 </span>            : 
<span class="lineNum">    6712 </span>            :     // `true` if an instance of `AutoStopwatch` is already monitoring
<span class="lineNum">    6713 </span>            :     // the performance of this performance group for this iteration
<span class="lineNum">    6714 </span>            :     // of the event loop, `false` otherwise.
<span class="lineNum">    6715 </span>            :     bool isAcquired(uint64_t it) const;
<span class="lineNum">    6716 </span>            : 
<span class="lineNum">    6717 </span>            :     // `true` if a specific instance of `AutoStopwatch` is already monitoring
<span class="lineNum">    6718 </span>            :     // the performance of this performance group for this iteration
<span class="lineNum">    6719 </span>            :     // of the event loop, `false` otherwise.
<span class="lineNum">    6720 </span>            :     bool isAcquired(uint64_t it, const AutoStopwatch* owner) const;
<span class="lineNum">    6721 </span>            : 
<span class="lineNum">    6722 </span>            :     // Mark that an instance of `AutoStopwatch` is monitoring
<span class="lineNum">    6723 </span>            :     // the performance of this group for a given iteration.
<span class="lineNum">    6724 </span>            :     void acquire(uint64_t it, const AutoStopwatch* owner);
<span class="lineNum">    6725 </span>            : 
<span class="lineNum">    6726 </span>            :     // Mark that no `AutoStopwatch` is monitoring the
<span class="lineNum">    6727 </span>            :     // performance of this group for the iteration.
<span class="lineNum">    6728 </span>            :     void release(uint64_t it, const AutoStopwatch* owner);
<span class="lineNum">    6729 </span>            : 
<span class="lineNum">    6730 </span>            :     // The number of cycles spent in this group during this iteration
<span class="lineNum">    6731 </span>            :     // of the event loop. Note that cycles are not a reliable measure,
<span class="lineNum">    6732 </span>            :     // especially over short intervals. See Stopwatch.* for a more
<span class="lineNum">    6733 </span>            :     // complete discussion on the imprecision of cycle measurement.
<span class="lineNum">    6734 </span>            :     uint64_t recentCycles(uint64_t iteration) const;
<span class="lineNum">    6735 </span>            :     void addRecentCycles(uint64_t iteration, uint64_t cycles);
<span class="lineNum">    6736 </span>            : 
<span class="lineNum">    6737 </span>            :     // The number of times this group has been activated during this
<span class="lineNum">    6738 </span>            :     // iteration of the event loop.
<span class="lineNum">    6739 </span>            :     uint64_t recentTicks(uint64_t iteration) const;
<span class="lineNum">    6740 </span>            :     void addRecentTicks(uint64_t iteration, uint64_t ticks);
<span class="lineNum">    6741 </span>            : 
<span class="lineNum">    6742 </span>            :     // The number of microseconds spent doing CPOW during this
<span class="lineNum">    6743 </span>            :     // iteration of the event loop.
<span class="lineNum">    6744 </span>            :     uint64_t recentCPOW(uint64_t iteration) const;
<span class="lineNum">    6745 </span>            :     void addRecentCPOW(uint64_t iteration, uint64_t CPOW);
<span class="lineNum">    6746 </span>            : 
<span class="lineNum">    6747 </span>            :     // Get rid of any data that pretends to be recent.
<span class="lineNum">    6748 </span>            :     void resetRecentData();
<span class="lineNum">    6749 </span>            : 
<span class="lineNum">    6750 </span>            :     // `true` if new measures should be added to this group, `false`
<span class="lineNum">    6751 </span>            :     // otherwise.
<span class="lineNum">    6752 </span>            :     bool isActive() const;
<span class="lineNum">    6753 </span>            :     void setIsActive(bool);
<span class="lineNum">    6754 </span>            : 
<span class="lineNum">    6755 </span>            :     // `true` if this group has been used in the current iteration,
<span class="lineNum">    6756 </span>            :     // `false` otherwise.
<span class="lineNum">    6757 </span>            :     bool isUsedInThisIteration() const;
<span class="lineNum">    6758 </span>            :     void setIsUsedInThisIteration(bool);
<span class="lineNum">    6759 </span>            :   protected:
<span class="lineNum">    6760 </span>            :     // An implementation of `delete` for this object. Must be provided
<span class="lineNum">    6761 </span>            :     // by the embedding.
<span class="lineNum">    6762 </span>            :     virtual void Delete() = 0;
<span class="lineNum">    6763 </span>            : 
<span class="lineNum">    6764 </span>            :   private:
<span class="lineNum">    6765 </span>            :     // The number of cycles spent in this group during this iteration
<span class="lineNum">    6766 </span>            :     // of the event loop. Note that cycles are not a reliable measure,
<span class="lineNum">    6767 </span>            :     // especially over short intervals. See Runtime.cpp for a more
<span class="lineNum">    6768 </span>            :     // complete discussion on the imprecision of cycle measurement.
<span class="lineNum">    6769 </span>            :     uint64_t recentCycles_;
<span class="lineNum">    6770 </span>            : 
<span class="lineNum">    6771 </span>            :     // The number of times this group has been activated during this
<span class="lineNum">    6772 </span>            :     // iteration of the event loop.
<span class="lineNum">    6773 </span>            :     uint64_t recentTicks_;
<span class="lineNum">    6774 </span>            : 
<span class="lineNum">    6775 </span>            :     // The number of microseconds spent doing CPOW during this
<span class="lineNum">    6776 </span>            :     // iteration of the event loop.
<span class="lineNum">    6777 </span>            :     uint64_t recentCPOW_;
<span class="lineNum">    6778 </span>            : 
<span class="lineNum">    6779 </span>            :     // The current iteration of the event loop. If necessary,
<span class="lineNum">    6780 </span>            :     // may safely overflow.
<span class="lineNum">    6781 </span>            :     uint64_t iteration_;
<span class="lineNum">    6782 </span>            : 
<span class="lineNum">    6783 </span>            :     // `true` if new measures should be added to this group, `false`
<span class="lineNum">    6784 </span>            :     // otherwise.
<span class="lineNum">    6785 </span>            :     bool isActive_;
<span class="lineNum">    6786 </span>            : 
<span class="lineNum">    6787 </span>            :     // `true` if this group has been used in the current iteration,
<span class="lineNum">    6788 </span>            :     // `false` otherwise.
<span class="lineNum">    6789 </span>            :     bool isUsedInThisIteration_;
<span class="lineNum">    6790 </span>            : 
<span class="lineNum">    6791 </span>            :     // The stopwatch currently monitoring the group,
<span class="lineNum">    6792 </span>            :     // or `nullptr` if none. Used ony for comparison.
<span class="lineNum">    6793 </span>            :     const AutoStopwatch* owner_;
<span class="lineNum">    6794 </span>            : 
<span class="lineNum">    6795 </span>            :   public:
<span class="lineNum">    6796 </span>            :     // Compatibility with RefPtr&lt;&gt;
<span class="lineNum">    6797 </span>            :     void AddRef();
<span class="lineNum">    6798 </span>            :     void Release();
<span class="lineNum">    6799 </span>            :     uint64_t refCount_;
<span class="lineNum">    6800 </span>            : };
<span class="lineNum">    6801 </span>            : 
<span class="lineNum">    6802 </span>            : using PerformanceGroupVector = mozilla::Vector&lt;RefPtr&lt;js::PerformanceGroup&gt;, 8, SystemAllocPolicy&gt;;
<span class="lineNum">    6803 </span>            : 
<span class="lineNum">    6804 </span>            : /**
<span class="lineNum">    6805 </span>            :  * Commit any Performance Monitoring data.
<span class="lineNum">    6806 </span>            :  *
<span class="lineNum">    6807 </span>            :  * Until `FlushMonitoring` has been called, all PerformanceMonitoring data is invisible
<span class="lineNum">    6808 </span>            :  * to the outside world and can cancelled with a call to `ResetMonitoring`.
<span class="lineNum">    6809 </span>            :  */
<span class="lineNum">    6810 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6811 </span>            : FlushPerformanceMonitoring(JSContext*);
<span class="lineNum">    6812 </span>            : 
<span class="lineNum">    6813 </span>            : /**
<span class="lineNum">    6814 </span>            :  * Cancel any measurement that hasn't been committed.
<span class="lineNum">    6815 </span>            :  */
<span class="lineNum">    6816 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6817 </span>            : ResetPerformanceMonitoring(JSContext*);
<span class="lineNum">    6818 </span>            : 
<span class="lineNum">    6819 </span>            : /**
<span class="lineNum">    6820 </span>            :  * Cleanup any memory used by performance monitoring.
<span class="lineNum">    6821 </span>            :  */
<span class="lineNum">    6822 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6823 </span>            : DisposePerformanceMonitoring(JSContext*);
<span class="lineNum">    6824 </span>            : 
<span class="lineNum">    6825 </span>            : /**
<span class="lineNum">    6826 </span>            :  * Turn on/off stopwatch-based CPU monitoring.
<span class="lineNum">    6827 </span>            :  *
<span class="lineNum">    6828 </span>            :  * `SetStopwatchIsMonitoringCPOW` or `SetStopwatchIsMonitoringJank`
<span class="lineNum">    6829 </span>            :  * may return `false` if monitoring could not be activated, which may
<span class="lineNum">    6830 </span>            :  * happen if we are out of memory.
<span class="lineNum">    6831 </span>            :  */
<span class="lineNum">    6832 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6833 </span>            : SetStopwatchIsMonitoringCPOW(JSContext*, bool);
<span class="lineNum">    6834 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6835 </span>            : GetStopwatchIsMonitoringCPOW(JSContext*);
<span class="lineNum">    6836 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6837 </span>            : SetStopwatchIsMonitoringJank(JSContext*, bool);
<span class="lineNum">    6838 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6839 </span>            : GetStopwatchIsMonitoringJank(JSContext*);
<span class="lineNum">    6840 </span>            : 
<span class="lineNum">    6841 </span>            : // Extract the CPU rescheduling data.
<span class="lineNum">    6842 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6843 </span>            : GetPerfMonitoringTestCpuRescheduling(JSContext*, uint64_t* stayed, uint64_t* moved);
<span class="lineNum">    6844 </span>            : 
<span class="lineNum">    6845 </span>            : 
<span class="lineNum">    6846 </span>            : /**
<span class="lineNum">    6847 </span>            :  * Add a number of microseconds to the time spent waiting on CPOWs
<span class="lineNum">    6848 </span>            :  * since process start.
<span class="lineNum">    6849 </span>            :  */
<span class="lineNum">    6850 </span>            : extern JS_PUBLIC_API(void)
<span class="lineNum">    6851 </span>            : AddCPOWPerformanceDelta(JSContext*, uint64_t delta);
<span class="lineNum">    6852 </span>            : 
<span class="lineNum">    6853 </span>            : typedef bool
<span class="lineNum">    6854 </span>            : (*StopwatchStartCallback)(uint64_t, void*);
<span class="lineNum">    6855 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6856 </span>            : SetStopwatchStartCallback(JSContext*, StopwatchStartCallback, void*);
<span class="lineNum">    6857 </span>            : 
<span class="lineNum">    6858 </span>            : typedef bool
<span class="lineNum">    6859 </span>            : (*StopwatchCommitCallback)(uint64_t, PerformanceGroupVector&amp;, void*);
<span class="lineNum">    6860 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6861 </span>            : SetStopwatchCommitCallback(JSContext*, StopwatchCommitCallback, void*);
<span class="lineNum">    6862 </span>            : 
<span class="lineNum">    6863 </span>            : typedef bool
<span class="lineNum">    6864 </span>            : (*GetGroupsCallback)(JSContext*, PerformanceGroupVector&amp;, void*);
<span class="lineNum">    6865 </span>            : extern JS_PUBLIC_API(bool)
<span class="lineNum">    6866 </span>            : SetGetPerformanceGroupsCallback(JSContext*, GetGroupsCallback, void*);
<span class="lineNum">    6867 </span>            : 
<span class="lineNum">    6868 </span>            : } /* namespace js */
<span class="lineNum">    6869 </span>            : 
<span class="lineNum">    6870 </span>            : namespace js {
<span class="lineNum">    6871 </span>            : 
<span class="lineNum">    6872 </span>            : enum class CompletionKind {
<span class="lineNum">    6873 </span>            :     Normal,
<span class="lineNum">    6874 </span>            :     Return,
<span class="lineNum">    6875 </span>            :     Throw
<span class="lineNum">    6876 </span>            : };
<span class="lineNum">    6877 </span>            : 
<span class="lineNum">    6878 </span>            : } /* namespace js */
<span class="lineNum">    6879 </span>            : 
<span class="lineNum">    6880 </span>            : #endif /* jsapi_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
