<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/generic/nsFlexContainerFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/generic</a> - nsFlexContainerFrame.cpp<span style="font-size: 80%;"> (source / <a href="nsFlexContainerFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1069</td>
            <td class="headerCovTableEntry">1203</td>
            <td class="headerCovTableEntryMed">88.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">98</td>
            <td class="headerCovTableEntry">103</td>
            <td class="headerCovTableEntryHi">95.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : /* This Source Code is subject to the terms of the Mozilla Public License
<span class="lineNum">       5 </span>            :  * version 2.0 (the &quot;License&quot;). You can obtain a copy of the License at
<span class="lineNum">       6 </span>            :  * http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : /* rendering object for CSS &quot;display: flex&quot; */
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;nsFlexContainerFrame.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsCSSAnonBoxes.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsDisplayList.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsIFrameInlines.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsPlaceholderFrame.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsRenderingContext.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsStyleContext.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/CSSOrderAwareFrameIterator.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/Logging.h&quot;
<span class="lineNum">      22 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/LinkedList.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mozilla/FloatingPoint.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;WritingModes.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : using namespace mozilla;
<span class="lineNum">      29 </span>            : using namespace mozilla::layout;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : // Convenience typedefs for helper classes that we forward-declare in .h file
<span class="lineNum">      32 </span>            : // (so that nsFlexContainerFrame methods can use them as parameters):
<span class="lineNum">      33 </span>            : typedef nsFlexContainerFrame::FlexItem FlexItem;
<span class="lineNum">      34 </span>            : typedef nsFlexContainerFrame::FlexLine FlexLine;
<span class="lineNum">      35 </span>            : typedef nsFlexContainerFrame::FlexboxAxisTracker FlexboxAxisTracker;
<span class="lineNum">      36 </span>            : typedef nsFlexContainerFrame::StrutInfo StrutInfo;
<span class="lineNum">      37 </span>            : typedef nsFlexContainerFrame::CachedMeasuringReflowResult
<span class="lineNum">      38 </span>            :           CachedMeasuringReflowResult;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : static mozilla::LazyLogModule gFlexContainerLog(&quot;nsFlexContainerFrame&quot;);
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // XXXdholbert Some of this helper-stuff should be separated out into a general
<span class="lineNum">      43 </span>            : // &quot;main/cross-axis utils&quot; header, shared by grid &amp; flexbox?
<span class="lineNum">      44 </span>            : // (Particularly when grid gets support for align-*/justify-* properties.)
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : // Helper enums
<span class="lineNum">      47 </span>            : // ============
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : // Represents a physical orientation for an axis.
<span class="lineNum">      50 </span>            : // The directional suffix indicates the direction in which the axis *grows*.
<span class="lineNum">      51 </span>            : // So e.g. eAxis_LR means a horizontal left-to-right axis, whereas eAxis_BT
<span class="lineNum">      52 </span>            : // means a vertical bottom-to-top axis.
<span class="lineNum">      53 </span>            : // NOTE: The order here is important -- these values are used as indices into
<span class="lineNum">      54 </span>            : // the static array 'kAxisOrientationToSidesMap', defined below.
<span class="lineNum">      55 </span>            : enum AxisOrientationType {
<span class="lineNum">      56 </span>            :   eAxis_LR,
<span class="lineNum">      57 </span>            :   eAxis_RL,
<span class="lineNum">      58 </span>            :   eAxis_TB,
<span class="lineNum">      59 </span>            :   eAxis_BT,
<span class="lineNum">      60 </span>            :   eNumAxisOrientationTypes // For sizing arrays that use these values as indices
<span class="lineNum">      61 </span>            : };
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : // Represents one or the other extreme of an axis (e.g. for the main axis, the
<span class="lineNum">      64 </span>            : // main-start vs. main-end edge.
<span class="lineNum">      65 </span>            : // NOTE: The order here is important -- these values are used as indices into
<span class="lineNum">      66 </span>            : // the sub-arrays in 'kAxisOrientationToSidesMap', defined below.
<span class="lineNum">      67 </span>            : enum AxisEdgeType {
<span class="lineNum">      68 </span>            :   eAxisEdge_Start,
<span class="lineNum">      69 </span>            :   eAxisEdge_End,
<span class="lineNum">      70 </span>            :   eNumAxisEdges // For sizing arrays that use these values as indices
<span class="lineNum">      71 </span>            : };
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : // This array maps each axis orientation to a pair of corresponding
<span class="lineNum">      74 </span>            : // [start, end] physical mozilla::Side values.
<span class="lineNum">      75 </span>            : static const mozilla::Side
<span class="lineNum">      76 </span>            : kAxisOrientationToSidesMap[eNumAxisOrientationTypes][eNumAxisEdges] = {
<span class="lineNum">      77 </span>            :   { eSideLeft,   eSideRight  },  // eAxis_LR
<span class="lineNum">      78 </span>            :   { eSideRight,  eSideLeft   },  // eAxis_RL
<span class="lineNum">      79 </span>            :   { eSideTop,    eSideBottom },  // eAxis_TB
<span class="lineNum">      80 </span>            :   { eSideBottom, eSideTop }      // eAxis_BT
<span class="lineNum">      81 </span>            : };
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : // Helper structs / classes / methods
<span class="lineNum">      84 </span>            : // ==================================
<span class="lineNum">      85 </span>            : // Returns true iff the given nsStyleDisplay has display:-webkit-{inline-}-box.
<span class="lineNum">      86 </span>            : static inline bool
<span class="lineNum">      87 </span>            : IsDisplayValueLegacyBox(const nsStyleDisplay* aStyleDisp)
<span class="lineNum">      88 </span>            : {
<span class="lineNum">      89 </span><span class="lineCov">          1 :   return aStyleDisp-&gt;mDisplay == mozilla::StyleDisplay::WebkitBox ||</span>
<span class="lineNum">      90 </span><span class="lineCov">          1 :     aStyleDisp-&gt;mDisplay == mozilla::StyleDisplay::WebkitInlineBox;</span>
<span class="lineNum">      91 </span>            : }
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : // Returns true if aFlexContainer is the frame for an element with
<span class="lineNum">      94 </span>            : // &quot;display:-webkit-box&quot; or &quot;display:-webkit-inline-box&quot;. aFlexContainer is
<span class="lineNum">      95 </span>            : // expected to be an instance of nsFlexContainerFrame (enforced with an assert);
<span class="lineNum">      96 </span>            : // otherwise, this function's state-bit-check here is bogus.
<span class="lineNum">      97 </span>            : static bool
<span class="lineNum">      98 </span>            : IsLegacyBox(const nsIFrame* aFlexContainer)
<span class="lineNum">      99 </span>            : {
<span class="lineNum">     100 </span>            :   MOZ_ASSERT(aFlexContainer-&gt;GetType() == nsGkAtoms::flexContainerFrame,
<span class="lineNum">     101 </span>            :              &quot;only flex containers may be passed to this function&quot;);
<span class="lineNum">     102 </span><span class="lineCov">          1 :   return aFlexContainer-&gt;HasAnyStateBits(NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX);</span>
<span class="lineNum">     103 </span>            : }
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : // Returns the OrderingProperty enum that we should pass to
<a name="106"><span class="lineNum">     106 </span>            : // CSSOrderAwareFrameIterator (depending on whether it's a legacy box).</a>
<span class="lineNum">     107 </span>            : static CSSOrderAwareFrameIterator::OrderingProperty
<span class="lineNum">     108 </span><span class="lineCov">          1 : OrderingPropertyForIter(const nsFlexContainerFrame* aFlexContainer)</span>
<span class="lineNum">     109 </span>            : {
<span class="lineNum">     110 </span>            :   return IsLegacyBox(aFlexContainer)
<span class="lineNum">     111 </span>            :     ? CSSOrderAwareFrameIterator::OrderingProperty::eUseBoxOrdinalGroup
<span class="lineNum">     112 </span><span class="lineCov">          1 :     : CSSOrderAwareFrameIterator::OrderingProperty::eUseOrder;</span>
<span class="lineNum">     113 </span>            : }
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : // Returns the &quot;align-items&quot; value that's equivalent to the legacy &quot;box-align&quot;
<a name="116"><span class="lineNum">     116 </span>            : // value in the given style struct.</a>
<span class="lineNum">     117 </span>            : static uint8_t
<span class="lineNum">     118 </span><span class="lineNoCov">          0 : ConvertLegacyStyleToAlignItems(const nsStyleXUL* aStyleXUL)</span>
<span class="lineNum">     119 </span>            : {
<span class="lineNum">     120 </span>            :   // -[moz|webkit]-box-align corresponds to modern &quot;align-items&quot;
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   switch (aStyleXUL-&gt;mBoxAlign) {</span>
<span class="lineNum">     122 </span>            :     case StyleBoxAlign::Stretch:
<span class="lineNum">     123 </span>            :       return NS_STYLE_ALIGN_STRETCH;
<span class="lineNum">     124 </span>            :     case StyleBoxAlign::Start:
<span class="lineNum">     125 </span>            :       return NS_STYLE_ALIGN_FLEX_START;
<span class="lineNum">     126 </span>            :     case StyleBoxAlign::Center:
<span class="lineNum">     127 </span>            :       return NS_STYLE_ALIGN_CENTER;
<span class="lineNum">     128 </span>            :     case StyleBoxAlign::Baseline:
<span class="lineNum">     129 </span>            :       return NS_STYLE_ALIGN_BASELINE;
<span class="lineNum">     130 </span>            :     case StyleBoxAlign::End:
<span class="lineNum">     131 </span>            :       return NS_STYLE_ALIGN_FLEX_END;
<span class="lineNum">     132 </span>            :   }
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   MOZ_ASSERT_UNREACHABLE(&quot;Unrecognized mBoxAlign enum value&quot;);
<span class="lineNum">     135 </span>            :   // Fall back to default value of &quot;align-items&quot; property:
<span class="lineNum">     136 </span>            :   return NS_STYLE_ALIGN_STRETCH;
<span class="lineNum">     137 </span>            : }
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : // Returns the &quot;justify-content&quot; value that's equivalent to the legacy
<a name="140"><span class="lineNum">     140 </span>            : // &quot;box-pack&quot; value in the given style struct.</a>
<span class="lineNum">     141 </span>            : static uint8_t
<span class="lineNum">     142 </span><span class="lineNoCov">          0 : ConvertLegacyStyleToJustifyContent(const nsStyleXUL* aStyleXUL)</span>
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span>            :   // -[moz|webkit]-box-pack corresponds to modern &quot;justify-content&quot;
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   switch (aStyleXUL-&gt;mBoxPack) {</span>
<span class="lineNum">     146 </span>            :     case StyleBoxPack::Start:
<span class="lineNum">     147 </span>            :       return NS_STYLE_ALIGN_FLEX_START;
<span class="lineNum">     148 </span>            :     case StyleBoxPack::Center:
<span class="lineNum">     149 </span>            :       return NS_STYLE_ALIGN_CENTER;
<span class="lineNum">     150 </span>            :     case StyleBoxPack::End:
<span class="lineNum">     151 </span>            :       return NS_STYLE_ALIGN_FLEX_END;
<span class="lineNum">     152 </span>            :     case StyleBoxPack::Justify:
<span class="lineNum">     153 </span>            :       return NS_STYLE_ALIGN_SPACE_BETWEEN;
<span class="lineNum">     154 </span>            :   }
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   MOZ_ASSERT_UNREACHABLE(&quot;Unrecognized mBoxPack enum value&quot;);
<span class="lineNum">     157 </span>            :   // Fall back to default value of &quot;justify-content&quot; property:
<span class="lineNum">     158 </span>            :   return NS_STYLE_ALIGN_FLEX_START;
<span class="lineNum">     159 </span>            : }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : // Indicates whether advancing along the given axis is equivalent to
<span class="lineNum">     162 </span>            : // increasing our X or Y position (as opposed to decreasing it).
<span class="lineNum">     163 </span>            : static inline bool
<span class="lineNum">     164 </span>            : AxisGrowsInPositiveDirection(AxisOrientationType aAxis)
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span><span class="lineCov">          1 :   return eAxis_LR == aAxis || eAxis_TB == aAxis;</span>
<span class="lineNum">     167 </span>            : }
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : // Given an AxisOrientationType, returns the &quot;reverse&quot; AxisOrientationType
<a name="170"><span class="lineNum">     170 </span>            : // (in the same dimension, but the opposite direction)</a>
<span class="lineNum">     171 </span>            : static inline AxisOrientationType
<span class="lineNum">     172 </span><span class="lineCov">          1 : GetReverseAxis(AxisOrientationType aAxis)</span>
<span class="lineNum">     173 </span>            : {
<span class="lineNum">     174 </span>            :   AxisOrientationType reversedAxis;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">          1 :   if (aAxis % 2 == 0) {</span>
<span class="lineNum">     177 </span>            :     // even enum value. Add 1 to reverse.
<span class="lineNum">     178 </span><span class="lineCov">          1 :     reversedAxis = AxisOrientationType(aAxis + 1);</span>
<span class="lineNum">     179 </span>            :   } else {
<span class="lineNum">     180 </span>            :     // odd enum value. Subtract 1 to reverse.
<span class="lineNum">     181 </span><span class="lineCov">          1 :     reversedAxis = AxisOrientationType(aAxis - 1);</span>
<span class="lineNum">     182 </span>            :   }
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   // Check that we're still in the enum's valid range
<span class="lineNum">     185 </span>            :   MOZ_ASSERT(reversedAxis &gt;= eAxis_LR &amp;&amp;
<span class="lineNum">     186 </span>            :              reversedAxis &lt;= eAxis_BT);
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineCov">          1 :   return reversedAxis;</span>
<span class="lineNum">     189 </span>            : }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : /**
<span class="lineNum">     192 </span>            :  * Converts a &quot;flex-relative&quot; coordinate in a single axis (a main- or cross-axis
<span class="lineNum">     193 </span>            :  * coordinate) into a coordinate in the corresponding physical (x or y) axis. If
<span class="lineNum">     194 </span>            :  * the flex-relative axis in question already maps *directly* to a physical
<span class="lineNum">     195 </span>            :  * axis (i.e. if it's LTR or TTB), then the physical coordinate has the same
<span class="lineNum">     196 </span>            :  * numeric value as the provided flex-relative coordinate. Otherwise, we have to
<span class="lineNum">     197 </span>            :  * subtract the flex-relative coordinate from the flex container's size in that
<span class="lineNum">     198 </span>            :  * axis, to flip the polarity. (So e.g. a main-axis position of 2px in a RTL
<span class="lineNum">     199 </span>            :  * 20px-wide container would correspond to a physical coordinate (x-value) of
<span class="lineNum">     200 </span>            :  * 18px.)
<a name="201"><span class="lineNum">     201 </span>            :  */</a>
<span class="lineNum">     202 </span>            : static nscoord
<span class="lineNum">     203 </span><span class="lineCov">          1 : PhysicalCoordFromFlexRelativeCoord(nscoord aFlexRelativeCoord,</span>
<span class="lineNum">     204 </span>            :                                    nscoord aContainerSize,
<span class="lineNum">     205 </span>            :                                    AxisOrientationType aAxis) {
<span class="lineNum">     206 </span><span class="lineCov">          1 :   if (AxisGrowsInPositiveDirection(aAxis)) {</span>
<span class="lineNum">     207 </span>            :     return aFlexRelativeCoord;
<span class="lineNum">     208 </span>            :   }
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   return aContainerSize - aFlexRelativeCoord;</span>
<span class="lineNum">     210 </span>            : }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : // Helper-macro to let us pick one of two expressions to evaluate
<span class="lineNum">     213 </span>            : // (a width expression vs. a height expression), to get a main-axis or
<span class="lineNum">     214 </span>            : // cross-axis component.
<span class="lineNum">     215 </span>            : // For code that has e.g. a nsSize object, FlexboxAxisTracker::GetMainComponent
<span class="lineNum">     216 </span>            : // and GetCrossComponent are cleaner; but in cases where we simply have
<span class="lineNum">     217 </span>            : // two separate expressions for width and height (which may be expensive to
<span class="lineNum">     218 </span>            : // evaluate), these macros will ensure that only the expression for the correct
<span class="lineNum">     219 </span>            : // axis gets evaluated.
<span class="lineNum">     220 </span>            : #define GET_MAIN_COMPONENT(axisTracker_, width_, height_)  \
<span class="lineNum">     221 </span>            :   (axisTracker_).IsMainAxisHorizontal() ? (width_) : (height_)
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : #define GET_CROSS_COMPONENT(axisTracker_, width_, height_)  \
<span class="lineNum">     224 </span>            :   (axisTracker_).IsCrossAxisHorizontal() ? (width_) : (height_)
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : // Logical versions of helper-macros above:
<span class="lineNum">     227 </span>            : #define GET_MAIN_COMPONENT_LOGICAL(axisTracker_, wm_, isize_, bsize_)  \
<span class="lineNum">     228 </span>            :   wm_.IsOrthogonalTo(axisTracker_.GetWritingMode()) != \
<span class="lineNum">     229 </span>            :     (axisTracker_).IsRowOriented() ? (isize_) : (bsize_)
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : #define GET_CROSS_COMPONENT_LOGICAL(axisTracker_, wm_, isize_, bsize_)  \
<span class="lineNum">     232 </span>            :   wm_.IsOrthogonalTo(axisTracker_.GetWritingMode()) != \
<span class="lineNum">     233 </span>            :     (axisTracker_).IsRowOriented() ? (bsize_) : (isize_)
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : // Flags to customize behavior of the FlexboxAxisTracker constructor:
<span class="lineNum">     236 </span>            : enum AxisTrackerFlags {
<span class="lineNum">     237 </span>            :   eNoFlags = 0x0,
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   // Normally, FlexboxAxisTracker may attempt to reverse axes &amp; iteration order
<span class="lineNum">     240 </span>            :   // to avoid bottom-to-top child ordering, for saner pagination. This flag
<span class="lineNum">     241 </span>            :   // suppresses that behavior (so that we allow bottom-to-top child ordering).
<span class="lineNum">     242 </span>            :   // (This may be helpful e.g. when we're only dealing with a single child.)
<span class="lineNum">     243 </span>            :   eAllowBottomToTopChildOrdering = 0x1
<span class="lineNum">     244 </span>            : };
<span class="lineNum">     245 </span><span class="lineCov">          1 : MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS(AxisTrackerFlags)</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : // Encapsulates our flex container's main &amp; cross axes.
<span class="lineNum">     248 </span>            : class MOZ_STACK_CLASS nsFlexContainerFrame::FlexboxAxisTracker {
<span class="lineNum">     249 </span>            : public:
<span class="lineNum">     250 </span>            :   FlexboxAxisTracker(const nsFlexContainerFrame* aFlexContainer,
<span class="lineNum">     251 </span>            :                      const WritingMode&amp; aWM,
<span class="lineNum">     252 </span>            :                      AxisTrackerFlags aFlags = eNoFlags);
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   // Accessors:
<span class="lineNum">     255 </span>            :   // XXXdholbert [BEGIN DEPRECATED]
<span class="lineNum">     256 </span>            :   AxisOrientationType GetMainAxis() const  { return mMainAxis;  }
<a name="257"><span class="lineNum">     257 </span>            :   AxisOrientationType GetCrossAxis() const { return mCrossAxis; }</a>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineCov">          1 :   bool IsMainAxisHorizontal() const {</span>
<span class="lineNum">     260 </span>            :     // If we're row-oriented, and our writing mode is NOT vertical,
<span class="lineNum">     261 </span>            :     // or we're column-oriented and our writing mode IS vertical,
<span class="lineNum">     262 </span>            :     // then our main axis is horizontal. This handles all cases:
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">          1 :     return mIsRowOriented != mWM.IsVertical();</span></a>
<span class="lineNum">     264 </span>            :   }
<span class="lineNum">     265 </span><span class="lineCov">          1 :   bool IsCrossAxisHorizontal() const {</span>
<span class="lineNum">     266 </span><span class="lineCov">          1 :     return !IsMainAxisHorizontal();</span>
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span>            :   // XXXdholbert [END DEPRECATED]
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   // Returns the flex container's writing mode.
<span class="lineNum">     271 </span>            :   WritingMode GetWritingMode() const { return mWM; }
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :   // Returns true if our main axis is in the reverse direction of our
<span class="lineNum">     274 </span>            :   // writing mode's corresponding axis. (From 'flex-direction: *-reverse')
<span class="lineNum">     275 </span>            :   bool IsMainAxisReversed() const {
<span class="lineNum">     276 </span>            :     return mIsMainAxisReversed;
<span class="lineNum">     277 </span>            :   }
<span class="lineNum">     278 </span>            :   // Returns true if our cross axis is in the reverse direction of our
<span class="lineNum">     279 </span>            :   // writing mode's corresponding axis. (From 'flex-wrap: *-reverse')
<span class="lineNum">     280 </span>            :   bool IsCrossAxisReversed() const {
<span class="lineNum">     281 </span>            :     return mIsCrossAxisReversed;
<span class="lineNum">     282 </span>            :   }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :   bool IsRowOriented() const { return mIsRowOriented; }
<span class="lineNum">     285 </span>            :   bool IsColumnOriented() const { return !mIsRowOriented; }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   nscoord GetMainComponent(const nsSize&amp; aSize) const {
<a name="288"><span class="lineNum">     288 </span>            :     return GET_MAIN_COMPONENT(*this, aSize.width, aSize.height);</a>
<span class="lineNum">     289 </span>            :   }
<span class="lineNum">     290 </span><span class="lineCov">          1 :   int32_t GetMainComponent(const LayoutDeviceIntSize&amp; aIntSize) const {</span>
<span class="lineNum">     291 </span><span class="lineCov">          1 :     return GET_MAIN_COMPONENT(*this, aIntSize.width, aIntSize.height);</span>
<a name="292"><span class="lineNum">     292 </span>            :   }</a>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineCov">          1 :   nscoord GetCrossComponent(const nsSize&amp; aSize) const {</span>
<a name="295"><span class="lineNum">     295 </span><span class="lineCov">          1 :     return GET_CROSS_COMPONENT(*this, aSize.width, aSize.height);</span></a>
<span class="lineNum">     296 </span>            :   }
<span class="lineNum">     297 </span><span class="lineCov">          1 :   int32_t GetCrossComponent(const LayoutDeviceIntSize&amp; aIntSize) const {</span>
<span class="lineNum">     298 </span><span class="lineCov">          1 :     return GET_CROSS_COMPONENT(*this, aIntSize.width, aIntSize.height);</span>
<a name="299"><span class="lineNum">     299 </span>            :   }</a>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineCov">          1 :   nscoord GetMarginSizeInMainAxis(const nsMargin&amp; aMargin) const {</span>
<span class="lineNum">     302 </span><span class="lineCov">          1 :     return IsMainAxisHorizontal() ?</span>
<span class="lineNum">     303 </span><span class="lineCov">          1 :       aMargin.LeftRight() :</span>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">          1 :       aMargin.TopBottom();</span></a>
<span class="lineNum">     305 </span>            :   }
<span class="lineNum">     306 </span><span class="lineCov">          1 :   nscoord GetMarginSizeInCrossAxis(const nsMargin&amp; aMargin) const {</span>
<span class="lineNum">     307 </span><span class="lineCov">          1 :     return IsCrossAxisHorizontal() ?</span>
<span class="lineNum">     308 </span><span class="lineCov">          1 :       aMargin.LeftRight() :</span>
<span class="lineNum">     309 </span><span class="lineCov">          1 :       aMargin.TopBottom();</span>
<span class="lineNum">     310 </span>            :   }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :   // Returns aFrame's computed value for 'height' or 'width' -- whichever is in
<a name="313"><span class="lineNum">     313 </span>            :   // the cross-axis. (NOTE: This is cross-axis-specific for now. If we need a</a>
<span class="lineNum">     314 </span>            :   // main-axis version as well, we could generalize or clone this function.)
<span class="lineNum">     315 </span><span class="lineCov">          1 :   const nsStyleCoord&amp; ComputedCrossSize(const nsIFrame* aFrame) const {</span>
<span class="lineNum">     316 </span><span class="lineCov">          1 :     const nsStylePosition* stylePos = aFrame-&gt;StylePosition();</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineCov">          1 :     return IsCrossAxisHorizontal() ?</span>
<span class="lineNum">     319 </span>            :       stylePos-&gt;mWidth :
<span class="lineNum">     320 </span><span class="lineCov">          1 :       stylePos-&gt;mHeight;</span>
<span class="lineNum">     321 </span>            :   }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   /**
<span class="lineNum">     324 </span>            :    * Converts a &quot;flex-relative&quot; point (a main-axis &amp; cross-axis coordinate)
<span class="lineNum">     325 </span>            :    * into a LogicalPoint, using the flex container's writing mode.
<span class="lineNum">     326 </span>            :    *
<span class="lineNum">     327 </span>            :    *  @arg aMainCoord  The main-axis coordinate -- i.e an offset from the
<span class="lineNum">     328 </span>            :    *                   main-start edge of the flex container's content box.
<span class="lineNum">     329 </span>            :    *  @arg aCrossCoord The cross-axis coordinate -- i.e an offset from the
<span class="lineNum">     330 </span>            :    *                   cross-start edge of the flex container's content box.
<span class="lineNum">     331 </span>            :    *  @arg aContainerMainSize  The main size of flex container's content box.
<span class="lineNum">     332 </span>            :    *  @arg aContainerCrossSize The cross size of flex container's content box.
<span class="lineNum">     333 </span>            :    *  @return A LogicalPoint, with the flex container's writing mode, that
<span class="lineNum">     334 </span>            :    *          represents the same position. The logical coordinates are
<span class="lineNum">     335 </span>            :    *          relative to the flex container's content box.
<a name="336"><span class="lineNum">     336 </span>            :    */</a>
<span class="lineNum">     337 </span>            :   LogicalPoint
<span class="lineNum">     338 </span><span class="lineCov">          1 :   LogicalPointFromFlexRelativePoint(nscoord aMainCoord,</span>
<span class="lineNum">     339 </span>            :                                     nscoord aCrossCoord,
<span class="lineNum">     340 </span>            :                                     nscoord aContainerMainSize,
<span class="lineNum">     341 </span>            :                                     nscoord aContainerCrossSize) const {
<span class="lineNum">     342 </span>            :     nscoord logicalCoordInMainAxis = mIsMainAxisReversed ?
<span class="lineNum">     343 </span><span class="lineCov">          1 :       aContainerMainSize - aMainCoord : aMainCoord;</span>
<span class="lineNum">     344 </span>            :     nscoord logicalCoordInCrossAxis = mIsCrossAxisReversed ?
<span class="lineNum">     345 </span><span class="lineCov">          1 :       aContainerCrossSize - aCrossCoord : aCrossCoord;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     return mIsRowOriented ?
<span class="lineNum">     348 </span>            :       LogicalPoint(mWM, logicalCoordInMainAxis, logicalCoordInCrossAxis) :
<span class="lineNum">     349 </span><span class="lineCov">          1 :       LogicalPoint(mWM, logicalCoordInCrossAxis, logicalCoordInMainAxis);</span>
<span class="lineNum">     350 </span>            :   }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :   /**
<span class="lineNum">     353 </span>            :    * Converts a &quot;flex-relative&quot; size (a main-axis &amp; cross-axis size)
<span class="lineNum">     354 </span>            :    * into a LogicalSize, using the flex container's writing mode.
<span class="lineNum">     355 </span>            :    *
<span class="lineNum">     356 </span>            :    *  @arg aMainSize  The main-axis size.
<span class="lineNum">     357 </span>            :    *  @arg aCrossSize The cross-axis size.
<span class="lineNum">     358 </span>            :    *  @return A LogicalSize, with the flex container's writing mode, that
<a name="359"><span class="lineNum">     359 </span>            :    *          represents the same size.</a>
<span class="lineNum">     360 </span>            :    */
<span class="lineNum">     361 </span><span class="lineCov">          1 :   LogicalSize LogicalSizeFromFlexRelativeSizes(nscoord aMainSize,</span>
<span class="lineNum">     362 </span>            :                                                nscoord aCrossSize) const {
<span class="lineNum">     363 </span>            :     return mIsRowOriented ?
<span class="lineNum">     364 </span>            :       LogicalSize(mWM, aMainSize, aCrossSize) :
<span class="lineNum">     365 </span><span class="lineCov">          1 :       LogicalSize(mWM, aCrossSize, aMainSize);</span>
<span class="lineNum">     366 </span>            :   }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :   // Are my axes reversed with respect to what the author asked for?
<span class="lineNum">     369 </span>            :   // (We may reverse the axes in the FlexboxAxisTracker constructor and set
<span class="lineNum">     370 </span>            :   // this flag, to avoid reflowing our children in bottom-to-top order.)
<span class="lineNum">     371 </span>            :   bool AreAxesInternallyReversed() const
<span class="lineNum">     372 </span>            :   {
<span class="lineNum">     373 </span>            :     return mAreAxesInternallyReversed;
<span class="lineNum">     374 </span>            :   }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : private:
<span class="lineNum">     377 </span>            :   // Delete copy-constructor &amp; reassignment operator, to prevent accidental
<span class="lineNum">     378 </span>            :   // (unnecessary) copying.
<span class="lineNum">     379 </span>            :   FlexboxAxisTracker(const FlexboxAxisTracker&amp;) = delete;
<span class="lineNum">     380 </span>            :   FlexboxAxisTracker&amp; operator=(const FlexboxAxisTracker&amp;) = delete;
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   // Helpers for constructor which determine the orientation of our axes, based
<span class="lineNum">     383 </span>            :   // on legacy box properties (-webkit-box-orient, -webkit-box-direction) or
<span class="lineNum">     384 </span>            :   // modern flexbox properties (flex-direction, flex-wrap) depending on whether
<span class="lineNum">     385 </span>            :   // the flex container is a &quot;legacy box&quot; (as determined by IsLegacyBox).
<span class="lineNum">     386 </span>            :   void InitAxesFromLegacyProps(const nsFlexContainerFrame* aFlexContainer);
<span class="lineNum">     387 </span>            :   void InitAxesFromModernProps(const nsFlexContainerFrame* aFlexContainer);
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   // XXXdholbert [BEGIN DEPRECATED]
<span class="lineNum">     390 </span>            :   AxisOrientationType mMainAxis;
<span class="lineNum">     391 </span>            :   AxisOrientationType mCrossAxis;
<span class="lineNum">     392 </span>            :   // XXXdholbert [END DEPRECATED]
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   const WritingMode mWM; // The flex container's writing mode.
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :   bool mIsRowOriented; // Is our main axis the inline axis?
<span class="lineNum">     397 </span>            :                        // (Are we 'flex-direction:row[-reverse]'?)
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   bool mIsMainAxisReversed; // Is our main axis in the opposite direction
<span class="lineNum">     400 </span>            :                             // as mWM's corresponding axis? (e.g. RTL vs LTR)
<span class="lineNum">     401 </span>            :   bool mIsCrossAxisReversed; // Is our cross axis in the opposite direction
<span class="lineNum">     402 </span>            :                              // as mWM's corresponding axis? (e.g. BTT vs TTB)
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   // Implementation detail -- this indicates whether we've decided to
<span class="lineNum">     405 </span>            :   // transparently reverse our axes &amp; our child ordering, to avoid having
<span class="lineNum">     406 </span>            :   // frames flow from bottom to top in either axis (&amp; to make pagination saner).
<span class="lineNum">     407 </span>            :   bool mAreAxesInternallyReversed;
<span class="lineNum">     408 </span>            : };
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : /**
<span class="lineNum">     411 </span>            :  * Represents a flex item.
<span class="lineNum">     412 </span>            :  * Includes the various pieces of input that the Flexbox Layout Algorithm uses
<span class="lineNum">     413 </span>            :  * to resolve a flexible width.
<span class="lineNum">     414 </span>            :  */
<span class="lineNum">     415 </span><span class="lineCov">          1 : class nsFlexContainerFrame::FlexItem : public LinkedListElement&lt;FlexItem&gt;</span>
<span class="lineNum">     416 </span>            : {
<span class="lineNum">     417 </span>            : public:
<span class="lineNum">     418 </span>            :   // Normal constructor:
<span class="lineNum">     419 </span>            :   FlexItem(ReflowInput&amp; aFlexItemReflowInput,
<span class="lineNum">     420 </span>            :            float aFlexGrow, float aFlexShrink, nscoord aMainBaseSize,
<span class="lineNum">     421 </span>            :            nscoord aMainMinSize, nscoord aMainMaxSize,
<span class="lineNum">     422 </span>            :            nscoord aTentativeCrossSize,
<span class="lineNum">     423 </span>            :            nscoord aCrossMinSize, nscoord aCrossMaxSize,
<span class="lineNum">     424 </span>            :            const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :   // Simplified constructor, to be used only for generating &quot;struts&quot;:
<span class="lineNum">     427 </span>            :   // (NOTE: This &quot;strut&quot; constructor uses the *container's* writing mode, which
<span class="lineNum">     428 </span>            :   // we'll use on this FlexItem instead of the child frame's real writing mode.
<span class="lineNum">     429 </span>            :   // This is fine - it doesn't matter what writing mode we use for a
<span class="lineNum">     430 </span>            :   // strut, since it won't render any content and we already know its size.)
<span class="lineNum">     431 </span>            :   FlexItem(nsIFrame* aChildFrame, nscoord aCrossSize, WritingMode aContainerWM);
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :   // Accessors
<span class="lineNum">     434 </span>            :   nsIFrame* Frame() const          { return mFrame; }
<span class="lineNum">     435 </span>            :   nscoord GetFlexBaseSize() const  { return mFlexBaseSize; }
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   nscoord GetMainMinSize() const   {
<span class="lineNum">     438 </span>            :     MOZ_ASSERT(!mNeedsMinSizeAutoResolution,
<span class="lineNum">     439 </span>            :                &quot;Someone's using an unresolved 'auto' main min-size&quot;);
<span class="lineNum">     440 </span>            :     return mMainMinSize;
<span class="lineNum">     441 </span>            :   }
<span class="lineNum">     442 </span>            :   nscoord GetMainMaxSize() const   { return mMainMaxSize; }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   // Note: These return the main-axis position and size of our *content box*.
<span class="lineNum">     445 </span>            :   nscoord GetMainSize() const      { return mMainSize; }
<span class="lineNum">     446 </span>            :   nscoord GetMainPosition() const  { return mMainPosn; }
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :   nscoord GetCrossMinSize() const  { return mCrossMinSize; }
<span class="lineNum">     449 </span>            :   nscoord GetCrossMaxSize() const  { return mCrossMaxSize; }
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :   // Note: These return the cross-axis position and size of our *content box*.
<span class="lineNum">     452 </span>            :   nscoord GetCrossSize() const     { return mCrossSize;  }
<a name="453"><span class="lineNum">     453 </span>            :   nscoord GetCrossPosition() const { return mCrossPosn; }</a>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineCov">          1 :   nscoord ResolvedAscent(bool aUseFirstBaseline) const {</span>
<span class="lineNum">     456 </span><span class="lineCov">          1 :     if (mAscent == ReflowOutput::ASK_FOR_BASELINE) {</span>
<span class="lineNum">     457 </span>            :       // XXXdholbert We should probably be using the *container's* writing-mode
<span class="lineNum">     458 </span>            :       // here, instead of the item's -- though it doesn't much matter right
<span class="lineNum">     459 </span>            :       // now, because all of the baseline-handling code here essentially
<span class="lineNum">     460 </span>            :       // assumes that the container &amp; items have the same writing-mode. This
<span class="lineNum">     461 </span>            :       // will matter more (&amp; can be expanded/tested) once we officially support
<span class="lineNum">     462 </span>            :       // logical directions &amp; vertical writing-modes in flexbox, in bug 1079155
<span class="lineNum">     463 </span>            :       // or a dependency.
<span class="lineNum">     464 </span>            :       // Use GetFirstLineBaseline() or GetLastLineBaseline() as appropriate,
<span class="lineNum">     465 </span>            :       // or just GetLogicalBaseline() if that fails.
<span class="lineNum">     466 </span>            :       bool found = aUseFirstBaseline ?
<span class="lineNum">     467 </span><span class="lineCov">          1 :         nsLayoutUtils::GetFirstLineBaseline(mWM, mFrame, &amp;mAscent) :</span>
<span class="lineNum">     468 </span><span class="lineCov">          1 :         nsLayoutUtils::GetLastLineBaseline(mWM, mFrame, &amp;mAscent);</span>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">          1 :       if (!found) {</span>
<span class="lineNum">     471 </span>            :         mAscent = mFrame-&gt;SynthesizeBaselineBOffsetFromBorderBox(mWM,
<span class="lineNum">     472 </span><span class="lineCov">          1 :                             BaselineSharingGroup::eFirst);</span>
<span class="lineNum">     473 </span>            :       }
<span class="lineNum">     474 </span>            :     }
<span class="lineNum">     475 </span><span class="lineCov">          1 :     return mAscent;</span>
<span class="lineNum">     476 </span>            :   }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   // Convenience methods to compute the main &amp; cross size of our *margin-box*.
<a name="479"><span class="lineNum">     479 </span>            :   // The caller is responsible for telling us the right axis, so that we can</a>
<span class="lineNum">     480 </span>            :   // pull out the appropriate components of our margin/border/padding structs.
<span class="lineNum">     481 </span><span class="lineCov">          1 :   nscoord GetOuterMainSize(AxisOrientationType aMainAxis) const</span>
<span class="lineNum">     482 </span>            :   {
<span class="lineNum">     483 </span><span class="lineCov">          1 :     return mMainSize + GetMarginBorderPaddingSizeInAxis(aMainAxis);</span>
<a name="484"><span class="lineNum">     484 </span>            :   }</a>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">          1 :   nscoord GetOuterCrossSize(AxisOrientationType aCrossAxis) const</span>
<span class="lineNum">     487 </span>            :   {
<span class="lineNum">     488 </span><span class="lineCov">          1 :     return mCrossSize + GetMarginBorderPaddingSizeInAxis(aCrossAxis);</span>
<span class="lineNum">     489 </span>            :   }
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // Returns the distance between this FlexItem's baseline and the cross-start
<span class="lineNum">     492 </span>            :   // edge of its margin-box. Used in baseline alignment.
<span class="lineNum">     493 </span>            :   // (This function needs to be told which edge we're measuring the baseline
<span class="lineNum">     494 </span>            :   // from, so that it can look up the appropriate components from mMargin.)
<span class="lineNum">     495 </span>            :   nscoord GetBaselineOffsetFromOuterCrossEdge(
<span class="lineNum">     496 </span>            :     AxisEdgeType aEdge,
<span class="lineNum">     497 </span>            :     const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">     498 </span>            :     bool aUseFirstLineBaseline) const;
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   float GetShareOfWeightSoFar() const { return mShareOfWeightSoFar; }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :   bool IsFrozen() const            { return mIsFrozen; }
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :   bool HadMinViolation() const     { return mHadMinViolation; }
<span class="lineNum">     505 </span>            :   bool HadMaxViolation() const     { return mHadMaxViolation; }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :   // Indicates whether this item received a preliminary &quot;measuring&quot; reflow
<span class="lineNum">     508 </span>            :   // before its actual reflow.
<span class="lineNum">     509 </span>            :   bool HadMeasuringReflow() const  { return mHadMeasuringReflow; }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :   // Indicates whether this item's cross-size has been stretched (from having
<span class="lineNum">     512 </span>            :   // &quot;align-self: stretch&quot; with an auto cross-size and no auto margins in the
<span class="lineNum">     513 </span>            :   // cross axis).
<span class="lineNum">     514 </span>            :   bool IsStretched() const         { return mIsStretched; }
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :   // Indicates whether we need to resolve an 'auto' value for the main-axis
<span class="lineNum">     517 </span>            :   // min-[width|height] property.
<span class="lineNum">     518 </span>            :   bool NeedsMinSizeAutoResolution() const
<span class="lineNum">     519 </span>            :     { return mNeedsMinSizeAutoResolution; }
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :   // Indicates whether this item is a &quot;strut&quot; left behind by an element with
<span class="lineNum">     522 </span>            :   // visibility:collapse.
<span class="lineNum">     523 </span>            :   bool IsStrut() const             { return mIsStrut; }
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            :   WritingMode GetWritingMode() const { return mWM; }
<span class="lineNum">     526 </span>            :   uint8_t GetAlignSelf() const     { return mAlignSelf; }
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :   // Returns the flex factor (flex-grow or flex-shrink), depending on
<span class="lineNum">     529 </span>            :   // 'aIsUsingFlexGrow'.
<span class="lineNum">     530 </span>            :   //
<span class="lineNum">     531 </span>            :   // Asserts fatally if called on a frozen item (since frozen items are not
<span class="lineNum">     532 </span>            :   // flexible).
<span class="lineNum">     533 </span>            :   float GetFlexFactor(bool aIsUsingFlexGrow)
<span class="lineNum">     534 </span>            :   {
<span class="lineNum">     535 </span>            :     MOZ_ASSERT(!IsFrozen(), &quot;shouldn't need flex factor after item is frozen&quot;);
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineCov">          1 :     return aIsUsingFlexGrow ? mFlexGrow : mFlexShrink;</span>
<span class="lineNum">     538 </span>            :   }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   // Returns the weight that we should use in the &quot;resolving flexible lengths&quot;
<span class="lineNum">     541 </span>            :   // algorithm.  If we're using the flex grow factor, we just return that;
<span class="lineNum">     542 </span>            :   // otherwise, we return the &quot;scaled flex shrink factor&quot; (scaled by our flex
<span class="lineNum">     543 </span>            :   // base size, so that when both large and small items are shrinking, the large
<span class="lineNum">     544 </span>            :   // items shrink more).
<span class="lineNum">     545 </span>            :   //
<span class="lineNum">     546 </span>            :   // I'm calling this a &quot;weight&quot; instead of a &quot;[scaled] flex-[grow|shrink]
<span class="lineNum">     547 </span>            :   // factor&quot;, to more clearly distinguish it from the actual flex-grow &amp;
<span class="lineNum">     548 </span>            :   // flex-shrink factors.
<span class="lineNum">     549 </span>            :   //
<a name="550"><span class="lineNum">     550 </span>            :   // Asserts fatally if called on a frozen item (since frozen items are not</a>
<span class="lineNum">     551 </span>            :   // flexible).
<span class="lineNum">     552 </span><span class="lineCov">          1 :   float GetWeight(bool aIsUsingFlexGrow)</span>
<span class="lineNum">     553 </span>            :   {
<span class="lineNum">     554 </span>            :     MOZ_ASSERT(!IsFrozen(), &quot;shouldn't need weight after item is frozen&quot;);
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineCov">          1 :     if (aIsUsingFlexGrow) {</span>
<span class="lineNum">     557 </span><span class="lineCov">          1 :       return mFlexGrow;</span>
<span class="lineNum">     558 </span>            :     }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :     // We're using flex-shrink --&gt; return mFlexShrink * mFlexBaseSize
<span class="lineNum">     561 </span><span class="lineCov">          1 :     if (mFlexBaseSize == 0) {</span>
<span class="lineNum">     562 </span>            :       // Special-case for mFlexBaseSize == 0 -- we have no room to shrink, so
<span class="lineNum">     563 </span>            :       // regardless of mFlexShrink, we should just return 0.
<span class="lineNum">     564 </span>            :       // (This is really a special-case for when mFlexShrink is infinity, to
<span class="lineNum">     565 </span>            :       // avoid performing mFlexShrink * mFlexBaseSize = inf * 0 = undefined.)
<span class="lineNum">     566 </span>            :       return 0.0f;
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span><span class="lineCov">          1 :     return mFlexShrink * mFlexBaseSize;</span>
<span class="lineNum">     569 </span>            :   }
<a name="570"><span class="lineNum">     570 </span>            : </a>
<span class="lineNum">     571 </span><span class="lineCov">          1 :   const nsSize&amp; IntrinsicRatio() const { return mIntrinsicRatio; }</span>
<span class="lineNum">     572 </span><span class="lineCov">          1 :   bool HasIntrinsicRatio() const { return mIntrinsicRatio != nsSize(); }</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :   // Getters for margin:
<span class="lineNum">     575 </span>            :   // ===================
<span class="lineNum">     576 </span><span class="lineCov">          1 :   const nsMargin&amp; GetMargin() const { return mMargin; }</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   // Returns the margin component for a given mozilla::Side
<span class="lineNum">     579 </span>            :   nscoord GetMarginComponentForSide(mozilla::Side aSide) const
<span class="lineNum">     580 </span><span class="lineCov">          1 :   { return mMargin.Side(aSide); }</span>
<a name="581"><span class="lineNum">     581 </span>            : </a>
<span class="lineNum">     582 </span>            :   // Returns the total space occupied by this item's margins in the given axis
<span class="lineNum">     583 </span><span class="lineCov">          1 :   nscoord GetMarginSizeInAxis(AxisOrientationType aAxis) const</span>
<span class="lineNum">     584 </span>            :   {
<span class="lineNum">     585 </span><span class="lineCov">          1 :     mozilla::Side startSide = kAxisOrientationToSidesMap[aAxis][eAxisEdge_Start];</span>
<span class="lineNum">     586 </span><span class="lineCov">          1 :     mozilla::Side endSide = kAxisOrientationToSidesMap[aAxis][eAxisEdge_End];</span>
<span class="lineNum">     587 </span><span class="lineCov">          1 :     return GetMarginComponentForSide(startSide) +</span>
<span class="lineNum">     588 </span><span class="lineCov">          1 :       GetMarginComponentForSide(endSide);</span>
<span class="lineNum">     589 </span>            :   }
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   // Getters for border/padding
<span class="lineNum">     592 </span>            :   // ==========================
<span class="lineNum">     593 </span>            :   const nsMargin&amp; GetBorderPadding() const { return mBorderPadding; }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   // Returns the border+padding component for a given mozilla::Side
<span class="lineNum">     596 </span>            :   nscoord GetBorderPaddingComponentForSide(mozilla::Side aSide) const
<span class="lineNum">     597 </span><span class="lineCov">          1 :   { return mBorderPadding.Side(aSide); }</span>
<span class="lineNum">     598 </span>            : 
<a name="599"><span class="lineNum">     599 </span>            :   // Returns the total space occupied by this item's borders and padding in</a>
<span class="lineNum">     600 </span>            :   // the given axis
<span class="lineNum">     601 </span><span class="lineCov">          1 :   nscoord GetBorderPaddingSizeInAxis(AxisOrientationType aAxis) const</span>
<span class="lineNum">     602 </span>            :   {
<span class="lineNum">     603 </span><span class="lineCov">          1 :     mozilla::Side startSide = kAxisOrientationToSidesMap[aAxis][eAxisEdge_Start];</span>
<span class="lineNum">     604 </span><span class="lineCov">          1 :     mozilla::Side endSide = kAxisOrientationToSidesMap[aAxis][eAxisEdge_End];</span>
<span class="lineNum">     605 </span><span class="lineCov">          1 :     return GetBorderPaddingComponentForSide(startSide) +</span>
<span class="lineNum">     606 </span><span class="lineCov">          1 :       GetBorderPaddingComponentForSide(endSide);</span>
<span class="lineNum">     607 </span>            :   }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :   // Getter for combined margin/border/padding
<span class="lineNum">     610 </span>            :   // =========================================
<a name="611"><span class="lineNum">     611 </span>            :   // Returns the total space occupied by this item's margins, borders and</a>
<span class="lineNum">     612 </span>            :   // padding in the given axis
<span class="lineNum">     613 </span><span class="lineCov">          1 :   nscoord GetMarginBorderPaddingSizeInAxis(AxisOrientationType aAxis) const</span>
<span class="lineNum">     614 </span>            :   {
<span class="lineNum">     615 </span><span class="lineCov">          1 :     return GetMarginSizeInAxis(aAxis) + GetBorderPaddingSizeInAxis(aAxis);</span>
<span class="lineNum">     616 </span>            :   }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :   // Setters
<span class="lineNum">     619 </span>            :   // =======
<a name="620"><span class="lineNum">     620 </span>            :   // Helper to set the resolved value of min-[width|height]:auto for the main</a>
<span class="lineNum">     621 </span>            :   // axis. (Should only be used if NeedsMinSizeAutoResolution() returns true.)
<span class="lineNum">     622 </span><span class="lineCov">          1 :   void UpdateMainMinSize(nscoord aNewMinSize)</span>
<span class="lineNum">     623 </span>            :   {
<span class="lineNum">     624 </span>            :     NS_ASSERTION(aNewMinSize &gt;= 0,
<span class="lineNum">     625 </span>            :                  &quot;How did we end up with a negative min-size?&quot;);
<span class="lineNum">     626 </span>            :     MOZ_ASSERT(mMainMaxSize &gt;= aNewMinSize,
<span class="lineNum">     627 </span>            :                &quot;Should only use this function for resolving min-size:auto, &quot;
<span class="lineNum">     628 </span>            :                &quot;and main max-size should be an upper-bound for resolved val&quot;);
<span class="lineNum">     629 </span>            :     MOZ_ASSERT(mNeedsMinSizeAutoResolution &amp;&amp;
<span class="lineNum">     630 </span>            :                (mMainMinSize == 0 || mFrame-&gt;IsThemed(mFrame-&gt;StyleDisplay())),
<span class="lineNum">     631 </span>            :                &quot;Should only use this function for resolving min-size:auto, &quot;
<span class="lineNum">     632 </span>            :                &quot;so we shouldn't already have a nonzero min-size established &quot;
<span class="lineNum">     633 </span>            :                &quot;(unless it's a themed-widget-imposed minimum size)&quot;);
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineCov">          1 :     if (aNewMinSize &gt; mMainMinSize) {</span>
<span class="lineNum">     636 </span><span class="lineCov">          1 :       mMainMinSize = aNewMinSize;</span>
<span class="lineNum">     637 </span>            :       // Also clamp main-size to be &gt;= new min-size:
<span class="lineNum">     638 </span><span class="lineCov">          1 :       mMainSize = std::max(mMainSize, aNewMinSize);</span>
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span><span class="lineCov">          1 :     mNeedsMinSizeAutoResolution = false;</span>
<span class="lineNum">     641 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   // This sets our flex base size, and then sets our main size to the
<a name="644"><span class="lineNum">     644 </span>            :   // resulting &quot;hypothetical main size&quot; (the base size clamped to our</a>
<span class="lineNum">     645 </span>            :   // main-axis [min,max] sizing constraints).
<span class="lineNum">     646 </span><span class="lineCov">          1 :   void SetFlexBaseSizeAndMainSize(nscoord aNewFlexBaseSize)</span>
<span class="lineNum">     647 </span>            :   {
<span class="lineNum">     648 </span>            :     MOZ_ASSERT(!mIsFrozen || mFlexBaseSize == NS_INTRINSICSIZE,
<span class="lineNum">     649 </span>            :                &quot;flex base size shouldn't change after we're frozen &quot;
<span class="lineNum">     650 </span>            :                &quot;(unless we're just resolving an intrinsic size)&quot;);
<span class="lineNum">     651 </span><span class="lineCov">          1 :     mFlexBaseSize = aNewFlexBaseSize;</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :     // Before we've resolved flexible lengths, we keep mMainSize set to
<span class="lineNum">     654 </span>            :     // the 'hypothetical main size', which is the flex base size, clamped
<span class="lineNum">     655 </span>            :     // to the [min,max] range:
<span class="lineNum">     656 </span><span class="lineCov">          1 :     mMainSize = NS_CSS_MINMAX(mFlexBaseSize, mMainMinSize, mMainMaxSize);</span>
<span class="lineNum">     657 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   // Setters used while we're resolving flexible lengths
<span class="lineNum">     660 </span>            :   // ---------------------------------------------------
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   // Sets the main-size of our flex item's content-box.
<span class="lineNum">     663 </span>            :   void SetMainSize(nscoord aNewMainSize)
<span class="lineNum">     664 </span>            :   {
<span class="lineNum">     665 </span>            :     MOZ_ASSERT(!mIsFrozen, &quot;main size shouldn't change after we're frozen&quot;);
<span class="lineNum">     666 </span><span class="lineCov">          1 :     mMainSize = aNewMainSize;</span>
<span class="lineNum">     667 </span>            :   }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :   void SetShareOfWeightSoFar(float aNewShare)
<span class="lineNum">     670 </span>            :   {
<span class="lineNum">     671 </span>            :     MOZ_ASSERT(!mIsFrozen || aNewShare == 0.0f,
<span class="lineNum">     672 </span>            :                &quot;shouldn't be giving this item any share of the weight &quot;
<span class="lineNum">     673 </span>            :                &quot;after it's frozen&quot;);
<span class="lineNum">     674 </span><span class="lineCov">          1 :     mShareOfWeightSoFar = aNewShare;</span>
<span class="lineNum">     675 </span>            :   }
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineCov">          1 :   void Freeze() { mIsFrozen = true; }</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :   void SetHadMinViolation()
<span class="lineNum">     680 </span>            :   {
<span class="lineNum">     681 </span>            :     MOZ_ASSERT(!mIsFrozen,
<span class="lineNum">     682 </span>            :                &quot;shouldn't be changing main size &amp; having violations &quot;
<span class="lineNum">     683 </span>            :                &quot;after we're frozen&quot;);
<span class="lineNum">     684 </span><span class="lineCov">          1 :     mHadMinViolation = true;</span>
<span class="lineNum">     685 </span>            :   }
<span class="lineNum">     686 </span>            :   void SetHadMaxViolation()
<span class="lineNum">     687 </span>            :   {
<span class="lineNum">     688 </span>            :     MOZ_ASSERT(!mIsFrozen,
<span class="lineNum">     689 </span>            :                &quot;shouldn't be changing main size &amp; having violations &quot;
<span class="lineNum">     690 </span>            :                &quot;after we're frozen&quot;);
<span class="lineNum">     691 </span><span class="lineCov">          1 :     mHadMaxViolation = true;</span>
<span class="lineNum">     692 </span>            :   }
<span class="lineNum">     693 </span>            :   void ClearViolationFlags()
<span class="lineNum">     694 </span><span class="lineCov">          1 :   { mHadMinViolation = mHadMaxViolation = false; }</span>
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :   // Setters for values that are determined after we've resolved our main size
<span class="lineNum">     697 </span>            :   // -------------------------------------------------------------------------
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :   // Sets the main-axis position of our flex item's content-box.
<span class="lineNum">     700 </span>            :   // (This is the distance between the main-start edge of the flex container
<span class="lineNum">     701 </span>            :   // and the main-start edge of the flex item's content-box.)
<span class="lineNum">     702 </span>            :   void SetMainPosition(nscoord aPosn) {
<span class="lineNum">     703 </span>            :     MOZ_ASSERT(mIsFrozen, &quot;main size should be resolved before this&quot;);
<span class="lineNum">     704 </span><span class="lineCov">          1 :     mMainPosn  = aPosn;</span>
<span class="lineNum">     705 </span>            :   }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :   // Sets the cross-size of our flex item's content-box.
<span class="lineNum">     708 </span>            :   void SetCrossSize(nscoord aCrossSize) {
<span class="lineNum">     709 </span>            :     MOZ_ASSERT(!mIsStretched,
<span class="lineNum">     710 </span>            :                &quot;Cross size shouldn't be modified after it's been stretched&quot;);
<span class="lineNum">     711 </span><span class="lineCov">          1 :     mCrossSize = aCrossSize;</span>
<span class="lineNum">     712 </span>            :   }
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :   // Sets the cross-axis position of our flex item's content-box.
<span class="lineNum">     715 </span>            :   // (This is the distance between the cross-start edge of the flex container
<span class="lineNum">     716 </span>            :   // and the cross-start edge of the flex item.)
<span class="lineNum">     717 </span>            :   void SetCrossPosition(nscoord aPosn) {
<span class="lineNum">     718 </span>            :     MOZ_ASSERT(mIsFrozen, &quot;main size should be resolved before this&quot;);
<span class="lineNum">     719 </span><span class="lineCov">          1 :     mCrossPosn = aPosn;</span>
<span class="lineNum">     720 </span>            :   }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :   // After a FlexItem has had a reflow, this method can be used to cache its
<span class="lineNum">     723 </span>            :   // (possibly-unresolved) ascent, in case it's needed later for
<span class="lineNum">     724 </span>            :   // baseline-alignment or to establish the container's baseline.
<span class="lineNum">     725 </span>            :   // (NOTE: This can be marked 'const' even though it's modifying mAscent,
<span class="lineNum">     726 </span>            :   // because mAscent is mutable. It's nice for this to be 'const', because it
<span class="lineNum">     727 </span>            :   // means our final reflow can iterate over const FlexItem pointers, and we
<span class="lineNum">     728 </span>            :   // can be sure it's not modifying those FlexItems, except via this method.)
<span class="lineNum">     729 </span>            :   void SetAscent(nscoord aAscent) const {
<span class="lineNum">     730 </span><span class="lineCov">          1 :     mAscent = aAscent; // NOTE: this may be ASK_FOR_BASELINE</span>
<span class="lineNum">     731 </span>            :   }
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :   void SetHadMeasuringReflow() {
<span class="lineNum">     734 </span><span class="lineCov">          1 :     mHadMeasuringReflow = true;</span>
<span class="lineNum">     735 </span>            :   }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   void SetIsStretched() {
<span class="lineNum">     738 </span>            :     MOZ_ASSERT(mIsFrozen, &quot;main size should be resolved before this&quot;);
<span class="lineNum">     739 </span>            :     mIsStretched = true;
<span class="lineNum">     740 </span>            :   }
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :   // Setter for margin components (for resolving &quot;auto&quot; margins)
<span class="lineNum">     743 </span>            :   void SetMarginComponentForSide(mozilla::Side aSide, nscoord aLength)
<span class="lineNum">     744 </span>            :   {
<span class="lineNum">     745 </span>            :     MOZ_ASSERT(mIsFrozen, &quot;main size should be resolved before this&quot;);
<span class="lineNum">     746 </span><span class="lineCov">          1 :     mMargin.Side(aSide) = aLength;</span>
<span class="lineNum">     747 </span>            :   }
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            :   void ResolveStretchedCrossSize(nscoord aLineCrossSize,
<span class="lineNum">     750 </span>            :                                  const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :   uint32_t GetNumAutoMarginsInAxis(AxisOrientationType aAxis) const;
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :   // Once the main size has been resolved, should we bother doing layout to
<span class="lineNum">     755 </span>            :   // establish the cross size?
<span class="lineNum">     756 </span>            :   bool CanMainSizeInfluenceCrossSize(const FlexboxAxisTracker&amp; aAxisTracker) const;
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            : protected:
<span class="lineNum">     759 </span>            :   // Helper called by the constructor, to set mNeedsMinSizeAutoResolution:
<span class="lineNum">     760 </span>            :   void CheckForMinSizeAuto(const ReflowInput&amp; aFlexItemReflowInput,
<span class="lineNum">     761 </span>            :                            const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   // Our frame:
<span class="lineNum">     764 </span>            :   nsIFrame* const mFrame;
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :   // Values that we already know in constructor: (and are hence mostly 'const')
<span class="lineNum">     767 </span>            :   const float mFlexGrow;
<span class="lineNum">     768 </span>            :   const float mFlexShrink;
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :   const nsSize mIntrinsicRatio;
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :   const nsMargin mBorderPadding;
<span class="lineNum">     773 </span>            :   nsMargin mMargin; // non-const because we need to resolve auto margins
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :   // These are non-const so that we can lazily update them with the item's
<span class="lineNum">     776 </span>            :   // intrinsic size (obtained via a &quot;measuring&quot; reflow), when necessary.
<span class="lineNum">     777 </span>            :   // (e.g. for &quot;flex-basis:auto;height:auto&quot; &amp; &quot;min-height:auto&quot;)
<span class="lineNum">     778 </span>            :   nscoord mFlexBaseSize;
<span class="lineNum">     779 </span>            :   nscoord mMainMinSize;
<span class="lineNum">     780 </span>            :   nscoord mMainMaxSize;
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            :   const nscoord mCrossMinSize;
<span class="lineNum">     783 </span>            :   const nscoord mCrossMaxSize;
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :   // Values that we compute after constructor:
<span class="lineNum">     786 </span>            :   nscoord mMainSize;
<span class="lineNum">     787 </span>            :   nscoord mMainPosn;
<span class="lineNum">     788 </span>            :   nscoord mCrossSize;
<span class="lineNum">     789 </span>            :   nscoord mCrossPosn;
<span class="lineNum">     790 </span>            :   mutable nscoord mAscent; // Mutable b/c it's set &amp; resolved lazily, sometimes
<span class="lineNum">     791 </span>            :                            // via const pointer. See comment above SetAscent().
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :   // Temporary state, while we're resolving flexible widths (for our main size)
<span class="lineNum">     794 </span>            :   // XXXdholbert To save space, we could use a union to make these variables
<span class="lineNum">     795 </span>            :   // overlay the same memory as some other member vars that aren't touched
<span class="lineNum">     796 </span>            :   // until after main-size has been resolved. In particular, these could share
<span class="lineNum">     797 </span>            :   // memory with mMainPosn through mAscent, and mIsStretched.
<span class="lineNum">     798 </span>            :   float mShareOfWeightSoFar;
<span class="lineNum">     799 </span>            :   bool mIsFrozen;
<span class="lineNum">     800 </span>            :   bool mHadMinViolation;
<span class="lineNum">     801 </span>            :   bool mHadMaxViolation;
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :   // Misc:
<span class="lineNum">     804 </span>            :   bool mHadMeasuringReflow; // Did this item get a preliminary reflow,
<span class="lineNum">     805 </span>            :                             // to measure its desired height?
<span class="lineNum">     806 </span>            :   bool mIsStretched; // See IsStretched() documentation
<span class="lineNum">     807 </span>            :   bool mIsStrut;     // Is this item a &quot;strut&quot; left behind by an element
<span class="lineNum">     808 </span>            :                      // with visibility:collapse?
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :   // Does this item need to resolve a min-[width|height]:auto (in main-axis).
<span class="lineNum">     811 </span>            :   bool mNeedsMinSizeAutoResolution;
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :   const WritingMode mWM; // The flex item's writing mode.
<span class="lineNum">     814 </span>            :   uint8_t mAlignSelf; // My &quot;align-self&quot; computed value (with &quot;auto&quot;
<span class="lineNum">     815 </span>            :                       // swapped out for parent&quot;s &quot;align-items&quot; value,
<span class="lineNum">     816 </span>            :                       // in our constructor).
<span class="lineNum">     817 </span>            : };
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            : /**
<span class="lineNum">     820 </span>            :  * Represents a single flex line in a flex container.
<a name="821"><span class="lineNum">     821 </span>            :  * Manages a linked list of the FlexItems that are in the line.</a>
<span class="lineNum">     822 </span>            :  */
<span class="lineNum">     823 </span><span class="lineCov">          1 : class nsFlexContainerFrame::FlexLine : public LinkedListElement&lt;FlexLine&gt;</span>
<a name="824"><span class="lineNum">     824 </span>            : {</a>
<span class="lineNum">     825 </span>            : public:
<span class="lineNum">     826 </span><span class="lineCov">          1 :   FlexLine()</span>
<span class="lineNum">     827 </span>            :   : mNumItems(0),
<span class="lineNum">     828 </span>            :     mNumFrozenItems(0),
<span class="lineNum">     829 </span>            :     mTotalInnerHypotheticalMainSize(0),
<span class="lineNum">     830 </span>            :     mTotalOuterHypotheticalMainSize(0),
<span class="lineNum">     831 </span>            :     mLineCrossSize(0),
<span class="lineNum">     832 </span>            :     mFirstBaselineOffset(nscoord_MIN),
<span class="lineNum">     833 </span><span class="lineCov">          1 :     mLastBaselineOffset(nscoord_MIN)</span>
<span class="lineNum">     834 </span><span class="lineCov">          1 :   {}</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :   // Returns the sum of our FlexItems' outer hypothetical main sizes.
<span class="lineNum">     837 </span>            :   // (&quot;outer&quot; = margin-box, and &quot;hypothetical&quot; = before flexing)
<span class="lineNum">     838 </span>            :   nscoord GetTotalOuterHypotheticalMainSize() const {
<span class="lineNum">     839 </span>            :     return mTotalOuterHypotheticalMainSize;
<span class="lineNum">     840 </span>            :   }
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :   // Accessors for our FlexItems &amp; information about them:
<span class="lineNum">     843 </span>            :   FlexItem* GetFirstItem()
<span class="lineNum">     844 </span>            :   {
<span class="lineNum">     845 </span>            :     MOZ_ASSERT(mItems.isEmpty() == (mNumItems == 0),
<span class="lineNum">     846 </span>            :                &quot;mNumItems bookkeeping is off&quot;);
<span class="lineNum">     847 </span><span class="lineCov">          1 :     return mItems.getFirst();</span>
<span class="lineNum">     848 </span>            :   }
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :   const FlexItem* GetFirstItem() const
<span class="lineNum">     851 </span>            :   {
<span class="lineNum">     852 </span>            :     MOZ_ASSERT(mItems.isEmpty() == (mNumItems == 0),
<span class="lineNum">     853 </span>            :                &quot;mNumItems bookkeeping is off&quot;);
<span class="lineNum">     854 </span><span class="lineCov">          1 :     return mItems.getFirst();</span>
<span class="lineNum">     855 </span>            :   }
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   FlexItem* GetLastItem()
<span class="lineNum">     858 </span>            :   {
<span class="lineNum">     859 </span>            :     MOZ_ASSERT(mItems.isEmpty() == (mNumItems == 0),
<span class="lineNum">     860 </span>            :                &quot;mNumItems bookkeeping is off&quot;);
<span class="lineNum">     861 </span><span class="lineCov">          1 :     return mItems.getLast();</span>
<span class="lineNum">     862 </span>            :   }
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :   const FlexItem* GetLastItem() const
<span class="lineNum">     865 </span>            :   {
<span class="lineNum">     866 </span>            :     MOZ_ASSERT(mItems.isEmpty() == (mNumItems == 0),
<span class="lineNum">     867 </span>            :                &quot;mNumItems bookkeeping is off&quot;);
<span class="lineNum">     868 </span>            :     return mItems.getLast();
<span class="lineNum">     869 </span>            :   }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :   bool IsEmpty() const
<span class="lineNum">     872 </span>            :   {
<span class="lineNum">     873 </span>            :     MOZ_ASSERT(mItems.isEmpty() == (mNumItems == 0),
<span class="lineNum">     874 </span>            :                &quot;mNumItems bookkeeping is off&quot;);
<span class="lineNum">     875 </span><span class="lineCov">          1 :     return mItems.isEmpty();</span>
<span class="lineNum">     876 </span>            :   }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   uint32_t NumItems() const
<span class="lineNum">     879 </span>            :   {
<span class="lineNum">     880 </span>            :     MOZ_ASSERT(mItems.isEmpty() == (mNumItems == 0),
<span class="lineNum">     881 </span>            :                &quot;mNumItems bookkeeping is off&quot;);
<span class="lineNum">     882 </span>            :     return mNumItems;
<span class="lineNum">     883 </span>            :   }
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   // Adds the given FlexItem to our list of items (at the front or back
<span class="lineNum">     886 </span>            :   // depending on aShouldInsertAtFront), and adds its hypothetical
<a name="887"><span class="lineNum">     887 </span>            :   // outer &amp; inner main sizes to our totals. Use this method instead of</a>
<span class="lineNum">     888 </span>            :   // directly modifying the item list, so that our bookkeeping remains correct.
<span class="lineNum">     889 </span><span class="lineCov">          1 :   void AddItem(FlexItem* aItem,</span>
<span class="lineNum">     890 </span>            :                bool aShouldInsertAtFront,
<span class="lineNum">     891 </span>            :                nscoord aItemInnerHypotheticalMainSize,
<span class="lineNum">     892 </span>            :                nscoord aItemOuterHypotheticalMainSize)
<span class="lineNum">     893 </span>            :   {
<span class="lineNum">     894 </span><span class="lineCov">          1 :     if (aShouldInsertAtFront) {</span>
<span class="lineNum">     895 </span><span class="lineCov">          1 :       mItems.insertFront(aItem);</span>
<span class="lineNum">     896 </span>            :     } else {
<span class="lineNum">     897 </span><span class="lineCov">          1 :       mItems.insertBack(aItem);</span>
<span class="lineNum">     898 </span>            :     }
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :     // Update our various bookkeeping member-vars:
<span class="lineNum">     901 </span><span class="lineCov">          1 :     mNumItems++;</span>
<span class="lineNum">     902 </span><span class="lineCov">          1 :     if (aItem-&gt;IsFrozen()) {</span>
<span class="lineNum">     903 </span><span class="lineCov">          1 :       mNumFrozenItems++;</span>
<span class="lineNum">     904 </span>            :     }
<span class="lineNum">     905 </span><span class="lineCov">          1 :     mTotalInnerHypotheticalMainSize += aItemInnerHypotheticalMainSize;</span>
<span class="lineNum">     906 </span><span class="lineCov">          1 :     mTotalOuterHypotheticalMainSize += aItemOuterHypotheticalMainSize;</span>
<span class="lineNum">     907 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :   // Computes the cross-size and baseline position of this FlexLine, based on
<span class="lineNum">     910 </span>            :   // its FlexItems.
<span class="lineNum">     911 </span>            :   void ComputeCrossSizeAndBaseline(const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :   // Returns the cross-size of this line.
<span class="lineNum">     914 </span>            :   nscoord GetLineCrossSize() const { return mLineCrossSize; }
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :   // Setter for line cross-size -- needed for cases where the flex container
<span class="lineNum">     917 </span>            :   // imposes a cross-size on the line. (e.g. for single-line flexbox, or for
<span class="lineNum">     918 </span>            :   // multi-line flexbox with 'align-content: stretch')
<span class="lineNum">     919 </span>            :   void SetLineCrossSize(nscoord aLineCrossSize) {
<span class="lineNum">     920 </span><span class="lineCov">          1 :     mLineCrossSize = aLineCrossSize;</span>
<span class="lineNum">     921 </span>            :   }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :   /**
<span class="lineNum">     924 </span>            :    * Returns the offset within this line where any baseline-aligned FlexItems
<span class="lineNum">     925 </span>            :    * should place their baseline. Usually, this represents a distance from the
<span class="lineNum">     926 </span>            :    * line's cross-start edge, but if we're internally reversing the axes (see
<span class="lineNum">     927 </span>            :    * AreAxesInternallyReversed()), this instead represents the distance from
<span class="lineNum">     928 </span>            :    * its cross-end edge.
<span class="lineNum">     929 </span>            :    *
<span class="lineNum">     930 </span>            :    * If there are no baseline-aligned FlexItems, returns nscoord_MIN.
<span class="lineNum">     931 </span>            :    */
<span class="lineNum">     932 </span>            :   nscoord GetFirstBaselineOffset() const {
<span class="lineNum">     933 </span>            :     return mFirstBaselineOffset;
<span class="lineNum">     934 </span>            :   }
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :   /**
<span class="lineNum">     937 </span>            :    * Returns the offset within this line where any last baseline-aligned
<span class="lineNum">     938 </span>            :    * FlexItems should place their baseline. Opposite the case of the first
<span class="lineNum">     939 </span>            :    * baseline offset, this represents a distance from the line's cross-end
<span class="lineNum">     940 </span>            :    * edge (since last baseline-aligned items are flush to the cross-end edge).
<span class="lineNum">     941 </span>            :    * If we're internally reversing the axes, this instead represents the
<span class="lineNum">     942 </span>            :    * distance from the line's cross-start edge.
<span class="lineNum">     943 </span>            :    *
<span class="lineNum">     944 </span>            :    * If there are no last baseline-aligned FlexItems, returns nscoord_MIN.
<span class="lineNum">     945 </span>            :    */
<span class="lineNum">     946 </span>            :   nscoord GetLastBaselineOffset() const {
<span class="lineNum">     947 </span>            :     return mLastBaselineOffset;
<span class="lineNum">     948 </span>            :   }
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :   // Runs the &quot;Resolving Flexible Lengths&quot; algorithm from section 9.7 of the
<span class="lineNum">     951 </span>            :   // CSS flexbox spec to distribute aFlexContainerMainSize among our flex items.
<span class="lineNum">     952 </span>            :   void ResolveFlexibleLengths(nscoord aFlexContainerMainSize);
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :   void PositionItemsInMainAxis(uint8_t aJustifyContent,
<span class="lineNum">     955 </span>            :                                nscoord aContentBoxMainSize,
<span class="lineNum">     956 </span>            :                                const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :   void PositionItemsInCrossAxis(nscoord aLineStartPosition,
<span class="lineNum">     959 </span>            :                                 const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :   friend class AutoFlexLineListClearer; // (needs access to mItems)
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : private:
<span class="lineNum">     964 </span>            :   // Helpers for ResolveFlexibleLengths():
<span class="lineNum">     965 </span>            :   void FreezeItemsEarly(bool aIsUsingFlexGrow);
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :   void FreezeOrRestoreEachFlexibleSize(const nscoord aTotalViolation,
<span class="lineNum">     968 </span>            :                                        bool aIsFinalIteration);
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :   LinkedList&lt;FlexItem&gt; mItems; // Linked list of this line's flex items.
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :   uint32_t mNumItems; // Number of FlexItems in this line (in |mItems|).
<span class="lineNum">     973 </span>            :                       // (Shouldn't change after GenerateFlexLines finishes
<span class="lineNum">     974 </span>            :                       // with this line -- at least, not until we add support
<span class="lineNum">     975 </span>            :                       // for splitting lines across continuations. Then we can
<span class="lineNum">     976 </span>            :                       // update this count carefully.)
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :   // Number of *frozen* FlexItems in this line, based on FlexItem::IsFrozen().
<span class="lineNum">     979 </span>            :   // Mostly used for optimization purposes, e.g. to bail out early from loops
<span class="lineNum">     980 </span>            :   // when we can tell they have nothing left to do.
<span class="lineNum">     981 </span>            :   uint32_t mNumFrozenItems;
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :   nscoord mTotalInnerHypotheticalMainSize;
<span class="lineNum">     984 </span>            :   nscoord mTotalOuterHypotheticalMainSize;
<span class="lineNum">     985 </span>            :   nscoord mLineCrossSize;
<span class="lineNum">     986 </span>            :   nscoord mFirstBaselineOffset;
<span class="lineNum">     987 </span>            :   nscoord mLastBaselineOffset;
<span class="lineNum">     988 </span>            : };
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            : // Information about a strut left behind by a FlexItem that's been collapsed
<span class="lineNum">     991 </span>            : // using &quot;visibility:collapse&quot;.
<span class="lineNum">     992 </span>            : struct nsFlexContainerFrame::StrutInfo {
<span class="lineNum">     993 </span>            :   StrutInfo(uint32_t aItemIdx, nscoord aStrutCrossSize)
<span class="lineNum">     994 </span>            :     : mItemIdx(aItemIdx),
<span class="lineNum">     995 </span><span class="lineCov">          1 :       mStrutCrossSize(aStrutCrossSize)</span>
<span class="lineNum">     996 </span>            :   {
<span class="lineNum">     997 </span>            :   }
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :   uint32_t mItemIdx;      // Index in the child list.
<span class="lineNum">    1000 </span>            :   nscoord mStrutCrossSize; // The cross-size of this strut.
<span class="lineNum">    1001 </span>            : };
<a name="1002"><span class="lineNum">    1002 </span>            : </a>
<span class="lineNum">    1003 </span>            : static void
<span class="lineNum">    1004 </span><span class="lineCov">          1 : BuildStrutInfoFromCollapsedItems(const FlexLine* aFirstLine,</span>
<span class="lineNum">    1005 </span>            :                                  nsTArray&lt;StrutInfo&gt;&amp; aStruts)
<span class="lineNum">    1006 </span>            : {
<span class="lineNum">    1007 </span>            :   MOZ_ASSERT(aFirstLine, &quot;null first line pointer&quot;);
<span class="lineNum">    1008 </span>            :   MOZ_ASSERT(aStruts.IsEmpty(),
<span class="lineNum">    1009 </span>            :              &quot;We should only build up StrutInfo once per reflow, so &quot;
<span class="lineNum">    1010 </span>            :              &quot;aStruts should be empty when this is called&quot;);
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineCov">          1 :   uint32_t itemIdxInContainer = 0;</span>
<span class="lineNum">    1013 </span><span class="lineCov">          1 :   for (const FlexLine* line = aFirstLine; line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    1014 </span><span class="lineCov">          1 :     for (const FlexItem* item = line-&gt;GetFirstItem(); item;</span>
<span class="lineNum">    1015 </span><span class="lineCov">          1 :          item = item-&gt;getNext()) {</span>
<span class="lineNum">    1016 </span><span class="lineCov">          1 :       if (NS_STYLE_VISIBILITY_COLLAPSE ==</span>
<span class="lineNum">    1017 </span><span class="lineCov">          1 :           item-&gt;Frame()-&gt;StyleVisibility()-&gt;mVisible) {</span>
<span class="lineNum">    1018 </span>            :         // Note the cross size of the line as the item's strut size.
<span class="lineNum">    1019 </span>            :         aStruts.AppendElement(StrutInfo(itemIdxInContainer,
<span class="lineNum">    1020 </span><span class="lineCov">          1 :                                         line-&gt;GetLineCrossSize()));</span>
<span class="lineNum">    1021 </span>            :       }
<span class="lineNum">    1022 </span><span class="lineCov">          1 :       itemIdxInContainer++;</span>
<span class="lineNum">    1023 </span>            :     }
<span class="lineNum">    1024 </span>            :   }
<span class="lineNum">    1025 </span><span class="lineCov">          1 : }</span>
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<span class="lineNum">    1027 </span>            : uint8_t
<span class="lineNum">    1028 </span><span class="lineCov">          1 : SimplifyAlignOrJustifyContentForOneItem(uint16_t aAlignmentVal,</span>
<span class="lineNum">    1029 </span>            :                                         bool aIsAlign)
<span class="lineNum">    1030 </span>            : {
<span class="lineNum">    1031 </span>            :   // Mask away any explicit fallback, to get the main (non-fallback) part of
<span class="lineNum">    1032 </span>            :   // the specified value:
<span class="lineNum">    1033 </span><span class="lineCov">          1 :   uint16_t specified = aAlignmentVal &amp; NS_STYLE_ALIGN_ALL_BITS;</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :   // XXX strip off &lt;overflow-position&gt; bits until we implement it (bug 1311892)
<span class="lineNum">    1036 </span><span class="lineCov">          1 :   specified &amp;= ~NS_STYLE_ALIGN_FLAG_BITS;</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :   // FIRST: handle a special-case for &quot;justify-content:stretch&quot; (or equivalent),
<span class="lineNum">    1039 </span>            :   // which requires that we ignore any author-provided explicit fallback value.
<span class="lineNum">    1040 </span><span class="lineCov">          1 :   if (specified == NS_STYLE_ALIGN_NORMAL) {</span>
<span class="lineNum">    1041 </span>            :     // In a flex container, *-content: &quot;'normal' behaves as 'stretch'&quot;.
<span class="lineNum">    1042 </span>            :     // Do that conversion early, so it benefits from our 'stretch' special-case.
<span class="lineNum">    1043 </span>            :     // https://drafts.csswg.org/css-align-3/#distribution-flex
<span class="lineNum">    1044 </span><span class="lineCov">          1 :     specified = NS_STYLE_ALIGN_STRETCH;</span>
<span class="lineNum">    1045 </span>            :   }
<span class="lineNum">    1046 </span><span class="lineCov">          1 :   if (!aIsAlign &amp;&amp; specified == NS_STYLE_ALIGN_STRETCH) {</span>
<span class="lineNum">    1047 </span>            :     // In a flex container, in &quot;justify-content Axis: [...] 'stretch' behaves
<span class="lineNum">    1048 </span>            :     // as 'flex-start' (ignoring the specified fallback alignment, if any).&quot;
<span class="lineNum">    1049 </span>            :     // https://drafts.csswg.org/css-align-3/#distribution-flex
<span class="lineNum">    1050 </span>            :     // So, we just directly return 'flex-start', &amp; ignore explicit fallback..
<span class="lineNum">    1051 </span>            :     return NS_STYLE_ALIGN_FLEX_START;
<span class="lineNum">    1052 </span>            :   }
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            :   // Now check for an explicit fallback value (and if it's present, use it).
<span class="lineNum">    1055 </span><span class="lineCov">          1 :   uint16_t explicitFallback = aAlignmentVal &gt;&gt; NS_STYLE_ALIGN_ALL_SHIFT;</span>
<span class="lineNum">    1056 </span><span class="lineCov">          1 :   if (explicitFallback) {</span>
<span class="lineNum">    1057 </span>            :     // XXX strip off &lt;overflow-position&gt; bits until we implement it
<span class="lineNum">    1058 </span>            :     // (bug 1311892)
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     explicitFallback &amp;= ~NS_STYLE_ALIGN_FLAG_BITS;</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     return explicitFallback;</span>
<span class="lineNum">    1061 </span>            :   }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :   // There's no explicit fallback. Use the implied fallback values for
<span class="lineNum">    1064 </span>            :   // space-{between,around,evenly} (since those values only make sense with
<span class="lineNum">    1065 </span>            :   // multiple alignment subjects), and otherwise just use the specified value:
<span class="lineNum">    1066 </span><span class="lineCov">          1 :   switch (specified) {</span>
<span class="lineNum">    1067 </span>            :     case NS_STYLE_ALIGN_SPACE_BETWEEN:
<span class="lineNum">    1068 </span>            :       return NS_STYLE_ALIGN_START;
<span class="lineNum">    1069 </span>            :     case NS_STYLE_ALIGN_SPACE_AROUND:
<span class="lineNum">    1070 </span>            :     case NS_STYLE_ALIGN_SPACE_EVENLY:
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :       return NS_STYLE_ALIGN_CENTER;</span>
<span class="lineNum">    1072 </span>            :     default:
<span class="lineNum">    1073 </span><span class="lineCov">          1 :       return specified;</span>
<span class="lineNum">    1074 </span>            :   }
<span class="lineNum">    1075 </span>            : }
<a name="1076"><span class="lineNum">    1076 </span>            : </a>
<span class="lineNum">    1077 </span>            : uint16_t
<span class="lineNum">    1078 </span><span class="lineCov">          1 : nsFlexContainerFrame::CSSAlignmentForAbsPosChild(</span>
<span class="lineNum">    1079 </span>            :   const ReflowInput&amp; aChildRI,
<span class="lineNum">    1080 </span>            :   LogicalAxis aLogicalAxis) const
<span class="lineNum">    1081 </span>            : {
<span class="lineNum">    1082 </span><span class="lineCov">          1 :   WritingMode wm = GetWritingMode();</span>
<span class="lineNum">    1083 </span>            :   const FlexboxAxisTracker
<span class="lineNum">    1084 </span><span class="lineCov">          1 :     axisTracker(this, wm, AxisTrackerFlags::eAllowBottomToTopChildOrdering);</span>
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :   // If we're row-oriented and the caller is asking about our inline axis (or
<span class="lineNum">    1087 </span>            :   // alternately, if we're column-oriented and the caller is asking about our
<span class="lineNum">    1088 </span>            :   // block axis), then the caller is really asking about our *main* axis.
<span class="lineNum">    1089 </span>            :   // Otherwise, the caller is asking about our cross axis.
<span class="lineNum">    1090 </span><span class="lineCov">          1 :   const bool isMainAxis = (axisTracker.IsRowOriented() ==</span>
<span class="lineNum">    1091 </span><span class="lineCov">          1 :                            (aLogicalAxis == eLogicalAxisInline));</span>
<span class="lineNum">    1092 </span><span class="lineCov">          1 :   const nsStylePosition* containerStylePos = StylePosition();</span>
<span class="lineNum">    1093 </span>            :   const bool isAxisReversed = isMainAxis ? axisTracker.IsMainAxisReversed()
<span class="lineNum">    1094 </span><span class="lineCov">          1 :                                          : axisTracker.IsCrossAxisReversed();</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   uint8_t alignment;
<span class="lineNum">    1097 </span><span class="lineCov">          1 :   if (isMainAxis) {</span>
<span class="lineNum">    1098 </span>            :     alignment = SimplifyAlignOrJustifyContentForOneItem(
<span class="lineNum">    1099 </span>            :                   containerStylePos-&gt;mJustifyContent,
<span class="lineNum">    1100 </span><span class="lineCov">          1 :                   /*aIsAlign = */false);</span>
<span class="lineNum">    1101 </span>            :   } else {
<span class="lineNum">    1102 </span>            :     const uint8_t alignContent = SimplifyAlignOrJustifyContentForOneItem(
<span class="lineNum">    1103 </span>            :                                    containerStylePos-&gt;mAlignContent,
<span class="lineNum">    1104 </span><span class="lineCov">          1 :                                    /*aIsAlign = */true);</span>
<span class="lineNum">    1105 </span><span class="lineCov">          1 :     if (NS_STYLE_FLEX_WRAP_NOWRAP != containerStylePos-&gt;mFlexWrap &amp;&amp;</span>
<span class="lineNum">    1106 </span>            :         alignContent != NS_STYLE_ALIGN_STRETCH) {
<span class="lineNum">    1107 </span>            :       // Multi-line, align-content isn't stretch --&gt; align-content determines
<span class="lineNum">    1108 </span>            :       // this child's alignment in the cross axis.
<span class="lineNum">    1109 </span>            :       alignment = alignContent;
<span class="lineNum">    1110 </span>            :     } else {
<span class="lineNum">    1111 </span>            :       // Single-line, or multi-line but the (one) line stretches to fill
<span class="lineNum">    1112 </span>            :       // container. Respect align-self.
<span class="lineNum">    1113 </span><span class="lineCov">          1 :       alignment = aChildRI.mStylePosition-&gt;UsedAlignSelf(StyleContext());</span>
<span class="lineNum">    1114 </span>            :       // XXX strip off &lt;overflow-position&gt; bits until we implement it
<span class="lineNum">    1115 </span>            :       // (bug 1311892)
<span class="lineNum">    1116 </span><span class="lineCov">          1 :       alignment &amp;= ~NS_STYLE_ALIGN_FLAG_BITS;</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineCov">          1 :       if (alignment == NS_STYLE_ALIGN_NORMAL) {</span>
<span class="lineNum">    1119 </span>            :         // &quot;the 'normal' keyword behaves as 'start' on replaced
<span class="lineNum">    1120 </span>            :         // absolutely-positioned boxes, and behaves as 'stretch' on all other
<span class="lineNum">    1121 </span>            :         // absolutely-positioned boxes.&quot;
<span class="lineNum">    1122 </span>            :         // https://drafts.csswg.org/css-align/#align-abspos
<span class="lineNum">    1123 </span><span class="lineCov">          1 :         alignment = aChildRI.mFrame-&gt;IsFrameOfType(nsIFrame::eReplaced) ?</span>
<span class="lineNum">    1124 </span><span class="lineCov">          1 :           NS_STYLE_ALIGN_START : NS_STYLE_ALIGN_STRETCH;</span>
<span class="lineNum">    1125 </span>            :       }
<span class="lineNum">    1126 </span>            :     }
<span class="lineNum">    1127 </span>            :   }
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span>            :   // Resolve flex-start, flex-end, auto, left, right, baseline, last baseline;
<span class="lineNum">    1130 </span><span class="lineCov">          1 :   if (alignment == NS_STYLE_ALIGN_FLEX_START) {</span>
<span class="lineNum">    1131 </span><span class="lineCov">          1 :     alignment = isAxisReversed ? NS_STYLE_ALIGN_END : NS_STYLE_ALIGN_START;</span>
<span class="lineNum">    1132 </span><span class="lineCov">          1 :   } else if (alignment == NS_STYLE_ALIGN_FLEX_END) {</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     alignment = isAxisReversed ? NS_STYLE_ALIGN_START : NS_STYLE_ALIGN_END;</span>
<span class="lineNum">    1134 </span><span class="lineCov">          1 :   } else if (alignment == NS_STYLE_ALIGN_LEFT ||</span>
<span class="lineNum">    1135 </span>            :              alignment == NS_STYLE_ALIGN_RIGHT) {
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     if (aLogicalAxis == eLogicalAxisInline) {</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :       const bool isLeft = (alignment == NS_STYLE_ALIGN_LEFT);</span>
<span class="lineNum">    1138 </span>            :       alignment = (isLeft == wm.IsBidiLTR()) ? NS_STYLE_ALIGN_START
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :                                              : NS_STYLE_ALIGN_END;</span>
<span class="lineNum">    1140 </span>            :     } else {
<span class="lineNum">    1141 </span>            :       alignment = NS_STYLE_ALIGN_START;
<span class="lineNum">    1142 </span>            :     }
<span class="lineNum">    1143 </span><span class="lineCov">          1 :   } else if (alignment == NS_STYLE_ALIGN_BASELINE) {</span>
<span class="lineNum">    1144 </span>            :     alignment = NS_STYLE_ALIGN_START;
<span class="lineNum">    1145 </span><span class="lineCov">          1 :   } else if (alignment == NS_STYLE_ALIGN_LAST_BASELINE) {</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     alignment = NS_STYLE_ALIGN_END;</span>
<span class="lineNum">    1147 </span>            :   }
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span><span class="lineCov">          1 :   return alignment;</span>
<span class="lineNum">    1150 </span>            : }
<a name="1151"><span class="lineNum">    1151 </span>            : </a>
<span class="lineNum">    1152 </span>            : bool
<span class="lineNum">    1153 </span><span class="lineCov">          1 : nsFlexContainerFrame::IsHorizontal()</span>
<span class="lineNum">    1154 </span>            : {
<span class="lineNum">    1155 </span><span class="lineCov">          1 :   const FlexboxAxisTracker axisTracker(this, GetWritingMode());</span>
<span class="lineNum">    1156 </span><span class="lineCov">          1 :   return axisTracker.IsMainAxisHorizontal();</span>
<span class="lineNum">    1157 </span>            : }
<a name="1158"><span class="lineNum">    1158 </span>            : </a>
<span class="lineNum">    1159 </span>            : UniquePtr&lt;FlexItem&gt;
<span class="lineNum">    1160 </span><span class="lineCov">          1 : nsFlexContainerFrame::GenerateFlexItemForChild(</span>
<span class="lineNum">    1161 </span>            :   nsPresContext* aPresContext,
<span class="lineNum">    1162 </span>            :   nsIFrame*      aChildFrame,
<span class="lineNum">    1163 </span>            :   const ReflowInput&amp; aParentReflowInput,
<span class="lineNum">    1164 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1165 </span>            : {
<span class="lineNum">    1166 </span>            :   // Create temporary reflow state just for sizing -- to get hypothetical
<span class="lineNum">    1167 </span>            :   // main-size and the computed values of min / max main-size property.
<span class="lineNum">    1168 </span>            :   // (This reflow state will _not_ be used for reflow.)
<span class="lineNum">    1169 </span>            :   ReflowInput
<span class="lineNum">    1170 </span>            :     childRI(aPresContext, aParentReflowInput, aChildFrame,
<span class="lineNum">    1171 </span><span class="lineCov">          1 :             aParentReflowInput.ComputedSize(aChildFrame-&gt;GetWritingMode()));</span>
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :   // FLEX GROW &amp; SHRINK WEIGHTS
<span class="lineNum">    1174 </span>            :   // --------------------------
<span class="lineNum">    1175 </span>            :   float flexGrow, flexShrink;
<span class="lineNum">    1176 </span><span class="lineCov">          1 :   if (IsLegacyBox(this)) {</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     flexGrow = flexShrink = aChildFrame-&gt;StyleXUL()-&gt;mBoxFlex;</span>
<span class="lineNum">    1178 </span>            :   } else {
<span class="lineNum">    1179 </span><span class="lineCov">          1 :     const nsStylePosition* stylePos = aChildFrame-&gt;StylePosition();</span>
<span class="lineNum">    1180 </span><span class="lineCov">          1 :     flexGrow   = stylePos-&gt;mFlexGrow;</span>
<span class="lineNum">    1181 </span><span class="lineCov">          1 :     flexShrink = stylePos-&gt;mFlexShrink;</span>
<span class="lineNum">    1182 </span>            :   }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">          1 :   WritingMode childWM = childRI.GetWritingMode();</span>
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            :   // MAIN SIZES (flex base size, min/max size)
<span class="lineNum">    1187 </span>            :   // -----------------------------------------
<span class="lineNum">    1188 </span><span class="lineCov">          1 :   nscoord flexBaseSize = GET_MAIN_COMPONENT_LOGICAL(aAxisTracker, childWM,</span>
<span class="lineNum">    1189 </span>            :                                                     childRI.ComputedISize(),
<span class="lineNum">    1190 </span>            :                                                     childRI.ComputedBSize());
<span class="lineNum">    1191 </span><span class="lineCov">          1 :   nscoord mainMinSize = GET_MAIN_COMPONENT_LOGICAL(aAxisTracker, childWM,</span>
<span class="lineNum">    1192 </span>            :                                                    childRI.ComputedMinISize(),
<span class="lineNum">    1193 </span>            :                                                    childRI.ComputedMinBSize());
<span class="lineNum">    1194 </span><span class="lineCov">          1 :   nscoord mainMaxSize = GET_MAIN_COMPONENT_LOGICAL(aAxisTracker, childWM,</span>
<span class="lineNum">    1195 </span>            :                                                    childRI.ComputedMaxISize(),
<span class="lineNum">    1196 </span>            :                                                    childRI.ComputedMaxBSize());
<span class="lineNum">    1197 </span>            :   // This is enforced by the ReflowInput where these values come from:
<span class="lineNum">    1198 </span>            :   MOZ_ASSERT(mainMinSize &lt;= mainMaxSize, &quot;min size is larger than max size&quot;);
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :   // CROSS SIZES (tentative cross size, min/max cross size)
<span class="lineNum">    1201 </span>            :   // ------------------------------------------------------
<span class="lineNum">    1202 </span>            :   // Grab the cross size from the reflow state. This might be the right value,
<span class="lineNum">    1203 </span>            :   // or we might resolve it to something else in SizeItemInCrossAxis(); hence,
<span class="lineNum">    1204 </span>            :   // it's tentative. See comment under &quot;Cross Size Determination&quot; for more.
<span class="lineNum">    1205 </span>            :   nscoord tentativeCrossSize =
<span class="lineNum">    1206 </span><span class="lineCov">          1 :     GET_CROSS_COMPONENT_LOGICAL(aAxisTracker, childWM,</span>
<span class="lineNum">    1207 </span>            :                                 childRI.ComputedISize(),
<span class="lineNum">    1208 </span>            :                                 childRI.ComputedBSize());
<span class="lineNum">    1209 </span>            :   nscoord crossMinSize =
<span class="lineNum">    1210 </span><span class="lineCov">          1 :     GET_CROSS_COMPONENT_LOGICAL(aAxisTracker, childWM,</span>
<span class="lineNum">    1211 </span>            :                                 childRI.ComputedMinISize(),
<span class="lineNum">    1212 </span>            :                                 childRI.ComputedMinBSize());
<span class="lineNum">    1213 </span>            :   nscoord crossMaxSize =
<span class="lineNum">    1214 </span><span class="lineCov">          1 :     GET_CROSS_COMPONENT_LOGICAL(aAxisTracker, childWM,</span>
<span class="lineNum">    1215 </span>            :                                 childRI.ComputedMaxISize(),
<span class="lineNum">    1216 </span>            :                                 childRI.ComputedMaxBSize());
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :   // SPECIAL-CASE FOR WIDGET-IMPOSED SIZES
<span class="lineNum">    1219 </span>            :   // Check if we're a themed widget, in which case we might have a minimum
<span class="lineNum">    1220 </span>            :   // main &amp; cross size imposed by our widget (which we can't go below), or
<span class="lineNum">    1221 </span>            :   // (more severe) our widget might have only a single valid size.
<span class="lineNum">    1222 </span><span class="lineCov">          1 :   bool isFixedSizeWidget = false;</span>
<span class="lineNum">    1223 </span><span class="lineCov">          1 :   const nsStyleDisplay* disp = aChildFrame-&gt;StyleDisplay();</span>
<span class="lineNum">    1224 </span><span class="lineCov">          1 :   if (aChildFrame-&gt;IsThemed(disp)) {</span>
<span class="lineNum">    1225 </span><span class="lineCov">          1 :     LayoutDeviceIntSize widgetMinSize;</span>
<span class="lineNum">    1226 </span><span class="lineCov">          1 :     bool canOverride = true;</span>
<span class="lineNum">    1227 </span><span class="lineCov">          1 :     aPresContext-&gt;GetTheme()-&gt;</span>
<span class="lineNum">    1228 </span>            :       GetMinimumWidgetSize(aPresContext, aChildFrame,
<span class="lineNum">    1229 </span>            :                            disp-&gt;UsedAppearance(),
<span class="lineNum">    1230 </span><span class="lineCov">          1 :                            &amp;widgetMinSize, &amp;canOverride);</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            :     nscoord widgetMainMinSize =
<span class="lineNum">    1233 </span>            :       aPresContext-&gt;DevPixelsToAppUnits(
<span class="lineNum">    1234 </span><span class="lineCov">          1 :         aAxisTracker.GetMainComponent(widgetMinSize));</span>
<span class="lineNum">    1235 </span>            :     nscoord widgetCrossMinSize =
<span class="lineNum">    1236 </span>            :       aPresContext-&gt;DevPixelsToAppUnits(
<span class="lineNum">    1237 </span><span class="lineCov">          1 :         aAxisTracker.GetCrossComponent(widgetMinSize));</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            :     // GMWS() returns border-box. We need content-box, so subtract
<span class="lineNum">    1240 </span>            :     // borderPadding (but don't let that push our min sizes below 0).
<span class="lineNum">    1241 </span><span class="lineCov">          1 :     nsMargin&amp; bp = childRI.ComputedPhysicalBorderPadding();</span>
<span class="lineNum">    1242 </span><span class="lineCov">          1 :     widgetMainMinSize = std::max(widgetMainMinSize -</span>
<span class="lineNum">    1243 </span><span class="lineCov">          1 :                                  aAxisTracker.GetMarginSizeInMainAxis(bp), 0);</span>
<span class="lineNum">    1244 </span><span class="lineCov">          1 :     widgetCrossMinSize = std::max(widgetCrossMinSize -</span>
<span class="lineNum">    1245 </span><span class="lineCov">          1 :                                   aAxisTracker.GetMarginSizeInCrossAxis(bp), 0);</span>
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineCov">          1 :     if (!canOverride) {</span>
<span class="lineNum">    1248 </span>            :       // Fixed-size widget: freeze our main-size at the widget's mandated size.
<span class="lineNum">    1249 </span>            :       // (Set min and max main-sizes to that size, too, to keep us from
<span class="lineNum">    1250 </span>            :       // clamping to any other size later on.)
<span class="lineNum">    1251 </span><span class="lineCov">          1 :       flexBaseSize = mainMinSize = mainMaxSize = widgetMainMinSize;</span>
<span class="lineNum">    1252 </span><span class="lineCov">          1 :       tentativeCrossSize = crossMinSize = crossMaxSize = widgetCrossMinSize;</span>
<span class="lineNum">    1253 </span><span class="lineCov">          1 :       isFixedSizeWidget = true;</span>
<span class="lineNum">    1254 </span>            :     } else {
<span class="lineNum">    1255 </span>            :       // Variable-size widget: ensure our min/max sizes are at least as large
<span class="lineNum">    1256 </span>            :       // as the widget's mandated minimum size, so we don't flex below that.
<span class="lineNum">    1257 </span><span class="lineCov">          1 :       mainMinSize = std::max(mainMinSize, widgetMainMinSize);</span>
<span class="lineNum">    1258 </span><span class="lineCov">          1 :       mainMaxSize = std::max(mainMaxSize, widgetMainMinSize);</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineCov">          1 :       if (tentativeCrossSize != NS_INTRINSICSIZE) {</span>
<span class="lineNum">    1261 </span><span class="lineCov">          1 :         tentativeCrossSize = std::max(tentativeCrossSize, widgetCrossMinSize);</span>
<span class="lineNum">    1262 </span>            :       }
<span class="lineNum">    1263 </span><span class="lineCov">          1 :       crossMinSize = std::max(crossMinSize, widgetCrossMinSize);</span>
<span class="lineNum">    1264 </span><span class="lineCov">          1 :       crossMaxSize = std::max(crossMaxSize, widgetCrossMinSize);</span>
<span class="lineNum">    1265 </span>            :     }
<span class="lineNum">    1266 </span>            :   }
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            :   // Construct the flex item!
<span class="lineNum">    1269 </span>            :   auto item = MakeUnique&lt;FlexItem&gt;(childRI,
<span class="lineNum">    1270 </span>            :                                    flexGrow, flexShrink, flexBaseSize,
<span class="lineNum">    1271 </span>            :                                    mainMinSize, mainMaxSize,
<span class="lineNum">    1272 </span>            :                                    tentativeCrossSize,
<span class="lineNum">    1273 </span>            :                                    crossMinSize, crossMaxSize,
<span class="lineNum">    1274 </span><span class="lineCov">          1 :                                    aAxisTracker);</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            :   // If we're inflexible, we can just freeze to our hypothetical main-size
<span class="lineNum">    1277 </span>            :   // up-front. Similarly, if we're a fixed-size widget, we only have one
<span class="lineNum">    1278 </span>            :   // valid size, so we freeze to keep ourselves from flexing.
<span class="lineNum">    1279 </span><span class="lineCov">          1 :   if (isFixedSizeWidget || (flexGrow == 0.0f &amp;&amp; flexShrink == 0.0f)) {</span>
<span class="lineNum">    1280 </span>            :     item-&gt;Freeze();
<span class="lineNum">    1281 </span>            :   }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :   // Resolve &quot;flex-basis:auto&quot; and/or &quot;min-[width|height]:auto&quot; (which might
<span class="lineNum">    1284 </span>            :   // require us to reflow the item to measure content height)
<span class="lineNum">    1285 </span>            :   ResolveAutoFlexBasisAndMinSize(aPresContext, *item,
<span class="lineNum">    1286 </span><span class="lineCov">          1 :                                  childRI, aAxisTracker);</span>
<span class="lineNum">    1287 </span><span class="lineCov">          1 :   return item;</span>
<span class="lineNum">    1288 </span>            : }
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            : // Static helper-functions for ResolveAutoFlexBasisAndMinSize():
<span class="lineNum">    1291 </span>            : // -------------------------------------------------------------
<span class="lineNum">    1292 </span>            : // Indicates whether the cross-size property is set to something definite.
<span class="lineNum">    1293 </span>            : // The logic here should be similar to the logic for isAutoWidth/isAutoHeight
<a name="1294"><span class="lineNum">    1294 </span>            : // in nsFrame::ComputeSizeWithIntrinsicDimensions().</a>
<span class="lineNum">    1295 </span>            : static bool
<span class="lineNum">    1296 </span><span class="lineCov">          1 : IsCrossSizeDefinite(const ReflowInput&amp; aItemReflowInput,</span>
<span class="lineNum">    1297 </span>            :                     const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1298 </span>            : {
<span class="lineNum">    1299 </span><span class="lineCov">          1 :   const nsStylePosition* pos = aItemReflowInput.mStylePosition;</span>
<span class="lineNum">    1300 </span><span class="lineCov">          1 :   if (aAxisTracker.IsCrossAxisHorizontal()) {</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     return pos-&gt;mWidth.GetUnit() != eStyleUnit_Auto;</span>
<span class="lineNum">    1302 </span>            :   }
<span class="lineNum">    1303 </span>            :   // else, vertical. (We need to use IsAutoHeight() to catch e.g. %-height
<span class="lineNum">    1304 </span>            :   // applied to indefinite-height containing block, which counts as auto.)
<span class="lineNum">    1305 </span><span class="lineCov">          1 :   nscoord cbHeight = aItemReflowInput.mCBReflowInput-&gt;ComputedHeight();</span>
<span class="lineNum">    1306 </span><span class="lineCov">          1 :   return !nsLayoutUtils::IsAutoHeight(pos-&gt;mHeight, cbHeight);</span>
<span class="lineNum">    1307 </span>            : }
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : // If aFlexItem has a definite cross size, this function returns it, for usage
<span class="lineNum">    1310 </span>            : // (in combination with an intrinsic ratio) for resolving the item's main size
<span class="lineNum">    1311 </span>            : // or main min-size.
<span class="lineNum">    1312 </span>            : //
<span class="lineNum">    1313 </span>            : // The parameter &quot;aMinSizeFallback&quot; indicates whether we should fall back to
<span class="lineNum">    1314 </span>            : // returning the cross min-size, when the cross size is indefinite. (This param
<span class="lineNum">    1315 </span>            : // should be set IFF the caller intends to resolve the main min-size.) If this
<span class="lineNum">    1316 </span>            : // param is true, then this function is guaranteed to return a definite value
<span class="lineNum">    1317 </span>            : // (i.e. not NS_AUTOHEIGHT, excluding cases where huge sizes are involved).
<span class="lineNum">    1318 </span>            : //
<span class="lineNum">    1319 </span>            : // XXXdholbert the min-size behavior here is based on my understanding in
<span class="lineNum">    1320 </span>            : //   http://lists.w3.org/Archives/Public/www-style/2014Jul/0053.html
<a name="1321"><span class="lineNum">    1321 </span>            : // If my understanding there ends up being wrong, we'll need to update this.</a>
<span class="lineNum">    1322 </span>            : static nscoord
<span class="lineNum">    1323 </span><span class="lineCov">          1 : CrossSizeToUseWithRatio(const FlexItem&amp; aFlexItem,</span>
<span class="lineNum">    1324 </span>            :                         const ReflowInput&amp; aItemReflowInput,
<span class="lineNum">    1325 </span>            :                         bool aMinSizeFallback,
<span class="lineNum">    1326 </span>            :                         const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1327 </span>            : {
<span class="lineNum">    1328 </span><span class="lineCov">          1 :   if (aFlexItem.IsStretched()) {</span>
<span class="lineNum">    1329 </span>            :     // Definite cross-size, imposed via 'align-self:stretch' &amp; flex container.
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     return aFlexItem.GetCrossSize();</span>
<span class="lineNum">    1331 </span>            :   }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span><span class="lineCov">          1 :   if (IsCrossSizeDefinite(aItemReflowInput, aAxisTracker)) {</span>
<span class="lineNum">    1334 </span>            :     // Definite cross size.
<span class="lineNum">    1335 </span><span class="lineCov">          1 :     return GET_CROSS_COMPONENT_LOGICAL(aAxisTracker, aFlexItem.GetWritingMode(),</span>
<span class="lineNum">    1336 </span>            :                                        aItemReflowInput.ComputedISize(),
<span class="lineNum">    1337 </span>            :                                        aItemReflowInput.ComputedBSize());
<span class="lineNum">    1338 </span>            :   }
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineCov">          1 :   if (aMinSizeFallback) {</span>
<span class="lineNum">    1341 </span>            :     // Indefinite cross-size, and we're resolving main min-size, so we'll fall
<span class="lineNum">    1342 </span>            :     // back to ussing the cross min-size (which should be definite).
<span class="lineNum">    1343 </span><span class="lineCov">          1 :     return GET_CROSS_COMPONENT_LOGICAL(aAxisTracker, aFlexItem.GetWritingMode(),</span>
<span class="lineNum">    1344 </span>            :                                        aItemReflowInput.ComputedMinISize(),
<span class="lineNum">    1345 </span>            :                                        aItemReflowInput.ComputedMinBSize());
<span class="lineNum">    1346 </span>            :   }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            :   // Indefinite cross-size.
<span class="lineNum">    1349 </span>            :   return NS_AUTOHEIGHT;
<span class="lineNum">    1350 </span>            : }
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            : // Convenience function; returns a main-size, given a cross-size and an
<span class="lineNum">    1353 </span>            : // intrinsic ratio. The intrinsic ratio must not have 0 in its cross-axis
<a name="1354"><span class="lineNum">    1354 </span>            : // component (or else we'll divide by 0).</a>
<span class="lineNum">    1355 </span>            : static nscoord
<span class="lineNum">    1356 </span><span class="lineCov">          1 : MainSizeFromAspectRatio(nscoord aCrossSize,</span>
<span class="lineNum">    1357 </span>            :                         const nsSize&amp; aIntrinsicRatio,
<span class="lineNum">    1358 </span>            :                         const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1359 </span>            : {
<span class="lineNum">    1360 </span>            :   MOZ_ASSERT(aAxisTracker.GetCrossComponent(aIntrinsicRatio) != 0,
<span class="lineNum">    1361 </span>            :              &quot;Invalid ratio; will divide by 0! Caller should've checked...&quot;);
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineCov">          1 :   if (aAxisTracker.IsCrossAxisHorizontal()) {</span>
<span class="lineNum">    1364 </span>            :     // cross axis horiz --&gt; aCrossSize is a width. Converting to height.
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     return NSCoordMulDiv(aCrossSize, aIntrinsicRatio.height, aIntrinsicRatio.width);</span>
<span class="lineNum">    1366 </span>            :   }
<span class="lineNum">    1367 </span>            :   // cross axis vert --&gt; aCrossSize is a height. Converting to width.
<span class="lineNum">    1368 </span><span class="lineCov">          1 :   return NSCoordMulDiv(aCrossSize, aIntrinsicRatio.width, aIntrinsicRatio.height);</span>
<span class="lineNum">    1369 </span>            : }
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            : // Partially resolves &quot;min-[width|height]:auto&quot; and returns the resulting value.
<span class="lineNum">    1372 </span>            : // By &quot;partially&quot;, I mean we don't consider the min-content size (but we do
<span class="lineNum">    1373 </span>            : // consider flex-basis, main max-size, and the intrinsic aspect ratio).
<span class="lineNum">    1374 </span>            : // The caller is responsible for computing &amp; considering the min-content size
<span class="lineNum">    1375 </span>            : // in combination with the partially-resolved value that this function returns.
<span class="lineNum">    1376 </span>            : //
<a name="1377"><span class="lineNum">    1377 </span>            : // Spec reference: http://dev.w3.org/csswg/css-flexbox/#min-size-auto</a>
<span class="lineNum">    1378 </span>            : static nscoord
<span class="lineNum">    1379 </span><span class="lineCov">          1 : PartiallyResolveAutoMinSize(const FlexItem&amp; aFlexItem,</span>
<span class="lineNum">    1380 </span>            :                             const ReflowInput&amp; aItemReflowInput,
<span class="lineNum">    1381 </span>            :                             const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1382 </span>            : {
<span class="lineNum">    1383 </span>            :   MOZ_ASSERT(aFlexItem.NeedsMinSizeAutoResolution(),
<span class="lineNum">    1384 </span>            :              &quot;only call for FlexItems that need min-size auto resolution&quot;);
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineCov">          1 :   nscoord minMainSize = nscoord_MAX; // Intentionally huge; we'll shrink it</span>
<span class="lineNum">    1387 </span>            :                                      // from here, w/ std::min().
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :   // We need the smallest of:
<span class="lineNum">    1390 </span>            :   // * the used flex-basis, if the computed flex-basis was 'auto':
<span class="lineNum">    1391 </span>            :   // XXXdholbert ('auto' might be renamed to 'main-size'; see bug 1032922)
<span class="lineNum">    1392 </span><span class="lineCov">          1 :   if (eStyleUnit_Auto ==</span>
<span class="lineNum">    1393 </span><span class="lineCov">          1 :       aItemReflowInput.mStylePosition-&gt;mFlexBasis.GetUnit() &amp;&amp;</span>
<span class="lineNum">    1394 </span><span class="lineCov">          1 :       aFlexItem.GetFlexBaseSize() != NS_AUTOHEIGHT) {</span>
<span class="lineNum">    1395 </span>            :     // NOTE: We skip this if the flex base size depends on content &amp; isn't yet
<span class="lineNum">    1396 </span>            :     // resolved. This is OK, because the caller is responsible for computing
<span class="lineNum">    1397 </span>            :     // the min-content height and min()'ing it with the value we return, which
<span class="lineNum">    1398 </span>            :     // is equivalent to what would happen if we min()'d that at this point.
<span class="lineNum">    1399 </span><span class="lineCov">          1 :     minMainSize = std::min(minMainSize, aFlexItem.GetFlexBaseSize());</span>
<span class="lineNum">    1400 </span>            :   }
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            :   // * the computed max-width (max-height), if that value is definite:
<span class="lineNum">    1403 </span>            :   nscoord maxSize =
<span class="lineNum">    1404 </span><span class="lineCov">          1 :     GET_MAIN_COMPONENT_LOGICAL(aAxisTracker, aFlexItem.GetWritingMode(),</span>
<span class="lineNum">    1405 </span>            :                                aItemReflowInput.ComputedMaxISize(),
<span class="lineNum">    1406 </span>            :                                aItemReflowInput.ComputedMaxBSize());
<span class="lineNum">    1407 </span><span class="lineCov">          1 :   if (maxSize != NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">    1408 </span><span class="lineCov">          1 :     minMainSize = std::min(minMainSize, maxSize);</span>
<span class="lineNum">    1409 </span>            :   }
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :   // * if the item has no intrinsic aspect ratio, its min-content size:
<span class="lineNum">    1412 </span>            :   //  --- SKIPPING THIS IN THIS FUNCTION --- caller's responsibility.
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            :   // * if the item has an intrinsic aspect ratio, the width (height) calculated
<span class="lineNum">    1415 </span>            :   //   from the aspect ratio and any definite size constraints in the opposite
<span class="lineNum">    1416 </span>            :   //   dimension.
<span class="lineNum">    1417 </span><span class="lineCov">          1 :   if (aAxisTracker.GetCrossComponent(aFlexItem.IntrinsicRatio()) != 0) {</span>
<span class="lineNum">    1418 </span>            :     // We have a usable aspect ratio. (not going to divide by 0)
<span class="lineNum">    1419 </span><span class="lineCov">          1 :     const bool useMinSizeIfCrossSizeIsIndefinite = true;</span>
<span class="lineNum">    1420 </span>            :     nscoord crossSizeToUseWithRatio =
<span class="lineNum">    1421 </span>            :       CrossSizeToUseWithRatio(aFlexItem, aItemReflowInput,
<span class="lineNum">    1422 </span>            :                               useMinSizeIfCrossSizeIsIndefinite,
<span class="lineNum">    1423 </span><span class="lineCov">          1 :                               aAxisTracker);</span>
<span class="lineNum">    1424 </span>            :     nscoord minMainSizeFromRatio =
<span class="lineNum">    1425 </span>            :       MainSizeFromAspectRatio(crossSizeToUseWithRatio,
<span class="lineNum">    1426 </span><span class="lineCov">          1 :                               aFlexItem.IntrinsicRatio(), aAxisTracker);</span>
<span class="lineNum">    1427 </span><span class="lineCov">          1 :     minMainSize = std::min(minMainSize, minMainSizeFromRatio);</span>
<span class="lineNum">    1428 </span>            :   }
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineCov">          1 :   return minMainSize;</span>
<span class="lineNum">    1431 </span>            : }
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            : // Resolves flex-basis:auto, using the given intrinsic ratio and the flex
<span class="lineNum">    1434 </span>            : // item's cross size.  On success, updates the flex item with its resolved
<span class="lineNum">    1435 </span>            : // flex-basis and returns true. On failure (e.g. if the ratio is invalid or
<a name="1436"><span class="lineNum">    1436 </span>            : // the cross-size is indefinite), returns false.</a>
<span class="lineNum">    1437 </span>            : static bool
<span class="lineNum">    1438 </span><span class="lineCov">          1 : ResolveAutoFlexBasisFromRatio(FlexItem&amp; aFlexItem,</span>
<span class="lineNum">    1439 </span>            :                               const ReflowInput&amp; aItemReflowInput,
<span class="lineNum">    1440 </span>            :                               const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1441 </span>            : {
<span class="lineNum">    1442 </span>            :   MOZ_ASSERT(NS_AUTOHEIGHT == aFlexItem.GetFlexBaseSize(),
<span class="lineNum">    1443 </span>            :              &quot;Should only be called to resolve an 'auto' flex-basis&quot;);
<span class="lineNum">    1444 </span>            :   // If the flex item has ...
<span class="lineNum">    1445 </span>            :   //  - an intrinsic aspect ratio,
<span class="lineNum">    1446 </span>            :   //  - a [used] flex-basis of 'main-size' [auto?] [We have this, if we're here.]
<span class="lineNum">    1447 </span>            :   //  - a definite cross size
<span class="lineNum">    1448 </span>            :   // then the flex base size is calculated from its inner cross size and the
<span class="lineNum">    1449 </span>            :   // flex item’s intrinsic aspect ratio.
<span class="lineNum">    1450 </span><span class="lineCov">          1 :   if (aAxisTracker.GetCrossComponent(aFlexItem.IntrinsicRatio()) != 0) {</span>
<span class="lineNum">    1451 </span>            :     // We have a usable aspect ratio. (not going to divide by 0)
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     const bool useMinSizeIfCrossSizeIsIndefinite = false;</span>
<span class="lineNum">    1453 </span>            :     nscoord crossSizeToUseWithRatio =
<span class="lineNum">    1454 </span>            :       CrossSizeToUseWithRatio(aFlexItem, aItemReflowInput,
<span class="lineNum">    1455 </span>            :                               useMinSizeIfCrossSizeIsIndefinite,
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                               aAxisTracker);</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     if (crossSizeToUseWithRatio != NS_AUTOHEIGHT) {</span>
<span class="lineNum">    1458 </span>            :       // We have a definite cross-size
<span class="lineNum">    1459 </span>            :       nscoord mainSizeFromRatio =
<span class="lineNum">    1460 </span>            :         MainSizeFromAspectRatio(crossSizeToUseWithRatio,
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :                                 aFlexItem.IntrinsicRatio(), aAxisTracker);</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :       aFlexItem.SetFlexBaseSizeAndMainSize(mainSizeFromRatio);</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1464 </span>            :     }
<span class="lineNum">    1465 </span>            :   }
<span class="lineNum">    1466 </span>            :   return false;
<span class="lineNum">    1467 </span>            : }
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            : // Note: If &amp; when we handle &quot;min-height: min-content&quot; for flex items,
<a name="1470"><span class="lineNum">    1470 </span>            : // we may want to resolve that in this function, too.</a>
<span class="lineNum">    1471 </span>            : void
<span class="lineNum">    1472 </span><span class="lineCov">          1 : nsFlexContainerFrame::</span>
<span class="lineNum">    1473 </span>            :   ResolveAutoFlexBasisAndMinSize(nsPresContext* aPresContext,
<span class="lineNum">    1474 </span>            :                                  FlexItem&amp; aFlexItem,
<span class="lineNum">    1475 </span>            :                                  const ReflowInput&amp; aItemReflowInput,
<span class="lineNum">    1476 </span>            :                                  const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1477 </span>            : {
<span class="lineNum">    1478 </span>            :   // (Note: We should never have a used flex-basis of &quot;auto&quot; if our main axis
<span class="lineNum">    1479 </span>            :   // is horizontal; width values should always be resolvable without reflow.)
<span class="lineNum">    1480 </span><span class="lineCov">          1 :   const bool isMainSizeAuto = (!aAxisTracker.IsMainAxisHorizontal() &amp;&amp;</span>
<span class="lineNum">    1481 </span><span class="lineCov">          1 :                                NS_AUTOHEIGHT == aFlexItem.GetFlexBaseSize());</span>
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">          1 :   const bool isMainMinSizeAuto = aFlexItem.NeedsMinSizeAutoResolution();</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">          1 :   if (!isMainSizeAuto &amp;&amp; !isMainMinSizeAuto) {</span>
<span class="lineNum">    1486 </span>            :     // Nothing to do; this function is only needed for flex items
<span class="lineNum">    1487 </span>            :     // with a used flex-basis of &quot;auto&quot; or a min-main-size of &quot;auto&quot;.
<span class="lineNum">    1488 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1489 </span>            :   }
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            :   // We may be about to do computations based on our item's cross-size
<span class="lineNum">    1492 </span>            :   // (e.g. using it as a contstraint when measuring our content in the
<span class="lineNum">    1493 </span>            :   // main axis, or using it with the intrinsic ratio to obtain a main size).
<span class="lineNum">    1494 </span>            :   // BEFORE WE DO THAT, we need let the item &quot;pre-stretch&quot; its cross size (if
<span class="lineNum">    1495 </span>            :   // it's got 'align-self:stretch'), for a certain case where the spec says
<span class="lineNum">    1496 </span>            :   // the stretched cross size is considered &quot;definite&quot;. That case is if we
<span class="lineNum">    1497 </span>            :   // have a single-line (nowrap) flex container which itself has a definite
<span class="lineNum">    1498 </span>            :   // cross-size.  Otherwise, we'll wait to do stretching, since (in other
<span class="lineNum">    1499 </span>            :   // cases) we don't know how much the item should stretch yet.
<span class="lineNum">    1500 </span><span class="lineCov">          1 :   const ReflowInput* flexContainerRI = aItemReflowInput.mParentReflowInput;</span>
<span class="lineNum">    1501 </span>            :   MOZ_ASSERT(flexContainerRI,
<span class="lineNum">    1502 </span>            :              &quot;flex item's reflow state should have ptr to container's state&quot;);
<span class="lineNum">    1503 </span><span class="lineCov">          1 :   if (NS_STYLE_FLEX_WRAP_NOWRAP == flexContainerRI-&gt;mStylePosition-&gt;mFlexWrap) {</span>
<span class="lineNum">    1504 </span>            :     // XXXdholbert Maybe this should share logic with ComputeCrossSize()...
<span class="lineNum">    1505 </span>            :     // Alternately, maybe tentative container cross size should be passed down.
<span class="lineNum">    1506 </span>            :     nscoord containerCrossSize =
<span class="lineNum">    1507 </span><span class="lineCov">          1 :       GET_CROSS_COMPONENT_LOGICAL(aAxisTracker, aAxisTracker.GetWritingMode(),</span>
<span class="lineNum">    1508 </span>            :                                   flexContainerRI-&gt;ComputedISize(),
<span class="lineNum">    1509 </span>            :                                   flexContainerRI-&gt;ComputedBSize());
<span class="lineNum">    1510 </span>            :     // Is container's cross size &quot;definite&quot;?
<span class="lineNum">    1511 </span>            :     // (Container's cross size is definite if cross-axis is horizontal, or if
<span class="lineNum">    1512 </span>            :     // cross-axis is vertical and the cross-size is not NS_AUTOHEIGHT.)
<span class="lineNum">    1513 </span><span class="lineCov">          1 :     if (aAxisTracker.IsCrossAxisHorizontal() ||</span>
<span class="lineNum">    1514 </span>            :         containerCrossSize != NS_AUTOHEIGHT) {
<span class="lineNum">    1515 </span><span class="lineCov">          1 :       aFlexItem.ResolveStretchedCrossSize(containerCrossSize, aAxisTracker);</span>
<span class="lineNum">    1516 </span>            :     }
<span class="lineNum">    1517 </span>            :   }
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            :   nscoord resolvedMinSize; // (only set/used if isMainMinSizeAuto==true)
<span class="lineNum">    1520 </span><span class="lineCov">          1 :   bool minSizeNeedsToMeasureContent = false; // assume the best</span>
<span class="lineNum">    1521 </span><span class="lineCov">          1 :   if (isMainMinSizeAuto) {</span>
<span class="lineNum">    1522 </span>            :     // Resolve the min-size, except for considering the min-content size.
<span class="lineNum">    1523 </span>            :     // (We'll consider that later, if we need to.)
<span class="lineNum">    1524 </span>            :     resolvedMinSize = PartiallyResolveAutoMinSize(aFlexItem, aItemReflowInput,
<span class="lineNum">    1525 </span><span class="lineCov">          1 :                                                   aAxisTracker);</span>
<span class="lineNum">    1526 </span><span class="lineCov">          1 :     if (resolvedMinSize &gt; 0 &amp;&amp;</span>
<span class="lineNum">    1527 </span><span class="lineCov">          1 :         aAxisTracker.GetCrossComponent(aFlexItem.IntrinsicRatio()) == 0) {</span>
<span class="lineNum">    1528 </span>            :       // We don't have a usable aspect ratio, so we need to consider our
<span class="lineNum">    1529 </span>            :       // min-content size as another candidate min-size, which we'll have to
<span class="lineNum">    1530 </span>            :       // min() with the current resolvedMinSize.
<span class="lineNum">    1531 </span>            :       // (If resolvedMinSize were already at 0, we could skip this measurement
<span class="lineNum">    1532 </span>            :       // because it can't go any lower. But it's not 0, so we need it.)
<span class="lineNum">    1533 </span><span class="lineCov">          1 :       minSizeNeedsToMeasureContent = true;</span>
<span class="lineNum">    1534 </span>            :     }
<span class="lineNum">    1535 </span>            :   }
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">          1 :   bool flexBasisNeedsToMeasureContent = false; // assume the best</span>
<span class="lineNum">    1538 </span><span class="lineCov">          1 :   if (isMainSizeAuto) {</span>
<span class="lineNum">    1539 </span><span class="lineCov">          1 :     if (!ResolveAutoFlexBasisFromRatio(aFlexItem, aItemReflowInput,</span>
<span class="lineNum">    1540 </span><span class="lineCov">          1 :                                        aAxisTracker)) {</span>
<span class="lineNum">    1541 </span><span class="lineCov">          1 :       flexBasisNeedsToMeasureContent = true;</span>
<span class="lineNum">    1542 </span>            :     }
<span class="lineNum">    1543 </span>            :   }
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            :   // Measure content, if needed (w/ intrinsic-width method or a reflow)
<span class="lineNum">    1546 </span><span class="lineCov">          1 :   if (minSizeNeedsToMeasureContent || flexBasisNeedsToMeasureContent) {</span>
<span class="lineNum">    1547 </span><span class="lineCov">          1 :     if (aAxisTracker.IsMainAxisHorizontal()) {</span>
<span class="lineNum">    1548 </span><span class="lineCov">          1 :       if (minSizeNeedsToMeasureContent) {</span>
<span class="lineNum">    1549 </span>            :         nscoord frameMinISize =
<span class="lineNum">    1550 </span><span class="lineCov">          1 :           aFlexItem.Frame()-&gt;GetMinISize(aItemReflowInput.mRenderingContext);</span>
<span class="lineNum">    1551 </span><span class="lineCov">          1 :         resolvedMinSize = std::min(resolvedMinSize, frameMinISize);</span>
<span class="lineNum">    1552 </span>            :       }
<span class="lineNum">    1553 </span>            :       NS_ASSERTION(!flexBasisNeedsToMeasureContent,
<span class="lineNum">    1554 </span>            :                    &quot;flex-basis:auto should have been resolved in the &quot;
<span class="lineNum">    1555 </span>            :                    &quot;reflow state, for horizontal flexbox. It shouldn't need &quot;
<span class="lineNum">    1556 </span>            :                    &quot;special handling here&quot;);
<span class="lineNum">    1557 </span>            :     } else {
<span class="lineNum">    1558 </span>            :       // If this item is flexible (vertically), or if we're measuring the
<span class="lineNum">    1559 </span>            :       // 'auto' min-height and our main-size is something else, then we assume
<span class="lineNum">    1560 </span>            :       // that the computed-height we're reflowing with now could be different
<span class="lineNum">    1561 </span>            :       // from the one we'll use for this flex item's &quot;actual&quot; reflow later on.
<span class="lineNum">    1562 </span>            :       // In that case, we need to be sure the flex item treats this as a
<span class="lineNum">    1563 </span>            :       // vertical resize, even though none of its ancestors are necessarily
<span class="lineNum">    1564 </span>            :       // being vertically resized.
<span class="lineNum">    1565 </span>            :       // (Note: We don't have to do this for width, because InitResizeFlags
<span class="lineNum">    1566 </span>            :       // will always turn on mHResize on when it sees that the computed width
<span class="lineNum">    1567 </span>            :       // is different from current width, and that's all we need.)
<span class="lineNum">    1568 </span>            :       bool forceVerticalResizeForMeasuringReflow =
<span class="lineNum">    1569 </span><span class="lineCov">          1 :         !aFlexItem.IsFrozen() ||         // Is the item flexible?</span>
<span class="lineNum">    1570 </span><span class="lineCov">          1 :         !flexBasisNeedsToMeasureContent; // Are we *only* measuring it for</span>
<span class="lineNum">    1571 </span>            :                                          // 'min-height:auto'?
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span>            :       nscoord contentHeight =
<span class="lineNum">    1574 </span>            :         MeasureFlexItemContentHeight(aPresContext, aFlexItem,
<span class="lineNum">    1575 </span>            :                                      forceVerticalResizeForMeasuringReflow,
<span class="lineNum">    1576 </span><span class="lineCov">          1 :                                      *flexContainerRI);</span>
<span class="lineNum">    1577 </span><span class="lineCov">          1 :       if (minSizeNeedsToMeasureContent) {</span>
<span class="lineNum">    1578 </span><span class="lineCov">          1 :         resolvedMinSize = std::min(resolvedMinSize, contentHeight);</span>
<span class="lineNum">    1579 </span>            :       }
<span class="lineNum">    1580 </span><span class="lineCov">          1 :       if (flexBasisNeedsToMeasureContent) {</span>
<span class="lineNum">    1581 </span><span class="lineCov">          1 :         aFlexItem.SetFlexBaseSizeAndMainSize(contentHeight);</span>
<span class="lineNum">    1582 </span>            :       }
<span class="lineNum">    1583 </span>            :     }
<span class="lineNum">    1584 </span>            :   }
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span><span class="lineCov">          1 :   if (isMainMinSizeAuto) {</span>
<span class="lineNum">    1587 </span><span class="lineCov">          1 :     aFlexItem.UpdateMainMinSize(resolvedMinSize);</span>
<span class="lineNum">    1588 </span>            :   }
<span class="lineNum">    1589 </span>            : }
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            : /**
<span class="lineNum">    1592 </span>            :  * A cached result for a measuring reflow.
<span class="lineNum">    1593 </span>            :  *
<span class="lineNum">    1594 </span>            :  * Right now we only need to cache the available size and the computed height
<span class="lineNum">    1595 </span>            :  * for checking that the reflow input is valid, and the height and the ascent
<span class="lineNum">    1596 </span>            :  * to be used. This can be extended later if needed.
<span class="lineNum">    1597 </span>            :  *
<span class="lineNum">    1598 </span>            :  * The assumption here is that a given flex item measurement won't change until
<span class="lineNum">    1599 </span>            :  * either the available size or computed height changes, or the flex container
<span class="lineNum">    1600 </span>            :  * intrinsic size is marked as dirty (due to a style or DOM change).
<span class="lineNum">    1601 </span>            :  *
<span class="lineNum">    1602 </span>            :  * In particular the computed height may change between measuring reflows due to
<span class="lineNum">    1603 </span>            :  * how the mIsFlexContainerMeasuringReflow flag affects size computation (see
<span class="lineNum">    1604 </span>            :  * bug 1336708).
<span class="lineNum">    1605 </span>            :  *
<span class="lineNum">    1606 </span>            :  * Caching it prevents us from doing exponential reflows in cases of deeply
<span class="lineNum">    1607 </span>            :  * nested flex and scroll frames.
<span class="lineNum">    1608 </span>            :  *
<span class="lineNum">    1609 </span>            :  * We store them in the frame property table for simplicity.
<span class="lineNum">    1610 </span>            :  */
<span class="lineNum">    1611 </span>            : class nsFlexContainerFrame::CachedMeasuringReflowResult
<span class="lineNum">    1612 </span>            : {
<span class="lineNum">    1613 </span>            :   // Members that are part of the cache key:
<span class="lineNum">    1614 </span>            :   const LogicalSize mAvailableSize;
<span class="lineNum">    1615 </span>            :   const nscoord mComputedHeight;
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            :   // Members that are part of the cache value:
<span class="lineNum">    1618 </span>            :   const nscoord mHeight;
<span class="lineNum">    1619 </span>            :   const nscoord mAscent;
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<span class="lineNum">    1621 </span>            : public:
<span class="lineNum">    1622 </span><span class="lineCov">          1 :   CachedMeasuringReflowResult(const ReflowInput&amp; aReflowInput,</span>
<span class="lineNum">    1623 </span>            :                               const ReflowOutput&amp; aDesiredSize)
<span class="lineNum">    1624 </span>            :     : mAvailableSize(aReflowInput.AvailableSize())
<span class="lineNum">    1625 </span><span class="lineCov">          1 :     , mComputedHeight(aReflowInput.ComputedHeight())</span>
<span class="lineNum">    1626 </span><span class="lineCov">          1 :     , mHeight(aDesiredSize.Height())</span>
<span class="lineNum">    1627 </span><span class="lineCov">          1 :     , mAscent(aDesiredSize.BlockStartAscent())</span>
<a name="1628"><span class="lineNum">    1628 </span><span class="lineCov">          1 :   {}</span></a>
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span><span class="lineCov">          1 :   bool IsValidFor(const ReflowInput&amp; aReflowInput) const {</span>
<span class="lineNum">    1631 </span><span class="lineCov">          1 :     return mAvailableSize == aReflowInput.AvailableSize() &amp;&amp;</span>
<span class="lineNum">    1632 </span><span class="lineCov">          1 :       mComputedHeight == aReflowInput.ComputedHeight();</span>
<span class="lineNum">    1633 </span>            :   }
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            :   nscoord Height() const { return mHeight; }
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span>            :   nscoord Ascent() const { return mAscent; }
<span class="lineNum">    1638 </span>            : };
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            : NS_DECLARE_FRAME_PROPERTY_DELETABLE(CachedFlexMeasuringReflow,
<span class="lineNum">    1641 </span>            :                                     CachedMeasuringReflowResult);
<a name="1642"><span class="lineNum">    1642 </span>            : </a>
<span class="lineNum">    1643 </span>            : const CachedMeasuringReflowResult&amp;
<span class="lineNum">    1644 </span><span class="lineCov">          1 : nsFlexContainerFrame::MeasureAscentAndHeightForFlexItem(</span>
<span class="lineNum">    1645 </span>            :   FlexItem&amp; aItem,
<span class="lineNum">    1646 </span>            :   nsPresContext* aPresContext,
<span class="lineNum">    1647 </span>            :   ReflowInput&amp; aChildReflowInput)
<span class="lineNum">    1648 </span>            : {
<span class="lineNum">    1649 </span><span class="lineCov">          1 :   const FrameProperties props = aItem.Frame()-&gt;Properties();</span>
<span class="lineNum">    1650 </span><span class="lineCov">          1 :   if (const auto* cachedResult = props.Get(CachedFlexMeasuringReflow())) {</span>
<span class="lineNum">    1651 </span><span class="lineCov">          1 :     if (cachedResult-&gt;IsValidFor(aChildReflowInput)) {</span>
<span class="lineNum">    1652 </span>            :       return *cachedResult;
<span class="lineNum">    1653 </span>            :     }
<span class="lineNum">    1654 </span>            :   }
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">          1 :   ReflowOutput childDesiredSize(aChildReflowInput);</span>
<span class="lineNum">    1657 </span><span class="lineCov">          1 :   nsReflowStatus childReflowStatus;</span>
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span><span class="lineCov">          1 :   const uint32_t flags = NS_FRAME_NO_MOVE_FRAME;</span>
<span class="lineNum">    1660 </span>            :   ReflowChild(aItem.Frame(), aPresContext,
<span class="lineNum">    1661 </span>            :               childDesiredSize, aChildReflowInput,
<span class="lineNum">    1662 </span><span class="lineCov">          1 :               0, 0, flags, childReflowStatus);</span>
<span class="lineNum">    1663 </span><span class="lineCov">          1 :   aItem.SetHadMeasuringReflow();</span>
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            :   // XXXdholbert Once we do pagination / splitting, we'll need to actually
<span class="lineNum">    1666 </span>            :   // handle incomplete childReflowStatuses. But for now, we give our kids
<span class="lineNum">    1667 </span>            :   // unconstrained available height, which means they should always complete.
<span class="lineNum">    1668 </span>            :   MOZ_ASSERT(childReflowStatus.IsComplete(),
<span class="lineNum">    1669 </span>            :              &quot;We gave flex item unconstrained available height, so it &quot;
<span class="lineNum">    1670 </span>            :              &quot;should be complete&quot;);
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            :   // Tell the child we're done with its initial reflow.
<span class="lineNum">    1673 </span>            :   // (Necessary for e.g. GetBaseline() to work below w/out asserting)
<span class="lineNum">    1674 </span>            :   FinishReflowChild(aItem.Frame(), aPresContext,
<span class="lineNum">    1675 </span><span class="lineCov">          1 :                     childDesiredSize, &amp;aChildReflowInput, 0, 0, flags);</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            :   auto result =
<span class="lineNum">    1678 </span><span class="lineCov">          1 :     new CachedMeasuringReflowResult(aChildReflowInput, childDesiredSize);</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineCov">          1 :   props.Set(CachedFlexMeasuringReflow(), result);</span>
<span class="lineNum">    1681 </span><span class="lineCov">          1 :   return *result;</span>
<span class="lineNum">    1682 </span>            : }
<a name="1683"><span class="lineNum">    1683 </span>            : </a>
<span class="lineNum">    1684 </span>            : /* virtual */ void
<span class="lineNum">    1685 </span><span class="lineCov">          1 : nsFlexContainerFrame::MarkIntrinsicISizesDirty()</span>
<span class="lineNum">    1686 </span>            : {
<span class="lineNum">    1687 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : mFrames) {</span>
<span class="lineNum">    1688 </span><span class="lineCov">          1 :     childFrame-&gt;Properties().Delete(CachedFlexMeasuringReflow());</span>
<span class="lineNum">    1689 </span>            :   }
<span class="lineNum">    1690 </span><span class="lineCov">          1 :   nsContainerFrame::MarkIntrinsicISizesDirty();</span>
<span class="lineNum">    1691 </span><span class="lineCov">          1 : }</span>
<a name="1692"><span class="lineNum">    1692 </span>            : </a>
<span class="lineNum">    1693 </span>            : nscoord
<span class="lineNum">    1694 </span><span class="lineCov">          1 : nsFlexContainerFrame::</span>
<span class="lineNum">    1695 </span>            :   MeasureFlexItemContentHeight(nsPresContext* aPresContext,
<span class="lineNum">    1696 </span>            :                                FlexItem&amp; aFlexItem,
<span class="lineNum">    1697 </span>            :                                bool aForceVerticalResizeForMeasuringReflow,
<span class="lineNum">    1698 </span>            :                                const ReflowInput&amp; aParentReflowInput)
<span class="lineNum">    1699 </span>            : {
<span class="lineNum">    1700 </span>            :   // Set up a reflow state for measuring the flex item's auto-height:
<span class="lineNum">    1701 </span><span class="lineCov">          1 :   WritingMode wm = aFlexItem.Frame()-&gt;GetWritingMode();</span>
<span class="lineNum">    1702 </span><span class="lineCov">          1 :   LogicalSize availSize = aParentReflowInput.ComputedSize(wm);</span>
<span class="lineNum">    1703 </span><span class="lineCov">          1 :   availSize.BSize(wm) = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">    1704 </span>            :   ReflowInput
<span class="lineNum">    1705 </span>            :     childRIForMeasuringHeight(aPresContext, aParentReflowInput,
<span class="lineNum">    1706 </span>            :                               aFlexItem.Frame(), availSize,
<span class="lineNum">    1707 </span><span class="lineCov">          1 :                               nullptr, ReflowInput::CALLER_WILL_INIT);</span>
<span class="lineNum">    1708 </span><span class="lineCov">          1 :   childRIForMeasuringHeight.mFlags.mIsFlexContainerMeasuringHeight = true;</span>
<span class="lineNum">    1709 </span><span class="lineCov">          1 :   childRIForMeasuringHeight.Init(aPresContext);</span>
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span><span class="lineCov">          1 :   if (aFlexItem.IsStretched()) {</span>
<span class="lineNum">    1712 </span><span class="lineCov">          1 :     childRIForMeasuringHeight.SetComputedWidth(aFlexItem.GetCrossSize());</span>
<span class="lineNum">    1713 </span><span class="lineCov">          1 :     childRIForMeasuringHeight.SetHResize(true);</span>
<span class="lineNum">    1714 </span>            :   }
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span><span class="lineCov">          1 :   if (aForceVerticalResizeForMeasuringReflow) {</span>
<span class="lineNum">    1717 </span><span class="lineCov">          1 :     childRIForMeasuringHeight.SetVResize(true);</span>
<span class="lineNum">    1718 </span>            :   }
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :   const CachedMeasuringReflowResult&amp; reflowResult =
<span class="lineNum">    1721 </span>            :     MeasureAscentAndHeightForFlexItem(aFlexItem, aPresContext,
<span class="lineNum">    1722 </span><span class="lineCov">          1 :                                       childRIForMeasuringHeight);</span>
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineCov">          1 :   aFlexItem.SetAscent(reflowResult.Ascent());</span>
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :   // Subtract border/padding in vertical axis, to get _just_
<span class="lineNum">    1727 </span>            :   // the effective computed value of the &quot;height&quot; property.
<span class="lineNum">    1728 </span><span class="lineCov">          1 :   nscoord childDesiredHeight = reflowResult.Height() -</span>
<span class="lineNum">    1729 </span><span class="lineCov">          1 :     childRIForMeasuringHeight.ComputedPhysicalBorderPadding().TopBottom();</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span><span class="lineCov">          1 :   return std::max(0, childDesiredHeight);</span>
<a name="1732"><span class="lineNum">    1732 </span>            : }</a>
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span><span class="lineCov">          1 : FlexItem::FlexItem(ReflowInput&amp; aFlexItemReflowInput,</span>
<span class="lineNum">    1735 </span>            :                    float aFlexGrow, float aFlexShrink, nscoord aFlexBaseSize,
<span class="lineNum">    1736 </span>            :                    nscoord aMainMinSize,  nscoord aMainMaxSize,
<span class="lineNum">    1737 </span>            :                    nscoord aTentativeCrossSize,
<span class="lineNum">    1738 </span>            :                    nscoord aCrossMinSize, nscoord aCrossMaxSize,
<span class="lineNum">    1739 </span>            :                    const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1740 </span>            :   : mFrame(aFlexItemReflowInput.mFrame),
<span class="lineNum">    1741 </span>            :     mFlexGrow(aFlexGrow),
<span class="lineNum">    1742 </span>            :     mFlexShrink(aFlexShrink),
<span class="lineNum">    1743 </span><span class="lineCov">          1 :     mIntrinsicRatio(mFrame-&gt;GetIntrinsicRatio()),</span>
<span class="lineNum">    1744 </span><span class="lineCov">          1 :     mBorderPadding(aFlexItemReflowInput.ComputedPhysicalBorderPadding()),</span>
<span class="lineNum">    1745 </span><span class="lineCov">          1 :     mMargin(aFlexItemReflowInput.ComputedPhysicalMargin()),</span>
<span class="lineNum">    1746 </span>            :     mMainMinSize(aMainMinSize),
<span class="lineNum">    1747 </span>            :     mMainMaxSize(aMainMaxSize),
<span class="lineNum">    1748 </span>            :     mCrossMinSize(aCrossMinSize),
<span class="lineNum">    1749 </span>            :     mCrossMaxSize(aCrossMaxSize),
<span class="lineNum">    1750 </span>            :     mMainPosn(0),
<span class="lineNum">    1751 </span>            :     mCrossSize(aTentativeCrossSize),
<span class="lineNum">    1752 </span>            :     mCrossPosn(0),
<span class="lineNum">    1753 </span>            :     mAscent(0),
<span class="lineNum">    1754 </span>            :     mShareOfWeightSoFar(0.0f),
<span class="lineNum">    1755 </span>            :     mIsFrozen(false),
<span class="lineNum">    1756 </span>            :     mHadMinViolation(false),
<span class="lineNum">    1757 </span>            :     mHadMaxViolation(false),
<span class="lineNum">    1758 </span>            :     mHadMeasuringReflow(false),
<span class="lineNum">    1759 </span>            :     mIsStretched(false),
<span class="lineNum">    1760 </span>            :     mIsStrut(false),
<span class="lineNum">    1761 </span>            :     // mNeedsMinSizeAutoResolution is initialized in CheckForMinSizeAuto()
<span class="lineNum">    1762 </span><span class="lineCov">          1 :     mWM(aFlexItemReflowInput.GetWritingMode())</span>
<span class="lineNum">    1763 </span>            :     // mAlignSelf, see below
<span class="lineNum">    1764 </span>            : {
<span class="lineNum">    1765 </span>            :   MOZ_ASSERT(mFrame, &quot;expecting a non-null child frame&quot;);
<span class="lineNum">    1766 </span>            :   MOZ_ASSERT(mFrame-&gt;GetType() != nsGkAtoms::placeholderFrame,
<span class="lineNum">    1767 </span>            :              &quot;placeholder frames should not be treated as flex items&quot;);
<span class="lineNum">    1768 </span>            :   MOZ_ASSERT(!(mFrame-&gt;GetStateBits() &amp; NS_FRAME_OUT_OF_FLOW),
<span class="lineNum">    1769 </span>            :              &quot;out-of-flow frames should not be treated as flex items&quot;);
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineCov">          1 :   const ReflowInput* containerRS = aFlexItemReflowInput.mParentReflowInput;</span>
<span class="lineNum">    1772 </span><span class="lineCov">          1 :   if (IsLegacyBox(containerRS-&gt;mFrame)) {</span>
<span class="lineNum">    1773 </span>            :     // For -webkit-box/-webkit-inline-box, we need to:
<span class="lineNum">    1774 </span>            :     // (1) Use &quot;-webkit-box-align&quot; instead of &quot;align-items&quot; to determine the
<span class="lineNum">    1775 </span>            :     //     container's cross-axis alignment behavior.
<span class="lineNum">    1776 </span>            :     // (2) Suppress the ability for flex items to override that with their own
<span class="lineNum">    1777 </span>            :     //     cross-axis alignment. (The legacy box model doesn't support this.)
<span class="lineNum">    1778 </span>            :     // So, each FlexItem simply copies the container's converted &quot;align-items&quot;
<span class="lineNum">    1779 </span>            :     // value and disregards their own &quot;align-self&quot; property.
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :     const nsStyleXUL* containerStyleXUL = containerRS-&gt;mFrame-&gt;StyleXUL();</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :     mAlignSelf = ConvertLegacyStyleToAlignItems(containerStyleXUL);</span>
<span class="lineNum">    1782 </span>            :   } else {
<span class="lineNum">    1783 </span>            :     mAlignSelf = aFlexItemReflowInput.mStylePosition-&gt;UsedAlignSelf(
<span class="lineNum">    1784 </span><span class="lineCov">          1 :                    containerRS-&gt;mFrame-&gt;StyleContext());</span>
<span class="lineNum">    1785 </span><span class="lineCov">          1 :     if (MOZ_LIKELY(mAlignSelf == NS_STYLE_ALIGN_NORMAL)) {</span>
<span class="lineNum">    1786 </span><span class="lineCov">          1 :       mAlignSelf = NS_STYLE_ALIGN_STRETCH;</span>
<span class="lineNum">    1787 </span>            :     }
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            :     // XXX strip off the &lt;overflow-position&gt; bit until we implement that
<span class="lineNum">    1790 </span><span class="lineCov">          1 :     mAlignSelf &amp;= ~NS_STYLE_ALIGN_FLAG_BITS;</span>
<span class="lineNum">    1791 </span>            :   }
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span><span class="lineCov">          1 :   SetFlexBaseSizeAndMainSize(aFlexBaseSize);</span>
<span class="lineNum">    1794 </span><span class="lineCov">          1 :   CheckForMinSizeAuto(aFlexItemReflowInput, aAxisTracker);</span>
<span class="lineNum">    1795 </span>            : 
<span class="lineNum">    1796 </span>            :   // Assert that any &quot;auto&quot; margin components are set to 0.
<span class="lineNum">    1797 </span>            :   // (We'll resolve them later; until then, we want to treat them as 0-sized.)
<span class="lineNum">    1798 </span>            : #ifdef DEBUG
<span class="lineNum">    1799 </span>            :   {
<span class="lineNum">    1800 </span>            :     const nsStyleSides&amp; styleMargin =
<span class="lineNum">    1801 </span>            :       aFlexItemReflowInput.mStyleMargin-&gt;mMargin;
<span class="lineNum">    1802 </span>            :     NS_FOR_CSS_SIDES(side) {
<span class="lineNum">    1803 </span>            :       if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {
<span class="lineNum">    1804 </span>            :         MOZ_ASSERT(GetMarginComponentForSide(side) == 0,
<span class="lineNum">    1805 </span>            :                    &quot;Someone else tried to resolve our auto margin&quot;);
<span class="lineNum">    1806 </span>            :       }
<span class="lineNum">    1807 </span>            :     }
<span class="lineNum">    1808 </span>            :   }
<span class="lineNum">    1809 </span>            : #endif // DEBUG
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span>            :   // Map align-self 'baseline' value to 'start' when baseline alignment
<span class="lineNum">    1812 </span>            :   // is not possible because the FlexItem's writing mode is orthogonal to
<span class="lineNum">    1813 </span>            :   // the main axis of the container. If that's the case, we just directly
<span class="lineNum">    1814 </span>            :   // convert our align-self value here, so that we don't have to handle this
<span class="lineNum">    1815 </span>            :   // with special cases elsewhere.
<span class="lineNum">    1816 </span>            :   // We are treating this case as one where it is appropriate to use the
<span class="lineNum">    1817 </span>            :   // fallback values defined at https://www.w3.org/TR/css-align-3/#baseline
<span class="lineNum">    1818 </span><span class="lineCov">          1 :   if (aAxisTracker.IsRowOriented() ==</span>
<span class="lineNum">    1819 </span><span class="lineCov">          1 :       aAxisTracker.GetWritingMode().IsOrthogonalTo(mWM)) {</span>
<span class="lineNum">    1820 </span><span class="lineCov">          1 :     if (mAlignSelf == NS_STYLE_ALIGN_BASELINE) {</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :       mAlignSelf = NS_STYLE_ALIGN_FLEX_START;</span>
<span class="lineNum">    1822 </span><span class="lineCov">          1 :     } else if (mAlignSelf == NS_STYLE_ALIGN_LAST_BASELINE) {</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :       mAlignSelf = NS_STYLE_ALIGN_FLEX_END;</span>
<span class="lineNum">    1824 </span>            :     }
<span class="lineNum">    1825 </span>            :   }
<span class="lineNum">    1826 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span>            : // Simplified constructor for creating a special &quot;strut&quot; FlexItem, for a child
<a name="1829"><span class="lineNum">    1829 </span>            : // with visibility:collapse. The strut has 0 main-size, and it only exists to</a>
<span class="lineNum">    1830 </span>            : // impose a minimum cross size on whichever FlexLine it ends up in.
<span class="lineNum">    1831 </span><span class="lineCov">          1 : FlexItem::FlexItem(nsIFrame* aChildFrame, nscoord aCrossSize,</span>
<span class="lineNum">    1832 </span>            :                    WritingMode aContainerWM)
<span class="lineNum">    1833 </span>            :   : mFrame(aChildFrame),
<span class="lineNum">    1834 </span>            :     mFlexGrow(0.0f),
<span class="lineNum">    1835 </span>            :     mFlexShrink(0.0f),
<span class="lineNum">    1836 </span>            :     mIntrinsicRatio(),
<span class="lineNum">    1837 </span>            :     // mBorderPadding uses default constructor,
<span class="lineNum">    1838 </span>            :     // mMargin uses default constructor,
<span class="lineNum">    1839 </span>            :     mFlexBaseSize(0),
<span class="lineNum">    1840 </span>            :     mMainMinSize(0),
<span class="lineNum">    1841 </span>            :     mMainMaxSize(0),
<span class="lineNum">    1842 </span>            :     mCrossMinSize(0),
<span class="lineNum">    1843 </span>            :     mCrossMaxSize(0),
<span class="lineNum">    1844 </span>            :     mMainSize(0),
<span class="lineNum">    1845 </span>            :     mMainPosn(0),
<span class="lineNum">    1846 </span>            :     mCrossSize(aCrossSize),
<span class="lineNum">    1847 </span>            :     mCrossPosn(0),
<span class="lineNum">    1848 </span>            :     mAscent(0),
<span class="lineNum">    1849 </span>            :     mShareOfWeightSoFar(0.0f),
<span class="lineNum">    1850 </span>            :     mIsFrozen(true),
<span class="lineNum">    1851 </span>            :     mHadMinViolation(false),
<span class="lineNum">    1852 </span>            :     mHadMaxViolation(false),
<span class="lineNum">    1853 </span>            :     mHadMeasuringReflow(false),
<span class="lineNum">    1854 </span>            :     mIsStretched(false),
<span class="lineNum">    1855 </span>            :     mIsStrut(true), // (this is the constructor for making struts, after all)
<span class="lineNum">    1856 </span>            :     mNeedsMinSizeAutoResolution(false),
<span class="lineNum">    1857 </span>            :     mWM(aContainerWM),
<span class="lineNum">    1858 </span><span class="lineCov">          1 :     mAlignSelf(NS_STYLE_ALIGN_FLEX_START)</span>
<span class="lineNum">    1859 </span>            : {
<span class="lineNum">    1860 </span>            :   MOZ_ASSERT(mFrame, &quot;expecting a non-null child frame&quot;);
<span class="lineNum">    1861 </span>            :   MOZ_ASSERT(NS_STYLE_VISIBILITY_COLLAPSE ==
<span class="lineNum">    1862 </span>            :              mFrame-&gt;StyleVisibility()-&gt;mVisible,
<span class="lineNum">    1863 </span>            :              &quot;Should only make struts for children with 'visibility:collapse'&quot;);
<span class="lineNum">    1864 </span>            :   MOZ_ASSERT(mFrame-&gt;GetType() != nsGkAtoms::placeholderFrame,
<span class="lineNum">    1865 </span>            :              &quot;placeholder frames should not be treated as flex items&quot;);
<span class="lineNum">    1866 </span>            :   MOZ_ASSERT(!(mFrame-&gt;GetStateBits() &amp; NS_FRAME_OUT_OF_FLOW),
<span class="lineNum">    1867 </span>            :              &quot;out-of-flow frames should not be treated as flex items&quot;);
<span class="lineNum">    1868 </span><span class="lineCov">          1 : }</span>
<a name="1869"><span class="lineNum">    1869 </span>            : </a>
<span class="lineNum">    1870 </span>            : void
<span class="lineNum">    1871 </span><span class="lineCov">          1 : FlexItem::CheckForMinSizeAuto(const ReflowInput&amp; aFlexItemReflowInput,</span>
<span class="lineNum">    1872 </span>            :                               const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    1873 </span>            : {
<span class="lineNum">    1874 </span><span class="lineCov">          1 :   const nsStylePosition* pos = aFlexItemReflowInput.mStylePosition;</span>
<span class="lineNum">    1875 </span><span class="lineCov">          1 :   const nsStyleDisplay* disp = aFlexItemReflowInput.mStyleDisplay;</span>
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            :   // We'll need special behavior for &quot;min-[width|height]:auto&quot; (whichever is in
<span class="lineNum">    1878 </span>            :   // the main axis) iff:
<span class="lineNum">    1879 </span>            :   // (a) its computed value is &quot;auto&quot;
<span class="lineNum">    1880 </span>            :   // (b) the &quot;overflow&quot; sub-property in the same axis (the main axis) has a
<span class="lineNum">    1881 </span>            :   //     computed value of &quot;visible&quot;
<span class="lineNum">    1882 </span><span class="lineCov">          1 :   const nsStyleCoord&amp; minSize = GET_MAIN_COMPONENT(aAxisTracker,</span>
<span class="lineNum">    1883 </span>            :                                                    pos-&gt;mMinWidth,
<span class="lineNum">    1884 </span>            :                                                    pos-&gt;mMinHeight);
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineCov">          1 :   const uint8_t overflowVal = GET_MAIN_COMPONENT(aAxisTracker,</span>
<span class="lineNum">    1887 </span>            :                                                  disp-&gt;mOverflowX,
<span class="lineNum">    1888 </span>            :                                                  disp-&gt;mOverflowY);
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineCov">          1 :   mNeedsMinSizeAutoResolution = (minSize.GetUnit() == eStyleUnit_Auto &amp;&amp;</span>
<span class="lineNum">    1891 </span><span class="lineCov">          1 :                                  overflowVal == NS_STYLE_OVERFLOW_VISIBLE);</span>
<span class="lineNum">    1892 </span><span class="lineCov">          1 : }</span>
<a name="1893"><span class="lineNum">    1893 </span>            : </a>
<span class="lineNum">    1894 </span>            : nscoord
<span class="lineNum">    1895 </span><span class="lineCov">          1 : FlexItem::GetBaselineOffsetFromOuterCrossEdge(</span>
<span class="lineNum">    1896 </span>            :   AxisEdgeType aEdge,
<span class="lineNum">    1897 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    1898 </span>            :   bool aUseFirstLineBaseline) const
<span class="lineNum">    1899 </span>            : {
<span class="lineNum">    1900 </span>            :   // NOTE: Currently, 'mAscent' (taken from reflow) is an inherently vertical
<span class="lineNum">    1901 </span>            :   // measurement -- it's the distance from the border-top edge of this FlexItem
<span class="lineNum">    1902 </span>            :   // to its baseline. So, we can really only do baseline alignment when the
<span class="lineNum">    1903 </span>            :   // cross axis is vertical. (The FlexItem constructor enforces this when
<span class="lineNum">    1904 </span>            :   // resolving the item's &quot;mAlignSelf&quot; value).
<span class="lineNum">    1905 </span>            :   MOZ_ASSERT(!aAxisTracker.IsCrossAxisHorizontal(),
<span class="lineNum">    1906 </span>            :              &quot;Only expecting to be doing baseline computations when the &quot;
<span class="lineNum">    1907 </span>            :              &quot;cross axis is vertical&quot;);
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span><span class="lineCov">          1 :   AxisOrientationType crossAxis = aAxisTracker.GetCrossAxis();</span>
<span class="lineNum">    1910 </span><span class="lineCov">          1 :   mozilla::Side sideToMeasureFrom = kAxisOrientationToSidesMap[crossAxis][aEdge];</span>
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span><span class="lineCov">          1 :   nscoord marginTopToBaseline = ResolvedAscent(aUseFirstLineBaseline) +</span>
<span class="lineNum">    1913 </span><span class="lineCov">          1 :                                 mMargin.top;</span>
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span><span class="lineCov">          1 :   if (sideToMeasureFrom == eSideTop) {</span>
<span class="lineNum">    1916 </span>            :     // Measuring from top (normal case): the distance from the margin-box top
<span class="lineNum">    1917 </span>            :     // edge to the baseline is just ascent + margin-top.
<span class="lineNum">    1918 </span>            :     return marginTopToBaseline;
<span class="lineNum">    1919 </span>            :   }
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span>            :   MOZ_ASSERT(sideToMeasureFrom == eSideBottom,
<span class="lineNum">    1922 </span>            :              &quot;We already checked that we're dealing with a vertical axis, and &quot;
<span class="lineNum">    1923 </span>            :              &quot;we're not using the top side, so that only leaves the bottom...&quot;);
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span>            :   // Measuring from bottom: The distance from the margin-box bottom edge to the
<span class="lineNum">    1926 </span>            :   // baseline is just the margin-box cross size (i.e. outer cross size), minus
<span class="lineNum">    1927 </span>            :   // the already-computed distance from margin-top to baseline.
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :   return GetOuterCrossSize(crossAxis) - marginTopToBaseline;</span>
<span class="lineNum">    1929 </span>            : }
<a name="1930"><span class="lineNum">    1930 </span>            : </a>
<span class="lineNum">    1931 </span>            : uint32_t
<span class="lineNum">    1932 </span><span class="lineCov">          1 : FlexItem::GetNumAutoMarginsInAxis(AxisOrientationType aAxis) const</span>
<span class="lineNum">    1933 </span>            : {
<span class="lineNum">    1934 </span><span class="lineCov">          1 :   uint32_t numAutoMargins = 0;</span>
<span class="lineNum">    1935 </span><span class="lineCov">          1 :   const nsStyleSides&amp; styleMargin = mFrame-&gt;StyleMargin()-&gt;mMargin;</span>
<span class="lineNum">    1936 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; eNumAxisEdges; i++) {</span>
<span class="lineNum">    1937 </span><span class="lineCov">          1 :     mozilla::Side side = kAxisOrientationToSidesMap[aAxis][i];</span>
<span class="lineNum">    1938 </span><span class="lineCov">          1 :     if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {</span>
<span class="lineNum">    1939 </span><span class="lineCov">          1 :       numAutoMargins++;</span>
<span class="lineNum">    1940 </span>            :     }
<span class="lineNum">    1941 </span>            :   }
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            :   // Mostly for clarity:
<span class="lineNum">    1944 </span>            :   MOZ_ASSERT(numAutoMargins &lt;= 2,
<span class="lineNum">    1945 </span>            :              &quot;We're just looking at one item along one dimension, so we &quot;
<span class="lineNum">    1946 </span>            :              &quot;should only have examined 2 margins&quot;);
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span><span class="lineCov">          1 :   return numAutoMargins;</span>
<span class="lineNum">    1949 </span>            : }
<a name="1950"><span class="lineNum">    1950 </span>            : </a>
<span class="lineNum">    1951 </span>            : bool
<span class="lineNum">    1952 </span><span class="lineCov">          1 : FlexItem::CanMainSizeInfluenceCrossSize(</span>
<span class="lineNum">    1953 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker) const
<span class="lineNum">    1954 </span>            : {
<span class="lineNum">    1955 </span><span class="lineCov">          1 :   if (mIsStretched) {</span>
<span class="lineNum">    1956 </span>            :     // We've already had our cross-size stretched for &quot;align-self:stretch&quot;).
<span class="lineNum">    1957 </span>            :     // The container is imposing its cross size on us.
<span class="lineNum">    1958 </span>            :     return false;
<span class="lineNum">    1959 </span>            :   }
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span><span class="lineCov">          1 :   if (mIsStrut) {</span>
<span class="lineNum">    1962 </span>            :     // Struts (for visibility:collapse items) have a predetermined size;
<span class="lineNum">    1963 </span>            :     // no need to measure anything.
<span class="lineNum">    1964 </span>            :     return false;
<span class="lineNum">    1965 </span>            :   }
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span><span class="lineCov">          1 :   if (HasIntrinsicRatio()) {</span>
<span class="lineNum">    1968 </span>            :     // For flex items that have an intrinsic ratio (and maintain it, i.e. are
<span class="lineNum">    1969 </span>            :     // not stretched, which we already checked above): changes to main-size
<span class="lineNum">    1970 </span>            :     // *do* influence the cross size.
<span class="lineNum">    1971 </span>            :     return true;
<span class="lineNum">    1972 </span>            :   }
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span><span class="lineCov">          1 :   if (aAxisTracker.IsCrossAxisHorizontal()) {</span>
<span class="lineNum">    1975 </span>            :     // If the cross axis is horizontal, then changes to the item's main size
<span class="lineNum">    1976 </span>            :     // (height) can't influence its cross size (width), if the item is a block
<span class="lineNum">    1977 </span>            :     // with a horizontal writing-mode.
<span class="lineNum">    1978 </span>            :     // XXXdholbert This doesn't account for vertical writing-modes, items with
<span class="lineNum">    1979 </span>            :     // aspect ratios, items that are multicol elements, &amp; items that are
<span class="lineNum">    1980 </span>            :     // multi-line vertical flex containers. In all of those cases, a change to
<span class="lineNum">    1981 </span>            :     // the height could influence the width.
<span class="lineNum">    1982 </span>            :     return false;
<span class="lineNum">    1983 </span>            :   }
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span>            :   // Default assumption, if we haven't proven otherwise: the resolved main size
<span class="lineNum">    1986 </span>            :   // *can* change the cross size.
<span class="lineNum">    1987 </span><span class="lineCov">          1 :   return true;</span>
<span class="lineNum">    1988 </span>            : }
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            : // Keeps track of our position along a particular axis (where a '0' position
<span class="lineNum">    1991 </span>            : // corresponds to the 'start' edge of that axis).
<span class="lineNum">    1992 </span>            : // This class shouldn't be instantiated directly -- rather, it should only be
<span class="lineNum">    1993 </span>            : // instantiated via its subclasses defined below.
<span class="lineNum">    1994 </span>            : class MOZ_STACK_CLASS PositionTracker {
<span class="lineNum">    1995 </span>            : public:
<span class="lineNum">    1996 </span>            :   // Accessor for the current value of the position that we're tracking.
<span class="lineNum">    1997 </span>            :   inline nscoord GetPosition() const { return mPosition; }
<span class="lineNum">    1998 </span>            :   inline AxisOrientationType GetAxis() const { return mAxis; }
<span class="lineNum">    1999 </span>            : 
<a name="2000"><span class="lineNum">    2000 </span>            :   // Advances our position across the start edge of the given margin, in the</a>
<span class="lineNum">    2001 </span>            :   // axis we're tracking.
<span class="lineNum">    2002 </span><span class="lineCov">          1 :   void EnterMargin(const nsMargin&amp; aMargin)</span>
<span class="lineNum">    2003 </span>            :   {
<span class="lineNum">    2004 </span><span class="lineCov">          1 :     mozilla::Side side = kAxisOrientationToSidesMap[mAxis][eAxisEdge_Start];</span>
<span class="lineNum">    2005 </span><span class="lineCov">          1 :     mPosition += aMargin.Side(side);</span>
<span class="lineNum">    2006 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2007 </span>            : 
<a name="2008"><span class="lineNum">    2008 </span>            :   // Advances our position across the end edge of the given margin, in the axis</a>
<span class="lineNum">    2009 </span>            :   // we're tracking.
<span class="lineNum">    2010 </span><span class="lineCov">          1 :   void ExitMargin(const nsMargin&amp; aMargin)</span>
<span class="lineNum">    2011 </span>            :   {
<span class="lineNum">    2012 </span><span class="lineCov">          1 :     mozilla::Side side = kAxisOrientationToSidesMap[mAxis][eAxisEdge_End];</span>
<span class="lineNum">    2013 </span><span class="lineCov">          1 :     mPosition += aMargin.Side(side);</span>
<span class="lineNum">    2014 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span>            :   // Advances our current position from the start side of a child frame's
<span class="lineNum">    2017 </span>            :   // border-box to the frame's upper or left edge (depending on our axis).
<a name="2018"><span class="lineNum">    2018 </span>            :   // (Note that this is a no-op if our axis grows in the same direction as</a>
<span class="lineNum">    2019 </span>            :   // the corresponding logical axis.)
<span class="lineNum">    2020 </span><span class="lineCov">          1 :   void EnterChildFrame(nscoord aChildFrameSize)</span>
<span class="lineNum">    2021 </span>            :   {
<span class="lineNum">    2022 </span><span class="lineCov">          1 :     if (mIsAxisReversed) {</span>
<span class="lineNum">    2023 </span><span class="lineCov">          1 :       mPosition += aChildFrameSize;</span>
<span class="lineNum">    2024 </span>            :     }
<span class="lineNum">    2025 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2026 </span>            : 
<span class="lineNum">    2027 </span>            :   // Advances our current position from a frame's upper or left border-box edge
<span class="lineNum">    2028 </span>            :   // (whichever is in the axis we're tracking) to the 'end' side of the frame
<a name="2029"><span class="lineNum">    2029 </span>            :   // in the axis that we're tracking. (Note that this is a no-op if our axis</a>
<span class="lineNum">    2030 </span>            :   // is reversed with respect to the corresponding logical axis.)
<span class="lineNum">    2031 </span><span class="lineCov">          1 :   void ExitChildFrame(nscoord aChildFrameSize)</span>
<span class="lineNum">    2032 </span>            :   {
<span class="lineNum">    2033 </span><span class="lineCov">          1 :     if (!mIsAxisReversed) {</span>
<span class="lineNum">    2034 </span><span class="lineCov">          1 :       mPosition += aChildFrameSize;</span>
<span class="lineNum">    2035 </span>            :     }
<span class="lineNum">    2036 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            : protected:
<span class="lineNum">    2039 </span>            :   // Protected constructor, to be sure we're only instantiated via a subclass.
<span class="lineNum">    2040 </span>            :   PositionTracker(AxisOrientationType aAxis, bool aIsAxisReversed)
<span class="lineNum">    2041 </span>            :     : mPosition(0),
<span class="lineNum">    2042 </span>            :       mAxis(aAxis),
<span class="lineNum">    2043 </span><span class="lineCov">          1 :       mIsAxisReversed(aIsAxisReversed)</span>
<span class="lineNum">    2044 </span>            :   {}
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span>            :   // Delete copy-constructor &amp; reassignment operator, to prevent accidental
<span class="lineNum">    2047 </span>            :   // (unnecessary) copying.
<span class="lineNum">    2048 </span>            :   PositionTracker(const PositionTracker&amp;) = delete;
<span class="lineNum">    2049 </span>            :   PositionTracker&amp; operator=(const PositionTracker&amp;) = delete;
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            :   // Member data:
<span class="lineNum">    2052 </span>            :   nscoord mPosition;               // The position we're tracking
<span class="lineNum">    2053 </span>            :   // XXXdholbert [BEGIN DEPRECATED]
<span class="lineNum">    2054 </span>            :   const AxisOrientationType mAxis; // The axis along which we're moving.
<span class="lineNum">    2055 </span>            :   // XXXdholbert [END DEPRECATED]
<span class="lineNum">    2056 </span>            :   const bool mIsAxisReversed; // Is the axis along which we're moving reversed
<span class="lineNum">    2057 </span>            :                               // (e.g. LTR vs RTL) with respect to the
<span class="lineNum">    2058 </span>            :                               // corresponding axis on the flex container's WM?
<span class="lineNum">    2059 </span>            : };
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            : // Tracks our position in the main axis, when we're laying out flex items.
<span class="lineNum">    2062 </span>            : // The &quot;0&quot; position represents the main-start edge of the flex container's
<span class="lineNum">    2063 </span>            : // content-box.
<span class="lineNum">    2064 </span>            : class MOZ_STACK_CLASS MainAxisPositionTracker : public PositionTracker {
<span class="lineNum">    2065 </span>            : public:
<span class="lineNum">    2066 </span>            :   MainAxisPositionTracker(const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    2067 </span>            :                           const FlexLine* aLine,
<span class="lineNum">    2068 </span>            :                           uint8_t aJustifyContent,
<span class="lineNum">    2069 </span>            :                           nscoord aContentBoxMainSize);
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span>            :   ~MainAxisPositionTracker() {
<span class="lineNum">    2072 </span>            :     MOZ_ASSERT(mNumPackingSpacesRemaining == 0,
<span class="lineNum">    2073 </span>            :                &quot;miscounted the number of packing spaces&quot;);
<span class="lineNum">    2074 </span>            :     MOZ_ASSERT(mNumAutoMarginsInMainAxis == 0,
<span class="lineNum">    2075 </span>            :                &quot;miscounted the number of auto margins&quot;);
<span class="lineNum">    2076 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            :   // Advances past the packing space (if any) between two flex items
<span class="lineNum">    2079 </span>            :   void TraversePackingSpace();
<span class="lineNum">    2080 </span>            : 
<span class="lineNum">    2081 </span>            :   // If aItem has any 'auto' margins in the main axis, this method updates the
<span class="lineNum">    2082 </span>            :   // corresponding values in its margin.
<span class="lineNum">    2083 </span>            :   void ResolveAutoMarginsInMainAxis(FlexItem&amp; aItem);
<span class="lineNum">    2084 </span>            : 
<span class="lineNum">    2085 </span>            : private:
<span class="lineNum">    2086 </span>            :   nscoord  mPackingSpaceRemaining;
<span class="lineNum">    2087 </span>            :   uint32_t mNumAutoMarginsInMainAxis;
<span class="lineNum">    2088 </span>            :   uint32_t mNumPackingSpacesRemaining;
<span class="lineNum">    2089 </span>            :   // XXX this should be uint16_t when we add explicit fallback handling
<span class="lineNum">    2090 </span>            :   uint8_t  mJustifyContent;
<span class="lineNum">    2091 </span>            : };
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span>            : // Utility class for managing our position along the cross axis along
<span class="lineNum">    2094 </span>            : // the whole flex container (at a higher level than a single line).
<span class="lineNum">    2095 </span>            : // The &quot;0&quot; position represents the cross-start edge of the flex container's
<span class="lineNum">    2096 </span>            : // content-box.
<span class="lineNum">    2097 </span>            : class MOZ_STACK_CLASS CrossAxisPositionTracker : public PositionTracker {
<span class="lineNum">    2098 </span>            : public:
<span class="lineNum">    2099 </span>            :   CrossAxisPositionTracker(FlexLine* aFirstLine,
<span class="lineNum">    2100 </span>            :                            const ReflowInput&amp; aReflowInput,
<span class="lineNum">    2101 </span>            :                            nscoord aContentBoxCrossSize,
<span class="lineNum">    2102 </span>            :                            bool aIsCrossSizeDefinite,
<span class="lineNum">    2103 </span>            :                            const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span>            :   // Advances past the packing space (if any) between two flex lines
<span class="lineNum">    2106 </span>            :   void TraversePackingSpace();
<span class="lineNum">    2107 </span>            : 
<span class="lineNum">    2108 </span>            :   // Advances past the given FlexLine
<span class="lineNum">    2109 </span><span class="lineCov">          1 :   void TraverseLine(FlexLine&amp; aLine) { mPosition += aLine.GetLineCrossSize(); }</span>
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span>            : private:
<span class="lineNum">    2112 </span>            :   // Redeclare the frame-related methods from PositionTracker as private with
<span class="lineNum">    2113 </span>            :   // = delete, to be sure (at compile time) that no client code can invoke
<span class="lineNum">    2114 </span>            :   // them. (Unlike the other PositionTracker derived classes, this class here
<span class="lineNum">    2115 </span>            :   // deals with FlexLines, not with individual FlexItems or frames.)
<span class="lineNum">    2116 </span>            :   void EnterMargin(const nsMargin&amp; aMargin) = delete;
<span class="lineNum">    2117 </span>            :   void ExitMargin(const nsMargin&amp; aMargin) = delete;
<span class="lineNum">    2118 </span>            :   void EnterChildFrame(nscoord aChildFrameSize) = delete;
<span class="lineNum">    2119 </span>            :   void ExitChildFrame(nscoord aChildFrameSize) = delete;
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span>            :   nscoord  mPackingSpaceRemaining;
<span class="lineNum">    2122 </span>            :   uint32_t mNumPackingSpacesRemaining;
<span class="lineNum">    2123 </span>            :   // XXX this should be uint16_t when we add explicit fallback handling
<span class="lineNum">    2124 </span>            :   uint8_t  mAlignContent;
<span class="lineNum">    2125 </span>            : };
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span>            : // Utility class for managing our position along the cross axis, *within* a
<span class="lineNum">    2128 </span>            : // single flex line.
<span class="lineNum">    2129 </span>            : class MOZ_STACK_CLASS SingleLineCrossAxisPositionTracker : public PositionTracker {
<span class="lineNum">    2130 </span>            : public:
<span class="lineNum">    2131 </span>            :   explicit SingleLineCrossAxisPositionTracker(const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span>            :   void ResolveAutoMarginsInCrossAxis(const FlexLine&amp; aLine,
<span class="lineNum">    2134 </span>            :                                      FlexItem&amp; aItem);
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span>            :   void EnterAlignPackingSpace(const FlexLine&amp; aLine,
<span class="lineNum">    2137 </span>            :                               const FlexItem&amp; aItem,
<span class="lineNum">    2138 </span>            :                               const FlexboxAxisTracker&amp; aAxisTracker);
<span class="lineNum">    2139 </span>            : 
<span class="lineNum">    2140 </span>            :   // Resets our position to the cross-start edge of this line.
<span class="lineNum">    2141 </span><span class="lineCov">          1 :   inline void ResetPosition() { mPosition = 0; }</span>
<span class="lineNum">    2142 </span>            : };
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span>            : // Frame class boilerplate
<a name="2147"><span class="lineNum">    2147 </span>            : // =======================</a>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span><span class="lineCov">          1 : NS_QUERYFRAME_HEAD(nsFlexContainerFrame)</span>
<span class="lineNum">    2150 </span>            :   NS_QUERYFRAME_ENTRY(nsFlexContainerFrame)
<a name="2151"><span class="lineNum">    2151 </span><span class="lineCov">          1 : NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)</span></a>
<span class="lineNum">    2152 </span>            : 
<span class="lineNum">    2153 </span><span class="lineCov">          1 : NS_IMPL_FRAMEARENA_HELPERS(nsFlexContainerFrame)</span>
<a name="2154"><span class="lineNum">    2154 </span>            : </a>
<span class="lineNum">    2155 </span>            : nsContainerFrame*
<span class="lineNum">    2156 </span><span class="lineCov">          1 : NS_NewFlexContainerFrame(nsIPresShell* aPresShell,</span>
<span class="lineNum">    2157 </span>            :                          nsStyleContext* aContext)
<span class="lineNum">    2158 </span>            : {
<span class="lineNum">    2159 </span><span class="lineCov">          1 :   return new (aPresShell) nsFlexContainerFrame(aContext);</span>
<span class="lineNum">    2160 </span>            : }
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    2163 </span>            : 
<span class="lineNum">    2164 </span>            : // nsFlexContainerFrame Method Implementations
<span class="lineNum">    2165 </span>            : // ===========================================
<a name="2166"><span class="lineNum">    2166 </span>            : </a>
<span class="lineNum">    2167 </span>            : /* virtual */
<span class="lineNum">    2168 </span><span class="lineCov">          1 : nsFlexContainerFrame::~nsFlexContainerFrame()</span>
<span class="lineNum">    2169 </span>            : {
<span class="lineNum">    2170 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    2171 </span>            : 
<a name="2172"><span class="lineNum">    2172 </span>            : /* virtual */</a>
<span class="lineNum">    2173 </span>            : void
<span class="lineNum">    2174 </span><span class="lineCov">          1 : nsFlexContainerFrame::Init(nsIContent*       aContent,</span>
<span class="lineNum">    2175 </span>            :                            nsContainerFrame* aParent,
<span class="lineNum">    2176 </span>            :                            nsIFrame*         aPrevInFlow)
<span class="lineNum">    2177 </span>            : {
<span class="lineNum">    2178 </span><span class="lineCov">          1 :   nsContainerFrame::Init(aContent, aParent, aPrevInFlow);</span>
<span class="lineNum">    2179 </span>            : 
<span class="lineNum">    2180 </span><span class="lineCov">          1 :   const nsStyleDisplay* styleDisp = StyleContext()-&gt;StyleDisplay();</span>
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            :   // Figure out if we should set a frame state bit to indicate that this frame
<span class="lineNum">    2183 </span>            :   // represents a legacy -webkit-{inline-}box container.
<span class="lineNum">    2184 </span>            :   // First, the trivial case: just check &quot;display&quot; directly.
<span class="lineNum">    2185 </span><span class="lineCov">          1 :   bool isLegacyBox = IsDisplayValueLegacyBox(styleDisp);</span>
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span>            :   // If this frame is for a scrollable element, then it will actually have
<span class="lineNum">    2188 </span>            :   // &quot;display:block&quot;, and its *parent frame* will have the real
<span class="lineNum">    2189 </span>            :   // flex-flavored display value. So in that case, check the parent frame to
<span class="lineNum">    2190 </span>            :   // find out if we're legacy.
<span class="lineNum">    2191 </span><span class="lineCov">          1 :   if (!isLegacyBox &amp;&amp; styleDisp-&gt;mDisplay == mozilla::StyleDisplay::Block) {</span>
<span class="lineNum">    2192 </span><span class="lineCov">          1 :     nsStyleContext* parentStyleContext = GetParent()-&gt;StyleContext();</span>
<span class="lineNum">    2193 </span>            :     NS_ASSERTION(parentStyleContext &amp;&amp;
<span class="lineNum">    2194 </span>            :                  (mStyleContext-&gt;GetPseudo() == nsCSSAnonBoxes::buttonContent ||
<span class="lineNum">    2195 </span>            :                   mStyleContext-&gt;GetPseudo() == nsCSSAnonBoxes::scrolledContent),
<span class="lineNum">    2196 </span>            :                  &quot;The only way a nsFlexContainerFrame can have 'display:block' &quot;
<span class="lineNum">    2197 </span>            :                  &quot;should be if it's the inner part of a scrollable or button &quot;
<span class="lineNum">    2198 </span>            :                  &quot;element&quot;);
<span class="lineNum">    2199 </span><span class="lineCov">          1 :     isLegacyBox = IsDisplayValueLegacyBox(parentStyleContext-&gt;StyleDisplay());</span>
<span class="lineNum">    2200 </span>            :   }
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span><span class="lineCov">          1 :   if (isLegacyBox) {</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     AddStateBits(NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX);</span>
<span class="lineNum">    2204 </span>            :   }
<span class="lineNum">    2205 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    2206 </span>            : 
<a name="2207"><span class="lineNum">    2207 </span>            : /* virtual */</a>
<span class="lineNum">    2208 </span>            : nsIAtom*
<span class="lineNum">    2209 </span><span class="lineCov">          1 : nsFlexContainerFrame::GetType() const</span>
<span class="lineNum">    2210 </span>            : {
<span class="lineNum">    2211 </span><span class="lineCov">          1 :   return nsGkAtoms::flexContainerFrame;</span>
<span class="lineNum">    2212 </span>            : }
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            : #ifdef DEBUG_FRAME_DUMP
<span class="lineNum">    2215 </span>            : nsresult
<span class="lineNum">    2216 </span>            : nsFlexContainerFrame::GetFrameName(nsAString&amp; aResult) const
<span class="lineNum">    2217 </span>            : {
<span class="lineNum">    2218 </span>            :   return MakeFrameName(NS_LITERAL_STRING(&quot;FlexContainer&quot;), aResult);
<span class="lineNum">    2219 </span>            : }
<span class="lineNum">    2220 </span>            : #endif
<a name="2221"><span class="lineNum">    2221 </span>            : </a>
<span class="lineNum">    2222 </span>            : nscoord
<span class="lineNum">    2223 </span><span class="lineCov">          1 : nsFlexContainerFrame::GetLogicalBaseline(mozilla::WritingMode aWM) const</span>
<span class="lineNum">    2224 </span>            : {
<span class="lineNum">    2225 </span>            :   NS_ASSERTION(mBaselineFromLastReflow != NS_INTRINSIC_WIDTH_UNKNOWN,
<span class="lineNum">    2226 </span>            :                &quot;baseline has not been set&quot;);
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineCov">          1 :   if (HasAnyStateBits(NS_STATE_FLEX_SYNTHESIZE_BASELINE)) {</span>
<span class="lineNum">    2229 </span>            :     // Return a baseline synthesized from our margin-box.
<span class="lineNum">    2230 </span><span class="lineCov">          1 :     return nsContainerFrame::GetLogicalBaseline(aWM);</span>
<span class="lineNum">    2231 </span>            :   }
<span class="lineNum">    2232 </span><span class="lineCov">          1 :   return mBaselineFromLastReflow;</span>
<span class="lineNum">    2233 </span>            : }
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span>            : // Helper for BuildDisplayList, to implement this special-case for flex items
<span class="lineNum">    2236 </span>            : // from the spec:
<span class="lineNum">    2237 </span>            : //    Flex items paint exactly the same as block-level elements in the
<span class="lineNum">    2238 </span>            : //    normal flow, except that 'z-index' values other than 'auto' create
<span class="lineNum">    2239 </span>            : //    a stacking context even if 'position' is 'static'.
<a name="2240"><span class="lineNum">    2240 </span>            : // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#painting</a>
<span class="lineNum">    2241 </span>            : uint32_t
<span class="lineNum">    2242 </span><span class="lineCov">          1 : GetDisplayFlagsForFlexItem(nsIFrame* aFrame)</span>
<span class="lineNum">    2243 </span>            : {
<span class="lineNum">    2244 </span>            :   MOZ_ASSERT(aFrame-&gt;IsFlexItem(), &quot;Should only be called on flex items&quot;);
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span><span class="lineCov">          1 :   const nsStylePosition* pos = aFrame-&gt;StylePosition();</span>
<span class="lineNum">    2247 </span><span class="lineCov">          1 :   if (pos-&gt;mZIndex.GetUnit() == eStyleUnit_Integer) {</span>
<span class="lineNum">    2248 </span>            :     return nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT;
<span class="lineNum">    2249 </span>            :   }
<span class="lineNum">    2250 </span><span class="lineCov">          1 :   return nsIFrame::DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT;</span>
<span class="lineNum">    2251 </span>            : }
<a name="2252"><span class="lineNum">    2252 </span>            : </a>
<span class="lineNum">    2253 </span>            : void
<span class="lineNum">    2254 </span><span class="lineCov">          1 : nsFlexContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    2255 </span>            :                                        const nsRect&amp;           aDirtyRect,
<span class="lineNum">    2256 </span>            :                                        const nsDisplayListSet&amp; aLists)
<span class="lineNum">    2257 </span>            : {
<span class="lineNum">    2258 </span><span class="lineCov">          1 :   DisplayBorderBackgroundOutline(aBuilder, aLists);</span>
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            :   // Our children are all block-level, so their borders/backgrounds all go on
<span class="lineNum">    2261 </span>            :   // the BlockBorderBackgrounds list.
<span class="lineNum">    2262 </span><span class="lineCov">          1 :   nsDisplayListSet childLists(aLists, aLists.BlockBorderBackgrounds());</span>
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span>            :   typedef CSSOrderAwareFrameIterator::OrderState OrderState;
<span class="lineNum">    2265 </span>            :   OrderState orderState =
<span class="lineNum">    2266 </span><span class="lineCov">          1 :     HasAnyStateBits(NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER)</span>
<span class="lineNum">    2267 </span>            :     ? OrderState::eKnownOrdered
<span class="lineNum">    2268 </span><span class="lineCov">          1 :     : OrderState::eKnownUnordered;</span>
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            :   CSSOrderAwareFrameIterator iter(this, kPrincipalList,
<span class="lineNum">    2271 </span>            :                                   CSSOrderAwareFrameIterator::eIncludeAll,
<span class="lineNum">    2272 </span>            :                                   orderState,
<span class="lineNum">    2273 </span><span class="lineCov">          1 :                                   OrderingPropertyForIter(this));</span>
<span class="lineNum">    2274 </span><span class="lineCov">          1 :   for (; !iter.AtEnd(); iter.Next()) {</span>
<span class="lineNum">    2275 </span><span class="lineCov">          1 :     nsIFrame* childFrame = *iter;</span>
<span class="lineNum">    2276 </span>            :     BuildDisplayListForChild(aBuilder, childFrame, aDirtyRect, childLists,
<span class="lineNum">    2277 </span><span class="lineCov">          1 :                              GetDisplayFlagsForFlexItem(childFrame));</span>
<span class="lineNum">    2278 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2279 </span><span class="lineCov">          1 : }</span>
<a name="2280"><span class="lineNum">    2280 </span>            : </a>
<span class="lineNum">    2281 </span>            : void
<span class="lineNum">    2282 </span><span class="lineCov">          1 : FlexLine::FreezeItemsEarly(bool aIsUsingFlexGrow)</span>
<span class="lineNum">    2283 </span>            : {
<span class="lineNum">    2284 </span>            :   // After we've established the type of flexing we're doing (growing vs.
<span class="lineNum">    2285 </span>            :   // shrinking), and before we try to flex any items, we freeze items that
<span class="lineNum">    2286 </span>            :   // obviously *can't* flex.
<span class="lineNum">    2287 </span>            :   //
<span class="lineNum">    2288 </span>            :   // Quoting the spec:
<span class="lineNum">    2289 </span>            :   //  # Freeze, setting its target main size to its hypothetical main size...
<span class="lineNum">    2290 </span>            :   //  #  - any item that has a flex factor of zero
<span class="lineNum">    2291 </span>            :   //  #  - if using the flex grow factor: any item that has a flex base size
<span class="lineNum">    2292 </span>            :   //  #    greater than its hypothetical main size
<span class="lineNum">    2293 </span>            :   //  #  - if using the flex shrink factor: any item that has a flex base size
<span class="lineNum">    2294 </span>            :   //  #    smaller than its hypothetical main size
<span class="lineNum">    2295 </span>            :   //  http://dev.w3.org/csswg/css-flexbox/#resolve-flexible-lengths-flex-factors
<span class="lineNum">    2296 </span>            :   //
<span class="lineNum">    2297 </span>            :   // (NOTE: At this point, item-&gt;GetMainSize() *is* the item's hypothetical
<span class="lineNum">    2298 </span>            :   // main size, since SetFlexBaseSizeAndMainSize() sets it up that way, and the
<span class="lineNum">    2299 </span>            :   // item hasn't had a chance to flex away from that yet.)
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span>            :   // Since this loop only operates on unfrozen flex items, we can break as
<span class="lineNum">    2302 </span>            :   // soon as we have seen all of them.
<span class="lineNum">    2303 </span><span class="lineCov">          1 :   uint32_t numUnfrozenItemsToBeSeen = mNumItems - mNumFrozenItems;</span>
<span class="lineNum">    2304 </span><span class="lineCov">          1 :   for (FlexItem* item = mItems.getFirst();</span>
<span class="lineNum">    2305 </span><span class="lineCov">          1 :        numUnfrozenItemsToBeSeen &gt; 0; item = item-&gt;getNext()) {</span>
<span class="lineNum">    2306 </span>            :     MOZ_ASSERT(item, &quot;numUnfrozenItemsToBeSeen says items remain to be seen&quot;);
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span><span class="lineCov">          1 :     if (!item-&gt;IsFrozen()) {</span>
<span class="lineNum">    2309 </span><span class="lineCov">          1 :       numUnfrozenItemsToBeSeen--;</span>
<span class="lineNum">    2310 </span><span class="lineCov">          1 :       bool shouldFreeze = (0.0f == item-&gt;GetFlexFactor(aIsUsingFlexGrow));</span>
<span class="lineNum">    2311 </span><span class="lineCov">          1 :       if (!shouldFreeze) {</span>
<span class="lineNum">    2312 </span><span class="lineCov">          1 :         if (aIsUsingFlexGrow) {</span>
<span class="lineNum">    2313 </span><span class="lineCov">          1 :           if (item-&gt;GetFlexBaseSize() &gt; item-&gt;GetMainSize()) {</span>
<span class="lineNum">    2314 </span><span class="lineCov">          1 :             shouldFreeze = true;</span>
<span class="lineNum">    2315 </span>            :           }
<span class="lineNum">    2316 </span>            :         } else { // using flex-shrink
<span class="lineNum">    2317 </span><span class="lineCov">          1 :           if (item-&gt;GetFlexBaseSize() &lt; item-&gt;GetMainSize()) {</span>
<span class="lineNum">    2318 </span><span class="lineCov">          1 :             shouldFreeze = true;</span>
<span class="lineNum">    2319 </span>            :           }
<span class="lineNum">    2320 </span>            :         }
<span class="lineNum">    2321 </span>            :       }
<span class="lineNum">    2322 </span><span class="lineCov">          1 :       if (shouldFreeze) {</span>
<span class="lineNum">    2323 </span>            :         // Freeze item! (at its hypothetical main size)
<span class="lineNum">    2324 </span><span class="lineCov">          1 :         item-&gt;Freeze();</span>
<span class="lineNum">    2325 </span><span class="lineCov">          1 :         mNumFrozenItems++;</span>
<span class="lineNum">    2326 </span>            :       }
<span class="lineNum">    2327 </span>            :     }
<span class="lineNum">    2328 </span>            :   }
<span class="lineNum">    2329 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    2330 </span>            : 
<span class="lineNum">    2331 </span>            : // Based on the sign of aTotalViolation, this function freezes a subset of our
<a name="2332"><span class="lineNum">    2332 </span>            : // flexible sizes, and restores the remaining ones to their initial pref sizes.</a>
<span class="lineNum">    2333 </span>            : void
<span class="lineNum">    2334 </span><span class="lineCov">          1 : FlexLine::FreezeOrRestoreEachFlexibleSize(const nscoord aTotalViolation,</span>
<span class="lineNum">    2335 </span>            :                                           bool aIsFinalIteration)
<span class="lineNum">    2336 </span>            : {
<span class="lineNum">    2337 </span>            :   enum FreezeType {
<span class="lineNum">    2338 </span>            :     eFreezeEverything,
<span class="lineNum">    2339 </span>            :     eFreezeMinViolations,
<span class="lineNum">    2340 </span>            :     eFreezeMaxViolations
<span class="lineNum">    2341 </span>            :   };
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span>            :   FreezeType freezeType;
<span class="lineNum">    2344 </span><span class="lineCov">          1 :   if (aTotalViolation == 0) {</span>
<span class="lineNum">    2345 </span>            :     freezeType = eFreezeEverything;
<span class="lineNum">    2346 </span><span class="lineCov">          1 :   } else if (aTotalViolation &gt; 0) {</span>
<span class="lineNum">    2347 </span>            :     freezeType = eFreezeMinViolations;
<span class="lineNum">    2348 </span>            :   } else { // aTotalViolation &lt; 0
<span class="lineNum">    2349 </span><span class="lineCov">          1 :     freezeType = eFreezeMaxViolations;</span>
<span class="lineNum">    2350 </span>            :   }
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span>            :   // Since this loop only operates on unfrozen flex items, we can break as
<span class="lineNum">    2353 </span>            :   // soon as we have seen all of them.
<span class="lineNum">    2354 </span><span class="lineCov">          1 :   uint32_t numUnfrozenItemsToBeSeen = mNumItems - mNumFrozenItems;</span>
<span class="lineNum">    2355 </span><span class="lineCov">          1 :   for (FlexItem* item = mItems.getFirst();</span>
<span class="lineNum">    2356 </span><span class="lineCov">          1 :        numUnfrozenItemsToBeSeen &gt; 0; item = item-&gt;getNext()) {</span>
<span class="lineNum">    2357 </span>            :     MOZ_ASSERT(item, &quot;numUnfrozenItemsToBeSeen says items remain to be seen&quot;);
<span class="lineNum">    2358 </span><span class="lineCov">          1 :     if (!item-&gt;IsFrozen()) {</span>
<span class="lineNum">    2359 </span><span class="lineCov">          1 :       numUnfrozenItemsToBeSeen--;</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span>            :       MOZ_ASSERT(!item-&gt;HadMinViolation() || !item-&gt;HadMaxViolation(),
<span class="lineNum">    2362 </span>            :                  &quot;Can have either min or max violation, but not both&quot;);
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span><span class="lineCov">          1 :       if (eFreezeEverything == freezeType ||</span>
<span class="lineNum">    2365 </span><span class="lineCov">          1 :           (eFreezeMinViolations == freezeType &amp;&amp; item-&gt;HadMinViolation()) ||</span>
<span class="lineNum">    2366 </span><span class="lineCov">          1 :           (eFreezeMaxViolations == freezeType &amp;&amp; item-&gt;HadMaxViolation())) {</span>
<span class="lineNum">    2367 </span>            : 
<span class="lineNum">    2368 </span>            :         MOZ_ASSERT(item-&gt;GetMainSize() &gt;= item-&gt;GetMainMinSize(),
<span class="lineNum">    2369 </span>            :                    &quot;Freezing item at a size below its minimum&quot;);
<span class="lineNum">    2370 </span>            :         MOZ_ASSERT(item-&gt;GetMainSize() &lt;= item-&gt;GetMainMaxSize(),
<span class="lineNum">    2371 </span>            :                    &quot;Freezing item at a size above its maximum&quot;);
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span><span class="lineCov">          1 :         item-&gt;Freeze();</span>
<span class="lineNum">    2374 </span><span class="lineCov">          1 :         mNumFrozenItems++;</span>
<span class="lineNum">    2375 </span><span class="lineCov">          1 :       } else if (MOZ_UNLIKELY(aIsFinalIteration)) {</span>
<span class="lineNum">    2376 </span>            :         // XXXdholbert If &amp; when bug 765861 is fixed, we should upgrade this
<span class="lineNum">    2377 </span>            :         // assertion to be fatal except in documents with enormous lengths.
<span class="lineNum">    2378 </span>            :         NS_ERROR(&quot;Final iteration still has unfrozen items, this shouldn't&quot;
<span class="lineNum">    2379 </span>            :                  &quot; happen unless there was nscoord under/overflow.&quot;);
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :         item-&gt;Freeze();</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :         mNumFrozenItems++;</span>
<span class="lineNum">    2382 </span>            :       } // else, we'll reset this item's main size to its flex base size on the
<span class="lineNum">    2383 </span>            :         // next iteration of this algorithm.
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            :       // Clear this item's violation(s), now that we've dealt with them
<span class="lineNum">    2386 </span>            :       item-&gt;ClearViolationFlags();
<span class="lineNum">    2387 </span>            :     }
<span class="lineNum">    2388 </span>            :   }
<span class="lineNum">    2389 </span><span class="lineCov">          1 : }</span>
<a name="2390"><span class="lineNum">    2390 </span>            : </a>
<span class="lineNum">    2391 </span>            : void
<span class="lineNum">    2392 </span><span class="lineCov">          1 : FlexLine::ResolveFlexibleLengths(nscoord aFlexContainerMainSize)</span>
<span class="lineNum">    2393 </span>            : {
<span class="lineNum">    2394 </span><span class="lineCov">          1 :   MOZ_LOG(gFlexContainerLog, LogLevel::Debug, (&quot;ResolveFlexibleLengths\n&quot;));</span>
<span class="lineNum">    2395 </span>            : 
<span class="lineNum">    2396 </span>            :   // Determine whether we're going to be growing or shrinking items.
<span class="lineNum">    2397 </span>            :   const bool isUsingFlexGrow =
<span class="lineNum">    2398 </span><span class="lineCov">          1 :     (mTotalOuterHypotheticalMainSize &lt; aFlexContainerMainSize);</span>
<span class="lineNum">    2399 </span>            : 
<span class="lineNum">    2400 </span>            :   // Do an &quot;early freeze&quot; for flex items that obviously can't flex in the
<span class="lineNum">    2401 </span>            :   // direction we've chosen:
<span class="lineNum">    2402 </span><span class="lineCov">          1 :   FreezeItemsEarly(isUsingFlexGrow);</span>
<span class="lineNum">    2403 </span>            : 
<span class="lineNum">    2404 </span><span class="lineCov">          1 :   if (mNumFrozenItems == mNumItems) {</span>
<span class="lineNum">    2405 </span>            :     // All our items are frozen, so we have no flexible lengths to resolve.
<span class="lineNum">    2406 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    2407 </span>            :   }
<span class="lineNum">    2408 </span>            :   MOZ_ASSERT(!IsEmpty(), &quot;empty lines should take the early-return above&quot;);
<span class="lineNum">    2409 </span>            : 
<span class="lineNum">    2410 </span>            :   // Subtract space occupied by our items' margins/borders/padding, so we can
<span class="lineNum">    2411 </span>            :   // just be dealing with the space available for our flex items' content
<span class="lineNum">    2412 </span>            :   // boxes.
<span class="lineNum">    2413 </span>            :   nscoord spaceReservedForMarginBorderPadding =
<span class="lineNum">    2414 </span><span class="lineCov">          1 :     mTotalOuterHypotheticalMainSize - mTotalInnerHypotheticalMainSize;</span>
<span class="lineNum">    2415 </span>            : 
<span class="lineNum">    2416 </span>            :   nscoord spaceAvailableForFlexItemsContentBoxes =
<span class="lineNum">    2417 </span><span class="lineCov">          1 :     aFlexContainerMainSize - spaceReservedForMarginBorderPadding;</span>
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span>            :   nscoord origAvailableFreeSpace;
<span class="lineNum">    2420 </span><span class="lineCov">          1 :   bool isOrigAvailFreeSpaceInitialized = false;</span>
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span>            :   // NOTE: I claim that this chunk of the algorithm (the looping part) needs to
<span class="lineNum">    2423 </span>            :   // run the loop at MOST mNumItems times.  This claim should hold up
<span class="lineNum">    2424 </span>            :   // because we'll freeze at least one item on each loop iteration, and once
<span class="lineNum">    2425 </span>            :   // we've run out of items to freeze, there's nothing left to do.  However,
<span class="lineNum">    2426 </span>            :   // in most cases, we'll break out of this loop long before we hit that many
<span class="lineNum">    2427 </span>            :   // iterations.
<span class="lineNum">    2428 </span><span class="lineCov">          1 :   for (uint32_t iterationCounter = 0;</span>
<span class="lineNum">    2429 </span><span class="lineCov">          1 :        iterationCounter &lt; mNumItems; iterationCounter++) {</span>
<span class="lineNum">    2430 </span>            :     // Set every not-yet-frozen item's used main size to its
<span class="lineNum">    2431 </span>            :     // flex base size, and subtract all the used main sizes from our
<span class="lineNum">    2432 </span>            :     // total amount of space to determine the 'available free space'
<span class="lineNum">    2433 </span>            :     // (positive or negative) to be distributed among our flexible items.
<span class="lineNum">    2434 </span><span class="lineCov">          1 :     nscoord availableFreeSpace = spaceAvailableForFlexItemsContentBoxes;</span>
<span class="lineNum">    2435 </span><span class="lineCov">          1 :     for (FlexItem* item = mItems.getFirst(); item; item = item-&gt;getNext()) {</span>
<span class="lineNum">    2436 </span><span class="lineCov">          1 :       if (!item-&gt;IsFrozen()) {</span>
<span class="lineNum">    2437 </span><span class="lineCov">          1 :         item-&gt;SetMainSize(item-&gt;GetFlexBaseSize());</span>
<span class="lineNum">    2438 </span>            :       }
<span class="lineNum">    2439 </span><span class="lineCov">          1 :       availableFreeSpace -= item-&gt;GetMainSize();</span>
<span class="lineNum">    2440 </span>            :     }
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span><span class="lineCov">          1 :     MOZ_LOG(gFlexContainerLog, LogLevel::Debug,</span>
<span class="lineNum">    2443 </span>            :            (&quot; available free space = %d\n&quot;, availableFreeSpace));
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span>            :     // The sign of our free space should agree with the type of flexing
<span class="lineNum">    2447 </span>            :     // (grow/shrink) that we're doing (except if we've had integer overflow;
<span class="lineNum">    2448 </span>            :     // then, all bets are off). Any disagreement should've made us use the
<span class="lineNum">    2449 </span>            :     // other type of flexing, or should've been resolved in FreezeItemsEarly.
<span class="lineNum">    2450 </span>            :     // XXXdholbert If &amp; when bug 765861 is fixed, we should upgrade this
<span class="lineNum">    2451 </span>            :     // assertion to be fatal except in documents with enormous lengths.
<span class="lineNum">    2452 </span>            :     NS_ASSERTION((isUsingFlexGrow &amp;&amp; availableFreeSpace &gt;= 0) ||
<span class="lineNum">    2453 </span>            :                  (!isUsingFlexGrow &amp;&amp; availableFreeSpace &lt;= 0),
<span class="lineNum">    2454 </span>            :                  &quot;availableFreeSpace's sign should match isUsingFlexGrow&quot;);
<span class="lineNum">    2455 </span>            : 
<span class="lineNum">    2456 </span>            :     // If we have any free space available, give each flexible item a portion
<span class="lineNum">    2457 </span>            :     // of availableFreeSpace.
<span class="lineNum">    2458 </span><span class="lineCov">          1 :     if (availableFreeSpace != 0) {</span>
<span class="lineNum">    2459 </span>            :       // The first time we do this, we initialize origAvailableFreeSpace.
<span class="lineNum">    2460 </span><span class="lineCov">          1 :       if (!isOrigAvailFreeSpaceInitialized) {</span>
<span class="lineNum">    2461 </span><span class="lineCov">          1 :         origAvailableFreeSpace = availableFreeSpace;</span>
<span class="lineNum">    2462 </span><span class="lineCov">          1 :         isOrigAvailFreeSpaceInitialized = true;</span>
<span class="lineNum">    2463 </span>            :       }
<span class="lineNum">    2464 </span>            : 
<span class="lineNum">    2465 </span>            :       // STRATEGY: On each item, we compute &amp; store its &quot;share&quot; of the total
<span class="lineNum">    2466 </span>            :       // weight that we've seen so far:
<span class="lineNum">    2467 </span>            :       //   curWeight / weightSum
<span class="lineNum">    2468 </span>            :       //
<span class="lineNum">    2469 </span>            :       // Then, when we go to actually distribute the space (in the next loop),
<span class="lineNum">    2470 </span>            :       // we can simply walk backwards through the elements and give each item
<span class="lineNum">    2471 </span>            :       // its &quot;share&quot; multiplied by the remaining available space.
<span class="lineNum">    2472 </span>            :       //
<span class="lineNum">    2473 </span>            :       // SPECIAL CASE: If the sum of the weights is larger than the
<span class="lineNum">    2474 </span>            :       // maximum representable float (overflowing to infinity), then we can't
<span class="lineNum">    2475 </span>            :       // sensibly divide out proportional shares anymore. In that case, we
<span class="lineNum">    2476 </span>            :       // simply treat the flex item(s) with the largest weights as if
<span class="lineNum">    2477 </span>            :       // their weights were infinite (dwarfing all the others), and we
<span class="lineNum">    2478 </span>            :       // distribute all of the available space among them.
<span class="lineNum">    2479 </span><span class="lineCov">          1 :       float weightSum = 0.0f;</span>
<span class="lineNum">    2480 </span><span class="lineCov">          1 :       float flexFactorSum = 0.0f;</span>
<span class="lineNum">    2481 </span><span class="lineCov">          1 :       float largestWeight = 0.0f;</span>
<span class="lineNum">    2482 </span><span class="lineCov">          1 :       uint32_t numItemsWithLargestWeight = 0;</span>
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span>            :       // Since this loop only operates on unfrozen flex items, we can break as
<span class="lineNum">    2485 </span>            :       // soon as we have seen all of them.
<span class="lineNum">    2486 </span><span class="lineCov">          1 :       uint32_t numUnfrozenItemsToBeSeen = mNumItems - mNumFrozenItems;</span>
<span class="lineNum">    2487 </span><span class="lineCov">          1 :       for (FlexItem* item = mItems.getFirst();</span>
<span class="lineNum">    2488 </span><span class="lineCov">          1 :            numUnfrozenItemsToBeSeen &gt; 0; item = item-&gt;getNext()) {</span>
<span class="lineNum">    2489 </span>            :         MOZ_ASSERT(item,
<span class="lineNum">    2490 </span>            :                    &quot;numUnfrozenItemsToBeSeen says items remain to be seen&quot;);
<span class="lineNum">    2491 </span><span class="lineCov">          1 :         if (!item-&gt;IsFrozen()) {</span>
<span class="lineNum">    2492 </span><span class="lineCov">          1 :           numUnfrozenItemsToBeSeen--;</span>
<span class="lineNum">    2493 </span>            : 
<span class="lineNum">    2494 </span><span class="lineCov">          1 :           float curWeight = item-&gt;GetWeight(isUsingFlexGrow);</span>
<span class="lineNum">    2495 </span><span class="lineCov">          1 :           float curFlexFactor = item-&gt;GetFlexFactor(isUsingFlexGrow);</span>
<span class="lineNum">    2496 </span>            :           MOZ_ASSERT(curWeight &gt;= 0.0f, &quot;weights are non-negative&quot;);
<span class="lineNum">    2497 </span>            :           MOZ_ASSERT(curFlexFactor &gt;= 0.0f, &quot;flex factors are non-negative&quot;);
<span class="lineNum">    2498 </span>            : 
<span class="lineNum">    2499 </span><span class="lineCov">          1 :           weightSum += curWeight;</span>
<span class="lineNum">    2500 </span><span class="lineCov">          1 :           flexFactorSum += curFlexFactor;</span>
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineCov">          1 :           if (IsFinite(weightSum)) {</span>
<span class="lineNum">    2503 </span><span class="lineCov">          1 :             if (curWeight == 0.0f) {</span>
<span class="lineNum">    2504 </span><span class="lineCov">          1 :               item-&gt;SetShareOfWeightSoFar(0.0f);</span>
<span class="lineNum">    2505 </span>            :             } else {
<span class="lineNum">    2506 </span><span class="lineCov">          1 :               item-&gt;SetShareOfWeightSoFar(curWeight / weightSum);</span>
<span class="lineNum">    2507 </span>            :             }
<span class="lineNum">    2508 </span>            :           } // else, the sum of weights overflows to infinity, in which
<span class="lineNum">    2509 </span>            :             // case we don't bother with &quot;SetShareOfWeightSoFar&quot; since
<span class="lineNum">    2510 </span>            :             // we know we won't use it. (instead, we'll just give every
<span class="lineNum">    2511 </span>            :             // item with the largest weight an equal share of space.)
<span class="lineNum">    2512 </span>            : 
<span class="lineNum">    2513 </span>            :           // Update our largest-weight tracking vars
<span class="lineNum">    2514 </span><span class="lineCov">          1 :           if (curWeight &gt; largestWeight) {</span>
<span class="lineNum">    2515 </span>            :             largestWeight = curWeight;
<span class="lineNum">    2516 </span>            :             numItemsWithLargestWeight = 1;
<span class="lineNum">    2517 </span><span class="lineCov">          1 :           } else if (curWeight == largestWeight) {</span>
<span class="lineNum">    2518 </span><span class="lineCov">          1 :             numItemsWithLargestWeight++;</span>
<span class="lineNum">    2519 </span>            :           }
<span class="lineNum">    2520 </span>            :         }
<span class="lineNum">    2521 </span>            :       }
<span class="lineNum">    2522 </span>            : 
<span class="lineNum">    2523 </span><span class="lineCov">          1 :       if (weightSum != 0.0f) {</span>
<span class="lineNum">    2524 </span>            :         MOZ_ASSERT(flexFactorSum != 0.0f,
<span class="lineNum">    2525 </span>            :                    &quot;flex factor sum can't be 0, if a weighted sum &quot;
<span class="lineNum">    2526 </span>            :                    &quot;of its components (weightSum) is nonzero&quot;);
<span class="lineNum">    2527 </span><span class="lineCov">          1 :         if (flexFactorSum &lt; 1.0f) {</span>
<span class="lineNum">    2528 </span>            :           // Our unfrozen flex items don't want all of the original free space!
<span class="lineNum">    2529 </span>            :           // (Their flex factors add up to something less than 1.)
<span class="lineNum">    2530 </span>            :           // Hence, make sure we don't distribute any more than the portion of
<span class="lineNum">    2531 </span>            :           // our original free space that these items actually want.
<span class="lineNum">    2532 </span>            :           nscoord totalDesiredPortionOfOrigFreeSpace =
<span class="lineNum">    2533 </span><span class="lineCov">          1 :             NSToCoordRound(origAvailableFreeSpace * flexFactorSum);</span>
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            :           // Clamp availableFreeSpace to be no larger than that ^^.
<span class="lineNum">    2536 </span>            :           // (using min or max, depending on sign).
<span class="lineNum">    2537 </span>            :           // This should not change the sign of availableFreeSpace (except
<span class="lineNum">    2538 </span>            :           // possibly by setting it to 0), as enforced by this assertion:
<span class="lineNum">    2539 </span>            :           MOZ_ASSERT(totalDesiredPortionOfOrigFreeSpace == 0 ||
<span class="lineNum">    2540 </span>            :                      ((totalDesiredPortionOfOrigFreeSpace &gt; 0) ==
<span class="lineNum">    2541 </span>            :                       (availableFreeSpace &gt; 0)),
<span class="lineNum">    2542 </span>            :                      &quot;When we reduce available free space for flex factors &lt; 1,&quot;
<span class="lineNum">    2543 </span>            :                      &quot;we shouldn't change the sign of the free space...&quot;);
<span class="lineNum">    2544 </span>            : 
<span class="lineNum">    2545 </span><span class="lineCov">          1 :           if (availableFreeSpace &gt; 0) {</span>
<span class="lineNum">    2546 </span>            :             availableFreeSpace = std::min(availableFreeSpace,
<span class="lineNum">    2547 </span><span class="lineCov">          1 :                                           totalDesiredPortionOfOrigFreeSpace);</span>
<span class="lineNum">    2548 </span>            :           } else {
<span class="lineNum">    2549 </span>            :             availableFreeSpace = std::max(availableFreeSpace,
<span class="lineNum">    2550 </span><span class="lineCov">          1 :                                           totalDesiredPortionOfOrigFreeSpace);</span>
<span class="lineNum">    2551 </span>            :           }
<span class="lineNum">    2552 </span>            :         }
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span><span class="lineCov">          1 :         MOZ_LOG(gFlexContainerLog, LogLevel::Debug,</span>
<span class="lineNum">    2555 </span>            :                (&quot; Distributing available space:&quot;));
<span class="lineNum">    2556 </span>            :         // Since this loop only operates on unfrozen flex items, we can break as
<span class="lineNum">    2557 </span>            :         // soon as we have seen all of them.
<span class="lineNum">    2558 </span><span class="lineCov">          1 :         numUnfrozenItemsToBeSeen = mNumItems - mNumFrozenItems;</span>
<span class="lineNum">    2559 </span>            : 
<span class="lineNum">    2560 </span>            :         // NOTE: It's important that we traverse our items in *reverse* order
<span class="lineNum">    2561 </span>            :         // here, for correct width distribution according to the items'
<span class="lineNum">    2562 </span>            :         // &quot;ShareOfWeightSoFar&quot; progressively-calculated values.
<span class="lineNum">    2563 </span><span class="lineCov">          1 :         for (FlexItem* item = mItems.getLast();</span>
<span class="lineNum">    2564 </span><span class="lineCov">          1 :              numUnfrozenItemsToBeSeen &gt; 0; item = item-&gt;getPrevious()) {</span>
<span class="lineNum">    2565 </span>            :           MOZ_ASSERT(item,
<span class="lineNum">    2566 </span>            :                      &quot;numUnfrozenItemsToBeSeen says items remain to be seen&quot;);
<span class="lineNum">    2567 </span><span class="lineCov">          1 :           if (!item-&gt;IsFrozen()) {</span>
<span class="lineNum">    2568 </span><span class="lineCov">          1 :             numUnfrozenItemsToBeSeen--;</span>
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span>            :             // To avoid rounding issues, we compute the change in size for this
<span class="lineNum">    2571 </span>            :             // item, and then subtract it from the remaining available space.
<span class="lineNum">    2572 </span><span class="lineCov">          1 :             nscoord sizeDelta = 0;</span>
<span class="lineNum">    2573 </span><span class="lineCov">          1 :             if (IsFinite(weightSum)) {</span>
<span class="lineNum">    2574 </span>            :               float myShareOfRemainingSpace =
<span class="lineNum">    2575 </span><span class="lineCov">          1 :                 item-&gt;GetShareOfWeightSoFar();</span>
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span>            :               MOZ_ASSERT(myShareOfRemainingSpace &gt;= 0.0f &amp;&amp;
<span class="lineNum">    2578 </span>            :                          myShareOfRemainingSpace &lt;= 1.0f,
<span class="lineNum">    2579 </span>            :                          &quot;my share should be nonnegative fractional amount&quot;);
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span><span class="lineCov">          1 :               if (myShareOfRemainingSpace == 1.0f) {</span>
<span class="lineNum">    2582 </span>            :                 // (We special-case 1.0f to avoid float error from converting
<span class="lineNum">    2583 </span>            :                 // availableFreeSpace from integer*1.0f --&gt; float --&gt; integer)
<span class="lineNum">    2584 </span><span class="lineCov">          1 :                 sizeDelta = availableFreeSpace;</span>
<span class="lineNum">    2585 </span><span class="lineCov">          1 :               } else if (myShareOfRemainingSpace &gt; 0.0f) {</span>
<span class="lineNum">    2586 </span>            :                 sizeDelta = NSToCoordRound(availableFreeSpace *
<span class="lineNum">    2587 </span><span class="lineCov">          1 :                                            myShareOfRemainingSpace);</span>
<span class="lineNum">    2588 </span>            :               }
<span class="lineNum">    2589 </span><span class="lineCov">          1 :             } else if (item-&gt;GetWeight(isUsingFlexGrow) == largestWeight) {</span>
<span class="lineNum">    2590 </span>            :               // Total flexibility is infinite, so we're just distributing
<span class="lineNum">    2591 </span>            :               // the available space equally among the items that are tied for
<span class="lineNum">    2592 </span>            :               // having the largest weight (and this is one of those items).
<span class="lineNum">    2593 </span>            :               sizeDelta =
<span class="lineNum">    2594 </span>            :                 NSToCoordRound(availableFreeSpace /
<span class="lineNum">    2595 </span><span class="lineCov">          1 :                                float(numItemsWithLargestWeight));</span>
<span class="lineNum">    2596 </span><span class="lineCov">          1 :               numItemsWithLargestWeight--;</span>
<span class="lineNum">    2597 </span>            :             }
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span><span class="lineCov">          1 :             availableFreeSpace -= sizeDelta;</span>
<span class="lineNum">    2600 </span>            : 
<span class="lineNum">    2601 </span><span class="lineCov">          1 :             item-&gt;SetMainSize(item-&gt;GetMainSize() + sizeDelta);</span>
<span class="lineNum">    2602 </span><span class="lineCov">          1 :             MOZ_LOG(gFlexContainerLog, LogLevel::Debug,</span>
<span class="lineNum">    2603 </span>            :                    (&quot;  child %p receives %d, for a total of %d\n&quot;,
<span class="lineNum">    2604 </span>            :                     item, sizeDelta, item-&gt;GetMainSize()));
<span class="lineNum">    2605 </span>            :           }
<span class="lineNum">    2606 </span>            :         }
<span class="lineNum">    2607 </span>            :       }
<span class="lineNum">    2608 </span>            :     }
<span class="lineNum">    2609 </span>            : 
<span class="lineNum">    2610 </span>            :     // Fix min/max violations:
<span class="lineNum">    2611 </span><span class="lineCov">          1 :     nscoord totalViolation = 0; // keeps track of adjustments for min/max</span>
<span class="lineNum">    2612 </span><span class="lineCov">          1 :     MOZ_LOG(gFlexContainerLog, LogLevel::Debug,</span>
<span class="lineNum">    2613 </span>            :            (&quot; Checking for violations:&quot;));
<span class="lineNum">    2614 </span>            : 
<span class="lineNum">    2615 </span>            :     // Since this loop only operates on unfrozen flex items, we can break as
<span class="lineNum">    2616 </span>            :     // soon as we have seen all of them.
<span class="lineNum">    2617 </span><span class="lineCov">          1 :     uint32_t numUnfrozenItemsToBeSeen = mNumItems - mNumFrozenItems;</span>
<span class="lineNum">    2618 </span><span class="lineCov">          1 :     for (FlexItem* item = mItems.getFirst();</span>
<span class="lineNum">    2619 </span><span class="lineCov">          1 :          numUnfrozenItemsToBeSeen &gt; 0; item = item-&gt;getNext()) {</span>
<span class="lineNum">    2620 </span>            :       MOZ_ASSERT(item, &quot;numUnfrozenItemsToBeSeen says items remain to be seen&quot;);
<span class="lineNum">    2621 </span><span class="lineCov">          1 :       if (!item-&gt;IsFrozen()) {</span>
<span class="lineNum">    2622 </span><span class="lineCov">          1 :         numUnfrozenItemsToBeSeen--;</span>
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span><span class="lineCov">          1 :         if (item-&gt;GetMainSize() &lt; item-&gt;GetMainMinSize()) {</span>
<span class="lineNum">    2625 </span>            :           // min violation
<span class="lineNum">    2626 </span><span class="lineCov">          1 :           totalViolation += item-&gt;GetMainMinSize() - item-&gt;GetMainSize();</span>
<span class="lineNum">    2627 </span><span class="lineCov">          1 :           item-&gt;SetMainSize(item-&gt;GetMainMinSize());</span>
<span class="lineNum">    2628 </span><span class="lineCov">          1 :           item-&gt;SetHadMinViolation();</span>
<span class="lineNum">    2629 </span><span class="lineCov">          1 :         } else if (item-&gt;GetMainSize() &gt; item-&gt;GetMainMaxSize()) {</span>
<span class="lineNum">    2630 </span>            :           // max violation
<span class="lineNum">    2631 </span><span class="lineCov">          1 :           totalViolation += item-&gt;GetMainMaxSize() - item-&gt;GetMainSize();</span>
<span class="lineNum">    2632 </span><span class="lineCov">          1 :           item-&gt;SetMainSize(item-&gt;GetMainMaxSize());</span>
<span class="lineNum">    2633 </span><span class="lineCov">          1 :           item-&gt;SetHadMaxViolation();</span>
<span class="lineNum">    2634 </span>            :         }
<span class="lineNum">    2635 </span>            :       }
<span class="lineNum">    2636 </span>            :     }
<span class="lineNum">    2637 </span>            : 
<span class="lineNum">    2638 </span>            :     FreezeOrRestoreEachFlexibleSize(totalViolation,
<span class="lineNum">    2639 </span><span class="lineCov">          1 :                                     iterationCounter + 1 == mNumItems);</span>
<span class="lineNum">    2640 </span>            : 
<span class="lineNum">    2641 </span><span class="lineCov">          1 :     MOZ_LOG(gFlexContainerLog, LogLevel::Debug,</span>
<span class="lineNum">    2642 </span>            :            (&quot; Total violation: %d\n&quot;, totalViolation));
<span class="lineNum">    2643 </span>            : 
<span class="lineNum">    2644 </span><span class="lineCov">          1 :     if (mNumFrozenItems == mNumItems) {</span>
<span class="lineNum">    2645 </span>            :       break;
<span class="lineNum">    2646 </span>            :     }
<span class="lineNum">    2647 </span>            : 
<span class="lineNum">    2648 </span>            :     MOZ_ASSERT(totalViolation != 0,
<span class="lineNum">    2649 </span>            :                &quot;Zero violation should've made us freeze all items &amp; break&quot;);
<span class="lineNum">    2650 </span>            :   }
<span class="lineNum">    2651 </span>            : 
<span class="lineNum">    2652 </span>            : #ifdef DEBUG
<span class="lineNum">    2653 </span>            :   // Post-condition: all items should've been frozen.
<span class="lineNum">    2654 </span>            :   // Make sure the counts match:
<span class="lineNum">    2655 </span>            :   MOZ_ASSERT(mNumFrozenItems == mNumItems, &quot;All items should be frozen&quot;);
<span class="lineNum">    2656 </span>            : 
<span class="lineNum">    2657 </span>            :   // For good measure, check each item directly, in case our counts are busted:
<span class="lineNum">    2658 </span>            :   for (const FlexItem* item = mItems.getFirst(); item; item = item-&gt;getNext()) {
<span class="lineNum">    2659 </span>            :     MOZ_ASSERT(item-&gt;IsFrozen(), &quot;All items should be frozen&quot;);
<span class="lineNum">    2660 </span>            :   }
<span class="lineNum">    2661 </span>            : #endif // DEBUG
<a name="2662"><span class="lineNum">    2662 </span>            : }</a>
<span class="lineNum">    2663 </span>            : 
<span class="lineNum">    2664 </span><span class="lineCov">          1 : MainAxisPositionTracker::</span>
<span class="lineNum">    2665 </span>            :   MainAxisPositionTracker(const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    2666 </span>            :                           const FlexLine* aLine,
<span class="lineNum">    2667 </span>            :                           uint8_t aJustifyContent,
<span class="lineNum">    2668 </span>            :                           nscoord aContentBoxMainSize)
<span class="lineNum">    2669 </span>            :   : PositionTracker(aAxisTracker.GetMainAxis(),
<span class="lineNum">    2670 </span><span class="lineCov">          1 :                     aAxisTracker.IsMainAxisReversed()),</span>
<span class="lineNum">    2671 </span>            :     mPackingSpaceRemaining(aContentBoxMainSize), // we chip away at this below
<span class="lineNum">    2672 </span>            :     mNumAutoMarginsInMainAxis(0),
<span class="lineNum">    2673 </span>            :     mNumPackingSpacesRemaining(0),
<span class="lineNum">    2674 </span><span class="lineCov">          1 :     mJustifyContent(aJustifyContent)</span>
<span class="lineNum">    2675 </span>            : {
<span class="lineNum">    2676 </span>            :   // 'normal' behaves as 'stretch', and 'stretch' behaves as 'flex-start',
<span class="lineNum">    2677 </span>            :   // in the main axis
<span class="lineNum">    2678 </span>            :   // https://drafts.csswg.org/css-align-3/#propdef-justify-content
<span class="lineNum">    2679 </span><span class="lineCov">          1 :   if (mJustifyContent == NS_STYLE_JUSTIFY_NORMAL ||</span>
<span class="lineNum">    2680 </span>            :       mJustifyContent == NS_STYLE_JUSTIFY_STRETCH) {
<span class="lineNum">    2681 </span><span class="lineCov">          1 :     mJustifyContent = NS_STYLE_JUSTIFY_FLEX_START;</span>
<span class="lineNum">    2682 </span>            :   }
<span class="lineNum">    2683 </span>            : 
<span class="lineNum">    2684 </span>            :   // XXX strip off the &lt;overflow-position&gt; bit until we implement that
<span class="lineNum">    2685 </span><span class="lineCov">          1 :   mJustifyContent &amp;= ~NS_STYLE_JUSTIFY_FLAG_BITS;</span>
<span class="lineNum">    2686 </span>            : 
<span class="lineNum">    2687 </span>            :   // mPackingSpaceRemaining is initialized to the container's main size.  Now
<span class="lineNum">    2688 </span>            :   // we'll subtract out the main sizes of our flex items, so that it ends up
<span class="lineNum">    2689 </span>            :   // with the *actual* amount of packing space.
<span class="lineNum">    2690 </span><span class="lineCov">          1 :   for (const FlexItem* item = aLine-&gt;GetFirstItem(); item;</span>
<span class="lineNum">    2691 </span><span class="lineCov">          1 :        item = item-&gt;getNext()) {</span>
<span class="lineNum">    2692 </span><span class="lineCov">          1 :     mPackingSpaceRemaining -= item-&gt;GetOuterMainSize(mAxis);</span>
<span class="lineNum">    2693 </span><span class="lineCov">          1 :     mNumAutoMarginsInMainAxis += item-&gt;GetNumAutoMarginsInAxis(mAxis);</span>
<span class="lineNum">    2694 </span>            :   }
<span class="lineNum">    2695 </span>            : 
<span class="lineNum">    2696 </span><span class="lineCov">          1 :   if (mPackingSpaceRemaining &lt;= 0) {</span>
<span class="lineNum">    2697 </span>            :     // No available packing space to use for resolving auto margins.
<span class="lineNum">    2698 </span><span class="lineCov">          1 :     mNumAutoMarginsInMainAxis = 0;</span>
<span class="lineNum">    2699 </span>            :   }
<span class="lineNum">    2700 </span>            : 
<span class="lineNum">    2701 </span>            :   // If packing space is negative, 'space-between' falls back to 'flex-start',
<span class="lineNum">    2702 </span>            :   // and 'space-around' &amp; 'space-evenly' fall back to 'center'. In those cases,
<span class="lineNum">    2703 </span>            :   // it's simplest to just pretend we have a different 'justify-content' value
<span class="lineNum">    2704 </span>            :   // and share code.
<span class="lineNum">    2705 </span><span class="lineCov">          1 :   if (mPackingSpaceRemaining &lt; 0) {</span>
<span class="lineNum">    2706 </span><span class="lineCov">          1 :     if (mJustifyContent == NS_STYLE_JUSTIFY_SPACE_BETWEEN) {</span>
<span class="lineNum">    2707 </span><span class="lineCov">          1 :       mJustifyContent = NS_STYLE_JUSTIFY_FLEX_START;</span>
<span class="lineNum">    2708 </span><span class="lineCov">          1 :     } else if (mJustifyContent == NS_STYLE_JUSTIFY_SPACE_AROUND ||</span>
<span class="lineNum">    2709 </span>            :                mJustifyContent == NS_STYLE_JUSTIFY_SPACE_EVENLY) {
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :       mJustifyContent = NS_STYLE_JUSTIFY_CENTER;</span>
<span class="lineNum">    2711 </span>            :     }
<span class="lineNum">    2712 </span>            :   }
<span class="lineNum">    2713 </span>            : 
<span class="lineNum">    2714 </span>            :   // Map 'left'/'right' to 'start'/'end'
<span class="lineNum">    2715 </span><span class="lineCov">          1 :   if (mJustifyContent == NS_STYLE_JUSTIFY_LEFT ||</span>
<span class="lineNum">    2716 </span>            :       mJustifyContent == NS_STYLE_JUSTIFY_RIGHT) {
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :     if (aAxisTracker.IsColumnOriented()) {</span>
<span class="lineNum">    2718 </span>            :       // Container's alignment axis is not parallel to the inline axis,
<span class="lineNum">    2719 </span>            :       // so we map both 'left' and 'right' to 'start'.
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :       mJustifyContent = NS_STYLE_JUSTIFY_START;</span>
<span class="lineNum">    2721 </span>            :     } else {
<span class="lineNum">    2722 </span>            :       // Row-oriented, so we map 'left' and 'right' to 'start' or 'end',
<span class="lineNum">    2723 </span>            :       // depending on left-to-right writing mode.
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :       const bool isLTR = aAxisTracker.GetWritingMode().IsBidiLTR();</span>
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :       const bool isJustifyLeft = (mJustifyContent == NS_STYLE_JUSTIFY_LEFT);</span>
<span class="lineNum">    2726 </span>            :       mJustifyContent = (isJustifyLeft == isLTR) ? NS_STYLE_JUSTIFY_START
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :                                                  : NS_STYLE_JUSTIFY_END;</span>
<span class="lineNum">    2728 </span>            :     }
<span class="lineNum">    2729 </span>            :   }
<span class="lineNum">    2730 </span>            : 
<span class="lineNum">    2731 </span>            :   // Map 'start'/'end' to 'flex-start'/'flex-end'.
<span class="lineNum">    2732 </span><span class="lineCov">          1 :   if (mJustifyContent == NS_STYLE_JUSTIFY_START) {</span>
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :     mJustifyContent = NS_STYLE_JUSTIFY_FLEX_START;</span>
<span class="lineNum">    2734 </span><span class="lineCov">          1 :   } else if (mJustifyContent == NS_STYLE_JUSTIFY_END) {</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :     mJustifyContent = NS_STYLE_JUSTIFY_FLEX_END;</span>
<span class="lineNum">    2736 </span>            :   }
<span class="lineNum">    2737 </span>            : 
<span class="lineNum">    2738 </span>            :   // If our main axis is (internally) reversed, swap the justify-content
<span class="lineNum">    2739 </span>            :   // &quot;flex-start&quot; and &quot;flex-end&quot; behaviors:
<span class="lineNum">    2740 </span><span class="lineCov">          1 :   if (aAxisTracker.AreAxesInternallyReversed()) {</span>
<span class="lineNum">    2741 </span><span class="lineCov">          1 :     if (mJustifyContent == NS_STYLE_JUSTIFY_FLEX_START) {</span>
<span class="lineNum">    2742 </span><span class="lineCov">          1 :       mJustifyContent = NS_STYLE_JUSTIFY_FLEX_END;</span>
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :     } else if (mJustifyContent == NS_STYLE_JUSTIFY_FLEX_END) {</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :       mJustifyContent = NS_STYLE_JUSTIFY_FLEX_START;</span>
<span class="lineNum">    2745 </span>            :     }
<span class="lineNum">    2746 </span>            :   }
<span class="lineNum">    2747 </span>            : 
<span class="lineNum">    2748 </span>            :   // Figure out how much space we'll set aside for auto margins or
<span class="lineNum">    2749 </span>            :   // packing spaces, and advance past any leading packing-space.
<span class="lineNum">    2750 </span><span class="lineCov">          1 :   if (mNumAutoMarginsInMainAxis == 0 &amp;&amp;</span>
<span class="lineNum">    2751 </span><span class="lineCov">          1 :       mPackingSpaceRemaining != 0 &amp;&amp;</span>
<span class="lineNum">    2752 </span>            :       !aLine-&gt;IsEmpty()) {
<span class="lineNum">    2753 </span><span class="lineCov">          1 :     switch (mJustifyContent) {</span>
<span class="lineNum">    2754 </span>            :       case NS_STYLE_JUSTIFY_BASELINE:
<span class="lineNum">    2755 </span>            :       case NS_STYLE_JUSTIFY_LAST_BASELINE:
<span class="lineNum">    2756 </span>            :         NS_WARNING(&quot;NYI: justify-content:left/right/baseline/last baseline&quot;);
<span class="lineNum">    2757 </span>            :         MOZ_FALLTHROUGH;
<span class="lineNum">    2758 </span>            :       case NS_STYLE_JUSTIFY_FLEX_START:
<span class="lineNum">    2759 </span>            :         // All packing space should go at the end --&gt; nothing to do here.
<span class="lineNum">    2760 </span>            :         break;
<span class="lineNum">    2761 </span>            :       case NS_STYLE_JUSTIFY_FLEX_END:
<span class="lineNum">    2762 </span>            :         // All packing space goes at the beginning
<span class="lineNum">    2763 </span><span class="lineCov">          1 :         mPosition += mPackingSpaceRemaining;</span>
<span class="lineNum">    2764 </span><span class="lineCov">          1 :         break;</span>
<span class="lineNum">    2765 </span>            :       case NS_STYLE_JUSTIFY_CENTER:
<span class="lineNum">    2766 </span>            :         // Half the packing space goes at the beginning
<span class="lineNum">    2767 </span><span class="lineCov">          1 :         mPosition += mPackingSpaceRemaining / 2;</span>
<span class="lineNum">    2768 </span><span class="lineCov">          1 :         break;</span>
<span class="lineNum">    2769 </span>            :       case NS_STYLE_JUSTIFY_SPACE_BETWEEN:
<span class="lineNum">    2770 </span>            :       case NS_STYLE_JUSTIFY_SPACE_AROUND:
<span class="lineNum">    2771 </span>            :       case NS_STYLE_JUSTIFY_SPACE_EVENLY:
<span class="lineNum">    2772 </span>            :         nsFlexContainerFrame::CalculatePackingSpace(aLine-&gt;NumItems(),
<span class="lineNum">    2773 </span>            :                                                     mJustifyContent,
<span class="lineNum">    2774 </span>            :                                                     &amp;mPosition,
<span class="lineNum">    2775 </span>            :                                                     &amp;mNumPackingSpacesRemaining,
<span class="lineNum">    2776 </span><span class="lineCov">          1 :                                                     &amp;mPackingSpaceRemaining);</span>
<span class="lineNum">    2777 </span><span class="lineCov">          1 :         break;</span>
<span class="lineNum">    2778 </span>            :       default:
<span class="lineNum">    2779 </span>            :         MOZ_ASSERT_UNREACHABLE(&quot;Unexpected justify-content value&quot;);
<span class="lineNum">    2780 </span>            :     }
<span class="lineNum">    2781 </span>            :   }
<span class="lineNum">    2782 </span>            : 
<span class="lineNum">    2783 </span>            :   MOZ_ASSERT(mNumPackingSpacesRemaining == 0 ||
<span class="lineNum">    2784 </span>            :              mNumAutoMarginsInMainAxis == 0,
<span class="lineNum">    2785 </span>            :              &quot;extra space should either go to packing space or to &quot;
<span class="lineNum">    2786 </span>            :              &quot;auto margins, but not to both&quot;);
<span class="lineNum">    2787 </span><span class="lineCov">          1 : }</span>
<a name="2788"><span class="lineNum">    2788 </span>            : </a>
<span class="lineNum">    2789 </span>            : void
<span class="lineNum">    2790 </span><span class="lineCov">          1 : MainAxisPositionTracker::ResolveAutoMarginsInMainAxis(FlexItem&amp; aItem)</span>
<span class="lineNum">    2791 </span>            : {
<span class="lineNum">    2792 </span><span class="lineCov">          1 :   if (mNumAutoMarginsInMainAxis) {</span>
<span class="lineNum">    2793 </span><span class="lineCov">          1 :     const nsStyleSides&amp; styleMargin = aItem.Frame()-&gt;StyleMargin()-&gt;mMargin;</span>
<span class="lineNum">    2794 </span><span class="lineCov">          1 :     for (uint32_t i = 0; i &lt; eNumAxisEdges; i++) {</span>
<span class="lineNum">    2795 </span><span class="lineCov">          1 :       mozilla::Side side = kAxisOrientationToSidesMap[mAxis][i];</span>
<span class="lineNum">    2796 </span><span class="lineCov">          1 :       if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {</span>
<span class="lineNum">    2797 </span>            :         // NOTE: This integer math will skew the distribution of remainder
<span class="lineNum">    2798 </span>            :         // app-units towards the end, which is fine.
<span class="lineNum">    2799 </span>            :         nscoord curAutoMarginSize =
<span class="lineNum">    2800 </span><span class="lineCov">          1 :           mPackingSpaceRemaining / mNumAutoMarginsInMainAxis;</span>
<span class="lineNum">    2801 </span>            : 
<span class="lineNum">    2802 </span>            :         MOZ_ASSERT(aItem.GetMarginComponentForSide(side) == 0,
<span class="lineNum">    2803 </span>            :                    &quot;Expecting auto margins to have value '0' before we &quot;
<span class="lineNum">    2804 </span>            :                    &quot;resolve them&quot;);
<span class="lineNum">    2805 </span>            :         aItem.SetMarginComponentForSide(side, curAutoMarginSize);
<span class="lineNum">    2806 </span>            : 
<span class="lineNum">    2807 </span><span class="lineCov">          1 :         mNumAutoMarginsInMainAxis--;</span>
<span class="lineNum">    2808 </span><span class="lineCov">          1 :         mPackingSpaceRemaining -= curAutoMarginSize;</span>
<span class="lineNum">    2809 </span>            :       }
<span class="lineNum">    2810 </span>            :     }
<span class="lineNum">    2811 </span>            :   }
<span class="lineNum">    2812 </span><span class="lineCov">          1 : }</span>
<a name="2813"><span class="lineNum">    2813 </span>            : </a>
<span class="lineNum">    2814 </span>            : void
<span class="lineNum">    2815 </span><span class="lineCov">          1 : MainAxisPositionTracker::TraversePackingSpace()</span>
<span class="lineNum">    2816 </span>            : {
<span class="lineNum">    2817 </span><span class="lineCov">          1 :   if (mNumPackingSpacesRemaining) {</span>
<span class="lineNum">    2818 </span>            :     MOZ_ASSERT(mJustifyContent == NS_STYLE_JUSTIFY_SPACE_BETWEEN ||
<span class="lineNum">    2819 </span>            :                mJustifyContent == NS_STYLE_JUSTIFY_SPACE_AROUND ||
<span class="lineNum">    2820 </span>            :                mJustifyContent == NS_STYLE_JUSTIFY_SPACE_EVENLY,
<span class="lineNum">    2821 </span>            :                &quot;mNumPackingSpacesRemaining only applies for &quot;
<span class="lineNum">    2822 </span>            :                &quot;space-between/space-around/space-evenly&quot;);
<span class="lineNum">    2823 </span>            : 
<span class="lineNum">    2824 </span>            :     MOZ_ASSERT(mPackingSpaceRemaining &gt;= 0,
<span class="lineNum">    2825 </span>            :                &quot;ran out of packing space earlier than we expected&quot;);
<span class="lineNum">    2826 </span>            : 
<span class="lineNum">    2827 </span>            :     // NOTE: This integer math will skew the distribution of remainder
<span class="lineNum">    2828 </span>            :     // app-units towards the end, which is fine.
<span class="lineNum">    2829 </span>            :     nscoord curPackingSpace =
<span class="lineNum">    2830 </span><span class="lineCov">          1 :       mPackingSpaceRemaining / mNumPackingSpacesRemaining;</span>
<span class="lineNum">    2831 </span>            : 
<span class="lineNum">    2832 </span><span class="lineCov">          1 :     mPosition += curPackingSpace;</span>
<span class="lineNum">    2833 </span><span class="lineCov">          1 :     mNumPackingSpacesRemaining--;</span>
<span class="lineNum">    2834 </span><span class="lineCov">          1 :     mPackingSpaceRemaining -= curPackingSpace;</span>
<span class="lineNum">    2835 </span>            :   }
<a name="2836"><span class="lineNum">    2836 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    2837 </span>            : 
<span class="lineNum">    2838 </span><span class="lineCov">          1 : CrossAxisPositionTracker::</span>
<span class="lineNum">    2839 </span>            :   CrossAxisPositionTracker(FlexLine* aFirstLine,
<span class="lineNum">    2840 </span>            :                            const ReflowInput&amp; aReflowInput,
<span class="lineNum">    2841 </span>            :                            nscoord aContentBoxCrossSize,
<span class="lineNum">    2842 </span>            :                            bool aIsCrossSizeDefinite,
<span class="lineNum">    2843 </span>            :                            const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    2844 </span>            :   : PositionTracker(aAxisTracker.GetCrossAxis(),
<span class="lineNum">    2845 </span><span class="lineCov">          1 :                     aAxisTracker.IsCrossAxisReversed()),</span>
<span class="lineNum">    2846 </span>            :     mPackingSpaceRemaining(0),
<span class="lineNum">    2847 </span>            :     mNumPackingSpacesRemaining(0),
<span class="lineNum">    2848 </span><span class="lineCov">          1 :     mAlignContent(aReflowInput.mStylePosition-&gt;mAlignContent)</span>
<span class="lineNum">    2849 </span>            : {
<span class="lineNum">    2850 </span>            :   MOZ_ASSERT(aFirstLine, &quot;null first line pointer&quot;);
<span class="lineNum">    2851 </span>            : 
<span class="lineNum">    2852 </span>            :   // 'normal' behaves as 'stretch'
<span class="lineNum">    2853 </span><span class="lineCov">          1 :   if (mAlignContent == NS_STYLE_ALIGN_NORMAL) {</span>
<span class="lineNum">    2854 </span><span class="lineCov">          1 :     mAlignContent = NS_STYLE_ALIGN_STRETCH;</span>
<span class="lineNum">    2855 </span>            :   }
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span>            :   // XXX strip of the &lt;overflow-position&gt; bit until we implement that
<span class="lineNum">    2858 </span><span class="lineCov">          1 :   mAlignContent &amp;= ~NS_STYLE_ALIGN_FLAG_BITS;</span>
<span class="lineNum">    2859 </span>            : 
<span class="lineNum">    2860 </span>            :   const bool isSingleLine =
<span class="lineNum">    2861 </span><span class="lineCov">          1 :     NS_STYLE_FLEX_WRAP_NOWRAP == aReflowInput.mStylePosition-&gt;mFlexWrap;</span>
<span class="lineNum">    2862 </span><span class="lineCov">          1 :   if (isSingleLine) {</span>
<span class="lineNum">    2863 </span>            :     MOZ_ASSERT(!aFirstLine-&gt;getNext(),
<span class="lineNum">    2864 </span>            :                &quot;If we're styled as single-line, we should only have 1 line&quot;);
<span class="lineNum">    2865 </span>            :     // &quot;If the flex container is single-line and has a definite cross size, the
<span class="lineNum">    2866 </span>            :     // cross size of the flex line is the flex container's inner cross size.&quot;
<span class="lineNum">    2867 </span>            :     //
<span class="lineNum">    2868 </span>            :     // SOURCE: https://drafts.csswg.org/css-flexbox/#algo-cross-line
<span class="lineNum">    2869 </span>            :     // NOTE: This means (by definition) that there's no packing space, which
<span class="lineNum">    2870 </span>            :     // means we don't need to be concerned with &quot;align-conent&quot; at all and we
<span class="lineNum">    2871 </span>            :     // can return early. This is handy, because this is the usual case (for
<span class="lineNum">    2872 </span>            :     // single-line flexbox).
<span class="lineNum">    2873 </span><span class="lineCov">          1 :     if (aIsCrossSizeDefinite) {</span>
<span class="lineNum">    2874 </span><span class="lineCov">          1 :       aFirstLine-&gt;SetLineCrossSize(aContentBoxCrossSize);</span>
<span class="lineNum">    2875 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">    2876 </span>            :     }
<span class="lineNum">    2877 </span>            : 
<span class="lineNum">    2878 </span>            :     // &quot;If the flex container is single-line, then clamp the line's
<span class="lineNum">    2879 </span>            :     // cross-size to be within the container's computed min and max cross-size
<span class="lineNum">    2880 </span>            :     // properties.&quot;
<span class="lineNum">    2881 </span>            :     aFirstLine-&gt;SetLineCrossSize(NS_CSS_MINMAX(aFirstLine-&gt;GetLineCrossSize(),
<span class="lineNum">    2882 </span>            :                                                aReflowInput.ComputedMinBSize(),
<span class="lineNum">    2883 </span><span class="lineCov">          1 :                                                aReflowInput.ComputedMaxBSize()));</span>
<span class="lineNum">    2884 </span>            :   }
<span class="lineNum">    2885 </span>            : 
<span class="lineNum">    2886 </span>            :   // NOTE: The rest of this function should essentially match
<span class="lineNum">    2887 </span>            :   // MainAxisPositionTracker's constructor, though with FlexLines instead of
<span class="lineNum">    2888 </span>            :   // FlexItems, and with the additional value &quot;stretch&quot; (and of course with
<span class="lineNum">    2889 </span>            :   // cross sizes instead of main sizes.)
<span class="lineNum">    2890 </span>            : 
<span class="lineNum">    2891 </span>            :   // Figure out how much packing space we have (container's cross size minus
<span class="lineNum">    2892 </span>            :   // all the lines' cross sizes).  Also, share this loop to count how many
<span class="lineNum">    2893 </span>            :   // lines we have. (We need that count in some cases below.)
<span class="lineNum">    2894 </span><span class="lineCov">          1 :   mPackingSpaceRemaining = aContentBoxCrossSize;</span>
<span class="lineNum">    2895 </span><span class="lineCov">          1 :   uint32_t numLines = 0;</span>
<span class="lineNum">    2896 </span><span class="lineCov">          1 :   for (FlexLine* line = aFirstLine; line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    2897 </span><span class="lineCov">          1 :     mPackingSpaceRemaining -= line-&gt;GetLineCrossSize();</span>
<span class="lineNum">    2898 </span><span class="lineCov">          1 :     numLines++;</span>
<span class="lineNum">    2899 </span>            :   }
<span class="lineNum">    2900 </span>            : 
<span class="lineNum">    2901 </span>            :   // If packing space is negative, 'space-between' and 'stretch' behave like
<span class="lineNum">    2902 </span>            :   // 'flex-start', and 'space-around' and 'space-evenly' behave like 'center'.
<span class="lineNum">    2903 </span>            :   // In those cases, it's simplest to just pretend we have a different
<span class="lineNum">    2904 </span>            :   // 'align-content' value and share code.
<span class="lineNum">    2905 </span><span class="lineCov">          1 :   if (mPackingSpaceRemaining &lt; 0) {</span>
<span class="lineNum">    2906 </span><span class="lineCov">          1 :     if (mAlignContent == NS_STYLE_ALIGN_SPACE_BETWEEN ||</span>
<span class="lineNum">    2907 </span>            :         mAlignContent == NS_STYLE_ALIGN_STRETCH) {
<span class="lineNum">    2908 </span><span class="lineCov">          1 :       mAlignContent = NS_STYLE_ALIGN_FLEX_START;</span>
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :     } else if (mAlignContent == NS_STYLE_ALIGN_SPACE_AROUND ||</span>
<span class="lineNum">    2910 </span>            :                mAlignContent == NS_STYLE_ALIGN_SPACE_EVENLY) {
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :       mAlignContent = NS_STYLE_ALIGN_CENTER;</span>
<span class="lineNum">    2912 </span>            :     }
<span class="lineNum">    2913 </span>            :   }
<span class="lineNum">    2914 </span>            : 
<span class="lineNum">    2915 </span>            :   // Map 'left'/'right' to 'start'/'end'
<span class="lineNum">    2916 </span><span class="lineCov">          1 :   if (mAlignContent == NS_STYLE_ALIGN_LEFT ||</span>
<span class="lineNum">    2917 </span>            :       mAlignContent == NS_STYLE_ALIGN_RIGHT) {
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 :     if (aAxisTracker.IsRowOriented()) {</span>
<span class="lineNum">    2919 </span>            :       // Container's alignment axis is not parallel to the inline axis,
<span class="lineNum">    2920 </span>            :       // so we map both 'left' and 'right' to 'start'.
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :       mAlignContent = NS_STYLE_ALIGN_START;</span>
<span class="lineNum">    2922 </span>            :     } else {
<span class="lineNum">    2923 </span>            :       // Column-oriented, so we map 'left' and 'right' to 'start' or 'end',
<span class="lineNum">    2924 </span>            :       // depending on left-to-right writing mode.
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 :       const bool isLTR = aAxisTracker.GetWritingMode().IsBidiLTR();</span>
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :       const bool isAlignLeft = (mAlignContent == NS_STYLE_ALIGN_LEFT);</span>
<span class="lineNum">    2927 </span>            :       mAlignContent = (isAlignLeft == isLTR) ? NS_STYLE_ALIGN_START
<span class="lineNum">    2928 </span><span class="lineNoCov">          0 :                                              : NS_STYLE_ALIGN_END;</span>
<span class="lineNum">    2929 </span>            :     }
<span class="lineNum">    2930 </span>            :   }
<span class="lineNum">    2931 </span>            : 
<span class="lineNum">    2932 </span>            :   // Map 'start'/'end' to 'flex-start'/'flex-end'.
<span class="lineNum">    2933 </span><span class="lineCov">          1 :   if (mAlignContent == NS_STYLE_ALIGN_START) {</span>
<span class="lineNum">    2934 </span><span class="lineNoCov">          0 :     mAlignContent = NS_STYLE_ALIGN_FLEX_START;</span>
<span class="lineNum">    2935 </span><span class="lineCov">          1 :   } else if (mAlignContent == NS_STYLE_ALIGN_END) {</span>
<span class="lineNum">    2936 </span><span class="lineNoCov">          0 :     mAlignContent = NS_STYLE_ALIGN_FLEX_END;</span>
<span class="lineNum">    2937 </span>            :   }
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span>            :   // If our cross axis is (internally) reversed, swap the align-content
<span class="lineNum">    2940 </span>            :   // &quot;flex-start&quot; and &quot;flex-end&quot; behaviors:
<span class="lineNum">    2941 </span><span class="lineCov">          1 :   if (aAxisTracker.AreAxesInternallyReversed()) {</span>
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :     if (mAlignContent == NS_STYLE_ALIGN_FLEX_START) {</span>
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :       mAlignContent = NS_STYLE_ALIGN_FLEX_END;</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :     } else if (mAlignContent == NS_STYLE_ALIGN_FLEX_END) {</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :       mAlignContent = NS_STYLE_ALIGN_FLEX_START;</span>
<span class="lineNum">    2946 </span>            :     }
<span class="lineNum">    2947 </span>            :   }
<span class="lineNum">    2948 </span>            : 
<span class="lineNum">    2949 </span>            :   // Figure out how much space we'll set aside for packing spaces, and advance
<span class="lineNum">    2950 </span>            :   // past any leading packing-space.
<span class="lineNum">    2951 </span><span class="lineCov">          1 :   if (mPackingSpaceRemaining != 0) {</span>
<span class="lineNum">    2952 </span><span class="lineCov">          1 :     switch (mAlignContent) {</span>
<span class="lineNum">    2953 </span>            :       case NS_STYLE_ALIGN_SELF_START:
<span class="lineNum">    2954 </span>            :       case NS_STYLE_ALIGN_SELF_END:
<span class="lineNum">    2955 </span>            :       case NS_STYLE_ALIGN_BASELINE:
<span class="lineNum">    2956 </span>            :       case NS_STYLE_ALIGN_LAST_BASELINE:
<span class="lineNum">    2957 </span>            :         NS_WARNING(&quot;NYI: align-items/align-self:left/right/self-start/self-end/baseline/last baseline&quot;);
<span class="lineNum">    2958 </span>            :         MOZ_FALLTHROUGH;
<span class="lineNum">    2959 </span>            :       case NS_STYLE_ALIGN_FLEX_START:
<span class="lineNum">    2960 </span>            :         // All packing space should go at the end --&gt; nothing to do here.
<span class="lineNum">    2961 </span>            :         break;
<span class="lineNum">    2962 </span>            :       case NS_STYLE_ALIGN_FLEX_END:
<span class="lineNum">    2963 </span>            :         // All packing space goes at the beginning
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :         mPosition += mPackingSpaceRemaining;</span>
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2966 </span>            :       case NS_STYLE_ALIGN_CENTER:
<span class="lineNum">    2967 </span>            :         // Half the packing space goes at the beginning
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :         mPosition += mPackingSpaceRemaining / 2;</span>
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2970 </span>            :       case NS_STYLE_ALIGN_SPACE_BETWEEN:
<span class="lineNum">    2971 </span>            :       case NS_STYLE_ALIGN_SPACE_AROUND:
<span class="lineNum">    2972 </span>            :       case NS_STYLE_ALIGN_SPACE_EVENLY:
<span class="lineNum">    2973 </span>            :         nsFlexContainerFrame::CalculatePackingSpace(numLines,
<span class="lineNum">    2974 </span>            :                                                     mAlignContent,
<span class="lineNum">    2975 </span>            :                                                     &amp;mPosition,
<span class="lineNum">    2976 </span>            :                                                     &amp;mNumPackingSpacesRemaining,
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :                                                     &amp;mPackingSpaceRemaining);</span>
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2979 </span>            :       case NS_STYLE_ALIGN_STRETCH: {
<span class="lineNum">    2980 </span>            :         // Split space equally between the lines:
<span class="lineNum">    2981 </span>            :         MOZ_ASSERT(mPackingSpaceRemaining &gt; 0,
<span class="lineNum">    2982 </span>            :                    &quot;negative packing space should make us use 'flex-start' &quot;
<span class="lineNum">    2983 </span>            :                    &quot;instead of 'stretch' (and we shouldn't bother with this &quot;
<span class="lineNum">    2984 </span>            :                    &quot;code if we have 0 packing space)&quot;);
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :         uint32_t numLinesLeft = numLines;</span>
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :         for (FlexLine* line = aFirstLine; line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    2988 </span>            :           // Our share is the amount of space remaining, divided by the number
<span class="lineNum">    2989 </span>            :           // of lines remainig.
<span class="lineNum">    2990 </span>            :           MOZ_ASSERT(numLinesLeft &gt; 0, &quot;miscalculated num lines&quot;);
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :           nscoord shareOfExtraSpace = mPackingSpaceRemaining / numLinesLeft;</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :           nscoord newSize = line-&gt;GetLineCrossSize() + shareOfExtraSpace;</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :           line-&gt;SetLineCrossSize(newSize);</span>
<span class="lineNum">    2994 </span>            : 
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :           mPackingSpaceRemaining -= shareOfExtraSpace;</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :           numLinesLeft--;</span>
<span class="lineNum">    2997 </span>            :         }
<span class="lineNum">    2998 </span>            :         MOZ_ASSERT(numLinesLeft == 0, &quot;miscalculated num lines&quot;);
<span class="lineNum">    2999 </span>            :         break;
<span class="lineNum">    3000 </span>            :       }
<span class="lineNum">    3001 </span>            :       default:
<span class="lineNum">    3002 </span>            :         MOZ_ASSERT_UNREACHABLE(&quot;Unexpected align-content value&quot;);
<span class="lineNum">    3003 </span>            :     }
<span class="lineNum">    3004 </span>            :   }
<span class="lineNum">    3005 </span>            : }
<a name="3006"><span class="lineNum">    3006 </span>            : </a>
<span class="lineNum">    3007 </span>            : void
<span class="lineNum">    3008 </span><span class="lineCov">          1 : CrossAxisPositionTracker::TraversePackingSpace()</span>
<span class="lineNum">    3009 </span>            : {
<span class="lineNum">    3010 </span><span class="lineCov">          1 :   if (mNumPackingSpacesRemaining) {</span>
<span class="lineNum">    3011 </span>            :     MOZ_ASSERT(mAlignContent == NS_STYLE_ALIGN_SPACE_BETWEEN ||
<span class="lineNum">    3012 </span>            :                mAlignContent == NS_STYLE_ALIGN_SPACE_AROUND ||
<span class="lineNum">    3013 </span>            :                mAlignContent == NS_STYLE_ALIGN_SPACE_EVENLY,
<span class="lineNum">    3014 </span>            :                &quot;mNumPackingSpacesRemaining only applies for &quot;
<span class="lineNum">    3015 </span>            :                &quot;space-between/space-around/space-evenly&quot;);
<span class="lineNum">    3016 </span>            : 
<span class="lineNum">    3017 </span>            :     MOZ_ASSERT(mPackingSpaceRemaining &gt;= 0,
<span class="lineNum">    3018 </span>            :                &quot;ran out of packing space earlier than we expected&quot;);
<span class="lineNum">    3019 </span>            : 
<span class="lineNum">    3020 </span>            :     // NOTE: This integer math will skew the distribution of remainder
<span class="lineNum">    3021 </span>            :     // app-units towards the end, which is fine.
<span class="lineNum">    3022 </span>            :     nscoord curPackingSpace =
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :       mPackingSpaceRemaining / mNumPackingSpacesRemaining;</span>
<span class="lineNum">    3024 </span>            : 
<span class="lineNum">    3025 </span><span class="lineNoCov">          0 :     mPosition += curPackingSpace;</span>
<span class="lineNum">    3026 </span><span class="lineNoCov">          0 :     mNumPackingSpacesRemaining--;</span>
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :     mPackingSpaceRemaining -= curPackingSpace;</span>
<span class="lineNum">    3028 </span>            :   }
<a name="3029"><span class="lineNum">    3029 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 : SingleLineCrossAxisPositionTracker::</span>
<span class="lineNum">    3032 </span>            :   SingleLineCrossAxisPositionTracker(const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3033 </span>            :   : PositionTracker(aAxisTracker.GetCrossAxis(),
<span class="lineNum">    3034 </span><span class="lineCov">          1 :                     aAxisTracker.IsCrossAxisReversed())</span>
<span class="lineNum">    3035 </span>            : {
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 : }</span>
<a name="3037"><span class="lineNum">    3037 </span>            : </a>
<span class="lineNum">    3038 </span>            : void
<span class="lineNum">    3039 </span><span class="lineCov">          1 : FlexLine::ComputeCrossSizeAndBaseline(const FlexboxAxisTracker&amp; aAxisTracker)</span>
<span class="lineNum">    3040 </span>            : {
<span class="lineNum">    3041 </span><span class="lineCov">          1 :   nscoord crossStartToFurthestFirstBaseline = nscoord_MIN;</span>
<span class="lineNum">    3042 </span><span class="lineCov">          1 :   nscoord crossEndToFurthestFirstBaseline = nscoord_MIN;</span>
<span class="lineNum">    3043 </span><span class="lineCov">          1 :   nscoord crossStartToFurthestLastBaseline = nscoord_MIN;</span>
<span class="lineNum">    3044 </span><span class="lineCov">          1 :   nscoord crossEndToFurthestLastBaseline = nscoord_MIN;</span>
<span class="lineNum">    3045 </span><span class="lineCov">          1 :   nscoord largestOuterCrossSize = 0;</span>
<span class="lineNum">    3046 </span><span class="lineCov">          1 :   for (const FlexItem* item = mItems.getFirst(); item; item = item-&gt;getNext()) {</span>
<span class="lineNum">    3047 </span>            :     nscoord curOuterCrossSize =
<span class="lineNum">    3048 </span><span class="lineCov">          1 :       item-&gt;GetOuterCrossSize(aAxisTracker.GetCrossAxis());</span>
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span><span class="lineCov">          1 :     if ((item-&gt;GetAlignSelf() == NS_STYLE_ALIGN_BASELINE ||</span>
<span class="lineNum">    3051 </span><span class="lineCov">          1 :         item-&gt;GetAlignSelf() == NS_STYLE_ALIGN_LAST_BASELINE) &amp;&amp;</span>
<span class="lineNum">    3052 </span><span class="lineCov">          1 :         item-&gt;GetNumAutoMarginsInAxis(aAxisTracker.GetCrossAxis()) == 0) {</span>
<span class="lineNum">    3053 </span><span class="lineCov">          1 :       const bool useFirst = (item-&gt;GetAlignSelf() == NS_STYLE_ALIGN_BASELINE);</span>
<span class="lineNum">    3054 </span>            :       // FIXME: Once we support &quot;writing-mode&quot;, we'll have to do baseline
<span class="lineNum">    3055 </span>            :       // alignment in vertical flex containers here (w/ horizontal cross-axes).
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span>            :       // Find distance from our item's cross-start and cross-end margin-box
<span class="lineNum">    3058 </span>            :       // edges to its baseline.
<span class="lineNum">    3059 </span>            :       //
<span class="lineNum">    3060 </span>            :       // Here's a diagram of a flex-item that we might be doing this on.
<span class="lineNum">    3061 </span>            :       // &quot;mmm&quot; is the margin-box, &quot;bbb&quot; is the border-box. The bottom of
<span class="lineNum">    3062 </span>            :       // the text &quot;BASE&quot; is the baseline.
<span class="lineNum">    3063 </span>            :       //
<span class="lineNum">    3064 </span>            :       // ---(cross-start)---
<span class="lineNum">    3065 </span>            :       //                ___              ___            ___
<span class="lineNum">    3066 </span>            :       //   mmmmmmmmmmmm  |                |margin-start  |
<span class="lineNum">    3067 </span>            :       //   m          m  |               _|_   ___       |
<span class="lineNum">    3068 </span>            :       //   m bbbbbbbb m  |curOuterCrossSize     |        |crossStartToBaseline
<span class="lineNum">    3069 </span>            :       //   m b      b m  |                      |ascent  |
<span class="lineNum">    3070 </span>            :       //   m b BASE b m  |                     _|_      _|_
<span class="lineNum">    3071 </span>            :       //   m b      b m  |                               |
<span class="lineNum">    3072 </span>            :       //   m bbbbbbbb m  |                               |crossEndToBaseline
<span class="lineNum">    3073 </span>            :       //   m          m  |                               |
<span class="lineNum">    3074 </span>            :       //   mmmmmmmmmmmm _|_                             _|_
<span class="lineNum">    3075 </span>            :       //
<span class="lineNum">    3076 </span>            :       // ---(cross-end)---
<span class="lineNum">    3077 </span>            :       //
<span class="lineNum">    3078 </span>            :       // We already have the curOuterCrossSize, margin-start, and the ascent.
<span class="lineNum">    3079 </span>            :       // * We can get crossStartToBaseline by adding margin-start + ascent.
<span class="lineNum">    3080 </span>            :       // * If we subtract that from the curOuterCrossSize, we get
<span class="lineNum">    3081 </span>            :       //   crossEndToBaseline.
<span class="lineNum">    3082 </span>            : 
<span class="lineNum">    3083 </span>            :       nscoord crossStartToBaseline =
<span class="lineNum">    3084 </span>            :         item-&gt;GetBaselineOffsetFromOuterCrossEdge(eAxisEdge_Start,
<span class="lineNum">    3085 </span>            :                                                   aAxisTracker,
<span class="lineNum">    3086 </span><span class="lineCov">          1 :                                                   useFirst);</span>
<span class="lineNum">    3087 </span><span class="lineCov">          1 :       nscoord crossEndToBaseline = curOuterCrossSize - crossStartToBaseline;</span>
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span>            :       // Now, update our &quot;largest&quot; values for these (across all the flex items
<span class="lineNum">    3090 </span>            :       // in this flex line), so we can use them in computing the line's cross
<span class="lineNum">    3091 </span>            :       // size below:
<span class="lineNum">    3092 </span><span class="lineCov">          1 :       if (useFirst) {</span>
<span class="lineNum">    3093 </span>            :         crossStartToFurthestFirstBaseline =
<span class="lineNum">    3094 </span><span class="lineCov">          1 :           std::max(crossStartToFurthestFirstBaseline, crossStartToBaseline);</span>
<span class="lineNum">    3095 </span>            :         crossEndToFurthestFirstBaseline =
<span class="lineNum">    3096 </span><span class="lineCov">          1 :           std::max(crossEndToFurthestFirstBaseline, crossEndToBaseline);</span>
<span class="lineNum">    3097 </span>            :       } else {
<span class="lineNum">    3098 </span>            :         crossStartToFurthestLastBaseline =
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :           std::max(crossStartToFurthestLastBaseline, crossStartToBaseline);</span>
<span class="lineNum">    3100 </span>            :         crossEndToFurthestLastBaseline =
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :           std::max(crossEndToFurthestLastBaseline, crossEndToBaseline);</span>
<span class="lineNum">    3102 </span>            :       }
<span class="lineNum">    3103 </span>            :     } else {
<span class="lineNum">    3104 </span><span class="lineCov">          1 :       largestOuterCrossSize = std::max(largestOuterCrossSize, curOuterCrossSize);</span>
<span class="lineNum">    3105 </span>            :     }
<span class="lineNum">    3106 </span>            :   }
<span class="lineNum">    3107 </span>            : 
<span class="lineNum">    3108 </span>            :   // The line's baseline offset is the distance from the line's edge (start or
<span class="lineNum">    3109 </span>            :   // end, depending on whether we've flipped the axes) to the furthest
<span class="lineNum">    3110 </span>            :   // item-baseline. The item(s) with that baseline will be exactly aligned with
<span class="lineNum">    3111 </span>            :   // the line's edge.
<span class="lineNum">    3112 </span><span class="lineCov">          1 :   mFirstBaselineOffset = aAxisTracker.AreAxesInternallyReversed() ?</span>
<span class="lineNum">    3113 </span><span class="lineCov">          1 :     crossEndToFurthestFirstBaseline : crossStartToFurthestFirstBaseline;</span>
<span class="lineNum">    3114 </span>            : 
<span class="lineNum">    3115 </span><span class="lineCov">          1 :   mLastBaselineOffset = aAxisTracker.AreAxesInternallyReversed() ?</span>
<span class="lineNum">    3116 </span><span class="lineCov">          1 :     crossStartToFurthestLastBaseline : crossEndToFurthestLastBaseline;</span>
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span>            :   // The line's cross-size is the larger of:
<span class="lineNum">    3119 </span>            :   //  (a) [largest cross-start-to-baseline + largest baseline-to-cross-end] of
<span class="lineNum">    3120 </span>            :   //      all baseline-aligned items with no cross-axis auto margins...
<span class="lineNum">    3121 </span>            :   // and
<span class="lineNum">    3122 </span>            :   //  (b) [largest cross-start-to-baseline + largest baseline-to-cross-end] of
<span class="lineNum">    3123 </span>            :   //      all last baseline-aligned items with no cross-axis auto margins...
<span class="lineNum">    3124 </span>            :   // and
<span class="lineNum">    3125 </span>            :   //  (c) largest cross-size of all other children.
<span class="lineNum">    3126 </span>            :   mLineCrossSize = std::max(
<span class="lineNum">    3127 </span><span class="lineCov">          1 :     std::max(crossStartToFurthestFirstBaseline + crossEndToFurthestFirstBaseline,</span>
<span class="lineNum">    3128 </span><span class="lineCov">          1 :              crossStartToFurthestLastBaseline + crossEndToFurthestLastBaseline),</span>
<span class="lineNum">    3129 </span><span class="lineCov">          1 :     largestOuterCrossSize);</span>
<span class="lineNum">    3130 </span><span class="lineCov">          1 : }</span>
<a name="3131"><span class="lineNum">    3131 </span>            : </a>
<span class="lineNum">    3132 </span>            : void
<span class="lineNum">    3133 </span><span class="lineCov">          1 : FlexItem::ResolveStretchedCrossSize(nscoord aLineCrossSize,</span>
<span class="lineNum">    3134 </span>            :                                     const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3135 </span>            : {
<span class="lineNum">    3136 </span><span class="lineCov">          1 :   AxisOrientationType crossAxis = aAxisTracker.GetCrossAxis();</span>
<span class="lineNum">    3137 </span>            :   // We stretch IFF we are align-self:stretch, have no auto margins in
<span class="lineNum">    3138 </span>            :   // cross axis, and have cross-axis size property == &quot;auto&quot;. If any of those
<span class="lineNum">    3139 </span>            :   // conditions don't hold up, we won't stretch.
<span class="lineNum">    3140 </span><span class="lineCov">          1 :   if (mAlignSelf != NS_STYLE_ALIGN_STRETCH ||</span>
<span class="lineNum">    3141 </span><span class="lineCov">          1 :       GetNumAutoMarginsInAxis(crossAxis) != 0 ||</span>
<span class="lineNum">    3142 </span><span class="lineCov">          1 :       eStyleUnit_Auto != aAxisTracker.ComputedCrossSize(mFrame).GetUnit()) {</span>
<span class="lineNum">    3143 </span>            :     return;
<span class="lineNum">    3144 </span>            :   }
<span class="lineNum">    3145 </span>            : 
<span class="lineNum">    3146 </span>            :   // If we've already been stretched, we can bail out early, too.
<span class="lineNum">    3147 </span>            :   // No need to redo the calculation.
<span class="lineNum">    3148 </span><span class="lineCov">          1 :   if (mIsStretched) {</span>
<span class="lineNum">    3149 </span>            :     return;
<span class="lineNum">    3150 </span>            :   }
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span>            :   // Reserve space for margins &amp; border &amp; padding, and then use whatever
<span class="lineNum">    3153 </span>            :   // remains as our item's cross-size (clamped to its min/max range).
<span class="lineNum">    3154 </span>            :   nscoord stretchedSize = aLineCrossSize -
<span class="lineNum">    3155 </span><span class="lineCov">          1 :     GetMarginBorderPaddingSizeInAxis(crossAxis);</span>
<span class="lineNum">    3156 </span>            : 
<span class="lineNum">    3157 </span><span class="lineCov">          1 :   stretchedSize = NS_CSS_MINMAX(stretchedSize, mCrossMinSize, mCrossMaxSize);</span>
<span class="lineNum">    3158 </span>            : 
<span class="lineNum">    3159 </span>            :   // Update the cross-size &amp; make a note that it's stretched, so we know to
<span class="lineNum">    3160 </span>            :   // override the reflow state's computed cross-size in our final reflow.
<span class="lineNum">    3161 </span><span class="lineCov">          1 :   SetCrossSize(stretchedSize);</span>
<span class="lineNum">    3162 </span><span class="lineCov">          1 :   mIsStretched = true;</span>
<span class="lineNum">    3163 </span>            : }
<a name="3164"><span class="lineNum">    3164 </span>            : </a>
<span class="lineNum">    3165 </span>            : void
<span class="lineNum">    3166 </span><span class="lineCov">          1 : SingleLineCrossAxisPositionTracker::</span>
<span class="lineNum">    3167 </span>            :   ResolveAutoMarginsInCrossAxis(const FlexLine&amp; aLine,
<span class="lineNum">    3168 </span>            :                                 FlexItem&amp; aItem)
<span class="lineNum">    3169 </span>            : {
<span class="lineNum">    3170 </span>            :   // Subtract the space that our item is already occupying, to see how much
<span class="lineNum">    3171 </span>            :   // space (if any) is available for its auto margins.
<span class="lineNum">    3172 </span><span class="lineCov">          1 :   nscoord spaceForAutoMargins = aLine.GetLineCrossSize() -</span>
<span class="lineNum">    3173 </span><span class="lineCov">          1 :     aItem.GetOuterCrossSize(mAxis);</span>
<span class="lineNum">    3174 </span>            : 
<span class="lineNum">    3175 </span><span class="lineCov">          1 :   if (spaceForAutoMargins &lt;= 0) {</span>
<span class="lineNum">    3176 </span>            :     return; // No available space  --&gt; nothing to do
<span class="lineNum">    3177 </span>            :   }
<span class="lineNum">    3178 </span>            : 
<span class="lineNum">    3179 </span><span class="lineCov">          1 :   uint32_t numAutoMargins = aItem.GetNumAutoMarginsInAxis(mAxis);</span>
<span class="lineNum">    3180 </span><span class="lineCov">          1 :   if (numAutoMargins == 0) {</span>
<span class="lineNum">    3181 </span>            :     return; // No auto margins --&gt; nothing to do.
<span class="lineNum">    3182 </span>            :   }
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span>            :   // OK, we have at least one auto margin and we have some available space.
<span class="lineNum">    3185 </span>            :   // Give each auto margin a share of the space.
<span class="lineNum">    3186 </span><span class="lineCov">          1 :   const nsStyleSides&amp; styleMargin = aItem.Frame()-&gt;StyleMargin()-&gt;mMargin;</span>
<span class="lineNum">    3187 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; eNumAxisEdges; i++) {</span>
<span class="lineNum">    3188 </span><span class="lineCov">          1 :     mozilla::Side side = kAxisOrientationToSidesMap[mAxis][i];</span>
<span class="lineNum">    3189 </span><span class="lineCov">          1 :     if (styleMargin.GetUnit(side) == eStyleUnit_Auto) {</span>
<span class="lineNum">    3190 </span>            :       MOZ_ASSERT(aItem.GetMarginComponentForSide(side) == 0,
<span class="lineNum">    3191 </span>            :                  &quot;Expecting auto margins to have value '0' before we &quot;
<span class="lineNum">    3192 </span>            :                  &quot;update them&quot;);
<span class="lineNum">    3193 </span>            : 
<span class="lineNum">    3194 </span>            :       // NOTE: integer divison is fine here; numAutoMargins is either 1 or 2.
<span class="lineNum">    3195 </span>            :       // If it's 2 &amp; spaceForAutoMargins is odd, 1st margin gets smaller half.
<span class="lineNum">    3196 </span><span class="lineCov">          1 :       nscoord curAutoMarginSize = spaceForAutoMargins / numAutoMargins;</span>
<span class="lineNum">    3197 </span>            :       aItem.SetMarginComponentForSide(side, curAutoMarginSize);
<span class="lineNum">    3198 </span><span class="lineCov">          1 :       numAutoMargins--;</span>
<span class="lineNum">    3199 </span><span class="lineCov">          1 :       spaceForAutoMargins -= curAutoMarginSize;</span>
<span class="lineNum">    3200 </span>            :     }
<span class="lineNum">    3201 </span>            :   }
<span class="lineNum">    3202 </span>            : }
<a name="3203"><span class="lineNum">    3203 </span>            : </a>
<span class="lineNum">    3204 </span>            : void
<span class="lineNum">    3205 </span><span class="lineCov">          1 : SingleLineCrossAxisPositionTracker::</span>
<span class="lineNum">    3206 </span>            :   EnterAlignPackingSpace(const FlexLine&amp; aLine,
<span class="lineNum">    3207 </span>            :                          const FlexItem&amp; aItem,
<span class="lineNum">    3208 </span>            :                          const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3209 </span>            : {
<span class="lineNum">    3210 </span>            :   // We don't do align-self alignment on items that have auto margins
<span class="lineNum">    3211 </span>            :   // in the cross axis.
<span class="lineNum">    3212 </span><span class="lineCov">          1 :   if (aItem.GetNumAutoMarginsInAxis(mAxis)) {</span>
<span class="lineNum">    3213 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    3214 </span>            :   }
<span class="lineNum">    3215 </span>            : 
<span class="lineNum">    3216 </span><span class="lineCov">          1 :   uint8_t alignSelf = aItem.GetAlignSelf();</span>
<span class="lineNum">    3217 </span>            :   // NOTE: 'stretch' behaves like 'flex-start' once we've stretched any
<span class="lineNum">    3218 </span>            :   // auto-sized items (which we've already done).
<span class="lineNum">    3219 </span><span class="lineCov">          1 :   if (alignSelf == NS_STYLE_ALIGN_STRETCH) {</span>
<span class="lineNum">    3220 </span><span class="lineCov">          1 :     alignSelf = NS_STYLE_ALIGN_FLEX_START;</span>
<span class="lineNum">    3221 </span>            :   }
<span class="lineNum">    3222 </span>            : 
<span class="lineNum">    3223 </span>            :   // Map 'left'/'right' to 'start'/'end'
<span class="lineNum">    3224 </span><span class="lineCov">          1 :   if (alignSelf == NS_STYLE_ALIGN_LEFT || alignSelf == NS_STYLE_ALIGN_RIGHT) {</span>
<span class="lineNum">    3225 </span><span class="lineNoCov">          0 :     if (aAxisTracker.IsRowOriented()) {</span>
<span class="lineNum">    3226 </span>            :       // Container's alignment axis is not parallel to the inline axis,
<span class="lineNum">    3227 </span>            :       // so we map both 'left' and 'right' to 'start'.
<span class="lineNum">    3228 </span>            :       alignSelf = NS_STYLE_ALIGN_START;
<span class="lineNum">    3229 </span>            :     } else {
<span class="lineNum">    3230 </span>            :       // Column-oriented, so we map 'left' and 'right' to 'start' or 'end',
<span class="lineNum">    3231 </span>            :       // depending on left-to-right writing mode.
<span class="lineNum">    3232 </span><span class="lineNoCov">          0 :       const bool isLTR = aAxisTracker.GetWritingMode().IsBidiLTR();</span>
<span class="lineNum">    3233 </span><span class="lineNoCov">          0 :       const bool isAlignLeft = (alignSelf == NS_STYLE_ALIGN_LEFT);</span>
<span class="lineNum">    3234 </span>            :       alignSelf = (isAlignLeft == isLTR) ? NS_STYLE_ALIGN_START
<span class="lineNum">    3235 </span><span class="lineNoCov">          0 :                                          : NS_STYLE_ALIGN_END;</span>
<span class="lineNum">    3236 </span>            :     }
<span class="lineNum">    3237 </span>            :   }
<span class="lineNum">    3238 </span>            : 
<span class="lineNum">    3239 </span>            :   // Map 'start'/'end' to 'flex-start'/'flex-end'.
<span class="lineNum">    3240 </span><span class="lineCov">          1 :   if (alignSelf == NS_STYLE_ALIGN_START) {</span>
<span class="lineNum">    3241 </span>            :     alignSelf = NS_STYLE_ALIGN_FLEX_START;
<span class="lineNum">    3242 </span><span class="lineCov">          1 :   } else if (alignSelf == NS_STYLE_ALIGN_END) {</span>
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 :     alignSelf = NS_STYLE_ALIGN_FLEX_END;</span>
<span class="lineNum">    3244 </span>            :   }
<span class="lineNum">    3245 </span>            : 
<span class="lineNum">    3246 </span>            :   // If our cross axis is (internally) reversed, swap the align-self
<span class="lineNum">    3247 </span>            :   // &quot;flex-start&quot; and &quot;flex-end&quot; behaviors:
<span class="lineNum">    3248 </span><span class="lineCov">          1 :   if (aAxisTracker.AreAxesInternallyReversed()) {</span>
<span class="lineNum">    3249 </span><span class="lineCov">          1 :     if (alignSelf == NS_STYLE_ALIGN_FLEX_START) {</span>
<span class="lineNum">    3250 </span>            :       alignSelf = NS_STYLE_ALIGN_FLEX_END;
<span class="lineNum">    3251 </span><span class="lineNoCov">          0 :     } else if (alignSelf == NS_STYLE_ALIGN_FLEX_END) {</span>
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :       alignSelf = NS_STYLE_ALIGN_FLEX_START;</span>
<span class="lineNum">    3253 </span>            :     }
<span class="lineNum">    3254 </span>            :   }
<span class="lineNum">    3255 </span>            : 
<span class="lineNum">    3256 </span><span class="lineCov">          1 :   switch (alignSelf) {</span>
<span class="lineNum">    3257 </span>            :     case NS_STYLE_ALIGN_SELF_START:
<span class="lineNum">    3258 </span>            :     case NS_STYLE_ALIGN_SELF_END:
<span class="lineNum">    3259 </span>            :       NS_WARNING(&quot;NYI: align-items/align-self:left/right/self-start/self-end&quot;);
<span class="lineNum">    3260 </span>            :       MOZ_FALLTHROUGH;
<span class="lineNum">    3261 </span>            :     case NS_STYLE_ALIGN_FLEX_START:
<span class="lineNum">    3262 </span>            :       // No space to skip over -- we're done.
<span class="lineNum">    3263 </span>            :       break;
<span class="lineNum">    3264 </span>            :     case NS_STYLE_ALIGN_FLEX_END:
<span class="lineNum">    3265 </span><span class="lineCov">          1 :       mPosition += aLine.GetLineCrossSize() - aItem.GetOuterCrossSize(mAxis);</span>
<span class="lineNum">    3266 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3267 </span>            :     case NS_STYLE_ALIGN_CENTER:
<span class="lineNum">    3268 </span>            :       // Note: If cross-size is odd, the &quot;after&quot; space will get the extra unit.
<span class="lineNum">    3269 </span>            :       mPosition +=
<span class="lineNum">    3270 </span><span class="lineCov">          1 :         (aLine.GetLineCrossSize() - aItem.GetOuterCrossSize(mAxis)) / 2;</span>
<span class="lineNum">    3271 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3272 </span>            :     case NS_STYLE_ALIGN_BASELINE:
<span class="lineNum">    3273 </span>            :     case NS_STYLE_ALIGN_LAST_BASELINE: {
<span class="lineNum">    3274 </span><span class="lineCov">          1 :       const bool useFirst = (alignSelf == NS_STYLE_ALIGN_BASELINE);</span>
<span class="lineNum">    3275 </span>            : 
<span class="lineNum">    3276 </span>            :       // Normally, baseline-aligned items are collectively aligned with the
<span class="lineNum">    3277 </span>            :       // line's cross-start edge; however, if our cross axis is (internally)
<span class="lineNum">    3278 </span>            :       // reversed, we instead align them with the cross-end edge.
<span class="lineNum">    3279 </span>            :       // A similar logic holds for last baseline-aligned items, but in reverse.
<span class="lineNum">    3280 </span>            :       AxisEdgeType baselineAlignEdge =
<span class="lineNum">    3281 </span><span class="lineCov">          1 :         aAxisTracker.AreAxesInternallyReversed() == useFirst ?</span>
<span class="lineNum">    3282 </span><span class="lineCov">          1 :         eAxisEdge_End : eAxisEdge_Start;</span>
<span class="lineNum">    3283 </span>            : 
<span class="lineNum">    3284 </span>            :       nscoord itemBaselineOffset =
<span class="lineNum">    3285 </span>            :         aItem.GetBaselineOffsetFromOuterCrossEdge(baselineAlignEdge,
<span class="lineNum">    3286 </span>            :                                                   aAxisTracker,
<span class="lineNum">    3287 </span><span class="lineCov">          1 :                                                   useFirst);</span>
<span class="lineNum">    3288 </span>            : 
<span class="lineNum">    3289 </span>            :       nscoord lineBaselineOffset = useFirst ? aLine.GetFirstBaselineOffset()
<span class="lineNum">    3290 </span><span class="lineCov">          1 :                                             : aLine.GetLastBaselineOffset();</span>
<span class="lineNum">    3291 </span>            : 
<span class="lineNum">    3292 </span>            :       NS_ASSERTION(lineBaselineOffset &gt;= itemBaselineOffset,
<span class="lineNum">    3293 </span>            :                    &quot;failed at finding largest baseline offset&quot;);
<span class="lineNum">    3294 </span>            : 
<span class="lineNum">    3295 </span>            :       // How much do we need to adjust our position (from the line edge),
<span class="lineNum">    3296 </span>            :       // to get the item's baseline to hit the line's baseline offset:
<span class="lineNum">    3297 </span><span class="lineCov">          1 :       nscoord baselineDiff = lineBaselineOffset - itemBaselineOffset;</span>
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span><span class="lineCov">          1 :       if (aAxisTracker.AreAxesInternallyReversed() == useFirst) {</span>
<span class="lineNum">    3300 </span>            :         // Advance to align item w/ line's flex-end edge (as in FLEX_END case):
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 :         mPosition += aLine.GetLineCrossSize() - aItem.GetOuterCrossSize(mAxis);</span>
<span class="lineNum">    3302 </span>            :         // ...and step *back* by the baseline adjustment:
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :         mPosition -= baselineDiff;</span>
<span class="lineNum">    3304 </span>            :       } else {
<span class="lineNum">    3305 </span>            :         // mPosition is already at line's flex-start edge.
<span class="lineNum">    3306 </span>            :         // From there, we step *forward* by the baseline adjustment:
<span class="lineNum">    3307 </span><span class="lineCov">          1 :         mPosition += baselineDiff;</span>
<span class="lineNum">    3308 </span>            :       }
<span class="lineNum">    3309 </span>            :       break;
<span class="lineNum">    3310 </span>            :     }
<span class="lineNum">    3311 </span>            :     default:
<span class="lineNum">    3312 </span>            :       MOZ_ASSERT_UNREACHABLE(&quot;Unexpected align-self value&quot;);
<span class="lineNum">    3313 </span>            :       break;
<span class="lineNum">    3314 </span>            :   }
<span class="lineNum">    3315 </span>            : }
<span class="lineNum">    3316 </span>            : 
<a name="3317"><span class="lineNum">    3317 </span>            : // Utility function to convert an InlineDir to an AxisOrientationType</a>
<span class="lineNum">    3318 </span>            : static inline AxisOrientationType
<span class="lineNum">    3319 </span><span class="lineCov">          1 : InlineDirToAxisOrientation(WritingMode::InlineDir aInlineDir)</span>
<span class="lineNum">    3320 </span>            : {
<span class="lineNum">    3321 </span><span class="lineCov">          1 :   switch (aInlineDir) {</span>
<span class="lineNum">    3322 </span>            :     case WritingMode::eInlineLTR:
<span class="lineNum">    3323 </span>            :       return eAxis_LR;
<span class="lineNum">    3324 </span>            :     case WritingMode::eInlineRTL:
<span class="lineNum">    3325 </span>            :       return eAxis_RL;
<span class="lineNum">    3326 </span>            :     case WritingMode::eInlineTTB:
<span class="lineNum">    3327 </span>            :       return eAxis_TB;
<span class="lineNum">    3328 </span>            :     case WritingMode::eInlineBTT:
<span class="lineNum">    3329 </span>            :       return eAxis_BT;
<span class="lineNum">    3330 </span>            :   }
<span class="lineNum">    3331 </span>            : 
<span class="lineNum">    3332 </span>            :   MOZ_ASSERT_UNREACHABLE(&quot;Unhandled InlineDir&quot;);
<span class="lineNum">    3333 </span>            :   return eAxis_LR; // in case of unforseen error, assume English LTR text flow.
<span class="lineNum">    3334 </span>            : }
<span class="lineNum">    3335 </span>            : 
<span class="lineNum">    3336 </span>            : // Utility function to convert a BlockDir to an AxisOrientationType
<span class="lineNum">    3337 </span>            : static inline AxisOrientationType
<span class="lineNum">    3338 </span>            : BlockDirToAxisOrientation(WritingMode::BlockDir aBlockDir)
<span class="lineNum">    3339 </span>            : {
<span class="lineNum">    3340 </span>            :   switch (aBlockDir) {
<span class="lineNum">    3341 </span>            :     case WritingMode::eBlockLR:
<span class="lineNum">    3342 </span>            :       return eAxis_LR;
<span class="lineNum">    3343 </span>            :     case WritingMode::eBlockRL:
<span class="lineNum">    3344 </span>            :       return eAxis_RL;
<span class="lineNum">    3345 </span>            :     case WritingMode::eBlockTB:
<span class="lineNum">    3346 </span>            :       return eAxis_TB;
<span class="lineNum">    3347 </span>            :     // NOTE: WritingMode::eBlockBT (bottom-to-top) does not exist.
<span class="lineNum">    3348 </span>            :   }
<span class="lineNum">    3349 </span>            : 
<span class="lineNum">    3350 </span>            :   MOZ_ASSERT_UNREACHABLE(&quot;Unhandled BlockDir&quot;);
<span class="lineNum">    3351 </span>            :   return eAxis_TB; // in case of unforseen error, assume English TTB block-flow
<a name="3352"><span class="lineNum">    3352 </span>            : }</a>
<span class="lineNum">    3353 </span>            : 
<span class="lineNum">    3354 </span><span class="lineCov">          1 : FlexboxAxisTracker::FlexboxAxisTracker(</span>
<span class="lineNum">    3355 </span>            :   const nsFlexContainerFrame* aFlexContainer,
<span class="lineNum">    3356 </span>            :   const WritingMode&amp; aWM,
<span class="lineNum">    3357 </span>            :   AxisTrackerFlags aFlags)
<span class="lineNum">    3358 </span>            :   : mWM(aWM),
<span class="lineNum">    3359 </span><span class="lineCov">          1 :     mAreAxesInternallyReversed(false)</span>
<span class="lineNum">    3360 </span>            : {
<span class="lineNum">    3361 </span><span class="lineCov">          1 :   if (IsLegacyBox(aFlexContainer)) {</span>
<span class="lineNum">    3362 </span><span class="lineNoCov">          0 :     InitAxesFromLegacyProps(aFlexContainer);</span>
<span class="lineNum">    3363 </span>            :   } else {
<span class="lineNum">    3364 </span><span class="lineCov">          1 :     InitAxesFromModernProps(aFlexContainer);</span>
<span class="lineNum">    3365 </span>            :   }
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span>            :   // Master switch to enable/disable bug 983427's code for reversing our axes
<span class="lineNum">    3368 </span>            :   // and reversing some logic, to avoid reflowing children in bottom-to-top
<span class="lineNum">    3369 </span>            :   // order. (This switch can be removed eventually, but for now, it allows
<span class="lineNum">    3370 </span>            :   // this special-case code path to be compared against the normal code path.)
<span class="lineNum">    3371 </span>            :   static bool sPreventBottomToTopChildOrdering = true;
<span class="lineNum">    3372 </span>            : 
<span class="lineNum">    3373 </span>            :   // Note: if the eAllowBottomToTopChildOrdering flag is set, that overrides
<span class="lineNum">    3374 </span>            :   // the static boolean and makes us skip this special case.
<span class="lineNum">    3375 </span><span class="lineCov">          1 :   if (!(aFlags &amp; AxisTrackerFlags::eAllowBottomToTopChildOrdering) &amp;&amp;</span>
<span class="lineNum">    3376 </span>            :       sPreventBottomToTopChildOrdering) {
<span class="lineNum">    3377 </span>            :     // If either axis is bottom-to-top, we flip both axes (and set a flag
<span class="lineNum">    3378 </span>            :     // so that we can flip some logic to make the reversal transparent).
<span class="lineNum">    3379 </span><span class="lineCov">          1 :     if (eAxis_BT == mMainAxis || eAxis_BT == mCrossAxis) {</span>
<span class="lineNum">    3380 </span><span class="lineCov">          1 :       mMainAxis = GetReverseAxis(mMainAxis);</span>
<span class="lineNum">    3381 </span><span class="lineCov">          1 :       mCrossAxis = GetReverseAxis(mCrossAxis);</span>
<span class="lineNum">    3382 </span><span class="lineCov">          1 :       mAreAxesInternallyReversed = true;</span>
<span class="lineNum">    3383 </span><span class="lineCov">          1 :       mIsMainAxisReversed = !mIsMainAxisReversed;</span>
<span class="lineNum">    3384 </span><span class="lineCov">          1 :       mIsCrossAxisReversed = !mIsCrossAxisReversed;</span>
<span class="lineNum">    3385 </span>            :     }
<span class="lineNum">    3386 </span>            :   }
<span class="lineNum">    3387 </span><span class="lineCov">          1 : }</span>
<a name="3388"><span class="lineNum">    3388 </span>            : </a>
<span class="lineNum">    3389 </span>            : void
<span class="lineNum">    3390 </span><span class="lineNoCov">          0 : FlexboxAxisTracker::InitAxesFromLegacyProps(</span>
<span class="lineNum">    3391 </span>            :   const nsFlexContainerFrame* aFlexContainer)
<span class="lineNum">    3392 </span>            : {
<span class="lineNum">    3393 </span><span class="lineNoCov">          0 :   const nsStyleXUL* styleXUL = aFlexContainer-&gt;StyleXUL();</span>
<span class="lineNum">    3394 </span>            : 
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :   const bool boxOrientIsVertical = (styleXUL-&gt;mBoxOrient ==</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :                                     StyleBoxOrient::Vertical);</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :   const bool wmIsVertical = mWM.IsVertical();</span>
<span class="lineNum">    3398 </span>            : 
<span class="lineNum">    3399 </span>            :   // If box-orient agrees with our writing-mode, then we're &quot;row-oriented&quot;
<span class="lineNum">    3400 </span>            :   // (i.e. the flexbox main axis is the same as our writing mode's inline
<span class="lineNum">    3401 </span>            :   // direction).  Otherwise, we're column-oriented (i.e. the flexbox's main
<span class="lineNum">    3402 </span>            :   // axis is perpendicular to the writing-mode's inline direction).
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :   mIsRowOriented = (boxOrientIsVertical == wmIsVertical);</span>
<span class="lineNum">    3404 </span>            : 
<span class="lineNum">    3405 </span>            :   // XXXdholbert BEGIN CODE TO SET DEPRECATED MEMBER-VARS
<span class="lineNum">    3406 </span><span class="lineNoCov">          0 :   if (boxOrientIsVertical) {</span>
<span class="lineNum">    3407 </span><span class="lineNoCov">          0 :     mMainAxis = eAxis_TB;</span>
<span class="lineNum">    3408 </span><span class="lineNoCov">          0 :     mCrossAxis = eAxis_LR;</span>
<span class="lineNum">    3409 </span>            :   } else {
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 :     mMainAxis = eAxis_LR;</span>
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :     mCrossAxis = eAxis_TB;</span>
<span class="lineNum">    3412 </span>            :   }
<span class="lineNum">    3413 </span>            :   // &quot;direction: rtl&quot; reverses the writing-mode's inline axis.
<span class="lineNum">    3414 </span>            :   // So, we need to reverse the corresponding flex axis to match.
<span class="lineNum">    3415 </span>            :   // (Note this we don't toggle &quot;mIsMainAxisReversed&quot; for this condition,
<span class="lineNum">    3416 </span>            :   // because the main axis will still match mWM's inline direction.)
<span class="lineNum">    3417 </span><span class="lineNoCov">          0 :   if (!mWM.IsBidiLTR()) {</span>
<span class="lineNum">    3418 </span><span class="lineNoCov">          0 :     AxisOrientationType&amp; axisToFlip = mIsRowOriented ? mMainAxis : mCrossAxis;</span>
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 :     axisToFlip = GetReverseAxis(axisToFlip);</span>
<span class="lineNum">    3420 </span>            :   }
<span class="lineNum">    3421 </span>            :   // XXXdholbert END CODE TO SET DEPRECATED MEMBER-VARS
<span class="lineNum">    3422 </span>            : 
<span class="lineNum">    3423 </span>            :   // Legacy flexbox can use &quot;-webkit-box-direction: reverse&quot; to reverse the
<span class="lineNum">    3424 </span>            :   // main axis (so it runs in the reverse direction of the inline axis):
<span class="lineNum">    3425 </span><span class="lineNoCov">          0 :   if (styleXUL-&gt;mBoxDirection == StyleBoxDirection::Reverse) {</span>
<span class="lineNum">    3426 </span><span class="lineNoCov">          0 :     mMainAxis = GetReverseAxis(mMainAxis);</span>
<span class="lineNum">    3427 </span><span class="lineNoCov">          0 :     mIsMainAxisReversed = true;</span>
<span class="lineNum">    3428 </span>            :   } else {
<span class="lineNum">    3429 </span><span class="lineNoCov">          0 :     mIsMainAxisReversed = false;</span>
<span class="lineNum">    3430 </span>            :   }
<span class="lineNum">    3431 </span>            : 
<span class="lineNum">    3432 </span>            :   // Legacy flexbox does not support reversing the cross axis -- it has no
<span class="lineNum">    3433 </span>            :   // equivalent of modern flexbox's &quot;flex-wrap: wrap-reverse&quot;.
<span class="lineNum">    3434 </span><span class="lineNoCov">          0 :   mIsCrossAxisReversed = false;</span>
<span class="lineNum">    3435 </span><span class="lineNoCov">          0 : }</span>
<a name="3436"><span class="lineNum">    3436 </span>            : </a>
<span class="lineNum">    3437 </span>            : void
<span class="lineNum">    3438 </span><span class="lineCov">          1 : FlexboxAxisTracker::InitAxesFromModernProps(</span>
<span class="lineNum">    3439 </span>            :   const nsFlexContainerFrame* aFlexContainer)
<span class="lineNum">    3440 </span>            : {
<span class="lineNum">    3441 </span><span class="lineCov">          1 :   const nsStylePosition* stylePos = aFlexContainer-&gt;StylePosition();</span>
<span class="lineNum">    3442 </span><span class="lineCov">          1 :   uint32_t flexDirection = stylePos-&gt;mFlexDirection;</span>
<span class="lineNum">    3443 </span>            : 
<span class="lineNum">    3444 </span>            :   // Inline dimension (&quot;start-to-end&quot;):
<span class="lineNum">    3445 </span>            :   // (NOTE: I'm intentionally not calling these &quot;inlineAxis&quot;/&quot;blockAxis&quot;, since
<span class="lineNum">    3446 </span>            :   // those terms have explicit definition in the writing-modes spec, which are
<span class="lineNum">    3447 </span>            :   // the opposite of how I'd be using them here.)
<span class="lineNum">    3448 </span>            :   AxisOrientationType inlineDimension =
<span class="lineNum">    3449 </span><span class="lineCov">          1 :     InlineDirToAxisOrientation(mWM.GetInlineDir());</span>
<span class="lineNum">    3450 </span>            :   AxisOrientationType blockDimension =
<span class="lineNum">    3451 </span><span class="lineCov">          1 :     BlockDirToAxisOrientation(mWM.GetBlockDir());</span>
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span>            :   // Determine main axis:
<span class="lineNum">    3454 </span><span class="lineCov">          1 :   switch (flexDirection) {</span>
<span class="lineNum">    3455 </span>            :     case NS_STYLE_FLEX_DIRECTION_ROW:
<span class="lineNum">    3456 </span><span class="lineCov">          1 :       mMainAxis = inlineDimension;</span>
<span class="lineNum">    3457 </span><span class="lineCov">          1 :       mIsRowOriented = true;</span>
<span class="lineNum">    3458 </span><span class="lineCov">          1 :       mIsMainAxisReversed = false;</span>
<span class="lineNum">    3459 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3460 </span>            :     case NS_STYLE_FLEX_DIRECTION_ROW_REVERSE:
<span class="lineNum">    3461 </span><span class="lineCov">          1 :       mMainAxis = GetReverseAxis(inlineDimension);</span>
<span class="lineNum">    3462 </span><span class="lineCov">          1 :       mIsRowOriented = true;</span>
<span class="lineNum">    3463 </span><span class="lineCov">          1 :       mIsMainAxisReversed = true;</span>
<span class="lineNum">    3464 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3465 </span>            :     case NS_STYLE_FLEX_DIRECTION_COLUMN:
<span class="lineNum">    3466 </span><span class="lineCov">          1 :       mMainAxis = blockDimension;</span>
<span class="lineNum">    3467 </span><span class="lineCov">          1 :       mIsRowOriented = false;</span>
<span class="lineNum">    3468 </span><span class="lineCov">          1 :       mIsMainAxisReversed = false;</span>
<span class="lineNum">    3469 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3470 </span>            :     case NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE:
<span class="lineNum">    3471 </span><span class="lineCov">          1 :       mMainAxis = GetReverseAxis(blockDimension);</span>
<span class="lineNum">    3472 </span><span class="lineCov">          1 :       mIsRowOriented = false;</span>
<span class="lineNum">    3473 </span><span class="lineCov">          1 :       mIsMainAxisReversed = true;</span>
<span class="lineNum">    3474 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3475 </span>            :     default:
<span class="lineNum">    3476 </span>            :       MOZ_ASSERT_UNREACHABLE(&quot;Unexpected flex-direction value&quot;);
<span class="lineNum">    3477 </span>            :   }
<span class="lineNum">    3478 </span>            : 
<span class="lineNum">    3479 </span>            :   // Determine cross axis:
<span class="lineNum">    3480 </span>            :   // (This is set up so that a bogus |flexDirection| value will
<span class="lineNum">    3481 </span>            :   // give us blockDimension.
<span class="lineNum">    3482 </span><span class="lineCov">          1 :   if (flexDirection == NS_STYLE_FLEX_DIRECTION_COLUMN ||</span>
<span class="lineNum">    3483 </span>            :       flexDirection == NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE) {
<span class="lineNum">    3484 </span><span class="lineCov">          1 :     mCrossAxis = inlineDimension;</span>
<span class="lineNum">    3485 </span>            :   } else {
<span class="lineNum">    3486 </span><span class="lineCov">          1 :     mCrossAxis = blockDimension;</span>
<span class="lineNum">    3487 </span>            :   }
<span class="lineNum">    3488 </span>            : 
<span class="lineNum">    3489 </span>            :   // &quot;flex-wrap: wrap-reverse&quot; reverses our cross axis.
<span class="lineNum">    3490 </span><span class="lineCov">          1 :   if (stylePos-&gt;mFlexWrap == NS_STYLE_FLEX_WRAP_WRAP_REVERSE) {</span>
<span class="lineNum">    3491 </span><span class="lineNoCov">          0 :     mCrossAxis = GetReverseAxis(mCrossAxis);</span>
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :     mIsCrossAxisReversed = true;</span>
<span class="lineNum">    3493 </span>            :   } else {
<span class="lineNum">    3494 </span><span class="lineCov">          1 :     mIsCrossAxisReversed = false;</span>
<span class="lineNum">    3495 </span>            :   }
<span class="lineNum">    3496 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    3497 </span>            : 
<span class="lineNum">    3498 </span>            : // Allocates a new FlexLine, adds it to the given LinkedList (at the front or
<a name="3499"><span class="lineNum">    3499 </span>            : // back depending on aShouldInsertAtFront), and returns a pointer to it.</a>
<span class="lineNum">    3500 </span>            : static FlexLine*
<span class="lineNum">    3501 </span><span class="lineCov">          1 : AddNewFlexLineToList(LinkedList&lt;FlexLine&gt;&amp; aLines,</span>
<span class="lineNum">    3502 </span>            :                      bool aShouldInsertAtFront)
<span class="lineNum">    3503 </span>            : {
<span class="lineNum">    3504 </span><span class="lineCov">          1 :   FlexLine* newLine = new FlexLine();</span>
<span class="lineNum">    3505 </span><span class="lineCov">          1 :   if (aShouldInsertAtFront) {</span>
<span class="lineNum">    3506 </span>            :     aLines.insertFront(newLine);
<span class="lineNum">    3507 </span>            :   } else {
<span class="lineNum">    3508 </span>            :     aLines.insertBack(newLine);
<span class="lineNum">    3509 </span>            :   }
<span class="lineNum">    3510 </span><span class="lineCov">          1 :   return newLine;</span>
<span class="lineNum">    3511 </span>            : }
<a name="3512"><span class="lineNum">    3512 </span>            : </a>
<span class="lineNum">    3513 </span>            : void
<span class="lineNum">    3514 </span><span class="lineCov">          1 : nsFlexContainerFrame::GenerateFlexLines(</span>
<span class="lineNum">    3515 </span>            :   nsPresContext* aPresContext,
<span class="lineNum">    3516 </span>            :   const ReflowInput&amp; aReflowInput,
<span class="lineNum">    3517 </span>            :   nscoord aContentBoxMainSize,
<span class="lineNum">    3518 </span>            :   nscoord aAvailableBSizeForContent,
<span class="lineNum">    3519 </span>            :   const nsTArray&lt;StrutInfo&gt;&amp; aStruts,
<span class="lineNum">    3520 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    3521 </span>            :   nsTArray&lt;nsIFrame*&gt;&amp; aPlaceholders, /* out */
<span class="lineNum">    3522 </span>            :   LinkedList&lt;FlexLine&gt;&amp; aLines /* out */)
<span class="lineNum">    3523 </span>            : {
<span class="lineNum">    3524 </span>            :   MOZ_ASSERT(aLines.isEmpty(), &quot;Expecting outparam to start out empty&quot;);
<span class="lineNum">    3525 </span>            : 
<span class="lineNum">    3526 </span>            :   const bool isSingleLine =
<span class="lineNum">    3527 </span><span class="lineCov">          1 :     NS_STYLE_FLEX_WRAP_NOWRAP == aReflowInput.mStylePosition-&gt;mFlexWrap;</span>
<span class="lineNum">    3528 </span>            : 
<span class="lineNum">    3529 </span>            :   // If we're transparently reversing axes, then we'll need to link up our
<span class="lineNum">    3530 </span>            :   // FlexItems and FlexLines in the reverse order, so that the rest of flex
<span class="lineNum">    3531 </span>            :   // layout (with flipped axes) will still produce the correct result.
<span class="lineNum">    3532 </span>            :   // Here, we declare a convenience bool that we'll pass when adding a new
<span class="lineNum">    3533 </span>            :   // FlexLine or FlexItem, to make us insert it at the beginning of its list
<span class="lineNum">    3534 </span>            :   // (so the list ends up reversed).
<span class="lineNum">    3535 </span><span class="lineCov">          1 :   const bool shouldInsertAtFront = aAxisTracker.AreAxesInternallyReversed();</span>
<span class="lineNum">    3536 </span>            : 
<span class="lineNum">    3537 </span>            :   // We have at least one FlexLine. Even an empty flex container has a single
<span class="lineNum">    3538 </span>            :   // (empty) flex line.
<span class="lineNum">    3539 </span><span class="lineCov">          1 :   FlexLine* curLine = AddNewFlexLineToList(aLines, shouldInsertAtFront);</span>
<span class="lineNum">    3540 </span>            : 
<span class="lineNum">    3541 </span>            :   nscoord wrapThreshold;
<span class="lineNum">    3542 </span><span class="lineCov">          1 :   if (isSingleLine) {</span>
<span class="lineNum">    3543 </span>            :     // Not wrapping. Set threshold to sentinel value that tells us not to wrap.
<span class="lineNum">    3544 </span><span class="lineCov">          1 :     wrapThreshold = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">    3545 </span>            :   } else {
<span class="lineNum">    3546 </span>            :     // Wrapping! Set wrap threshold to flex container's content-box main-size.
<span class="lineNum">    3547 </span><span class="lineCov">          1 :     wrapThreshold = aContentBoxMainSize;</span>
<span class="lineNum">    3548 </span>            : 
<span class="lineNum">    3549 </span>            :     // If the flex container doesn't have a definite content-box main-size
<span class="lineNum">    3550 </span>            :     // (e.g. if main axis is vertical &amp; 'height' is 'auto'), make sure we at
<span class="lineNum">    3551 </span>            :     // least wrap when we hit its max main-size.
<span class="lineNum">    3552 </span><span class="lineCov">          1 :     if (wrapThreshold == NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">    3553 </span>            :       const nscoord flexContainerMaxMainSize =
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :         GET_MAIN_COMPONENT_LOGICAL(aAxisTracker, aAxisTracker.GetWritingMode(),</span>
<span class="lineNum">    3555 </span>            :                                    aReflowInput.ComputedMaxISize(),
<span class="lineNum">    3556 </span>            :                                    aReflowInput.ComputedMaxBSize());
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :       wrapThreshold = flexContainerMaxMainSize;</span>
<span class="lineNum">    3559 </span>            :     }
<span class="lineNum">    3560 </span>            : 
<span class="lineNum">    3561 </span>            :     // Also: if we're column-oriented and paginating in the block dimension,
<span class="lineNum">    3562 </span>            :     // we may need to wrap to a new flex line sooner (before we grow past the
<span class="lineNum">    3563 </span>            :     // available BSize, potentially running off the end of the page).
<span class="lineNum">    3564 </span><span class="lineCov">          1 :     if (aAxisTracker.IsColumnOriented() &amp;&amp;</span>
<span class="lineNum">    3565 </span><span class="lineNoCov">          0 :         aAvailableBSizeForContent != NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">    3566 </span><span class="lineNoCov">          0 :       wrapThreshold = std::min(wrapThreshold, aAvailableBSizeForContent);</span>
<span class="lineNum">    3567 </span>            :     }
<span class="lineNum">    3568 </span>            :   }
<span class="lineNum">    3569 </span>            : 
<span class="lineNum">    3570 </span>            :   // Tracks the index of the next strut, in aStruts (and when this hits
<span class="lineNum">    3571 </span>            :   // aStruts.Length(), that means there are no more struts):
<span class="lineNum">    3572 </span><span class="lineCov">          1 :   uint32_t nextStrutIdx = 0;</span>
<span class="lineNum">    3573 </span>            : 
<span class="lineNum">    3574 </span>            :   // Overall index of the current flex item in the flex container. (This gets
<span class="lineNum">    3575 </span>            :   // checked against entries in aStruts.)
<span class="lineNum">    3576 </span><span class="lineCov">          1 :   uint32_t itemIdxInContainer = 0;</span>
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span>            :   CSSOrderAwareFrameIterator iter(this, kPrincipalList,
<span class="lineNum">    3579 </span>            :                                   CSSOrderAwareFrameIterator::eIncludeAll,
<span class="lineNum">    3580 </span>            :                                   CSSOrderAwareFrameIterator::eUnknownOrder,
<span class="lineNum">    3581 </span><span class="lineCov">          1 :                                   OrderingPropertyForIter(this));</span>
<span class="lineNum">    3582 </span>            : 
<span class="lineNum">    3583 </span><span class="lineCov">          1 :   if (iter.ItemsAreAlreadyInOrder()) {</span>
<span class="lineNum">    3584 </span><span class="lineCov">          1 :     AddStateBits(NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER);</span>
<span class="lineNum">    3585 </span>            :   } else {
<span class="lineNum">    3586 </span><span class="lineCov">          1 :     RemoveStateBits(NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER);</span>
<span class="lineNum">    3587 </span>            :   }
<span class="lineNum">    3588 </span>            : 
<span class="lineNum">    3589 </span><span class="lineCov">          1 :   for (; !iter.AtEnd(); iter.Next()) {</span>
<span class="lineNum">    3590 </span><span class="lineCov">          1 :     nsIFrame* childFrame = *iter;</span>
<span class="lineNum">    3591 </span>            :     // Don't create flex items / lines for placeholder frames:
<span class="lineNum">    3592 </span><span class="lineCov">          1 :     if (childFrame-&gt;GetType() == nsGkAtoms::placeholderFrame) {</span>
<span class="lineNum">    3593 </span><span class="lineCov">          1 :       aPlaceholders.AppendElement(childFrame);</span>
<span class="lineNum">    3594 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    3595 </span>            :     }
<span class="lineNum">    3596 </span>            : 
<span class="lineNum">    3597 </span>            :     // Honor &quot;page-break-before&quot;, if we're multi-line and this line isn't empty:
<span class="lineNum">    3598 </span><span class="lineCov">          1 :     if (!isSingleLine &amp;&amp; !curLine-&gt;IsEmpty() &amp;&amp;</span>
<span class="lineNum">    3599 </span><span class="lineCov">          1 :         childFrame-&gt;StyleDisplay()-&gt;mBreakBefore) {</span>
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :       curLine = AddNewFlexLineToList(aLines, shouldInsertAtFront);</span>
<span class="lineNum">    3601 </span>            :     }
<span class="lineNum">    3602 </span>            : 
<span class="lineNum">    3603 </span>            :     UniquePtr&lt;FlexItem&gt; item;
<span class="lineNum">    3604 </span><span class="lineCov">          1 :     if (nextStrutIdx &lt; aStruts.Length() &amp;&amp;</span>
<span class="lineNum">    3605 </span><span class="lineCov">          1 :         aStruts[nextStrutIdx].mItemIdx == itemIdxInContainer) {</span>
<span class="lineNum">    3606 </span>            : 
<span class="lineNum">    3607 </span>            :       // Use the simplified &quot;strut&quot; FlexItem constructor:
<span class="lineNum">    3608 </span><span class="lineCov">          1 :       item = MakeUnique&lt;FlexItem&gt;(childFrame, aStruts[nextStrutIdx].mStrutCrossSize,</span>
<span class="lineNum">    3609 </span><span class="lineCov">          1 :                                   aReflowInput.GetWritingMode());</span>
<span class="lineNum">    3610 </span><span class="lineCov">          1 :       nextStrutIdx++;</span>
<span class="lineNum">    3611 </span>            :     } else {
<span class="lineNum">    3612 </span><span class="lineCov">          1 :       item = GenerateFlexItemForChild(aPresContext, childFrame,</span>
<span class="lineNum">    3613 </span><span class="lineCov">          1 :                                       aReflowInput, aAxisTracker);</span>
<span class="lineNum">    3614 </span>            :     }
<span class="lineNum">    3615 </span>            : 
<span class="lineNum">    3616 </span><span class="lineCov">          1 :     nscoord itemInnerHypotheticalMainSize = item-&gt;GetMainSize();</span>
<span class="lineNum">    3617 </span>            :     nscoord itemOuterHypotheticalMainSize =
<span class="lineNum">    3618 </span><span class="lineCov">          1 :       item-&gt;GetOuterMainSize(aAxisTracker.GetMainAxis());</span>
<span class="lineNum">    3619 </span>            : 
<span class="lineNum">    3620 </span>            :     // Check if we need to wrap |item| to a new line
<span class="lineNum">    3621 </span>            :     // (i.e. check if its outer hypothetical main size pushes our line over
<span class="lineNum">    3622 </span>            :     // the threshold)
<span class="lineNum">    3623 </span><span class="lineCov">          1 :     if (wrapThreshold != NS_UNCONSTRAINEDSIZE &amp;&amp;</span>
<span class="lineNum">    3624 </span><span class="lineCov">          1 :         !curLine-&gt;IsEmpty() &amp;&amp; // No need to wrap at start of a line.</span>
<span class="lineNum">    3625 </span><span class="lineCov">          1 :         wrapThreshold &lt; (curLine-&gt;GetTotalOuterHypotheticalMainSize() +</span>
<span class="lineNum">    3626 </span>            :                          itemOuterHypotheticalMainSize)) {
<span class="lineNum">    3627 </span><span class="lineCov">          1 :       curLine = AddNewFlexLineToList(aLines, shouldInsertAtFront);</span>
<span class="lineNum">    3628 </span>            :     }
<span class="lineNum">    3629 </span>            : 
<span class="lineNum">    3630 </span>            :     // Add item to current flex line (and update the line's bookkeeping about
<span class="lineNum">    3631 </span>            :     // how large its items collectively are).
<span class="lineNum">    3632 </span>            :     curLine-&gt;AddItem(item.release(), shouldInsertAtFront,
<span class="lineNum">    3633 </span>            :                      itemInnerHypotheticalMainSize,
<span class="lineNum">    3634 </span><span class="lineCov">          1 :                      itemOuterHypotheticalMainSize);</span>
<span class="lineNum">    3635 </span>            : 
<span class="lineNum">    3636 </span>            :     // Honor &quot;page-break-after&quot;, if we're multi-line and have more children:
<span class="lineNum">    3637 </span><span class="lineCov">          1 :     if (!isSingleLine &amp;&amp; childFrame-&gt;GetNextSibling() &amp;&amp;</span>
<span class="lineNum">    3638 </span><span class="lineCov">          1 :         childFrame-&gt;StyleDisplay()-&gt;mBreakAfter) {</span>
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 :       curLine = AddNewFlexLineToList(aLines, shouldInsertAtFront);</span>
<span class="lineNum">    3640 </span>            :     }
<span class="lineNum">    3641 </span><span class="lineCov">          1 :     itemIdxInContainer++;</span>
<span class="lineNum">    3642 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    3643 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    3644 </span>            : 
<span class="lineNum">    3645 </span>            : // Retrieves the content-box main-size of our flex container from the
<span class="lineNum">    3646 </span>            : // reflow state (specifically, the main-size of *this continuation* of the
<a name="3647"><span class="lineNum">    3647 </span>            : // flex container).</a>
<span class="lineNum">    3648 </span>            : nscoord
<span class="lineNum">    3649 </span><span class="lineCov">          1 : nsFlexContainerFrame::GetMainSizeFromReflowInput(</span>
<span class="lineNum">    3650 </span>            :   const ReflowInput&amp; aReflowInput,
<span class="lineNum">    3651 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3652 </span>            : {
<span class="lineNum">    3653 </span><span class="lineCov">          1 :   if (aAxisTracker.IsRowOriented()) {</span>
<span class="lineNum">    3654 </span>            :     // Row-oriented --&gt; our main axis is the inline axis, so our main size
<span class="lineNum">    3655 </span>            :     // is our inline size (which should already be resolved).
<span class="lineNum">    3656 </span>            :     NS_WARNING_ASSERTION(
<span class="lineNum">    3657 </span>            :       aReflowInput.ComputedISize() != NS_UNCONSTRAINEDSIZE,
<span class="lineNum">    3658 </span>            :       &quot;Unconstrained inline size; this should only result from huge sizes &quot;
<span class="lineNum">    3659 </span>            :       &quot;(not intrinsic sizing w/ orthogonal flows)&quot;);
<span class="lineNum">    3660 </span><span class="lineCov">          1 :     return aReflowInput.ComputedISize();</span>
<span class="lineNum">    3661 </span>            :   }
<span class="lineNum">    3662 </span>            : 
<span class="lineNum">    3663 </span>            :   // Note: This may be unconstrained, if our block size is &quot;auto&quot;:
<span class="lineNum">    3664 </span><span class="lineCov">          1 :   return GetEffectiveComputedBSize(aReflowInput);</span>
<span class="lineNum">    3665 </span>            : }
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span>            : // Returns the largest outer hypothetical main-size of any line in |aLines|.
<a name="3668"><span class="lineNum">    3668 </span>            : // (i.e. the hypothetical main-size of the largest line)</a>
<span class="lineNum">    3669 </span>            : static nscoord
<span class="lineNum">    3670 </span><span class="lineCov">          1 : GetLargestLineMainSize(const FlexLine* aFirstLine)</span>
<span class="lineNum">    3671 </span>            : {
<span class="lineNum">    3672 </span><span class="lineCov">          1 :   nscoord largestLineOuterSize = 0;</span>
<span class="lineNum">    3673 </span><span class="lineCov">          1 :   for (const FlexLine* line = aFirstLine; line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    3674 </span>            :     largestLineOuterSize = std::max(largestLineOuterSize,
<span class="lineNum">    3675 </span><span class="lineCov">          1 :                                     line-&gt;GetTotalOuterHypotheticalMainSize());</span>
<span class="lineNum">    3676 </span>            :   }
<span class="lineNum">    3677 </span><span class="lineCov">          1 :   return largestLineOuterSize;</span>
<span class="lineNum">    3678 </span>            : }
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span>            : /* Resolves the content-box main-size of a flex container frame,
<span class="lineNum">    3681 </span>            :  * primarily based on:
<span class="lineNum">    3682 </span>            :  * - the &quot;tentative&quot; main size, taken from the reflow state (&quot;tentative&quot;
<span class="lineNum">    3683 </span>            :  *    because it may be unconstrained or may run off the page).
<span class="lineNum">    3684 </span>            :  * - the available BSize (needed if the main axis is the block axis).
<span class="lineNum">    3685 </span>            :  * - the sizes of our lines of flex items.
<span class="lineNum">    3686 </span>            :  *
<span class="lineNum">    3687 </span>            :  * Guaranteed to return a definite length, i.e. not NS_UNCONSTRAINEDSIZE,
<span class="lineNum">    3688 </span>            :  * aside from cases with huge lengths which happen to compute to that value.
<span class="lineNum">    3689 </span>            :  *
<span class="lineNum">    3690 </span>            :  * (Note: This function should be structurally similar to 'ComputeCrossSize()',
<span class="lineNum">    3691 </span>            :  * except that here, the caller has already grabbed the tentative size from the
<span class="lineNum">    3692 </span>            :  * reflow state.)
<a name="3693"><span class="lineNum">    3693 </span>            :  */</a>
<span class="lineNum">    3694 </span>            : static nscoord
<span class="lineNum">    3695 </span><span class="lineCov">          1 : ResolveFlexContainerMainSize(const ReflowInput&amp; aReflowInput,</span>
<span class="lineNum">    3696 </span>            :                              const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    3697 </span>            :                              nscoord aTentativeMainSize,
<span class="lineNum">    3698 </span>            :                              nscoord aAvailableBSizeForContent,
<span class="lineNum">    3699 </span>            :                              const FlexLine* aFirstLine,
<span class="lineNum">    3700 </span>            :                              nsReflowStatus&amp; aStatus)
<span class="lineNum">    3701 </span>            : {
<span class="lineNum">    3702 </span>            :   MOZ_ASSERT(aFirstLine, &quot;null first line pointer&quot;);
<span class="lineNum">    3703 </span>            : 
<span class="lineNum">    3704 </span><span class="lineCov">          1 :   if (aAxisTracker.IsRowOriented()) {</span>
<span class="lineNum">    3705 </span>            :     // Row-oriented --&gt; our main axis is the inline axis, so our main size
<span class="lineNum">    3706 </span>            :     // is our inline size (which should already be resolved).
<span class="lineNum">    3707 </span><span class="lineCov">          1 :     return aTentativeMainSize;</span>
<span class="lineNum">    3708 </span>            :   }
<span class="lineNum">    3709 </span>            : 
<span class="lineNum">    3710 </span><span class="lineCov">          1 :   if (aTentativeMainSize != NS_INTRINSICSIZE) {</span>
<span class="lineNum">    3711 </span>            :     // Column-oriented case, with fixed BSize:
<span class="lineNum">    3712 </span><span class="lineCov">          1 :     if (aAvailableBSizeForContent == NS_UNCONSTRAINEDSIZE ||</span>
<span class="lineNum">    3713 </span><span class="lineCov">          1 :         aTentativeMainSize &lt; aAvailableBSizeForContent) {</span>
<span class="lineNum">    3714 </span>            :       // Not in a fragmenting context, OR no need to fragment because we have
<span class="lineNum">    3715 </span>            :       // more available BSize than we need. Either way, we don't need to clamp.
<span class="lineNum">    3716 </span>            :       // (Note that the reflow state has already done the appropriate
<span class="lineNum">    3717 </span>            :       // min/max-BSize clamping.)
<span class="lineNum">    3718 </span>            :       return aTentativeMainSize;
<span class="lineNum">    3719 </span>            :     }
<span class="lineNum">    3720 </span>            : 
<span class="lineNum">    3721 </span>            :     // Fragmenting *and* our fixed BSize is larger than available BSize:
<span class="lineNum">    3722 </span>            :     // Mark incomplete so we get a next-in-flow, and take up all of the
<span class="lineNum">    3723 </span>            :     // available BSize (or the amount of BSize required by our children, if
<span class="lineNum">    3724 </span>            :     // that's larger; but of course not more than our own computed BSize).
<span class="lineNum">    3725 </span>            :     // XXXdholbert For now, we don't support pushing children to our next
<span class="lineNum">    3726 </span>            :     // continuation or splitting children, so &quot;amount of BSize required by
<span class="lineNum">    3727 </span>            :     // our children&quot; is just the main-size (BSize) of our longest flex line.
<span class="lineNum">    3728 </span>            :     aStatus.SetIncomplete();
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 :     nscoord largestLineOuterSize = GetLargestLineMainSize(aFirstLine);</span>
<span class="lineNum">    3730 </span>            : 
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :     if (largestLineOuterSize &lt;= aAvailableBSizeForContent) {</span>
<span class="lineNum">    3732 </span>            :       return aAvailableBSizeForContent;
<span class="lineNum">    3733 </span>            :     }
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :     return std::min(aTentativeMainSize, largestLineOuterSize);</span>
<span class="lineNum">    3735 </span>            :   }
<span class="lineNum">    3736 </span>            : 
<span class="lineNum">    3737 </span>            :   // Column-oriented case, with auto BSize:
<span class="lineNum">    3738 </span>            :   // Resolve auto BSize to the largest FlexLine length, clamped to our
<span class="lineNum">    3739 </span>            :   // computed min/max main-size properties.
<span class="lineNum">    3740 </span>            :   // XXXdholbert Handle constrained-aAvailableBSizeForContent case here.
<span class="lineNum">    3741 </span><span class="lineCov">          1 :   nscoord largestLineOuterSize = GetLargestLineMainSize(aFirstLine);</span>
<span class="lineNum">    3742 </span>            :   return NS_CSS_MINMAX(largestLineOuterSize,
<span class="lineNum">    3743 </span>            :                        aReflowInput.ComputedMinBSize(),
<span class="lineNum">    3744 </span><span class="lineCov">          1 :                        aReflowInput.ComputedMaxBSize());</span>
<span class="lineNum">    3745 </span>            : }
<a name="3746"><span class="lineNum">    3746 </span>            : </a>
<span class="lineNum">    3747 </span>            : nscoord
<span class="lineNum">    3748 </span><span class="lineCov">          1 : nsFlexContainerFrame::ComputeCrossSize(const ReflowInput&amp; aReflowInput,</span>
<span class="lineNum">    3749 </span>            :                                        const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    3750 </span>            :                                        nscoord aSumLineCrossSizes,
<span class="lineNum">    3751 </span>            :                                        nscoord aAvailableBSizeForContent,
<span class="lineNum">    3752 </span>            :                                        bool* aIsDefinite,
<span class="lineNum">    3753 </span>            :                                        nsReflowStatus&amp; aStatus)
<span class="lineNum">    3754 </span>            : {
<span class="lineNum">    3755 </span>            :   MOZ_ASSERT(aIsDefinite, &quot;outparam pointer must be non-null&quot;);
<span class="lineNum">    3756 </span>            : 
<span class="lineNum">    3757 </span><span class="lineCov">          1 :   if (aAxisTracker.IsColumnOriented()) {</span>
<span class="lineNum">    3758 </span>            :     // Column-oriented --&gt; our cross axis is the inline axis, so our cross size
<span class="lineNum">    3759 </span>            :     // is our inline size (which should already be resolved).
<span class="lineNum">    3760 </span>            :     NS_WARNING_ASSERTION(
<span class="lineNum">    3761 </span>            :       aReflowInput.ComputedISize() != NS_UNCONSTRAINEDSIZE,
<span class="lineNum">    3762 </span>            :       &quot;Unconstrained inline size; this should only result from huge sizes &quot;
<span class="lineNum">    3763 </span>            :       &quot;(not intrinsic sizing w/ orthogonal flows)&quot;);
<span class="lineNum">    3764 </span><span class="lineCov">          1 :     *aIsDefinite = true;</span>
<span class="lineNum">    3765 </span><span class="lineCov">          1 :     return aReflowInput.ComputedISize();</span>
<span class="lineNum">    3766 </span>            :   }
<span class="lineNum">    3767 </span>            : 
<span class="lineNum">    3768 </span><span class="lineCov">          1 :   nscoord effectiveComputedBSize = GetEffectiveComputedBSize(aReflowInput);</span>
<span class="lineNum">    3769 </span><span class="lineCov">          1 :   if (effectiveComputedBSize != NS_INTRINSICSIZE) {</span>
<span class="lineNum">    3770 </span>            :     // Row-oriented case (cross axis is block-axis), with fixed BSize:
<span class="lineNum">    3771 </span><span class="lineCov">          1 :     *aIsDefinite = true;</span>
<span class="lineNum">    3772 </span><span class="lineCov">          1 :     if (aAvailableBSizeForContent == NS_UNCONSTRAINEDSIZE ||</span>
<span class="lineNum">    3773 </span><span class="lineCov">          1 :         effectiveComputedBSize &lt; aAvailableBSizeForContent) {</span>
<span class="lineNum">    3774 </span>            :       // Not in a fragmenting context, OR no need to fragment because we have
<span class="lineNum">    3775 </span>            :       // more available BSize than we need. Either way, just use our fixed
<span class="lineNum">    3776 </span>            :       // BSize.  (Note that the reflow state has already done the appropriate
<span class="lineNum">    3777 </span>            :       // min/max-BSize clamping.)
<span class="lineNum">    3778 </span>            :       return effectiveComputedBSize;
<span class="lineNum">    3779 </span>            :     }
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span>            :     // Fragmenting *and* our fixed BSize is too tall for available BSize:
<span class="lineNum">    3782 </span>            :     // Mark incomplete so we get a next-in-flow, and take up all of the
<span class="lineNum">    3783 </span>            :     // available BSize (or the amount of BSize required by our children, if
<span class="lineNum">    3784 </span>            :     // that's larger; but of course not more than our own computed BSize).
<span class="lineNum">    3785 </span>            :     // XXXdholbert For now, we don't support pushing children to our next
<span class="lineNum">    3786 </span>            :     // continuation or splitting children, so &quot;amount of BSize required by
<span class="lineNum">    3787 </span>            :     // our children&quot; is just the sum of our FlexLines' BSizes (cross sizes).
<span class="lineNum">    3788 </span>            :     aStatus.SetIncomplete();
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :     if (aSumLineCrossSizes &lt;= aAvailableBSizeForContent) {</span>
<span class="lineNum">    3790 </span>            :       return aAvailableBSizeForContent;
<span class="lineNum">    3791 </span>            :     }
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :     return std::min(effectiveComputedBSize, aSumLineCrossSizes);</span>
<span class="lineNum">    3793 </span>            :   }
<span class="lineNum">    3794 </span>            : 
<span class="lineNum">    3795 </span>            :   // Row-oriented case (cross axis is block axis), with auto BSize:
<span class="lineNum">    3796 </span>            :   // Shrink-wrap our line(s), subject to our min-size / max-size
<span class="lineNum">    3797 </span>            :   // constraints in that (block) axis.
<span class="lineNum">    3798 </span>            :   // XXXdholbert Handle constrained-aAvailableBSizeForContent case here.
<span class="lineNum">    3799 </span><span class="lineCov">          1 :   *aIsDefinite = false;</span>
<span class="lineNum">    3800 </span>            :   return NS_CSS_MINMAX(aSumLineCrossSizes,
<span class="lineNum">    3801 </span>            :                        aReflowInput.ComputedMinBSize(),
<span class="lineNum">    3802 </span><span class="lineCov">          1 :                        aReflowInput.ComputedMaxBSize());</span>
<span class="lineNum">    3803 </span>            : }
<a name="3804"><span class="lineNum">    3804 </span>            : </a>
<span class="lineNum">    3805 </span>            : void
<span class="lineNum">    3806 </span><span class="lineCov">          1 : FlexLine::PositionItemsInMainAxis(uint8_t aJustifyContent,</span>
<span class="lineNum">    3807 </span>            :                                   nscoord aContentBoxMainSize,
<span class="lineNum">    3808 </span>            :                                   const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3809 </span>            : {
<span class="lineNum">    3810 </span>            :   MainAxisPositionTracker mainAxisPosnTracker(aAxisTracker, this,
<span class="lineNum">    3811 </span>            :                                               aJustifyContent,
<span class="lineNum">    3812 </span><span class="lineCov">          1 :                                               aContentBoxMainSize);</span>
<span class="lineNum">    3813 </span><span class="lineCov">          1 :   for (FlexItem* item = mItems.getFirst(); item; item = item-&gt;getNext()) {</span>
<span class="lineNum">    3814 </span>            :     nscoord itemMainBorderBoxSize =
<span class="lineNum">    3815 </span><span class="lineCov">          1 :       item-&gt;GetMainSize() +</span>
<span class="lineNum">    3816 </span><span class="lineCov">          1 :       item-&gt;GetBorderPaddingSizeInAxis(mainAxisPosnTracker.GetAxis());</span>
<span class="lineNum">    3817 </span>            : 
<span class="lineNum">    3818 </span>            :     // Resolve any main-axis 'auto' margins on aChild to an actual value.
<span class="lineNum">    3819 </span><span class="lineCov">          1 :     mainAxisPosnTracker.ResolveAutoMarginsInMainAxis(*item);</span>
<span class="lineNum">    3820 </span>            : 
<span class="lineNum">    3821 </span>            :     // Advance our position tracker to child's upper-left content-box corner,
<span class="lineNum">    3822 </span>            :     // and use that as its position in the main axis.
<span class="lineNum">    3823 </span><span class="lineCov">          1 :     mainAxisPosnTracker.EnterMargin(item-&gt;GetMargin());</span>
<span class="lineNum">    3824 </span><span class="lineCov">          1 :     mainAxisPosnTracker.EnterChildFrame(itemMainBorderBoxSize);</span>
<span class="lineNum">    3825 </span>            : 
<span class="lineNum">    3826 </span><span class="lineCov">          1 :     item-&gt;SetMainPosition(mainAxisPosnTracker.GetPosition());</span>
<span class="lineNum">    3827 </span>            : 
<span class="lineNum">    3828 </span><span class="lineCov">          1 :     mainAxisPosnTracker.ExitChildFrame(itemMainBorderBoxSize);</span>
<span class="lineNum">    3829 </span><span class="lineCov">          1 :     mainAxisPosnTracker.ExitMargin(item-&gt;GetMargin());</span>
<span class="lineNum">    3830 </span><span class="lineCov">          1 :     mainAxisPosnTracker.TraversePackingSpace();</span>
<span class="lineNum">    3831 </span>            :   }
<span class="lineNum">    3832 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    3833 </span>            : 
<span class="lineNum">    3834 </span>            : /**
<span class="lineNum">    3835 </span>            :  * Given the flex container's &quot;flex-relative ascent&quot; (i.e. distance from the
<span class="lineNum">    3836 </span>            :  * flex container's content-box cross-start edge to its baseline), returns
<span class="lineNum">    3837 </span>            :  * its actual physical ascent value (the distance from the *border-box* top
<span class="lineNum">    3838 </span>            :  * edge to its baseline).
<a name="3839"><span class="lineNum">    3839 </span>            :  */</a>
<span class="lineNum">    3840 </span>            : static nscoord
<span class="lineNum">    3841 </span><span class="lineCov">          1 : ComputePhysicalAscentFromFlexRelativeAscent(</span>
<span class="lineNum">    3842 </span>            :   nscoord aFlexRelativeAscent,
<span class="lineNum">    3843 </span>            :   nscoord aContentBoxCrossSize,
<span class="lineNum">    3844 </span>            :   const ReflowInput&amp; aReflowInput,
<span class="lineNum">    3845 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3846 </span>            : {
<span class="lineNum">    3847 </span><span class="lineCov">          1 :   return aReflowInput.ComputedPhysicalBorderPadding().top +</span>
<span class="lineNum">    3848 </span>            :     PhysicalCoordFromFlexRelativeCoord(aFlexRelativeAscent,
<span class="lineNum">    3849 </span>            :                                        aContentBoxCrossSize,
<span class="lineNum">    3850 </span><span class="lineCov">          1 :                                        aAxisTracker.GetCrossAxis());</span>
<span class="lineNum">    3851 </span>            : }
<a name="3852"><span class="lineNum">    3852 </span>            : </a>
<span class="lineNum">    3853 </span>            : void
<span class="lineNum">    3854 </span><span class="lineCov">          1 : nsFlexContainerFrame::SizeItemInCrossAxis(</span>
<span class="lineNum">    3855 </span>            :   nsPresContext* aPresContext,
<span class="lineNum">    3856 </span>            :   const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    3857 </span>            :   ReflowInput&amp; aChildReflowInput,
<span class="lineNum">    3858 </span>            :   FlexItem&amp; aItem)
<span class="lineNum">    3859 </span>            : {
<span class="lineNum">    3860 </span><span class="lineCov">          1 :   if (aAxisTracker.IsCrossAxisHorizontal()) {</span>
<span class="lineNum">    3861 </span>            :     MOZ_ASSERT(aItem.HasIntrinsicRatio(),
<span class="lineNum">    3862 </span>            :                &quot;For now, caller's CanMainSizeInfluenceCrossSize check should &quot;
<span class="lineNum">    3863 </span>            :                &quot;only allow us to get here for items with intrinsic ratio&quot;);
<span class="lineNum">    3864 </span>            :     // XXXdholbert When we finish support for vertical writing-modes,
<span class="lineNum">    3865 </span>            :     // (in bug 1079155 or a dependency), we'll relax the horizontal check in
<span class="lineNum">    3866 </span>            :     // CanMainSizeInfluenceCrossSize, and this function will need to be able
<span class="lineNum">    3867 </span>            :     // to measure the baseline &amp; width (given our resolved height)
<span class="lineNum">    3868 </span>            :     // of vertical-writing-mode flex items here.
<span class="lineNum">    3869 </span>            :     // For now, we only expect to get here for items with an intrinsic aspect
<span class="lineNum">    3870 </span>            :     // ratio; and for those items, we can just read the size off of the reflow
<span class="lineNum">    3871 </span>            :     // state, without performing reflow.
<span class="lineNum">    3872 </span><span class="lineCov">          1 :     aItem.SetCrossSize(aChildReflowInput.ComputedWidth());</span>
<span class="lineNum">    3873 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    3874 </span>            :   }
<span class="lineNum">    3875 </span>            : 
<span class="lineNum">    3876 </span>            :   MOZ_ASSERT(!aItem.HadMeasuringReflow(),
<span class="lineNum">    3877 </span>            :              &quot;We shouldn't need more than one measuring reflow&quot;);
<span class="lineNum">    3878 </span>            : 
<span class="lineNum">    3879 </span><span class="lineCov">          1 :   if (aItem.GetAlignSelf() == NS_STYLE_ALIGN_STRETCH) {</span>
<span class="lineNum">    3880 </span>            :     // This item's got &quot;align-self: stretch&quot;, so we probably imposed a
<span class="lineNum">    3881 </span>            :     // stretched computed height on it during its previous reflow. We're
<span class="lineNum">    3882 </span>            :     // not imposing that height for *this* measuring reflow, so we need to
<span class="lineNum">    3883 </span>            :     // tell it to treat this reflow as a vertical resize (regardless of
<span class="lineNum">    3884 </span>            :     // whether any of its ancestors are being resized).
<span class="lineNum">    3885 </span><span class="lineCov">          1 :     aChildReflowInput.SetVResize(true);</span>
<span class="lineNum">    3886 </span>            :   }
<span class="lineNum">    3887 </span>            : 
<span class="lineNum">    3888 </span>            :   // Potentially reflow the item, and get the sizing info.
<span class="lineNum">    3889 </span>            :   const CachedMeasuringReflowResult&amp; reflowResult =
<span class="lineNum">    3890 </span><span class="lineCov">          1 :     MeasureAscentAndHeightForFlexItem(aItem, aPresContext, aChildReflowInput);</span>
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span>            :   // Save the sizing info that we learned from this reflow
<span class="lineNum">    3893 </span>            :   // -----------------------------------------------------
<span class="lineNum">    3894 </span>            : 
<span class="lineNum">    3895 </span>            :   // Tentatively store the child's desired content-box cross-size.
<span class="lineNum">    3896 </span>            :   // Note that childDesiredSize is the border-box size, so we have to
<span class="lineNum">    3897 </span>            :   // subtract border &amp; padding to get the content-box size.
<span class="lineNum">    3898 </span>            :   // (Note that at this point in the code, we know our cross axis is vertical,
<span class="lineNum">    3899 </span>            :   // so we don't bother with making aAxisTracker pick the cross-axis component
<span class="lineNum">    3900 </span>            :   // for us.)
<span class="lineNum">    3901 </span><span class="lineCov">          1 :   nscoord crossAxisBorderPadding = aItem.GetBorderPadding().TopBottom();</span>
<span class="lineNum">    3902 </span><span class="lineCov">          1 :   if (reflowResult.Height() &lt; crossAxisBorderPadding) {</span>
<span class="lineNum">    3903 </span>            :     // Child's requested size isn't large enough for its border/padding!
<span class="lineNum">    3904 </span>            :     // This is OK for the trivial nsFrame::Reflow() impl, but other frame
<span class="lineNum">    3905 </span>            :     // classes should know better. So, if we get here, the child had better be
<span class="lineNum">    3906 </span>            :     // an instance of nsFrame (i.e. it should return null from GetType()).
<span class="lineNum">    3907 </span>            :     // XXXdholbert Once we've fixed bug 765861, we should upgrade this to an
<span class="lineNum">    3908 </span>            :     // assertion that trivially passes if bug 765861's flag has been flipped.
<span class="lineNum">    3909 </span>            :     NS_WARNING_ASSERTION(
<span class="lineNum">    3910 </span>            :       !aItem.Frame()-&gt;GetType(),
<span class="lineNum">    3911 </span>            :       &quot;Child should at least request space for border/padding&quot;);
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :     aItem.SetCrossSize(0);</span>
<span class="lineNum">    3913 </span>            :   } else {
<span class="lineNum">    3914 </span>            :     // (normal case)
<span class="lineNum">    3915 </span><span class="lineCov">          1 :     aItem.SetCrossSize(reflowResult.Height() - crossAxisBorderPadding);</span>
<span class="lineNum">    3916 </span>            :   }
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span><span class="lineCov">          1 :   aItem.SetAscent(reflowResult.Ascent());</span>
<span class="lineNum">    3919 </span>            : }
<a name="3920"><span class="lineNum">    3920 </span>            : </a>
<span class="lineNum">    3921 </span>            : void
<span class="lineNum">    3922 </span><span class="lineCov">          1 : FlexLine::PositionItemsInCrossAxis(nscoord aLineStartPosition,</span>
<span class="lineNum">    3923 </span>            :                                    const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    3924 </span>            : {
<span class="lineNum">    3925 </span>            :   SingleLineCrossAxisPositionTracker lineCrossAxisPosnTracker(aAxisTracker);
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span><span class="lineCov">          1 :   for (FlexItem* item = mItems.getFirst(); item; item = item-&gt;getNext()) {</span>
<span class="lineNum">    3928 </span>            :     // First, stretch the item's cross size (if appropriate), and resolve any
<span class="lineNum">    3929 </span>            :     // auto margins in this axis.
<span class="lineNum">    3930 </span><span class="lineCov">          1 :     item-&gt;ResolveStretchedCrossSize(mLineCrossSize, aAxisTracker);</span>
<span class="lineNum">    3931 </span><span class="lineCov">          1 :     lineCrossAxisPosnTracker.ResolveAutoMarginsInCrossAxis(*this, *item);</span>
<span class="lineNum">    3932 </span>            : 
<span class="lineNum">    3933 </span>            :     // Compute the cross-axis position of this item
<span class="lineNum">    3934 </span>            :     nscoord itemCrossBorderBoxSize =
<span class="lineNum">    3935 </span><span class="lineCov">          1 :       item-&gt;GetCrossSize() +</span>
<span class="lineNum">    3936 </span><span class="lineCov">          1 :       item-&gt;GetBorderPaddingSizeInAxis(aAxisTracker.GetCrossAxis());</span>
<span class="lineNum">    3937 </span><span class="lineCov">          1 :     lineCrossAxisPosnTracker.EnterAlignPackingSpace(*this, *item, aAxisTracker);</span>
<span class="lineNum">    3938 </span><span class="lineCov">          1 :     lineCrossAxisPosnTracker.EnterMargin(item-&gt;GetMargin());</span>
<span class="lineNum">    3939 </span><span class="lineCov">          1 :     lineCrossAxisPosnTracker.EnterChildFrame(itemCrossBorderBoxSize);</span>
<span class="lineNum">    3940 </span>            : 
<span class="lineNum">    3941 </span>            :     item-&gt;SetCrossPosition(aLineStartPosition +
<span class="lineNum">    3942 </span><span class="lineCov">          1 :                            lineCrossAxisPosnTracker.GetPosition());</span>
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span>            :     // Back out to cross-axis edge of the line.
<span class="lineNum">    3945 </span><span class="lineCov">          1 :     lineCrossAxisPosnTracker.ResetPosition();</span>
<span class="lineNum">    3946 </span>            :   }
<span class="lineNum">    3947 </span><span class="lineCov">          1 : }</span>
<a name="3948"><span class="lineNum">    3948 </span>            : </a>
<span class="lineNum">    3949 </span>            : void
<span class="lineNum">    3950 </span><span class="lineCov">          1 : nsFlexContainerFrame::Reflow(nsPresContext* aPresContext,</span>
<span class="lineNum">    3951 </span>            :                              ReflowOutput&amp; aDesiredSize,
<span class="lineNum">    3952 </span>            :                              const ReflowInput&amp; aReflowInput,
<span class="lineNum">    3953 </span>            :                              nsReflowStatus&amp; aStatus)
<span class="lineNum">    3954 </span>            : {
<span class="lineNum">    3955 </span><span class="lineCov">          1 :   MarkInReflow();</span>
<span class="lineNum">    3956 </span>            :   DO_GLOBAL_REFLOW_COUNT(&quot;nsFlexContainerFrame&quot;);
<span class="lineNum">    3957 </span>            :   DISPLAY_REFLOW(aPresContext, this, aReflowInput, aDesiredSize, aStatus);
<span class="lineNum">    3958 </span><span class="lineCov">          1 :   MOZ_LOG(gFlexContainerLog, LogLevel::Debug,</span>
<span class="lineNum">    3959 </span>            :          (&quot;Reflow() for nsFlexContainerFrame %p\n&quot;, this));
<span class="lineNum">    3960 </span>            : 
<span class="lineNum">    3961 </span><span class="lineCov">          1 :   if (IsFrameTreeTooDeep(aReflowInput, aDesiredSize, aStatus)) {</span>
<span class="lineNum">    3962 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3963 </span>            :   }
<span class="lineNum">    3964 </span>            : 
<span class="lineNum">    3965 </span>            :   // We (and our children) can only depend on our ancestor's bsize if we have
<span class="lineNum">    3966 </span>            :   // a percent-bsize, or if we're positioned and we have &quot;block-start&quot; and &quot;block-end&quot;
<span class="lineNum">    3967 </span>            :   // set and have block-size:auto.  (There are actually other cases, too -- e.g. if
<span class="lineNum">    3968 </span>            :   // our parent is itself a block-dir flex container and we're flexible -- but
<span class="lineNum">    3969 </span>            :   // we'll let our ancestors handle those sorts of cases.)
<span class="lineNum">    3970 </span><span class="lineCov">          1 :   WritingMode wm = aReflowInput.GetWritingMode();</span>
<span class="lineNum">    3971 </span><span class="lineCov">          1 :   const nsStylePosition* stylePos = StylePosition();</span>
<span class="lineNum">    3972 </span><span class="lineCov">          1 :   const nsStyleCoord&amp; bsize = stylePos-&gt;BSize(wm);</span>
<span class="lineNum">    3973 </span><span class="lineCov">          1 :   if (bsize.HasPercent() ||</span>
<span class="lineNum">    3974 </span><span class="lineCov">          1 :       (StyleDisplay()-&gt;IsAbsolutelyPositionedStyle() &amp;&amp;</span>
<span class="lineNum">    3975 </span><span class="lineCov">          1 :        eStyleUnit_Auto == bsize.GetUnit() &amp;&amp;</span>
<span class="lineNum">    3976 </span><span class="lineCov">          1 :        eStyleUnit_Auto != stylePos-&gt;mOffset.GetBStartUnit(wm) &amp;&amp;</span>
<span class="lineNum">    3977 </span><span class="lineCov">          1 :        eStyleUnit_Auto != stylePos-&gt;mOffset.GetBEndUnit(wm))) {</span>
<span class="lineNum">    3978 </span><span class="lineCov">          1 :     AddStateBits(NS_FRAME_CONTAINS_RELATIVE_BSIZE);</span>
<span class="lineNum">    3979 </span>            :   }
<span class="lineNum">    3980 </span>            : 
<span class="lineNum">    3981 </span><span class="lineCov">          1 :   RenumberList();</span>
<span class="lineNum">    3982 </span>            : 
<span class="lineNum">    3983 </span><span class="lineCov">          1 :   const FlexboxAxisTracker axisTracker(this, aReflowInput.GetWritingMode());</span>
<span class="lineNum">    3984 </span>            : 
<span class="lineNum">    3985 </span>            :   // If we're being fragmented into a constrained BSize, then subtract off
<span class="lineNum">    3986 </span>            :   // borderpadding BStart from that constrained BSize, to get the available
<span class="lineNum">    3987 </span>            :   // BSize for our content box. (No need to subtract the borderpadding BStart
<span class="lineNum">    3988 </span>            :   // if we're already skipping it via GetLogicalSkipSides, though.)
<span class="lineNum">    3989 </span><span class="lineCov">          1 :   nscoord availableBSizeForContent = aReflowInput.AvailableBSize();</span>
<span class="lineNum">    3990 </span><span class="lineCov">          1 :   if (availableBSizeForContent != NS_UNCONSTRAINEDSIZE &amp;&amp;</span>
<span class="lineNum">    3991 </span><span class="lineCov">          1 :       !(GetLogicalSkipSides(&amp;aReflowInput).BStart())) {</span>
<span class="lineNum">    3992 </span>            :     availableBSizeForContent -=
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :       aReflowInput.ComputedLogicalBorderPadding().BStart(wm);</span>
<span class="lineNum">    3994 </span>            :     // (Don't let that push availableBSizeForContent below zero, though):
<span class="lineNum">    3995 </span><span class="lineNoCov">          0 :     availableBSizeForContent = std::max(availableBSizeForContent, 0);</span>
<span class="lineNum">    3996 </span>            :   }
<span class="lineNum">    3997 </span>            : 
<span class="lineNum">    3998 </span>            :   nscoord contentBoxMainSize = GetMainSizeFromReflowInput(aReflowInput,
<span class="lineNum">    3999 </span><span class="lineCov">          1 :                                                           axisTracker);</span>
<span class="lineNum">    4000 </span>            : 
<span class="lineNum">    4001 </span><span class="lineCov">          1 :   AutoTArray&lt;StrutInfo, 1&gt; struts;</span>
<span class="lineNum">    4002 </span>            :   DoFlexLayout(aPresContext, aDesiredSize, aReflowInput, aStatus,
<span class="lineNum">    4003 </span>            :                contentBoxMainSize, availableBSizeForContent,
<span class="lineNum">    4004 </span><span class="lineCov">          1 :                struts, axisTracker);</span>
<span class="lineNum">    4005 </span>            : 
<span class="lineNum">    4006 </span><span class="lineCov">          1 :   if (!struts.IsEmpty()) {</span>
<span class="lineNum">    4007 </span>            :     // We're restarting flex layout, with new knowledge of collapsed items.
<span class="lineNum">    4008 </span>            :     DoFlexLayout(aPresContext, aDesiredSize, aReflowInput, aStatus,
<span class="lineNum">    4009 </span>            :                  contentBoxMainSize, availableBSizeForContent,
<span class="lineNum">    4010 </span><span class="lineCov">          1 :                  struts, axisTracker);</span>
<span class="lineNum">    4011 </span>            :   }
<span class="lineNum">    4012 </span>            : }
<span class="lineNum">    4013 </span>            : 
<span class="lineNum">    4014 </span>            : // RAII class to clean up a list of FlexLines.
<span class="lineNum">    4015 </span>            : // Specifically, this removes each line from the list, deletes all the
<span class="lineNum">    4016 </span>            : // FlexItems in its list, and deletes the FlexLine.
<span class="lineNum">    4017 </span>            : class MOZ_RAII AutoFlexLineListClearer
<span class="lineNum">    4018 </span>            : {
<span class="lineNum">    4019 </span>            : public:
<span class="lineNum">    4020 </span>            :   explicit AutoFlexLineListClearer(LinkedList&lt;FlexLine&gt;&amp; aLines
<span class="lineNum">    4021 </span>            :                                    MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">    4022 </span><span class="lineCov">          1 :   : mLines(aLines)</span>
<span class="lineNum">    4023 </span>            :   {
<span class="lineNum">    4024 </span>            :     MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<a name="4025"><span class="lineNum">    4025 </span>            :   }</a>
<span class="lineNum">    4026 </span>            : 
<span class="lineNum">    4027 </span><span class="lineCov">          1 :   ~AutoFlexLineListClearer()</span>
<span class="lineNum">    4028 </span>            :   {
<span class="lineNum">    4029 </span><span class="lineCov">          1 :     while (FlexLine* line = mLines.popFirst()) {</span>
<span class="lineNum">    4030 </span><span class="lineCov">          1 :       while (FlexItem* item = line-&gt;mItems.popFirst()) {</span>
<span class="lineNum">    4031 </span><span class="lineCov">          1 :         delete item;</span>
<span class="lineNum">    4032 </span>            :       }
<span class="lineNum">    4033 </span><span class="lineCov">          1 :       delete line;</span>
<span class="lineNum">    4034 </span>            :     }
<span class="lineNum">    4035 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    4036 </span>            : 
<span class="lineNum">    4037 </span>            : private:
<span class="lineNum">    4038 </span>            :   LinkedList&lt;FlexLine&gt;&amp; mLines;
<span class="lineNum">    4039 </span>            :   MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    4040 </span>            : };
<span class="lineNum">    4041 </span>            : 
<span class="lineNum">    4042 </span>            : // Class to let us temporarily provide an override value for the the main-size
<span class="lineNum">    4043 </span>            : // CSS property ('width' or 'height') on a flex item, for use in
<span class="lineNum">    4044 </span>            : // nsFrame::ComputeSizeWithIntrinsicDimensions.
<span class="lineNum">    4045 </span>            : // (We could use this overridden size more broadly, too, but it's probably
<span class="lineNum">    4046 </span>            : // better to avoid property-table accesses.  So, where possible, we communicate
<span class="lineNum">    4047 </span>            : // the resolved main-size to the child via modifying its reflow state directly,
<span class="lineNum">    4048 </span>            : // instead of using this class.)
<span class="lineNum">    4049 </span>            : class MOZ_RAII AutoFlexItemMainSizeOverride final
<a name="4050"><span class="lineNum">    4050 </span>            : {</a>
<span class="lineNum">    4051 </span>            : public:
<span class="lineNum">    4052 </span><span class="lineCov">          1 :   explicit AutoFlexItemMainSizeOverride(FlexItem&amp; aItem</span>
<span class="lineNum">    4053 </span>            :                                         MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
<span class="lineNum">    4054 </span><span class="lineCov">          1 :     : mItemProps(aItem.Frame()-&gt;Properties())</span>
<span class="lineNum">    4055 </span>            :   {
<span class="lineNum">    4056 </span>            :     MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">    4057 </span>            : 
<span class="lineNum">    4058 </span>            :     MOZ_ASSERT(!mItemProps.Has(nsIFrame::FlexItemMainSizeOverride()),
<span class="lineNum">    4059 </span>            :                &quot;FlexItemMainSizeOverride prop shouldn't be set already; &quot;
<span class="lineNum">    4060 </span>            :                &quot;it should only be set temporarily (&amp; not recursively)&quot;);
<span class="lineNum">    4061 </span>            :     NS_ASSERTION(aItem.HasIntrinsicRatio(),
<span class="lineNum">    4062 </span>            :                  &quot;This should only be needed for items with an aspect ratio&quot;);
<span class="lineNum">    4063 </span>            : 
<span class="lineNum">    4064 </span><span class="lineCov">          1 :     mItemProps.Set(nsIFrame::FlexItemMainSizeOverride(), aItem.GetMainSize());</span>
<a name="4065"><span class="lineNum">    4065 </span><span class="lineCov">          1 :   }</span></a>
<span class="lineNum">    4066 </span>            : 
<span class="lineNum">    4067 </span><span class="lineCov">          1 :   ~AutoFlexItemMainSizeOverride() {</span>
<span class="lineNum">    4068 </span><span class="lineCov">          1 :     mItemProps.Remove(nsIFrame::FlexItemMainSizeOverride());</span>
<span class="lineNum">    4069 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    4070 </span>            : 
<span class="lineNum">    4071 </span>            : private:
<span class="lineNum">    4072 </span>            :   const FrameProperties mItemProps;
<span class="lineNum">    4073 </span>            :   MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    4074 </span>            : };
<a name="4075"><span class="lineNum">    4075 </span>            : </a>
<span class="lineNum">    4076 </span>            : void
<span class="lineNum">    4077 </span><span class="lineCov">          1 : nsFlexContainerFrame::CalculatePackingSpace(uint32_t aNumThingsToPack,</span>
<span class="lineNum">    4078 </span>            :                                             uint8_t aAlignVal,
<span class="lineNum">    4079 </span>            :                                             nscoord* aFirstSubjectOffset,
<span class="lineNum">    4080 </span>            :                                             uint32_t* aNumPackingSpacesRemaining,
<span class="lineNum">    4081 </span>            :                                             nscoord* aPackingSpaceRemaining)
<span class="lineNum">    4082 </span>            : {
<span class="lineNum">    4083 </span>            :   MOZ_ASSERT(NS_STYLE_ALIGN_SPACE_BETWEEN == NS_STYLE_JUSTIFY_SPACE_BETWEEN &amp;&amp;
<span class="lineNum">    4084 </span>            :              NS_STYLE_ALIGN_SPACE_AROUND == NS_STYLE_JUSTIFY_SPACE_AROUND &amp;&amp;
<span class="lineNum">    4085 </span>            :              NS_STYLE_ALIGN_SPACE_EVENLY == NS_STYLE_JUSTIFY_SPACE_EVENLY,
<span class="lineNum">    4086 </span>            :              &quot;CalculatePackingSpace assumes that NS_STYLE_ALIGN_SPACE and &quot;
<span class="lineNum">    4087 </span>            :              &quot;NS_STYLE_JUSTIFY_SPACE constants are interchangeable&quot;);
<span class="lineNum">    4088 </span>            : 
<span class="lineNum">    4089 </span>            :   MOZ_ASSERT(aAlignVal == NS_STYLE_ALIGN_SPACE_BETWEEN ||
<span class="lineNum">    4090 </span>            :              aAlignVal == NS_STYLE_ALIGN_SPACE_AROUND ||
<span class="lineNum">    4091 </span>            :              aAlignVal == NS_STYLE_ALIGN_SPACE_EVENLY,
<span class="lineNum">    4092 </span>            :              &quot;Unexpected alignment value&quot;);
<span class="lineNum">    4093 </span>            : 
<span class="lineNum">    4094 </span>            :   MOZ_ASSERT(*aPackingSpaceRemaining &gt;= 0,
<span class="lineNum">    4095 </span>            :              &quot;Should not be called with negative packing space&quot;);
<span class="lineNum">    4096 </span>            : 
<span class="lineNum">    4097 </span>            :   MOZ_ASSERT(aNumThingsToPack &gt;= 1,
<span class="lineNum">    4098 </span>            :              &quot;Should not be called with less than 1 thing to pack&quot;);
<span class="lineNum">    4099 </span>            : 
<span class="lineNum">    4100 </span>            :   // Packing spaces between items:
<span class="lineNum">    4101 </span><span class="lineCov">          1 :   *aNumPackingSpacesRemaining = aNumThingsToPack - 1;</span>
<span class="lineNum">    4102 </span>            : 
<span class="lineNum">    4103 </span><span class="lineCov">          1 :   if (aAlignVal == NS_STYLE_ALIGN_SPACE_BETWEEN) {</span>
<span class="lineNum">    4104 </span>            :     // No need to reserve space at beginning/end, so we're done.
<span class="lineNum">    4105 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    4106 </span>            :   }
<span class="lineNum">    4107 </span>            : 
<span class="lineNum">    4108 </span>            :   // We need to add 1 or 2 packing spaces, split between beginning/end, for
<span class="lineNum">    4109 </span>            :   // space-around / space-evenly:
<span class="lineNum">    4110 </span>            :   size_t numPackingSpacesForEdges =
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :     aAlignVal == NS_STYLE_JUSTIFY_SPACE_AROUND ? 1 : 2;</span>
<span class="lineNum">    4112 </span>            : 
<span class="lineNum">    4113 </span>            :   // How big will each &quot;full&quot; packing space be:
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :   nscoord packingSpaceSize = *aPackingSpaceRemaining /</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :     (*aNumPackingSpacesRemaining + numPackingSpacesForEdges);</span>
<span class="lineNum">    4116 </span>            :   // How much packing-space are we allocating to the edges:
<span class="lineNum">    4117 </span><span class="lineNoCov">          0 :   nscoord totalEdgePackingSpace = numPackingSpacesForEdges * packingSpaceSize;</span>
<span class="lineNum">    4118 </span>            : 
<span class="lineNum">    4119 </span>            :   // Use half of that edge packing space right now:
<span class="lineNum">    4120 </span><span class="lineNoCov">          0 :   *aFirstSubjectOffset += totalEdgePackingSpace / 2;</span>
<span class="lineNum">    4121 </span>            :   // ...but we need to subtract all of it right away, so that we won't
<span class="lineNum">    4122 </span>            :   // hand out any of it to intermediate packing spaces.
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 :   *aPackingSpaceRemaining -= totalEdgePackingSpace;</span>
<span class="lineNum">    4124 </span>            : }
<a name="4125"><span class="lineNum">    4125 </span>            : </a>
<span class="lineNum">    4126 </span>            : void
<span class="lineNum">    4127 </span><span class="lineCov">          1 : nsFlexContainerFrame::DoFlexLayout(nsPresContext*           aPresContext,</span>
<span class="lineNum">    4128 </span>            :                                    ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">    4129 </span>            :                                    const ReflowInput&amp; aReflowInput,
<span class="lineNum">    4130 </span>            :                                    nsReflowStatus&amp;          aStatus,
<span class="lineNum">    4131 </span>            :                                    nscoord aContentBoxMainSize,
<span class="lineNum">    4132 </span>            :                                    nscoord aAvailableBSizeForContent,
<span class="lineNum">    4133 </span>            :                                    nsTArray&lt;StrutInfo&gt;&amp; aStruts,
<span class="lineNum">    4134 </span>            :                                    const FlexboxAxisTracker&amp; aAxisTracker)
<span class="lineNum">    4135 </span>            : {
<span class="lineNum">    4136 </span><span class="lineCov">          1 :   aStatus.Reset();</span>
<span class="lineNum">    4137 </span>            : 
<span class="lineNum">    4138 </span>            :   LinkedList&lt;FlexLine&gt; lines;
<span class="lineNum">    4139 </span>            :   nsTArray&lt;nsIFrame*&gt; placeholderKids;
<span class="lineNum">    4140 </span><span class="lineCov">          1 :   AutoFlexLineListClearer cleanupLines(lines);</span>
<span class="lineNum">    4141 </span>            : 
<span class="lineNum">    4142 </span>            :   GenerateFlexLines(aPresContext, aReflowInput,
<span class="lineNum">    4143 </span>            :                     aContentBoxMainSize,
<span class="lineNum">    4144 </span>            :                     aAvailableBSizeForContent,
<span class="lineNum">    4145 </span>            :                     aStruts, aAxisTracker,
<span class="lineNum">    4146 </span><span class="lineCov">          1 :                     placeholderKids, lines);</span>
<span class="lineNum">    4147 </span>            : 
<span class="lineNum">    4148 </span><span class="lineCov">          1 :   if (lines.getFirst()-&gt;IsEmpty() &amp;&amp;</span>
<span class="lineNum">    4149 </span><span class="lineCov">          1 :       !lines.getFirst()-&gt;getNext()) {</span>
<span class="lineNum">    4150 </span>            :     // We have no flex items, our parent should synthesize a baseline if needed.
<span class="lineNum">    4151 </span><span class="lineCov">          1 :     AddStateBits(NS_STATE_FLEX_SYNTHESIZE_BASELINE);</span>
<span class="lineNum">    4152 </span>            :   } else {
<span class="lineNum">    4153 </span><span class="lineCov">          1 :     RemoveStateBits(NS_STATE_FLEX_SYNTHESIZE_BASELINE);</span>
<span class="lineNum">    4154 </span>            :   }
<span class="lineNum">    4155 </span>            : 
<span class="lineNum">    4156 </span>            :   aContentBoxMainSize =
<span class="lineNum">    4157 </span>            :     ResolveFlexContainerMainSize(aReflowInput, aAxisTracker,
<span class="lineNum">    4158 </span>            :                                  aContentBoxMainSize, aAvailableBSizeForContent,
<span class="lineNum">    4159 </span><span class="lineCov">          1 :                                  lines.getFirst(), aStatus);</span>
<span class="lineNum">    4160 </span>            : 
<span class="lineNum">    4161 </span><span class="lineCov">          1 :   for (FlexLine* line = lines.getFirst(); line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    4162 </span><span class="lineCov">          1 :     line-&gt;ResolveFlexibleLengths(aContentBoxMainSize);</span>
<span class="lineNum">    4163 </span>            :   }
<span class="lineNum">    4164 </span>            : 
<span class="lineNum">    4165 </span>            :   // Cross Size Determination - Flexbox spec section 9.4
<span class="lineNum">    4166 </span>            :   // ===================================================
<span class="lineNum">    4167 </span>            :   // Calculate the hypothetical cross size of each item:
<span class="lineNum">    4168 </span><span class="lineCov">          1 :   nscoord sumLineCrossSizes = 0;</span>
<span class="lineNum">    4169 </span><span class="lineCov">          1 :   for (FlexLine* line = lines.getFirst(); line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    4170 </span><span class="lineCov">          1 :     for (FlexItem* item = line-&gt;GetFirstItem(); item; item = item-&gt;getNext()) {</span>
<span class="lineNum">    4171 </span>            :       // The item may already have the correct cross-size; only recalculate
<span class="lineNum">    4172 </span>            :       // if the item's main size resolution (flexing) could have influenced it:
<span class="lineNum">    4173 </span><span class="lineCov">          1 :       if (item-&gt;CanMainSizeInfluenceCrossSize(aAxisTracker)) {</span>
<span class="lineNum">    4174 </span>            :         Maybe&lt;AutoFlexItemMainSizeOverride&gt; sizeOverride;
<span class="lineNum">    4175 </span><span class="lineCov">          1 :         if (item-&gt;HasIntrinsicRatio()) {</span>
<span class="lineNum">    4176 </span>            :           // For flex items with an aspect ratio, we have to impose an override
<span class="lineNum">    4177 </span>            :           // for the main-size property *before* we even instantiate the reflow
<span class="lineNum">    4178 </span>            :           // state, in order for aspect ratio calculations to produce the right
<span class="lineNum">    4179 </span>            :           // cross size in the reflow state. (For other flex items, it's OK
<span class="lineNum">    4180 </span>            :           // (and cheaper) to impose our main size *after* the reflow state has
<span class="lineNum">    4181 </span>            :           // been constructed, since the main size shouldn't influence anything
<span class="lineNum">    4182 </span>            :           // about cross-size measurement until we actually reflow the child.)
<span class="lineNum">    4183 </span><span class="lineCov">          1 :           sizeOverride.emplace(*item);</span>
<span class="lineNum">    4184 </span>            :         }
<span class="lineNum">    4185 </span>            : 
<span class="lineNum">    4186 </span><span class="lineCov">          1 :         WritingMode wm = item-&gt;Frame()-&gt;GetWritingMode();</span>
<span class="lineNum">    4187 </span><span class="lineCov">          1 :         LogicalSize availSize = aReflowInput.ComputedSize(wm);</span>
<span class="lineNum">    4188 </span><span class="lineCov">          1 :         availSize.BSize(wm) = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">    4189 </span>            :         ReflowInput childReflowInput(aPresContext, aReflowInput,
<span class="lineNum">    4190 </span><span class="lineCov">          1 :                                      item-&gt;Frame(), availSize);</span>
<span class="lineNum">    4191 </span><span class="lineCov">          1 :         if (!sizeOverride) {</span>
<span class="lineNum">    4192 </span>            :           // Directly override the computed main-size, by tweaking reflow state:
<span class="lineNum">    4193 </span><span class="lineCov">          1 :           if (aAxisTracker.IsMainAxisHorizontal()) {</span>
<span class="lineNum">    4194 </span><span class="lineCov">          1 :             childReflowInput.SetComputedWidth(item-&gt;GetMainSize());</span>
<span class="lineNum">    4195 </span>            :           } else {
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :             childReflowInput.SetComputedHeight(item-&gt;GetMainSize());</span>
<span class="lineNum">    4197 </span>            :           }
<span class="lineNum">    4198 </span>            :         }
<span class="lineNum">    4199 </span>            : 
<span class="lineNum">    4200 </span>            :         SizeItemInCrossAxis(aPresContext, aAxisTracker,
<span class="lineNum">    4201 </span><span class="lineCov">          1 :                             childReflowInput, *item);</span>
<span class="lineNum">    4202 </span>            :       }
<span class="lineNum">    4203 </span>            :     }
<span class="lineNum">    4204 </span>            :     // Now that we've finished with this line's items, size the line itself:
<span class="lineNum">    4205 </span><span class="lineCov">          1 :     line-&gt;ComputeCrossSizeAndBaseline(aAxisTracker);</span>
<span class="lineNum">    4206 </span><span class="lineCov">          1 :     sumLineCrossSizes += line-&gt;GetLineCrossSize();</span>
<span class="lineNum">    4207 </span>            :   }
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span>            :   bool isCrossSizeDefinite;
<span class="lineNum">    4210 </span>            :   const nscoord contentBoxCrossSize =
<span class="lineNum">    4211 </span>            :     ComputeCrossSize(aReflowInput, aAxisTracker, sumLineCrossSizes,
<span class="lineNum">    4212 </span><span class="lineCov">          1 :                      aAvailableBSizeForContent, &amp;isCrossSizeDefinite, aStatus);</span>
<span class="lineNum">    4213 </span>            : 
<span class="lineNum">    4214 </span>            :   // Set up state for cross-axis alignment, at a high level (outside the
<span class="lineNum">    4215 </span>            :   // scope of a particular flex line)
<span class="lineNum">    4216 </span>            :   CrossAxisPositionTracker
<span class="lineNum">    4217 </span>            :     crossAxisPosnTracker(lines.getFirst(),
<span class="lineNum">    4218 </span>            :                          aReflowInput, contentBoxCrossSize,
<span class="lineNum">    4219 </span><span class="lineCov">          1 :                          isCrossSizeDefinite, aAxisTracker);</span>
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span>            :   // Now that we know the cross size of each line (including
<span class="lineNum">    4222 </span>            :   // &quot;align-content:stretch&quot; adjustments, from the CrossAxisPositionTracker
<span class="lineNum">    4223 </span>            :   // constructor), we can create struts for any flex items with
<span class="lineNum">    4224 </span>            :   // &quot;visibility: collapse&quot; (and restart flex layout).
<span class="lineNum">    4225 </span><span class="lineCov">          1 :   if (aStruts.IsEmpty()) { // (Don't make struts if we already did)</span>
<span class="lineNum">    4226 </span><span class="lineCov">          1 :     BuildStrutInfoFromCollapsedItems(lines.getFirst(), aStruts);</span>
<span class="lineNum">    4227 </span><span class="lineCov">          1 :     if (!aStruts.IsEmpty()) {</span>
<span class="lineNum">    4228 </span>            :       // Restart flex layout, using our struts.
<span class="lineNum">    4229 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">    4230 </span>            :     }
<span class="lineNum">    4231 </span>            :   }
<span class="lineNum">    4232 </span>            : 
<span class="lineNum">    4233 </span>            :   // If the container should derive its baseline from the first FlexLine,
<span class="lineNum">    4234 </span>            :   // do that here (while crossAxisPosnTracker is conveniently pointing
<span class="lineNum">    4235 </span>            :   // at the cross-start edge of that line, which the line's baseline offset is
<span class="lineNum">    4236 </span>            :   // measured from):
<span class="lineNum">    4237 </span>            :   nscoord flexContainerAscent;
<span class="lineNum">    4238 </span><span class="lineCov">          1 :   if (!aAxisTracker.AreAxesInternallyReversed()) {</span>
<span class="lineNum">    4239 </span><span class="lineCov">          1 :     nscoord firstLineBaselineOffset = lines.getFirst()-&gt;GetFirstBaselineOffset();</span>
<span class="lineNum">    4240 </span><span class="lineCov">          1 :     if (firstLineBaselineOffset == nscoord_MIN) {</span>
<span class="lineNum">    4241 </span>            :       // No baseline-aligned items in line. Use sentinel value to prompt us to
<span class="lineNum">    4242 </span>            :       // get baseline from the first FlexItem after we've reflowed it.
<span class="lineNum">    4243 </span>            :       flexContainerAscent = nscoord_MIN;
<span class="lineNum">    4244 </span>            :     } else  {
<span class="lineNum">    4245 </span>            :       flexContainerAscent =
<span class="lineNum">    4246 </span>            :         ComputePhysicalAscentFromFlexRelativeAscent(
<span class="lineNum">    4247 </span><span class="lineCov">          1 :           crossAxisPosnTracker.GetPosition() + firstLineBaselineOffset,</span>
<span class="lineNum">    4248 </span><span class="lineCov">          1 :           contentBoxCrossSize, aReflowInput, aAxisTracker);</span>
<span class="lineNum">    4249 </span>            :     }
<span class="lineNum">    4250 </span>            :   }
<span class="lineNum">    4251 </span>            : 
<span class="lineNum">    4252 </span><span class="lineCov">          1 :   const auto justifyContent = IsLegacyBox(aReflowInput.mFrame) ?</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :     ConvertLegacyStyleToJustifyContent(StyleXUL()) :</span>
<span class="lineNum">    4254 </span><span class="lineCov">          1 :     aReflowInput.mStylePosition-&gt;mJustifyContent;</span>
<span class="lineNum">    4255 </span>            : 
<span class="lineNum">    4256 </span><span class="lineCov">          1 :   for (FlexLine* line = lines.getFirst(); line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    4257 </span>            :     // Main-Axis Alignment - Flexbox spec section 9.5
<span class="lineNum">    4258 </span>            :     // ==============================================
<span class="lineNum">    4259 </span>            :     line-&gt;PositionItemsInMainAxis(justifyContent,
<span class="lineNum">    4260 </span>            :                                   aContentBoxMainSize,
<span class="lineNum">    4261 </span><span class="lineCov">          1 :                                   aAxisTracker);</span>
<span class="lineNum">    4262 </span>            : 
<span class="lineNum">    4263 </span>            :     // Cross-Axis Alignment - Flexbox spec section 9.6
<span class="lineNum">    4264 </span>            :     // ===============================================
<span class="lineNum">    4265 </span>            :     line-&gt;PositionItemsInCrossAxis(crossAxisPosnTracker.GetPosition(),
<span class="lineNum">    4266 </span><span class="lineCov">          1 :                                    aAxisTracker);</span>
<span class="lineNum">    4267 </span><span class="lineCov">          1 :     crossAxisPosnTracker.TraverseLine(*line);</span>
<span class="lineNum">    4268 </span><span class="lineCov">          1 :     crossAxisPosnTracker.TraversePackingSpace();</span>
<span class="lineNum">    4269 </span>            :   }
<span class="lineNum">    4270 </span>            : 
<span class="lineNum">    4271 </span>            :   // If the container should derive its baseline from the last FlexLine,
<span class="lineNum">    4272 </span>            :   // do that here (while crossAxisPosnTracker is conveniently pointing
<span class="lineNum">    4273 </span>            :   // at the cross-end edge of that line, which the line's baseline offset is
<span class="lineNum">    4274 </span>            :   // measured from):
<span class="lineNum">    4275 </span><span class="lineCov">          1 :   if (aAxisTracker.AreAxesInternallyReversed()) {</span>
<span class="lineNum">    4276 </span><span class="lineCov">          1 :     nscoord lastLineBaselineOffset = lines.getLast()-&gt;GetFirstBaselineOffset();</span>
<span class="lineNum">    4277 </span><span class="lineCov">          1 :     if (lastLineBaselineOffset == nscoord_MIN) {</span>
<span class="lineNum">    4278 </span>            :       // No baseline-aligned items in line. Use sentinel value to prompt us to
<span class="lineNum">    4279 </span>            :       // get baseline from the last FlexItem after we've reflowed it.
<span class="lineNum">    4280 </span>            :       flexContainerAscent = nscoord_MIN;
<span class="lineNum">    4281 </span>            :     } else {
<span class="lineNum">    4282 </span>            :       flexContainerAscent =
<span class="lineNum">    4283 </span>            :         ComputePhysicalAscentFromFlexRelativeAscent(
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :           crossAxisPosnTracker.GetPosition() - lastLineBaselineOffset,</span>
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 :           contentBoxCrossSize, aReflowInput, aAxisTracker);</span>
<span class="lineNum">    4286 </span>            :     }
<span class="lineNum">    4287 </span>            :   }
<span class="lineNum">    4288 </span>            : 
<span class="lineNum">    4289 </span>            :   // Before giving each child a final reflow, calculate the origin of the
<span class="lineNum">    4290 </span>            :   // flex container's content box (with respect to its border-box), so that
<span class="lineNum">    4291 </span>            :   // we can compute our flex item's final positions.
<span class="lineNum">    4292 </span><span class="lineCov">          1 :   WritingMode flexWM = aReflowInput.GetWritingMode();</span>
<span class="lineNum">    4293 </span><span class="lineCov">          1 :   LogicalMargin containerBP = aReflowInput.ComputedLogicalBorderPadding();</span>
<span class="lineNum">    4294 </span>            : 
<span class="lineNum">    4295 </span>            :   // Unconditionally skip block-end border &amp; padding for now, regardless of
<span class="lineNum">    4296 </span>            :   // writing-mode/GetLogicalSkipSides.  We add it lower down, after we've
<span class="lineNum">    4297 </span>            :   // established baseline and decided whether bottom border-padding fits (if
<span class="lineNum">    4298 </span>            :   // we're fragmented).
<span class="lineNum">    4299 </span><span class="lineCov">          1 :   const nscoord blockEndContainerBP = containerBP.BEnd(flexWM);</span>
<span class="lineNum">    4300 </span>            :   const LogicalSides skipSides =
<span class="lineNum">    4301 </span><span class="lineCov">          1 :     GetLogicalSkipSides(&amp;aReflowInput) | LogicalSides(eLogicalSideBitsBEnd);</span>
<span class="lineNum">    4302 </span><span class="lineCov">          1 :   containerBP.ApplySkipSides(skipSides);</span>
<span class="lineNum">    4303 </span>            : 
<span class="lineNum">    4304 </span>            :   const LogicalPoint containerContentBoxOrigin(flexWM,
<span class="lineNum">    4305 </span><span class="lineCov">          1 :                                                containerBP.IStart(flexWM),</span>
<span class="lineNum">    4306 </span><span class="lineCov">          1 :                                                containerBP.BStart(flexWM));</span>
<span class="lineNum">    4307 </span>            : 
<span class="lineNum">    4308 </span>            :   // Determine flex container's border-box size (used in positioning children):
<span class="lineNum">    4309 </span>            :   LogicalSize logSize =
<span class="lineNum">    4310 </span>            :     aAxisTracker.LogicalSizeFromFlexRelativeSizes(aContentBoxMainSize,
<span class="lineNum">    4311 </span><span class="lineCov">          1 :                                                   contentBoxCrossSize);</span>
<span class="lineNum">    4312 </span><span class="lineCov">          1 :   logSize += aReflowInput.ComputedLogicalBorderPadding().Size(flexWM);</span>
<span class="lineNum">    4313 </span><span class="lineCov">          1 :   nsSize containerSize = logSize.GetPhysicalSize(flexWM);</span>
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span>            :   // If the flex container has no baseline-aligned items, it will use this item
<span class="lineNum">    4316 </span>            :   // (the first item, discounting any under-the-hood reversing that we've done)
<span class="lineNum">    4317 </span>            :   // to determine its baseline:
<span class="lineNum">    4318 </span>            :   const FlexItem* const firstItem =
<span class="lineNum">    4319 </span><span class="lineCov">          1 :     aAxisTracker.AreAxesInternallyReversed()</span>
<span class="lineNum">    4320 </span><span class="lineCov">          1 :     ? lines.getLast()-&gt;GetLastItem()</span>
<span class="lineNum">    4321 </span><span class="lineCov">          1 :     : lines.getFirst()-&gt;GetFirstItem();</span>
<span class="lineNum">    4322 </span>            : 
<span class="lineNum">    4323 </span>            :   // FINAL REFLOW: Give each child frame another chance to reflow, now that
<span class="lineNum">    4324 </span>            :   // we know its final size and position.
<span class="lineNum">    4325 </span><span class="lineCov">          1 :   for (const FlexLine* line = lines.getFirst(); line; line = line-&gt;getNext()) {</span>
<span class="lineNum">    4326 </span><span class="lineCov">          1 :     for (const FlexItem* item = line-&gt;GetFirstItem(); item;</span>
<span class="lineNum">    4327 </span><span class="lineCov">          1 :          item = item-&gt;getNext()) {</span>
<span class="lineNum">    4328 </span>            :       LogicalPoint framePos = aAxisTracker.LogicalPointFromFlexRelativePoint(
<span class="lineNum">    4329 </span>            :                                item-&gt;GetMainPosition(),
<span class="lineNum">    4330 </span>            :                                item-&gt;GetCrossPosition(),
<span class="lineNum">    4331 </span>            :                                aContentBoxMainSize,
<span class="lineNum">    4332 </span><span class="lineCov">          1 :                                contentBoxCrossSize);</span>
<span class="lineNum">    4333 </span>            :       // Adjust framePos to be relative to the container's border-box
<span class="lineNum">    4334 </span>            :       // (i.e. its frame rect), instead of the container's content-box:
<span class="lineNum">    4335 </span><span class="lineCov">          1 :       framePos += containerContentBoxOrigin;</span>
<span class="lineNum">    4336 </span>            : 
<span class="lineNum">    4337 </span>            :       // (Intentionally snapshotting this before ApplyRelativePositioning, to
<span class="lineNum">    4338 </span>            :       // maybe use for setting the flex container's baseline.)
<span class="lineNum">    4339 </span><span class="lineCov">          1 :       const nscoord itemNormalBPos = framePos.B(flexWM);</span>
<span class="lineNum">    4340 </span>            : 
<span class="lineNum">    4341 </span>            :       // Check if we actually need to reflow the item -- if we already reflowed
<span class="lineNum">    4342 </span>            :       // it with the right size, we can just reposition it as-needed.
<span class="lineNum">    4343 </span><span class="lineCov">          1 :       bool itemNeedsReflow = true; // (Start out assuming the worst.)</span>
<span class="lineNum">    4344 </span><span class="lineCov">          1 :       if (item-&gt;HadMeasuringReflow()) {</span>
<span class="lineNum">    4345 </span>            :         LogicalSize finalFlexItemCBSize =
<span class="lineNum">    4346 </span>            :           aAxisTracker.LogicalSizeFromFlexRelativeSizes(item-&gt;GetMainSize(),
<span class="lineNum">    4347 </span><span class="lineCov">          1 :                                                         item-&gt;GetCrossSize());</span>
<span class="lineNum">    4348 </span>            :         // We've already reflowed the child once. Was the size we gave it in
<span class="lineNum">    4349 </span>            :         // that reflow the same as its final (post-flexing/stretching) size?
<span class="lineNum">    4350 </span><span class="lineCov">          1 :         if (finalFlexItemCBSize ==</span>
<span class="lineNum">    4351 </span>            :             LogicalSize(flexWM,
<span class="lineNum">    4352 </span><span class="lineCov">          1 :                         item-&gt;Frame()-&gt;GetContentRectRelativeToSelf().Size())) {</span>
<span class="lineNum">    4353 </span>            :           // Even if our size hasn't changed, some of our descendants might
<span class="lineNum">    4354 </span>            :           // care that our bsize is now considered &quot;definite&quot; (whereas it
<span class="lineNum">    4355 </span>            :           // wasn't in our previous &quot;measuring&quot; reflow), if they have a
<span class="lineNum">    4356 </span>            :           // relative bsize.
<span class="lineNum">    4357 </span><span class="lineCov">          1 :           if (!(item-&gt;Frame()-&gt;GetStateBits() &amp;</span>
<span class="lineNum">    4358 </span>            :                 NS_FRAME_CONTAINS_RELATIVE_BSIZE)) {
<span class="lineNum">    4359 </span>            :             // Item has the correct size (and its children don't care that
<span class="lineNum">    4360 </span>            :             // it's now &quot;definite&quot;). Let's just make sure it's at the right
<span class="lineNum">    4361 </span>            :             // position.
<span class="lineNum">    4362 </span><span class="lineCov">          1 :             itemNeedsReflow = false;</span>
<span class="lineNum">    4363 </span>            :             MoveFlexItemToFinalPosition(aReflowInput, *item, framePos,
<span class="lineNum">    4364 </span><span class="lineCov">          1 :                                         containerSize);</span>
<span class="lineNum">    4365 </span>            :           }
<span class="lineNum">    4366 </span>            :         }
<span class="lineNum">    4367 </span>            :       }
<span class="lineNum">    4368 </span><span class="lineCov">          1 :       if (itemNeedsReflow) {</span>
<span class="lineNum">    4369 </span>            :         ReflowFlexItem(aPresContext, aAxisTracker, aReflowInput,
<span class="lineNum">    4370 </span><span class="lineCov">          1 :                        *item, framePos, containerSize);</span>
<span class="lineNum">    4371 </span>            :       }
<span class="lineNum">    4372 </span>            : 
<span class="lineNum">    4373 </span>            :       // If this is our first item and we haven't established a baseline for
<span class="lineNum">    4374 </span>            :       // the container yet (i.e. if we don't have 'align-self: baseline' on any
<span class="lineNum">    4375 </span>            :       // children), then use this child's first baseline as the container's
<span class="lineNum">    4376 </span>            :       // baseline.
<span class="lineNum">    4377 </span><span class="lineCov">          1 :       if (item == firstItem &amp;&amp;</span>
<span class="lineNum">    4378 </span><span class="lineCov">          1 :           flexContainerAscent == nscoord_MIN) {</span>
<span class="lineNum">    4379 </span><span class="lineCov">          1 :         flexContainerAscent = itemNormalBPos + item-&gt;ResolvedAscent(true);</span>
<span class="lineNum">    4380 </span>            :       }
<span class="lineNum">    4381 </span>            :     }
<span class="lineNum">    4382 </span>            :   }
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span><span class="lineCov">          1 :   if (!placeholderKids.IsEmpty()) {</span>
<span class="lineNum">    4385 </span>            :     ReflowPlaceholders(aPresContext, aReflowInput,
<span class="lineNum">    4386 </span>            :                        placeholderKids, containerContentBoxOrigin,
<span class="lineNum">    4387 </span><span class="lineCov">          1 :                        containerSize);</span>
<span class="lineNum">    4388 </span>            :   }
<span class="lineNum">    4389 </span>            : 
<span class="lineNum">    4390 </span>            :   // Compute flex container's desired size (in its own writing-mode),
<span class="lineNum">    4391 </span>            :   // starting w/ content-box size &amp; growing from there:
<span class="lineNum">    4392 </span>            :   LogicalSize desiredSizeInFlexWM =
<span class="lineNum">    4393 </span>            :     aAxisTracker.LogicalSizeFromFlexRelativeSizes(aContentBoxMainSize,
<span class="lineNum">    4394 </span><span class="lineCov">          1 :                                                   contentBoxCrossSize);</span>
<span class="lineNum">    4395 </span>            :   // Add border/padding (w/ skipSides already applied):
<span class="lineNum">    4396 </span><span class="lineCov">          1 :   desiredSizeInFlexWM.ISize(flexWM) += containerBP.IStartEnd(flexWM);</span>
<span class="lineNum">    4397 </span><span class="lineCov">          1 :   desiredSizeInFlexWM.BSize(flexWM) += containerBP.BStartEnd(flexWM);</span>
<span class="lineNum">    4398 </span>            : 
<span class="lineNum">    4399 </span><span class="lineCov">          1 :   if (flexContainerAscent == nscoord_MIN) {</span>
<span class="lineNum">    4400 </span>            :     // Still don't have our baseline set -- this happens if we have no
<span class="lineNum">    4401 </span>            :     // children (or if our children are huge enough that they have nscoord_MIN
<span class="lineNum">    4402 </span>            :     // as their baseline... in which case, we'll use the wrong baseline, but no
<span class="lineNum">    4403 </span>            :     // big deal)
<span class="lineNum">    4404 </span>            :     NS_WARNING_ASSERTION(
<span class="lineNum">    4405 </span>            :       lines.getFirst()-&gt;IsEmpty(),
<span class="lineNum">    4406 </span>            :       &quot;Have flex items but didn't get an ascent - that's odd (or there are &quot;
<span class="lineNum">    4407 </span>            :       &quot;just gigantic sizes involved)&quot;);
<span class="lineNum">    4408 </span>            :     // Per spec, synthesize baseline from the flex container's content box
<span class="lineNum">    4409 </span>            :     // (i.e. use block-end side of content-box)
<span class="lineNum">    4410 </span>            :     // XXXdholbert This only makes sense if parent's writing mode is
<span class="lineNum">    4411 </span>            :     // horizontal (&amp; even then, really we should be using the BSize in terms
<span class="lineNum">    4412 </span>            :     // of the parent's writing mode, not ours). Clean up in bug 1155322.
<span class="lineNum">    4413 </span><span class="lineCov">          1 :     flexContainerAscent = desiredSizeInFlexWM.BSize(flexWM);</span>
<span class="lineNum">    4414 </span>            :   }
<span class="lineNum">    4415 </span>            : 
<span class="lineNum">    4416 </span><span class="lineCov">          1 :   if (HasAnyStateBits(NS_STATE_FLEX_SYNTHESIZE_BASELINE)) {</span>
<span class="lineNum">    4417 </span>            :     // This will force our parent to call GetLogicalBaseline, which will
<span class="lineNum">    4418 </span>            :     // synthesize a margin-box baseline.
<span class="lineNum">    4419 </span><span class="lineCov">          1 :     aDesiredSize.SetBlockStartAscent(ReflowOutput::ASK_FOR_BASELINE);</span>
<span class="lineNum">    4420 </span>            :   } else {
<span class="lineNum">    4421 </span>            :     // XXXdholbert flexContainerAscent needs to be in terms of
<span class="lineNum">    4422 </span>            :     // our parent's writing-mode here. See bug 1155322.
<span class="lineNum">    4423 </span><span class="lineCov">          1 :     aDesiredSize.SetBlockStartAscent(flexContainerAscent);</span>
<span class="lineNum">    4424 </span>            :   }
<span class="lineNum">    4425 </span>            : 
<span class="lineNum">    4426 </span>            :   // Now: If we're complete, add bottom border/padding to desired height (which
<span class="lineNum">    4427 </span>            :   // we skipped via skipSides) -- unless that pushes us over available height,
<span class="lineNum">    4428 </span>            :   // in which case we become incomplete (unless we already weren't asking for
<span class="lineNum">    4429 </span>            :   // any height, in which case we stay complete to avoid looping forever).
<span class="lineNum">    4430 </span>            :   // NOTE: If we're auto-height, we allow our bottom border/padding to push us
<span class="lineNum">    4431 </span>            :   // over the available height without requesting a continuation, for
<span class="lineNum">    4432 </span>            :   // consistency with the behavior of &quot;display:block&quot; elements.
<span class="lineNum">    4433 </span><span class="lineCov">          1 :   if (aStatus.IsComplete()) {</span>
<span class="lineNum">    4434 </span>            :     nscoord desiredBSizeWithBEndBP =
<span class="lineNum">    4435 </span><span class="lineCov">          1 :       desiredSizeInFlexWM.BSize(flexWM) + blockEndContainerBP;</span>
<span class="lineNum">    4436 </span>            : 
<span class="lineNum">    4437 </span><span class="lineCov">          1 :     if (aReflowInput.AvailableBSize() == NS_UNCONSTRAINEDSIZE ||</span>
<span class="lineNum">    4438 </span><span class="lineNoCov">          0 :         desiredSizeInFlexWM.BSize(flexWM) == 0 ||</span>
<span class="lineNum">    4439 </span><span class="lineCov">          1 :         desiredBSizeWithBEndBP &lt;= aReflowInput.AvailableBSize() ||</span>
<span class="lineNum">    4440 </span><span class="lineNoCov">          0 :         aReflowInput.ComputedBSize() == NS_INTRINSICSIZE) {</span>
<span class="lineNum">    4441 </span>            :       // Update desired height to include block-end border/padding
<span class="lineNum">    4442 </span>            :       desiredSizeInFlexWM.BSize(flexWM) = desiredBSizeWithBEndBP;
<span class="lineNum">    4443 </span>            :     } else {
<span class="lineNum">    4444 </span>            :       // We couldn't fit bottom border/padding, so we'll need a continuation.
<span class="lineNum">    4445 </span>            :       aStatus.SetIncomplete();
<span class="lineNum">    4446 </span>            :     }
<span class="lineNum">    4447 </span>            :   }
<span class="lineNum">    4448 </span>            : 
<span class="lineNum">    4449 </span>            :   // Calculate the container baselines so that our parent can baseline-align us.
<span class="lineNum">    4450 </span><span class="lineCov">          1 :   mBaselineFromLastReflow = flexContainerAscent;</span>
<span class="lineNum">    4451 </span><span class="lineCov">          1 :   mLastBaselineFromLastReflow = lines.getLast()-&gt;GetLastBaselineOffset();</span>
<span class="lineNum">    4452 </span><span class="lineCov">          1 :   if (mLastBaselineFromLastReflow == nscoord_MIN) {</span>
<span class="lineNum">    4453 </span>            :     // XXX we fall back to a mirrored first baseline here for now, but this
<span class="lineNum">    4454 </span>            :     // should probably use the last baseline of the last item or something.
<span class="lineNum">    4455 </span>            :     mLastBaselineFromLastReflow =
<span class="lineNum">    4456 </span><span class="lineCov">          1 :       desiredSizeInFlexWM.BSize(flexWM) - flexContainerAscent;</span>
<span class="lineNum">    4457 </span>            :   }
<span class="lineNum">    4458 </span>            : 
<span class="lineNum">    4459 </span>            :   // Convert flex container's final desired size to parent's WM, for outparam.
<span class="lineNum">    4460 </span><span class="lineCov">          1 :   aDesiredSize.SetSize(flexWM, desiredSizeInFlexWM);</span>
<span class="lineNum">    4461 </span>            : 
<span class="lineNum">    4462 </span>            :   // Overflow area = union(my overflow area, kids' overflow areas)
<span class="lineNum">    4463 </span><span class="lineCov">          1 :   aDesiredSize.SetOverflowAreasToDesiredBounds();</span>
<span class="lineNum">    4464 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : mFrames) {</span>
<span class="lineNum">    4465 </span><span class="lineCov">          1 :     ConsiderChildOverflow(aDesiredSize.mOverflowAreas, childFrame);</span>
<span class="lineNum">    4466 </span>            :   }
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span>            :   FinishReflowWithAbsoluteFrames(aPresContext, aDesiredSize,
<span class="lineNum">    4469 </span><span class="lineCov">          1 :                                  aReflowInput, aStatus);</span>
<span class="lineNum">    4470 </span>            : 
<span class="lineNum">    4471 </span><span class="lineCov">          1 :   NS_FRAME_SET_TRUNCATION(aStatus, aReflowInput, aDesiredSize)</span>
<span class="lineNum">    4472 </span>            : }
<a name="4473"><span class="lineNum">    4473 </span>            : </a>
<span class="lineNum">    4474 </span>            : void
<span class="lineNum">    4475 </span><span class="lineCov">          1 : nsFlexContainerFrame::MoveFlexItemToFinalPosition(</span>
<span class="lineNum">    4476 </span>            :   const ReflowInput&amp; aReflowInput,
<span class="lineNum">    4477 </span>            :   const FlexItem&amp; aItem,
<span class="lineNum">    4478 </span>            :   LogicalPoint&amp; aFramePos,
<span class="lineNum">    4479 </span>            :   const nsSize&amp; aContainerSize)
<span class="lineNum">    4480 </span>            : {
<span class="lineNum">    4481 </span><span class="lineCov">          1 :   WritingMode outerWM = aReflowInput.GetWritingMode();</span>
<span class="lineNum">    4482 </span>            : 
<span class="lineNum">    4483 </span>            :   // If item is relpos, look up its offsets (cached from prev reflow)
<span class="lineNum">    4484 </span>            :   LogicalMargin logicalOffsets(outerWM);
<span class="lineNum">    4485 </span><span class="lineCov">          1 :   if (NS_STYLE_POSITION_RELATIVE == aItem.Frame()-&gt;StyleDisplay()-&gt;mPosition) {</span>
<span class="lineNum">    4486 </span><span class="lineCov">          1 :     FrameProperties props = aItem.Frame()-&gt;Properties();</span>
<span class="lineNum">    4487 </span><span class="lineCov">          1 :     nsMargin* cachedOffsets = props.Get(nsIFrame::ComputedOffsetProperty());</span>
<span class="lineNum">    4488 </span>            :     MOZ_ASSERT(cachedOffsets,
<span class="lineNum">    4489 </span>            :                &quot;relpos previously-reflowed frame should've cached its offsets&quot;);
<span class="lineNum">    4490 </span><span class="lineCov">          1 :     logicalOffsets = LogicalMargin(outerWM, *cachedOffsets);</span>
<span class="lineNum">    4491 </span>            :   }
<span class="lineNum">    4492 </span>            :   ReflowInput::ApplyRelativePositioning(aItem.Frame(), outerWM,
<span class="lineNum">    4493 </span>            :                                               logicalOffsets, &amp;aFramePos,
<span class="lineNum">    4494 </span><span class="lineCov">          1 :                                               aContainerSize);</span>
<span class="lineNum">    4495 </span><span class="lineCov">          1 :   aItem.Frame()-&gt;SetPosition(outerWM, aFramePos, aContainerSize);</span>
<span class="lineNum">    4496 </span><span class="lineCov">          1 :   PositionFrameView(aItem.Frame());</span>
<span class="lineNum">    4497 </span><span class="lineCov">          1 :   PositionChildViews(aItem.Frame());</span>
<span class="lineNum">    4498 </span><span class="lineCov">          1 : }</span>
<a name="4499"><span class="lineNum">    4499 </span>            : </a>
<span class="lineNum">    4500 </span>            : void
<span class="lineNum">    4501 </span><span class="lineCov">          1 : nsFlexContainerFrame::ReflowFlexItem(nsPresContext* aPresContext,</span>
<span class="lineNum">    4502 </span>            :                                      const FlexboxAxisTracker&amp; aAxisTracker,
<span class="lineNum">    4503 </span>            :                                      const ReflowInput&amp; aReflowInput,
<span class="lineNum">    4504 </span>            :                                      const FlexItem&amp; aItem,
<span class="lineNum">    4505 </span>            :                                      LogicalPoint&amp; aFramePos,
<span class="lineNum">    4506 </span>            :                                      const nsSize&amp; aContainerSize)
<span class="lineNum">    4507 </span>            : {
<span class="lineNum">    4508 </span><span class="lineCov">          1 :   WritingMode outerWM = aReflowInput.GetWritingMode();</span>
<span class="lineNum">    4509 </span><span class="lineCov">          1 :   WritingMode wm = aItem.Frame()-&gt;GetWritingMode();</span>
<span class="lineNum">    4510 </span><span class="lineCov">          1 :   LogicalSize availSize = aReflowInput.ComputedSize(wm);</span>
<span class="lineNum">    4511 </span><span class="lineCov">          1 :   availSize.BSize(wm) = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">    4512 </span>            :   ReflowInput childReflowInput(aPresContext, aReflowInput,
<span class="lineNum">    4513 </span><span class="lineCov">          1 :                                      aItem.Frame(), availSize);</span>
<span class="lineNum">    4514 </span>            : 
<span class="lineNum">    4515 </span>            :   // Keep track of whether we've overriden the child's computed height
<span class="lineNum">    4516 </span>            :   // and/or width, so we can set its resize flags accordingly.
<span class="lineNum">    4517 </span><span class="lineCov">          1 :   bool didOverrideComputedWidth = false;</span>
<span class="lineNum">    4518 </span><span class="lineCov">          1 :   bool didOverrideComputedHeight = false;</span>
<span class="lineNum">    4519 </span>            : 
<span class="lineNum">    4520 </span>            :   // Override computed main-size
<span class="lineNum">    4521 </span><span class="lineCov">          1 :   if (aAxisTracker.IsMainAxisHorizontal()) {</span>
<span class="lineNum">    4522 </span><span class="lineCov">          1 :     childReflowInput.SetComputedWidth(aItem.GetMainSize());</span>
<span class="lineNum">    4523 </span><span class="lineCov">          1 :     didOverrideComputedWidth = true;</span>
<span class="lineNum">    4524 </span>            :   } else {
<span class="lineNum">    4525 </span><span class="lineCov">          1 :     childReflowInput.SetComputedHeight(aItem.GetMainSize());</span>
<span class="lineNum">    4526 </span><span class="lineCov">          1 :     didOverrideComputedHeight = true;</span>
<span class="lineNum">    4527 </span>            :   }
<span class="lineNum">    4528 </span>            : 
<span class="lineNum">    4529 </span>            :   // Override reflow state's computed cross-size if either:
<span class="lineNum">    4530 </span>            :   // - the item was stretched (in which case we're imposing a cross size)
<span class="lineNum">    4531 </span>            :   // ...or...
<span class="lineNum">    4532 </span>            :   // - the item it has an aspect ratio (in which case the cross-size that's
<span class="lineNum">    4533 </span>            :   // currently in the reflow state is based on arithmetic involving a stale
<span class="lineNum">    4534 </span>            :   // main-size value that we just stomped on above). (Note that we could handle
<span class="lineNum">    4535 </span>            :   // this case using an AutoFlexItemMainSizeOverride, as we do elsewhere; but
<span class="lineNum">    4536 </span>            :   // given that we *already know* the correct cross size to use here, it's
<span class="lineNum">    4537 </span>            :   // cheaper to just directly set it instead of setting a frame property.)
<span class="lineNum">    4538 </span><span class="lineCov">          1 :   if (aItem.IsStretched() ||</span>
<span class="lineNum">    4539 </span><span class="lineCov">          1 :       aItem.HasIntrinsicRatio()) {</span>
<span class="lineNum">    4540 </span><span class="lineCov">          1 :     if (aAxisTracker.IsCrossAxisHorizontal()) {</span>
<span class="lineNum">    4541 </span><span class="lineCov">          1 :       childReflowInput.SetComputedWidth(aItem.GetCrossSize());</span>
<span class="lineNum">    4542 </span><span class="lineCov">          1 :       didOverrideComputedWidth = true;</span>
<span class="lineNum">    4543 </span>            :     } else {
<span class="lineNum">    4544 </span><span class="lineCov">          1 :       childReflowInput.SetComputedHeight(aItem.GetCrossSize());</span>
<span class="lineNum">    4545 </span><span class="lineCov">          1 :       didOverrideComputedHeight = true;</span>
<span class="lineNum">    4546 </span>            :     }
<span class="lineNum">    4547 </span>            :   }
<span class="lineNum">    4548 </span><span class="lineCov">          1 :   if (aItem.IsStretched() &amp;&amp; !aAxisTracker.IsCrossAxisHorizontal()) {</span>
<span class="lineNum">    4549 </span>            :     // If this item's height is stretched, it's a relative height.
<span class="lineNum">    4550 </span><span class="lineCov">          1 :     aItem.Frame()-&gt;AddStateBits(NS_FRAME_CONTAINS_RELATIVE_BSIZE);</span>
<span class="lineNum">    4551 </span>            :   }
<span class="lineNum">    4552 </span>            : 
<span class="lineNum">    4553 </span>            :   // XXXdholbert Might need to actually set the correct margins in the
<span class="lineNum">    4554 </span>            :   // reflow state at some point, so that they can be saved on the frame for
<span class="lineNum">    4555 </span>            :   // UsedMarginProperty().  Maybe doesn't matter though...?
<span class="lineNum">    4556 </span>            : 
<span class="lineNum">    4557 </span>            :   // If we're overriding the computed width or height, *and* we had an
<span class="lineNum">    4558 </span>            :   // earlier &quot;measuring&quot; reflow, then this upcoming reflow needs to be
<span class="lineNum">    4559 </span>            :   // treated as a resize.
<span class="lineNum">    4560 </span><span class="lineCov">          1 :   if (aItem.HadMeasuringReflow()) {</span>
<span class="lineNum">    4561 </span><span class="lineCov">          1 :     if (didOverrideComputedWidth) {</span>
<span class="lineNum">    4562 </span>            :       // (This is somewhat redundant, since the reflow state already
<span class="lineNum">    4563 </span>            :       // sets mHResize whenever our computed width has changed since the
<span class="lineNum">    4564 </span>            :       // previous reflow. Still, it's nice for symmetry, and it may become
<span class="lineNum">    4565 </span>            :       // necessary once we support orthogonal flows.)
<span class="lineNum">    4566 </span><span class="lineCov">          1 :       childReflowInput.SetHResize(true);</span>
<span class="lineNum">    4567 </span>            :     }
<span class="lineNum">    4568 </span><span class="lineCov">          1 :     if (didOverrideComputedHeight) {</span>
<span class="lineNum">    4569 </span><span class="lineCov">          1 :       childReflowInput.SetVResize(true);</span>
<span class="lineNum">    4570 </span>            :     }
<span class="lineNum">    4571 </span>            :   }
<span class="lineNum">    4572 </span>            :   // NOTE: Be very careful about doing anything else with childReflowInput
<span class="lineNum">    4573 </span>            :   // after this point, because some of its methods (e.g. SetComputedWidth)
<span class="lineNum">    4574 </span>            :   // internally call InitResizeFlags and stomp on mVResize &amp; mHResize.
<span class="lineNum">    4575 </span>            : 
<span class="lineNum">    4576 </span><span class="lineCov">          1 :   ReflowOutput childDesiredSize(childReflowInput);</span>
<span class="lineNum">    4577 </span><span class="lineCov">          1 :   nsReflowStatus childReflowStatus;</span>
<span class="lineNum">    4578 </span>            :   ReflowChild(aItem.Frame(), aPresContext,
<span class="lineNum">    4579 </span>            :               childDesiredSize, childReflowInput,
<span class="lineNum">    4580 </span>            :               outerWM, aFramePos, aContainerSize,
<span class="lineNum">    4581 </span><span class="lineCov">          1 :               0, childReflowStatus);</span>
<span class="lineNum">    4582 </span>            : 
<span class="lineNum">    4583 </span>            :   // XXXdholbert Once we do pagination / splitting, we'll need to actually
<span class="lineNum">    4584 </span>            :   // handle incomplete childReflowStatuses. But for now, we give our kids
<span class="lineNum">    4585 </span>            :   // unconstrained available height, which means they should always
<span class="lineNum">    4586 </span>            :   // complete.
<span class="lineNum">    4587 </span>            :   MOZ_ASSERT(childReflowStatus.IsComplete(),
<span class="lineNum">    4588 </span>            :              &quot;We gave flex item unconstrained available height, so it &quot;
<span class="lineNum">    4589 </span>            :              &quot;should be complete&quot;);
<span class="lineNum">    4590 </span>            : 
<span class="lineNum">    4591 </span>            :   LogicalMargin offsets =
<span class="lineNum">    4592 </span><span class="lineCov">          1 :     childReflowInput.ComputedLogicalOffsets().ConvertTo(outerWM, wm);</span>
<span class="lineNum">    4593 </span>            :   ReflowInput::ApplyRelativePositioning(aItem.Frame(), outerWM,
<span class="lineNum">    4594 </span>            :                                               offsets, &amp;aFramePos,
<span class="lineNum">    4595 </span><span class="lineCov">          1 :                                               aContainerSize);</span>
<span class="lineNum">    4596 </span>            : 
<span class="lineNum">    4597 </span>            :   FinishReflowChild(aItem.Frame(), aPresContext,
<span class="lineNum">    4598 </span>            :                     childDesiredSize, &amp;childReflowInput,
<span class="lineNum">    4599 </span><span class="lineCov">          1 :                     outerWM, aFramePos, aContainerSize, 0);</span>
<span class="lineNum">    4600 </span>            : 
<span class="lineNum">    4601 </span><span class="lineCov">          1 :   aItem.SetAscent(childDesiredSize.BlockStartAscent());</span>
<span class="lineNum">    4602 </span><span class="lineCov">          1 : }</span>
<a name="4603"><span class="lineNum">    4603 </span>            : </a>
<span class="lineNum">    4604 </span>            : void
<span class="lineNum">    4605 </span><span class="lineCov">          1 : nsFlexContainerFrame::ReflowPlaceholders(nsPresContext* aPresContext,</span>
<span class="lineNum">    4606 </span>            :                                          const ReflowInput&amp; aReflowInput,
<span class="lineNum">    4607 </span>            :                                          nsTArray&lt;nsIFrame*&gt;&amp; aPlaceholders,
<span class="lineNum">    4608 </span>            :                                          const LogicalPoint&amp; aContentBoxOrigin,
<span class="lineNum">    4609 </span>            :                                          const nsSize&amp; aContainerSize)
<span class="lineNum">    4610 </span>            : {
<span class="lineNum">    4611 </span><span class="lineCov">          1 :   WritingMode outerWM = aReflowInput.GetWritingMode();</span>
<span class="lineNum">    4612 </span>            : 
<span class="lineNum">    4613 </span>            :   // As noted in this method's documentation, we'll reflow every entry in
<span class="lineNum">    4614 </span>            :   // |aPlaceholders| at the container's content-box origin.
<span class="lineNum">    4615 </span><span class="lineCov">          1 :   for (nsIFrame* placeholder : aPlaceholders) {</span>
<span class="lineNum">    4616 </span>            :     MOZ_ASSERT(placeholder-&gt;GetType() == nsGkAtoms::placeholderFrame,
<span class="lineNum">    4617 </span>            :                &quot;placeholders array should only contain placeholder frames&quot;);
<span class="lineNum">    4618 </span><span class="lineCov">          1 :     WritingMode wm = placeholder-&gt;GetWritingMode();</span>
<span class="lineNum">    4619 </span><span class="lineCov">          1 :     LogicalSize availSize = aReflowInput.ComputedSize(wm);</span>
<span class="lineNum">    4620 </span>            :     ReflowInput childReflowInput(aPresContext, aReflowInput,
<span class="lineNum">    4621 </span><span class="lineCov">          1 :                                  placeholder, availSize);</span>
<span class="lineNum">    4622 </span><span class="lineCov">          1 :     ReflowOutput childDesiredSize(childReflowInput);</span>
<span class="lineNum">    4623 </span><span class="lineCov">          1 :     nsReflowStatus childReflowStatus;</span>
<span class="lineNum">    4624 </span>            :     ReflowChild(placeholder, aPresContext,
<span class="lineNum">    4625 </span>            :                 childDesiredSize, childReflowInput,
<span class="lineNum">    4626 </span>            :                 outerWM, aContentBoxOrigin, aContainerSize, 0,
<span class="lineNum">    4627 </span><span class="lineCov">          1 :                 childReflowStatus);</span>
<span class="lineNum">    4628 </span>            : 
<span class="lineNum">    4629 </span>            :     FinishReflowChild(placeholder, aPresContext,
<span class="lineNum">    4630 </span>            :                       childDesiredSize, &amp;childReflowInput,
<span class="lineNum">    4631 </span><span class="lineCov">          1 :                       outerWM, aContentBoxOrigin, aContainerSize, 0);</span>
<span class="lineNum">    4632 </span>            : 
<span class="lineNum">    4633 </span>            :     // Mark the placeholder frame to indicate that it's not actually at the
<span class="lineNum">    4634 </span>            :     // element's static position, because we need to apply CSS Alignment after
<span class="lineNum">    4635 </span>            :     // we determine the OOF's size:
<span class="lineNum">    4636 </span>            :     placeholder-&gt;AddStateBits(PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN);
<span class="lineNum">    4637 </span>            :   }
<span class="lineNum">    4638 </span><span class="lineCov">          1 : }</span>
<a name="4639"><span class="lineNum">    4639 </span>            : </a>
<span class="lineNum">    4640 </span>            : /* virtual */ nscoord
<span class="lineNum">    4641 </span><span class="lineCov">          1 : nsFlexContainerFrame::GetMinISize(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">    4642 </span>            : {
<span class="lineNum">    4643 </span><span class="lineCov">          1 :   nscoord minISize = 0;</span>
<span class="lineNum">    4644 </span>            :   DISPLAY_MIN_WIDTH(this, minISize);
<span class="lineNum">    4645 </span>            : 
<span class="lineNum">    4646 </span><span class="lineCov">          1 :   RenumberList();</span>
<span class="lineNum">    4647 </span>            : 
<span class="lineNum">    4648 </span><span class="lineCov">          1 :   const nsStylePosition* stylePos = StylePosition();</span>
<span class="lineNum">    4649 </span><span class="lineCov">          1 :   const FlexboxAxisTracker axisTracker(this, GetWritingMode());</span>
<span class="lineNum">    4650 </span>            : 
<span class="lineNum">    4651 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : mFrames) {</span>
<span class="lineNum">    4652 </span>            :     nscoord childMinISize =
<span class="lineNum">    4653 </span>            :       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, childFrame,
<span class="lineNum">    4654 </span><span class="lineCov">          1 :                                            nsLayoutUtils::MIN_ISIZE);</span>
<span class="lineNum">    4655 </span>            :     // For a horizontal single-line flex container, the intrinsic min
<span class="lineNum">    4656 </span>            :     // isize is the sum of its items' min isizes.
<span class="lineNum">    4657 </span>            :     // For a column-oriented flex container, or for a multi-line row-
<span class="lineNum">    4658 </span>            :     // oriented flex container, the intrinsic min isize is the max of
<span class="lineNum">    4659 </span>            :     // its items' min isizes.
<span class="lineNum">    4660 </span><span class="lineCov">          1 :     if (axisTracker.IsRowOriented() &amp;&amp;</span>
<span class="lineNum">    4661 </span><span class="lineCov">          1 :         NS_STYLE_FLEX_WRAP_NOWRAP == stylePos-&gt;mFlexWrap) {</span>
<span class="lineNum">    4662 </span><span class="lineCov">          1 :       minISize += childMinISize;</span>
<span class="lineNum">    4663 </span>            :     } else {
<span class="lineNum">    4664 </span><span class="lineCov">          1 :       minISize = std::max(minISize, childMinISize);</span>
<span class="lineNum">    4665 </span>            :     }
<span class="lineNum">    4666 </span>            :   }
<span class="lineNum">    4667 </span><span class="lineCov">          1 :   return minISize;</span>
<span class="lineNum">    4668 </span>            : }
<a name="4669"><span class="lineNum">    4669 </span>            : </a>
<span class="lineNum">    4670 </span>            : /* virtual */ nscoord
<span class="lineNum">    4671 </span><span class="lineCov">          1 : nsFlexContainerFrame::GetPrefISize(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">    4672 </span>            : {
<span class="lineNum">    4673 </span><span class="lineCov">          1 :   nscoord prefISize = 0;</span>
<span class="lineNum">    4674 </span>            :   DISPLAY_PREF_WIDTH(this, prefISize);
<span class="lineNum">    4675 </span>            : 
<span class="lineNum">    4676 </span><span class="lineCov">          1 :   RenumberList();</span>
<span class="lineNum">    4677 </span>            : 
<span class="lineNum">    4678 </span>            :   // XXXdholbert Optimization: We could cache our intrinsic widths like
<span class="lineNum">    4679 </span>            :   // nsBlockFrame does (and return it early from this function if it's set).
<span class="lineNum">    4680 </span>            :   // Whenever anything happens that might change it, set it to
<span class="lineNum">    4681 </span>            :   // NS_INTRINSIC_WIDTH_UNKNOWN (like nsBlockFrame::MarkIntrinsicISizesDirty
<span class="lineNum">    4682 </span>            :   // does)
<span class="lineNum">    4683 </span><span class="lineCov">          1 :   const FlexboxAxisTracker axisTracker(this, GetWritingMode());</span>
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : mFrames) {</span>
<span class="lineNum">    4686 </span>            :     nscoord childPrefISize =
<span class="lineNum">    4687 </span>            :       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, childFrame,
<span class="lineNum">    4688 </span><span class="lineCov">          1 :                                            nsLayoutUtils::PREF_ISIZE);</span>
<span class="lineNum">    4689 </span><span class="lineCov">          1 :     if (axisTracker.IsRowOriented()) {</span>
<span class="lineNum">    4690 </span><span class="lineCov">          1 :       prefISize += childPrefISize;</span>
<span class="lineNum">    4691 </span>            :     } else {
<span class="lineNum">    4692 </span><span class="lineCov">          1 :       prefISize = std::max(prefISize, childPrefISize);</span>
<span class="lineNum">    4693 </span>            :     }
<span class="lineNum">    4694 </span>            :   }
<span class="lineNum">    4695 </span><span class="lineCov">          1 :   return prefISize;</span>
<span class="lineNum">    4696 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
