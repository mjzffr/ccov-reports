<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/mathml/nsMathMLContainerFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/mathml</a> - nsMathMLContainerFrame.cpp<span style="font-size: 80%;"> (source / <a href="nsMathMLContainerFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">519</td>
            <td class="headerCovTableEntry">585</td>
            <td class="headerCovTableEntryMed">88.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">55</td>
            <td class="headerCovTableEntry">64</td>
            <td class="headerCovTableEntryMed">85.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;nsMathMLContainerFrame.h&quot;
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsIPresShell.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsStyleContext.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsNameSpaceManager.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsRenderingContext.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsIDOMMutationEvent.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsDisplayList.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsIReflowCallback.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/Likely.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsIScriptError.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsMathMLElement.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : using namespace mozilla;
<span class="lineNum">      26 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : //
<span class="lineNum">      29 </span>            : // nsMathMLContainerFrame implementation
<a name="30"><span class="lineNum">      30 </span>            : //</a>
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span><span class="lineCov">          1 : NS_QUERYFRAME_HEAD(nsMathMLContainerFrame)</span>
<span class="lineNum">      33 </span><span class="lineCov">          1 :   NS_QUERYFRAME_ENTRY(nsIMathMLFrame)</span>
<span class="lineNum">      34 </span>            :   NS_QUERYFRAME_ENTRY(nsMathMLContainerFrame)
<span class="lineNum">      35 </span><span class="lineCov">          1 : NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)</span>
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : // =============================================================================
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // error handlers
<a name="40"><span class="lineNum">      40 </span>            : // provide a feedback to the user when a frame with bad markup can not be rendered</a>
<span class="lineNum">      41 </span>            : nsresult
<span class="lineNum">      42 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ReflowError(DrawTarget* aDrawTarget,</span>
<span class="lineNum">      43 </span>            :                                     ReflowOutput&amp; aDesiredSize)
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span>            :   // clear all other flags and record that there is an error with this frame
<span class="lineNum">      46 </span><span class="lineCov">          1 :   mEmbellishData.flags = 0;</span>
<span class="lineNum">      47 </span><span class="lineCov">          1 :   mPresentationData.flags = NS_MATHML_ERROR;</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   ///////////////
<span class="lineNum">      50 </span>            :   // Set font
<span class="lineNum">      51 </span>            :   RefPtr&lt;nsFontMetrics&gt; fm =
<span class="lineNum">      52 </span><span class="lineCov">          1 :     nsLayoutUtils::GetInflatedFontMetricsForFrame(this);</span>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :   // bounding metrics
<span class="lineNum">      55 </span><span class="lineCov">          1 :   nsAutoString errorMsg; errorMsg.AssignLiteral(&quot;invalid-markup&quot;);</span>
<span class="lineNum">      56 </span>            :   mBoundingMetrics =
<span class="lineNum">      57 </span>            :     nsLayoutUtils::AppUnitBoundsOfString(errorMsg.get(), errorMsg.Length(),
<span class="lineNum">      58 </span><span class="lineCov">          1 :                                          *fm, aDrawTarget);</span>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   // reflow metrics
<span class="lineNum">      61 </span><span class="lineCov">          1 :   WritingMode wm = aDesiredSize.GetWritingMode();</span>
<span class="lineNum">      62 </span><span class="lineCov">          1 :   aDesiredSize.SetBlockStartAscent(fm-&gt;MaxAscent());</span>
<span class="lineNum">      63 </span><span class="lineCov">          1 :   nscoord descent = fm-&gt;MaxDescent();</span>
<span class="lineNum">      64 </span><span class="lineCov">          1 :   aDesiredSize.BSize(wm) = aDesiredSize.BlockStartAscent() + descent;</span>
<span class="lineNum">      65 </span><span class="lineCov">          1 :   aDesiredSize.ISize(wm) = mBoundingMetrics.width;</span>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :   // Also return our bounding metrics
<span class="lineNum">      68 </span><span class="lineCov">          1 :   aDesiredSize.mBoundingMetrics = mBoundingMetrics;</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineCov">          1 :   return NS_OK;</span>
<a name="71"><span class="lineNum">      71 </span>            : }</a>
<span class="lineNum">      72 </span>            : 
<a name="73"><span class="lineNum">      73 </span><span class="lineCov">          1 : class nsDisplayMathMLError : public nsDisplayItem {</span></a>
<span class="lineNum">      74 </span>            : public:
<span class="lineNum">      75 </span><span class="lineCov">          1 :   nsDisplayMathMLError(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)</span>
<span class="lineNum">      76 </span><span class="lineCov">          1 :     : nsDisplayItem(aBuilder, aFrame) {</span>
<span class="lineNum">      77 </span>            :     MOZ_COUNT_CTOR(nsDisplayMathMLError);
<span class="lineNum">      78 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">      79 </span>            : #ifdef NS_BUILD_REFCNT_LOGGING
<span class="lineNum">      80 </span>            :   virtual ~nsDisplayMathMLError() {
<span class="lineNum">      81 </span>            :     MOZ_COUNT_DTOR(nsDisplayMathMLError);
<span class="lineNum">      82 </span>            :   }
<span class="lineNum">      83 </span>            : #endif
<span class="lineNum">      84 </span>            : 
<a name="85"><span class="lineNum">      85 </span>            :   virtual void Paint(nsDisplayListBuilder* aBuilder,</a>
<span class="lineNum">      86 </span>            :                      nsRenderingContext* aCtx) override;
<span class="lineNum">      87 </span><span class="lineCov">          1 :   NS_DISPLAY_DECL_NAME(&quot;MathMLError&quot;, TYPE_MATHML_ERROR)</span>
<a name="88"><span class="lineNum">      88 </span>            : };</a>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineCov">          1 : void nsDisplayMathMLError::Paint(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">      91 </span>            :                                  nsRenderingContext* aCtx)
<span class="lineNum">      92 </span>            : {
<span class="lineNum">      93 </span>            :   // Set color and font ...
<span class="lineNum">      94 </span>            :   RefPtr&lt;nsFontMetrics&gt; fm =
<span class="lineNum">      95 </span><span class="lineCov">          1 :     nsLayoutUtils::GetFontMetricsForFrame(mFrame, 1.0f);</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span><span class="lineCov">          1 :   nsPoint pt = ToReferenceFrame();</span>
<span class="lineNum">      98 </span><span class="lineCov">          1 :   int32_t appUnitsPerDevPixel = mFrame-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">      99 </span><span class="lineCov">          1 :   DrawTarget* drawTarget = aCtx-&gt;GetDrawTarget();</span>
<span class="lineNum">     100 </span><span class="lineCov">          1 :   Rect rect = NSRectToSnappedRect(nsRect(pt, mFrame-&gt;GetSize()),</span>
<span class="lineNum">     101 </span>            :                                   appUnitsPerDevPixel,
<span class="lineNum">     102 </span><span class="lineCov">          1 :                                   *drawTarget);</span>
<span class="lineNum">     103 </span><span class="lineCov">          1 :   ColorPattern red(ToDeviceColor(Color(1.f, 0.f, 0.f, 1.f)));</span>
<span class="lineNum">     104 </span><span class="lineCov">          1 :   drawTarget-&gt;FillRect(rect, red);</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineCov">          1 :   aCtx-&gt;ThebesContext()-&gt;SetColor(Color(1.f, 1.f, 1.f));</span>
<span class="lineNum">     107 </span><span class="lineCov">          1 :   nscoord ascent = fm-&gt;MaxAscent();</span>
<span class="lineNum">     108 </span>            :   NS_NAMED_LITERAL_STRING(errorMsg, &quot;invalid-markup&quot;);
<span class="lineNum">     109 </span>            :   nsLayoutUtils::DrawUniDirString(errorMsg.get(), uint32_t(errorMsg.Length()),
<span class="lineNum">     110 </span><span class="lineCov">          1 :                                   nsPoint(pt.x, pt.y + ascent), *fm, *aCtx);</span>
<span class="lineNum">     111 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : /* /////////////
<span class="lineNum">     114 </span>            :  * nsIMathMLFrame - support methods for stretchy elements
<span class="lineNum">     115 </span>            :  * =============================================================================
<span class="lineNum">     116 </span>            :  */
<a name="117"><span class="lineNum">     117 </span>            : </a>
<span class="lineNum">     118 </span>            : static bool
<span class="lineNum">     119 </span><span class="lineCov">          1 : IsForeignChild(const nsIFrame* aFrame)</span>
<span class="lineNum">     120 </span>            : {
<span class="lineNum">     121 </span>            :   // This counts nsMathMLmathBlockFrame as a foreign child, because it
<span class="lineNum">     122 </span>            :   // uses block reflow
<span class="lineNum">     123 </span><span class="lineCov">          1 :   return !(aFrame-&gt;IsFrameOfType(nsIFrame::eMathML)) ||</span>
<span class="lineNum">     124 </span><span class="lineCov">          1 :     aFrame-&gt;GetType() == nsGkAtoms::blockFrame;</span>
<span class="lineNum">     125 </span>            : }
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : NS_DECLARE_FRAME_PROPERTY_DELETABLE(HTMLReflowOutputProperty,
<span class="lineNum">     128 </span>            :                                     ReflowOutput)
<a name="129"><span class="lineNum">     129 </span>            : </a>
<span class="lineNum">     130 </span>            : /* static */ void
<span class="lineNum">     131 </span><span class="lineCov">          1 : nsMathMLContainerFrame::SaveReflowAndBoundingMetricsFor(nsIFrame*                  aFrame,</span>
<span class="lineNum">     132 </span>            :                                                         const ReflowOutput&amp; aReflowOutput,
<span class="lineNum">     133 </span>            :                                                         const nsBoundingMetrics&amp;   aBoundingMetrics)
<span class="lineNum">     134 </span>            : {
<span class="lineNum">     135 </span><span class="lineCov">          1 :   ReflowOutput* reflowOutput = new ReflowOutput(aReflowOutput);</span>
<span class="lineNum">     136 </span><span class="lineCov">          1 :   reflowOutput-&gt;mBoundingMetrics = aBoundingMetrics;</span>
<span class="lineNum">     137 </span><span class="lineCov">          1 :   aFrame-&gt;Properties().Set(HTMLReflowOutputProperty(), reflowOutput);</span>
<span class="lineNum">     138 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     139 </span>            : 
<a name="140"><span class="lineNum">     140 </span>            : // helper method to facilitate getting the reflow and bounding metrics</a>
<span class="lineNum">     141 </span>            : /* static */ void
<span class="lineNum">     142 </span><span class="lineCov">          1 : nsMathMLContainerFrame::GetReflowAndBoundingMetricsFor(nsIFrame*            aFrame,</span>
<span class="lineNum">     143 </span>            :                                                        ReflowOutput&amp; aReflowOutput,
<span class="lineNum">     144 </span>            :                                                        nsBoundingMetrics&amp;   aBoundingMetrics,
<span class="lineNum">     145 </span>            :                                                        eMathMLFrameType*    aMathMLFrameType)
<span class="lineNum">     146 </span>            : {
<span class="lineNum">     147 </span>            :   NS_PRECONDITION(aFrame, &quot;null arg&quot;);
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   ReflowOutput* reflowOutput =
<span class="lineNum">     150 </span><span class="lineCov">          1 :     aFrame-&gt;Properties().Get(HTMLReflowOutputProperty());</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   // IMPORTANT: This function is only meant to be called in Place() methods
<span class="lineNum">     153 </span>            :   // where it is assumed that SaveReflowAndBoundingMetricsFor has recorded the
<span class="lineNum">     154 </span>            :   // information.
<span class="lineNum">     155 </span>            :   NS_ASSERTION(reflowOutput, &quot;Didn't SaveReflowAndBoundingMetricsFor frame!&quot;);
<span class="lineNum">     156 </span><span class="lineCov">          1 :   if (reflowOutput) {</span>
<span class="lineNum">     157 </span><span class="lineCov">          1 :     aReflowOutput = *reflowOutput;</span>
<span class="lineNum">     158 </span><span class="lineCov">          1 :     aBoundingMetrics = reflowOutput-&gt;mBoundingMetrics;</span>
<span class="lineNum">     159 </span>            :   }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">          1 :   if (aMathMLFrameType) {</span>
<span class="lineNum">     162 </span><span class="lineCov">          1 :     if (!IsForeignChild(aFrame)) {</span>
<span class="lineNum">     163 </span><span class="lineCov">          1 :       nsIMathMLFrame* mathMLFrame = do_QueryFrame(aFrame);</span>
<span class="lineNum">     164 </span><span class="lineCov">          1 :       if (mathMLFrame) {</span>
<span class="lineNum">     165 </span><span class="lineCov">          1 :         *aMathMLFrameType = mathMLFrame-&gt;GetMathMLFrameType();</span>
<span class="lineNum">     166 </span><span class="lineCov">          1 :         return;</span>
<span class="lineNum">     167 </span>            :       }
<span class="lineNum">     168 </span>            :     }
<span class="lineNum">     169 </span><span class="lineCov">          1 :     *aMathMLFrameType = eMathMLFrameType_UNKNOWN;</span>
<span class="lineNum">     170 </span>            :   }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : }
<a name="173"><span class="lineNum">     173 </span>            : </a>
<span class="lineNum">     174 </span>            : void
<span class="lineNum">     175 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ClearSavedChildMetrics()</span>
<span class="lineNum">     176 </span>            : {
<span class="lineNum">     177 </span><span class="lineCov">          1 :   nsIFrame* childFrame = mFrames.FirstChild();</span>
<span class="lineNum">     178 </span><span class="lineCov">          1 :   FramePropertyTable* props = PresContext()-&gt;PropertyTable();</span>
<span class="lineNum">     179 </span><span class="lineCov">          1 :   while (childFrame) {</span>
<span class="lineNum">     180 </span><span class="lineCov">          1 :     props-&gt;Delete(childFrame, HTMLReflowOutputProperty());</span>
<span class="lineNum">     181 </span><span class="lineCov">          1 :     childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">     182 </span>            :   }
<span class="lineNum">     183 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : // helper to get the preferred size that a container frame should use to fire
<a name="186"><span class="lineNum">     186 </span>            : // the stretch on its stretchy child frames.</a>
<span class="lineNum">     187 </span>            : void
<span class="lineNum">     188 </span><span class="lineCov">          1 : nsMathMLContainerFrame::GetPreferredStretchSize(DrawTarget*          aDrawTarget,</span>
<span class="lineNum">     189 </span>            :                                                 uint32_t             aOptions,
<span class="lineNum">     190 </span>            :                                                 nsStretchDirection   aStretchDirection,
<span class="lineNum">     191 </span>            :                                                 nsBoundingMetrics&amp;   aPreferredStretchSize)
<span class="lineNum">     192 </span>            : {
<span class="lineNum">     193 </span><span class="lineCov">          1 :   if (aOptions &amp; STRETCH_CONSIDER_ACTUAL_SIZE) {</span>
<span class="lineNum">     194 </span>            :     // when our actual size is ok, just use it
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     aPreferredStretchSize = mBoundingMetrics;</span>
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span><span class="lineCov">          1 :   else if (aOptions &amp; STRETCH_CONSIDER_EMBELLISHMENTS) {</span>
<span class="lineNum">     198 </span>            :     // compute our up-to-date size using Place()
<span class="lineNum">     199 </span><span class="lineCov">          1 :     ReflowOutput reflowOutput(GetWritingMode());</span>
<span class="lineNum">     200 </span><span class="lineCov">          1 :     Place(aDrawTarget, false, reflowOutput);</span>
<span class="lineNum">     201 </span><span class="lineCov">          1 :     aPreferredStretchSize = reflowOutput.mBoundingMetrics;</span>
<span class="lineNum">     202 </span>            :   }
<span class="lineNum">     203 </span>            :   else {
<span class="lineNum">     204 </span>            :     // compute a size that includes embellishments iff the container stretches
<span class="lineNum">     205 </span>            :     // in the same direction as the embellished operator.
<span class="lineNum">     206 </span>            :     bool stretchAll = aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL ?
<span class="lineNum">     207 </span><span class="lineCov">          1 :                       NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) :</span>
<span class="lineNum">     208 </span><span class="lineCov">          1 :                       NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);</span>
<span class="lineNum">     209 </span>            :     NS_ASSERTION(aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL ||
<span class="lineNum">     210 </span>            :                  aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL,
<span class="lineNum">     211 </span>            :                  &quot;You must specify a direction in which to stretch&quot;);
<span class="lineNum">     212 </span>            :     NS_ASSERTION(NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) ||
<span class="lineNum">     213 </span>            :                  stretchAll,
<span class="lineNum">     214 </span>            :                  &quot;invalid call to GetPreferredStretchSize&quot;);
<span class="lineNum">     215 </span><span class="lineCov">          1 :     bool firstTime = true;</span>
<span class="lineNum">     216 </span><span class="lineCov">          1 :     nsBoundingMetrics bm, bmChild;</span>
<span class="lineNum">     217 </span>            :     nsIFrame* childFrame =
<span class="lineNum">     218 </span><span class="lineCov">          1 :       stretchAll ? PrincipalChildList().FirstChild() : mPresentationData.baseFrame;</span>
<span class="lineNum">     219 </span><span class="lineCov">          1 :     while (childFrame) {</span>
<span class="lineNum">     220 </span>            :       // initializations in case this child happens not to be a MathML frame
<span class="lineNum">     221 </span><span class="lineCov">          1 :       nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);</span>
<span class="lineNum">     222 </span><span class="lineCov">          1 :       if (mathMLFrame) {</span>
<span class="lineNum">     223 </span><span class="lineCov">          1 :         nsEmbellishData embellishData;</span>
<span class="lineNum">     224 </span>            :         nsPresentationData presentationData;
<span class="lineNum">     225 </span><span class="lineCov">          1 :         mathMLFrame-&gt;GetEmbellishData(embellishData);</span>
<span class="lineNum">     226 </span><span class="lineCov">          1 :         mathMLFrame-&gt;GetPresentationData(presentationData);</span>
<span class="lineNum">     227 </span><span class="lineCov">          1 :         if (NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags) &amp;&amp;</span>
<span class="lineNum">     228 </span><span class="lineCov">          1 :             embellishData.direction == aStretchDirection &amp;&amp;</span>
<span class="lineNum">     229 </span>            :             presentationData.baseFrame) {
<span class="lineNum">     230 </span>            :           // embellishements are not included, only consider the inner first child itself
<span class="lineNum">     231 </span>            :           // XXXkt Does that mean the core descendent frame should be used
<span class="lineNum">     232 </span>            :           // instead of the base child?
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :           nsIMathMLFrame* mathMLchildFrame = do_QueryFrame(presentationData.baseFrame);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :           if (mathMLchildFrame) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :             mathMLFrame = mathMLchildFrame;</span>
<span class="lineNum">     236 </span>            :           }
<span class="lineNum">     237 </span>            :         }
<span class="lineNum">     238 </span><span class="lineCov">          1 :         mathMLFrame-&gt;GetBoundingMetrics(bmChild);</span>
<span class="lineNum">     239 </span>            :       }
<span class="lineNum">     240 </span>            :       else {
<span class="lineNum">     241 </span><span class="lineCov">          1 :         ReflowOutput unused(GetWritingMode());</span>
<span class="lineNum">     242 </span><span class="lineCov">          1 :         GetReflowAndBoundingMetricsFor(childFrame, unused, bmChild);</span>
<span class="lineNum">     243 </span>            :       }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineCov">          1 :       if (firstTime) {</span>
<span class="lineNum">     246 </span><span class="lineCov">          1 :         firstTime = false;</span>
<span class="lineNum">     247 </span><span class="lineCov">          1 :         bm = bmChild;</span>
<span class="lineNum">     248 </span><span class="lineCov">          1 :         if (!stretchAll) {</span>
<span class="lineNum">     249 </span>            :           // we may get here for cases such as &lt;msup&gt;&lt;mo&gt;...&lt;/mo&gt; ... &lt;/msup&gt;,
<span class="lineNum">     250 </span>            :           // or &lt;maction&gt;...&lt;mo&gt;...&lt;/mo&gt;&lt;/maction&gt;.
<span class="lineNum">     251 </span>            :           break;
<span class="lineNum">     252 </span>            :         }
<span class="lineNum">     253 </span>            :       }
<span class="lineNum">     254 </span>            :       else {
<span class="lineNum">     255 </span><span class="lineCov">          1 :         if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {</span>
<span class="lineNum">     256 </span>            :           // if we get here, it means this is container that will stack its children
<span class="lineNum">     257 </span>            :           // vertically and fire an horizontal stretch on each them. This is the case
<span class="lineNum">     258 </span>            :           // for \munder, \mover, \munderover. We just sum-up the size vertically.
<span class="lineNum">     259 </span><span class="lineCov">          1 :           bm.descent += bmChild.ascent + bmChild.descent;</span>
<span class="lineNum">     260 </span>            :           // Sometimes non-spacing marks (when width is zero) are positioned
<span class="lineNum">     261 </span>            :           // to the left of the origin, but it is the distance between left
<span class="lineNum">     262 </span>            :           // and right bearing that is important rather than the offsets from
<span class="lineNum">     263 </span>            :           // the origin.
<span class="lineNum">     264 </span><span class="lineCov">          1 :           if (bmChild.width == 0) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :             bmChild.rightBearing -= bmChild.leftBearing;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :             bmChild.leftBearing = 0;</span>
<span class="lineNum">     267 </span>            :           }
<span class="lineNum">     268 </span><span class="lineCov">          1 :           if (bm.leftBearing &gt; bmChild.leftBearing)</span>
<span class="lineNum">     269 </span><span class="lineCov">          1 :             bm.leftBearing = bmChild.leftBearing;</span>
<span class="lineNum">     270 </span><span class="lineCov">          1 :           if (bm.rightBearing &lt; bmChild.rightBearing)</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :             bm.rightBearing = bmChild.rightBearing;</span>
<span class="lineNum">     272 </span>            :         }
<span class="lineNum">     273 </span><span class="lineCov">          1 :         else if (aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) {</span>
<span class="lineNum">     274 </span>            :           // just sum-up the sizes horizontally.
<span class="lineNum">     275 </span><span class="lineCov">          1 :           bm += bmChild;</span>
<span class="lineNum">     276 </span>            :         }
<span class="lineNum">     277 </span>            :         else {
<span class="lineNum">     278 </span>            :           NS_ERROR(&quot;unexpected case in GetPreferredStretchSize&quot;);
<span class="lineNum">     279 </span>            :           break;
<span class="lineNum">     280 </span>            :         }
<span class="lineNum">     281 </span>            :       }
<span class="lineNum">     282 </span><span class="lineCov">          1 :       childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">     283 </span>            :     }
<span class="lineNum">     284 </span><span class="lineCov">          1 :     aPreferredStretchSize = bm;</span>
<span class="lineNum">     285 </span>            :   }
<span class="lineNum">     286 </span><span class="lineCov">          1 : }</span>
<a name="287"><span class="lineNum">     287 </span>            : </a>
<span class="lineNum">     288 </span>            : NS_IMETHODIMP
<span class="lineNum">     289 </span><span class="lineCov">          1 : nsMathMLContainerFrame::Stretch(DrawTarget*          aDrawTarget,</span>
<span class="lineNum">     290 </span>            :                                 nsStretchDirection   aStretchDirection,
<span class="lineNum">     291 </span>            :                                 nsBoundingMetrics&amp;   aContainerSize,
<span class="lineNum">     292 </span>            :                                 ReflowOutput&amp; aDesiredStretchSize)
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span><span class="lineCov">          1 :   if (NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags)) {</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineCov">          1 :     if (NS_MATHML_STRETCH_WAS_DONE(mPresentationData.flags)) {</span>
<span class="lineNum">     297 </span>            :       NS_WARNING(&quot;it is wrong to fire stretch more than once on a frame&quot;);
<span class="lineNum">     298 </span>            :       return NS_OK;
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span><span class="lineCov">          1 :     mPresentationData.flags |= NS_MATHML_STRETCH_DONE;</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineCov">          1 :     if (NS_MATHML_HAS_ERROR(mPresentationData.flags)) {</span>
<span class="lineNum">     303 </span>            :       NS_WARNING(&quot;it is wrong to fire stretch on a erroneous frame&quot;);
<span class="lineNum">     304 </span>            :       return NS_OK;
<span class="lineNum">     305 </span>            :     }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :     // Pass the stretch to the base child ...
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineCov">          1 :     nsIFrame* baseFrame = mPresentationData.baseFrame;</span>
<span class="lineNum">     310 </span><span class="lineCov">          1 :     if (baseFrame) {</span>
<span class="lineNum">     311 </span><span class="lineCov">          1 :       nsIMathMLFrame* mathMLFrame = do_QueryFrame(baseFrame);</span>
<span class="lineNum">     312 </span>            :       NS_ASSERTION(mathMLFrame, &quot;Something is wrong somewhere&quot;);
<span class="lineNum">     313 </span><span class="lineCov">          1 :       if (mathMLFrame) {</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :         // And the trick is that the child's rect.x is still holding the descent,
<span class="lineNum">     316 </span>            :         // and rect.y is still holding the ascent ...
<span class="lineNum">     317 </span><span class="lineCov">          1 :         ReflowOutput childSize(aDesiredStretchSize);</span>
<span class="lineNum">     318 </span><span class="lineCov">          1 :         GetReflowAndBoundingMetricsFor(baseFrame, childSize, childSize.mBoundingMetrics);</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :         // See if we should downsize and confine the stretch to us...
<span class="lineNum">     321 </span>            :         // XXX there may be other cases where we can downsize the stretch,
<span class="lineNum">     322 </span>            :         // e.g., the first &amp;Sum; might appear big in the following situation
<span class="lineNum">     323 </span>            :         // &lt;math xmlns='http://www.w3.org/1998/Math/MathML'&gt;
<span class="lineNum">     324 </span>            :         //   &lt;mstyle&gt;
<span class="lineNum">     325 </span>            :         //     &lt;msub&gt;
<span class="lineNum">     326 </span>            :         //        &lt;msub&gt;&lt;mo&gt;&amp;Sum;&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mfrac&gt;&lt;/msub&gt;
<span class="lineNum">     327 </span>            :         //        &lt;msub&gt;&lt;mo&gt;&amp;Sum;&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mfrac&gt;&lt;/msub&gt;
<span class="lineNum">     328 </span>            :         //      &lt;/msub&gt;
<span class="lineNum">     329 </span>            :         //   &lt;/mstyle&gt;
<span class="lineNum">     330 </span>            :         // &lt;/math&gt;
<span class="lineNum">     331 </span><span class="lineCov">          1 :         nsBoundingMetrics containerSize = aContainerSize;</span>
<span class="lineNum">     332 </span><span class="lineCov">          1 :         if (aStretchDirection != mEmbellishData.direction &amp;&amp;</span>
<span class="lineNum">     333 </span>            :             mEmbellishData.direction != NS_STRETCH_DIRECTION_UNSUPPORTED) {
<span class="lineNum">     334 </span>            :           NS_ASSERTION(mEmbellishData.direction != NS_STRETCH_DIRECTION_DEFAULT,
<span class="lineNum">     335 </span>            :                        &quot;Stretches may have a default direction, operators can not.&quot;);
<span class="lineNum">     336 </span><span class="lineCov">          1 :           if (mEmbellishData.direction == NS_STRETCH_DIRECTION_VERTICAL ?</span>
<span class="lineNum">     337 </span><span class="lineCov">          1 :               NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) :</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :               NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags)) {</span>
<span class="lineNum">     339 </span>            :             GetPreferredStretchSize(aDrawTarget, 0,
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                                     mEmbellishData.direction, containerSize);</span>
<span class="lineNum">     341 </span>            :             // Stop further recalculations
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :             aStretchDirection = mEmbellishData.direction;</span>
<span class="lineNum">     343 </span>            :           } else {
<span class="lineNum">     344 </span>            :             // We aren't going to stretch the child, so just use the child metrics.
<span class="lineNum">     345 </span><span class="lineCov">          1 :             containerSize = childSize.mBoundingMetrics;</span>
<span class="lineNum">     346 </span>            :           }
<span class="lineNum">     347 </span>            :         }
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :         // do the stretching...
<span class="lineNum">     350 </span>            :         mathMLFrame-&gt;Stretch(aDrawTarget,
<span class="lineNum">     351 </span><span class="lineCov">          1 :                              aStretchDirection, containerSize, childSize);</span>
<span class="lineNum">     352 </span>            :         // store the updated metrics
<span class="lineNum">     353 </span>            :         SaveReflowAndBoundingMetricsFor(baseFrame, childSize,
<span class="lineNum">     354 </span><span class="lineCov">          1 :                                         childSize.mBoundingMetrics);</span>
<span class="lineNum">     355 </span>            :         
<span class="lineNum">     356 </span>            :         // Remember the siblings which were _deferred_.
<span class="lineNum">     357 </span>            :         // Now that this embellished child may have changed, we need to
<span class="lineNum">     358 </span>            :         // fire the stretch on its siblings using our updated size
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineCov">          1 :         if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ||</span>
<span class="lineNum">     361 </span>            :             NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags)) {
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :           nsStretchDirection stretchDir =
<span class="lineNum">     364 </span><span class="lineCov">          1 :             NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ?</span>
<span class="lineNum">     365 </span><span class="lineCov">          1 :               NS_STRETCH_DIRECTION_VERTICAL : NS_STRETCH_DIRECTION_HORIZONTAL;</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :           GetPreferredStretchSize(aDrawTarget, STRETCH_CONSIDER_EMBELLISHMENTS,
<span class="lineNum">     368 </span><span class="lineCov">          1 :                                   stretchDir, containerSize);</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineCov">          1 :           nsIFrame* childFrame = mFrames.FirstChild();</span>
<span class="lineNum">     371 </span><span class="lineCov">          1 :           while (childFrame) {</span>
<span class="lineNum">     372 </span><span class="lineCov">          1 :             if (childFrame != mPresentationData.baseFrame) {</span>
<span class="lineNum">     373 </span><span class="lineCov">          1 :               mathMLFrame = do_QueryFrame(childFrame);</span>
<span class="lineNum">     374 </span><span class="lineCov">          1 :               if (mathMLFrame) {</span>
<span class="lineNum">     375 </span>            :                 // retrieve the metrics that was stored at the previous pass
<span class="lineNum">     376 </span>            :                 GetReflowAndBoundingMetricsFor(childFrame, 
<span class="lineNum">     377 </span><span class="lineCov">          1 :                   childSize, childSize.mBoundingMetrics);</span>
<span class="lineNum">     378 </span>            :                 // do the stretching...
<span class="lineNum">     379 </span>            :                 mathMLFrame-&gt;Stretch(aDrawTarget, stretchDir,
<span class="lineNum">     380 </span><span class="lineCov">          1 :                                      containerSize, childSize);</span>
<span class="lineNum">     381 </span>            :                 // store the updated metrics
<span class="lineNum">     382 </span>            :                 SaveReflowAndBoundingMetricsFor(childFrame, childSize,
<span class="lineNum">     383 </span><span class="lineCov">          1 :                                                 childSize.mBoundingMetrics);</span>
<span class="lineNum">     384 </span>            :               }
<span class="lineNum">     385 </span>            :             }
<span class="lineNum">     386 </span><span class="lineCov">          1 :             childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">     387 </span>            :           }
<span class="lineNum">     388 </span>            :         }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :         // re-position all our children
<span class="lineNum">     391 </span><span class="lineCov">          1 :         nsresult rv = Place(aDrawTarget, true, aDesiredStretchSize);</span>
<span class="lineNum">     392 </span><span class="lineCov">          1 :         if (NS_MATHML_HAS_ERROR(mPresentationData.flags) || NS_FAILED(rv)) {</span>
<span class="lineNum">     393 </span>            :           // Make sure the child frames get their DidReflow() calls.
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :           DidReflowChildren(mFrames.FirstChild());</span>
<span class="lineNum">     395 </span>            :         }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :         // If our parent is not embellished, it means we are the outermost embellished
<span class="lineNum">     398 </span>            :         // container and so we put the spacing, otherwise we don't include the spacing,
<span class="lineNum">     399 </span>            :         // the outermost embellished container will take care of it.
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">          1 :         nsEmbellishData parentData;</span>
<span class="lineNum">     402 </span><span class="lineCov">          1 :         GetEmbellishDataFrom(GetParent(), parentData);</span>
<span class="lineNum">     403 </span>            :         // ensure that we are the embellished child, not just a sibling
<span class="lineNum">     404 </span>            :         // (need to test coreFrame since &lt;mfrac&gt; resets other things)
<span class="lineNum">     405 </span><span class="lineCov">          1 :         if (parentData.coreFrame != mEmbellishData.coreFrame) {</span>
<span class="lineNum">     406 </span>            :           // (we fetch values from the core since they may use units that depend
<span class="lineNum">     407 </span>            :           // on style data, and style changes could have occurred in the core since
<span class="lineNum">     408 </span>            :           // our last visit there)
<span class="lineNum">     409 </span><span class="lineCov">          1 :           nsEmbellishData coreData;</span>
<span class="lineNum">     410 </span><span class="lineCov">          1 :           GetEmbellishDataFrom(mEmbellishData.coreFrame, coreData);</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            :           mBoundingMetrics.width +=
<span class="lineNum">     413 </span><span class="lineCov">          1 :             coreData.leadingSpace + coreData.trailingSpace;</span>
<span class="lineNum">     414 </span><span class="lineCov">          1 :           aDesiredStretchSize.Width() = mBoundingMetrics.width;</span>
<span class="lineNum">     415 </span><span class="lineCov">          1 :           aDesiredStretchSize.mBoundingMetrics.width = mBoundingMetrics.width;</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineCov">          1 :           nscoord dx = (StyleVisibility()-&gt;mDirection ?</span>
<span class="lineNum">     418 </span><span class="lineCov">          1 :                         coreData.trailingSpace : coreData.leadingSpace);</span>
<span class="lineNum">     419 </span><span class="lineCov">          1 :           if (dx != 0) {</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :             mBoundingMetrics.leftBearing += dx;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             mBoundingMetrics.rightBearing += dx;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :             aDesiredStretchSize.mBoundingMetrics.leftBearing += dx;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :             aDesiredStretchSize.mBoundingMetrics.rightBearing += dx;</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :             nsIFrame* childFrame = mFrames.FirstChild();</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             while (childFrame) {</span>
<span class="lineNum">     427 </span>            :               childFrame-&gt;SetPosition(childFrame-&gt;GetPosition()
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                                       + nsPoint(dx, 0));</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :               childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">     430 </span>            :             }
<span class="lineNum">     431 </span>            :           }
<span class="lineNum">     432 </span>            :         }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :         // Finished with these:
<span class="lineNum">     435 </span><span class="lineCov">          1 :         ClearSavedChildMetrics();</span>
<span class="lineNum">     436 </span>            :         // Set our overflow area
<span class="lineNum">     437 </span><span class="lineCov">          1 :         GatherAndStoreOverflow(&amp;aDesiredStretchSize);</span>
<span class="lineNum">     438 </span>            :       }
<span class="lineNum">     439 </span>            :     }
<span class="lineNum">     440 </span>            :   }
<span class="lineNum">     441 </span>            :   return NS_OK;
<span class="lineNum">     442 </span>            : }
<a name="443"><span class="lineNum">     443 </span>            : </a>
<span class="lineNum">     444 </span>            : nsresult
<span class="lineNum">     445 </span><span class="lineCov">          1 : nsMathMLContainerFrame::FinalizeReflow(DrawTarget* aDrawTarget,</span>
<span class="lineNum">     446 </span>            :                                        ReflowOutput&amp; aDesiredSize)
<span class="lineNum">     447 </span>            : {
<span class="lineNum">     448 </span>            :   // During reflow, we use rect.x and rect.y as placeholders for the child's ascent
<span class="lineNum">     449 </span>            :   // and descent in expectation of a stretch command. Hence we need to ensure that
<span class="lineNum">     450 </span>            :   // a stretch command will actually be fired later on, after exiting from our
<span class="lineNum">     451 </span>            :   // reflow. If the stretch is not fired, the rect.x, and rect.y will remain
<span class="lineNum">     452 </span>            :   // with inappropriate data causing children to be improperly positioned.
<span class="lineNum">     453 </span>            :   // This helper method checks to see if our parent will fire a stretch command
<span class="lineNum">     454 </span>            :   // targeted at us. If not, we go ahead and fire an involutive stretch on
<span class="lineNum">     455 </span>            :   // ourselves. This will clear all the rect.x and rect.y, and return our
<span class="lineNum">     456 </span>            :   // desired size.
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :   // First, complete the post-reflow hook.
<span class="lineNum">     460 </span>            :   // We use the information in our children rectangles to position them.
<span class="lineNum">     461 </span>            :   // If placeOrigin==false, then Place() will not touch rect.x, and rect.y.
<span class="lineNum">     462 </span>            :   // They will still be holding the ascent and descent for each child.
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   // The first clause caters for any non-embellished container.
<span class="lineNum">     465 </span>            :   // The second clause is for a container which won't fire stretch even though it is
<span class="lineNum">     466 </span>            :   // embellished, e.g., as in &lt;mfrac&gt;&lt;mo&gt;...&lt;/mo&gt; ... &lt;/mfrac&gt;, the test is convoluted
<span class="lineNum">     467 </span>            :   // because it excludes the particular case of the core &lt;mo&gt;...&lt;/mo&gt; itself.
<span class="lineNum">     468 </span>            :   // (&lt;mo&gt; needs to fire stretch on its MathMLChar in any case to initialize it)
<span class="lineNum">     469 </span><span class="lineCov">          1 :   bool placeOrigin = !NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) ||</span>
<span class="lineNum">     470 </span><span class="lineCov">          1 :                        (mEmbellishData.coreFrame != this &amp;&amp; !mPresentationData.baseFrame &amp;&amp;</span>
<span class="lineNum">     471 </span><span class="lineCov">          1 :                         mEmbellishData.direction == NS_STRETCH_DIRECTION_UNSUPPORTED);</span>
<span class="lineNum">     472 </span><span class="lineCov">          1 :   nsresult rv = Place(aDrawTarget, placeOrigin, aDesiredSize);</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :   // Place() will call FinishReflowChild() when placeOrigin is true but if
<span class="lineNum">     475 </span>            :   // it returns before reaching FinishReflowChild() due to errors we need
<span class="lineNum">     476 </span>            :   // to fulfill the reflow protocol by calling DidReflow for the child frames
<span class="lineNum">     477 </span>            :   // that still needs it here (or we may crash - bug 366012).
<span class="lineNum">     478 </span>            :   // If placeOrigin is false we should reach Place() with aPlaceOrigin == true
<span class="lineNum">     479 </span>            :   // through Stretch() eventually.
<span class="lineNum">     480 </span><span class="lineCov">          1 :   if (NS_MATHML_HAS_ERROR(mPresentationData.flags) || NS_FAILED(rv)) {</span>
<span class="lineNum">     481 </span><span class="lineCov">          1 :     GatherAndStoreOverflow(&amp;aDesiredSize);</span>
<span class="lineNum">     482 </span><span class="lineCov">          1 :     DidReflowChildren(PrincipalChildList().FirstChild());</span>
<span class="lineNum">     483 </span><span class="lineCov">          1 :     return rv;</span>
<span class="lineNum">     484 </span>            :   }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">          1 :   bool parentWillFireStretch = false;</span>
<span class="lineNum">     487 </span><span class="lineCov">          1 :   if (!placeOrigin) {</span>
<span class="lineNum">     488 </span>            :     // This means the rect.x and rect.y of our children were not set!!
<span class="lineNum">     489 </span>            :     // Don't go without checking to see if our parent will later fire a Stretch() command
<span class="lineNum">     490 </span>            :     // targeted at us. The Stretch() will cause the rect.x and rect.y to clear...
<span class="lineNum">     491 </span><span class="lineCov">          1 :     nsIMathMLFrame* mathMLFrame = do_QueryFrame(GetParent());</span>
<span class="lineNum">     492 </span><span class="lineCov">          1 :     if (mathMLFrame) {</span>
<span class="lineNum">     493 </span><span class="lineCov">          1 :       nsEmbellishData embellishData;</span>
<span class="lineNum">     494 </span>            :       nsPresentationData presentationData;
<span class="lineNum">     495 </span><span class="lineCov">          1 :       mathMLFrame-&gt;GetEmbellishData(embellishData);</span>
<span class="lineNum">     496 </span><span class="lineCov">          1 :       mathMLFrame-&gt;GetPresentationData(presentationData);</span>
<span class="lineNum">     497 </span><span class="lineCov">          1 :       if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(presentationData.flags) ||</span>
<span class="lineNum">     498 </span><span class="lineCov">          1 :           NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(presentationData.flags) ||</span>
<span class="lineNum">     499 </span><span class="lineCov">          1 :           (NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags)</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :             &amp;&amp; presentationData.baseFrame == this))</span>
<span class="lineNum">     501 </span>            :       {
<span class="lineNum">     502 </span><span class="lineCov">          1 :         parentWillFireStretch = true;</span>
<span class="lineNum">     503 </span>            :       }
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span><span class="lineCov">          1 :     if (!parentWillFireStretch) {</span>
<span class="lineNum">     506 </span>            :       // There is nobody who will fire the stretch for us, we do it ourselves!
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :       bool stretchAll =
<span class="lineNum">     509 </span>            :         /* NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) || */
<span class="lineNum">     510 </span><span class="lineCov">          1 :         NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :       nsStretchDirection stretchDir;
<span class="lineNum">     513 </span><span class="lineCov">          1 :       if (mEmbellishData.coreFrame == this || /* case of a bare &lt;mo&gt;...&lt;/mo&gt; itself */</span>
<span class="lineNum">     514 </span><span class="lineCov">          1 :           (mEmbellishData.direction == NS_STRETCH_DIRECTION_HORIZONTAL &amp;&amp;</span>
<span class="lineNum">     515 </span><span class="lineCov">          1 :            stretchAll) || /* or &lt;mover&gt;&lt;mo&gt;...&lt;/mo&gt;...&lt;/mover&gt;, or friends */</span>
<span class="lineNum">     516 </span>            :           mEmbellishData.direction == NS_STRETCH_DIRECTION_UNSUPPORTED) { /* Doesn't stretch */
<span class="lineNum">     517 </span><span class="lineCov">          1 :         stretchDir = mEmbellishData.direction;</span>
<span class="lineNum">     518 </span>            :       } else {
<span class="lineNum">     519 </span>            :         // Let the Stretch() call decide the direction.
<span class="lineNum">     520 </span>            :         stretchDir = NS_STRETCH_DIRECTION_DEFAULT;
<span class="lineNum">     521 </span>            :       }
<span class="lineNum">     522 </span>            :       // Use our current size as computed earlier by Place()
<span class="lineNum">     523 </span>            :       // The stretch call will detect if this is incorrect and recalculate the size.
<span class="lineNum">     524 </span><span class="lineCov">          1 :       nsBoundingMetrics defaultSize = aDesiredSize.mBoundingMetrics;</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">          1 :       Stretch(aDrawTarget, stretchDir, defaultSize, aDesiredSize);</span>
<span class="lineNum">     527 </span>            : #ifdef DEBUG
<span class="lineNum">     528 </span>            :       {
<span class="lineNum">     529 </span>            :         // The Place() call above didn't request FinishReflowChild(),
<span class="lineNum">     530 </span>            :         // so let's check that we eventually did through Stretch().
<span class="lineNum">     531 </span>            :         for (nsIFrame* childFrame : PrincipalChildList()) {
<span class="lineNum">     532 </span>            :           NS_ASSERTION(!(childFrame-&gt;GetStateBits() &amp; NS_FRAME_IN_REFLOW),
<span class="lineNum">     533 </span>            :                        &quot;DidReflow() was never called&quot;);
<span class="lineNum">     534 </span>            :         }
<span class="lineNum">     535 </span>            :       }
<span class="lineNum">     536 </span>            : #endif
<span class="lineNum">     537 </span>            :     }
<span class="lineNum">     538 </span>            :   }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   // Also return our bounding metrics
<span class="lineNum">     541 </span><span class="lineCov">          1 :   aDesiredSize.mBoundingMetrics = mBoundingMetrics;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   // see if we should fix the spacing
<span class="lineNum">     544 </span><span class="lineCov">          1 :   FixInterFrameSpacing(aDesiredSize);</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineCov">          1 :   if (!parentWillFireStretch) {</span>
<span class="lineNum">     547 </span>            :     // Not expecting a stretch.
<span class="lineNum">     548 </span>            :     // Finished with these:
<span class="lineNum">     549 </span><span class="lineCov">          1 :     ClearSavedChildMetrics();</span>
<span class="lineNum">     550 </span>            :     // Set our overflow area.
<span class="lineNum">     551 </span><span class="lineCov">          1 :     GatherAndStoreOverflow(&amp;aDesiredSize);</span>
<span class="lineNum">     552 </span>            :   }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   return NS_OK;
<span class="lineNum">     555 </span>            : }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            : /* /////////////
<span class="lineNum">     559 </span>            :  * nsIMathMLFrame - support methods for scripting elements (nested frames
<span class="lineNum">     560 </span>            :  * within msub, msup, msubsup, munder, mover, munderover, mmultiscripts,
<span class="lineNum">     561 </span>            :  * mfrac, mroot, mtable).
<span class="lineNum">     562 </span>            :  * =============================================================================
<span class="lineNum">     563 </span>            :  */
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : // helper to let the update of presentation data pass through
<a name="566"><span class="lineNum">     566 </span>            : // a subtree that may contain non-mathml container frames</a>
<span class="lineNum">     567 </span>            : /* static */ void
<span class="lineNum">     568 </span><span class="lineCov">          1 : nsMathMLContainerFrame::PropagatePresentationDataFor(nsIFrame*       aFrame,</span>
<span class="lineNum">     569 </span>            :                                                      uint32_t        aFlagsValues,
<span class="lineNum">     570 </span>            :                                                      uint32_t        aFlagsToUpdate)
<span class="lineNum">     571 </span>            : {
<span class="lineNum">     572 </span><span class="lineCov">          1 :   if (!aFrame || !aFlagsToUpdate)</span>
<span class="lineNum">     573 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     574 </span><span class="lineCov">          1 :   nsIMathMLFrame* mathMLFrame = do_QueryFrame(aFrame);</span>
<span class="lineNum">     575 </span><span class="lineCov">          1 :   if (mathMLFrame) {</span>
<span class="lineNum">     576 </span>            :     // update
<span class="lineNum">     577 </span>            :     mathMLFrame-&gt;UpdatePresentationData(aFlagsValues,
<span class="lineNum">     578 </span><span class="lineCov">          1 :                                         aFlagsToUpdate);</span>
<span class="lineNum">     579 </span>            :     // propagate using the base method to make sure that the control
<span class="lineNum">     580 </span>            :     // is passed on to MathML frames that may be overloading the method
<span class="lineNum">     581 </span>            :     mathMLFrame-&gt;UpdatePresentationDataFromChildAt(0, -1,
<span class="lineNum">     582 </span><span class="lineCov">          1 :       aFlagsValues, aFlagsToUpdate);</span>
<span class="lineNum">     583 </span>            :   }
<span class="lineNum">     584 </span>            :   else {
<span class="lineNum">     585 </span>            :     // propagate down the subtrees
<span class="lineNum">     586 </span><span class="lineCov">          1 :     for (nsIFrame* childFrame : aFrame-&gt;PrincipalChildList()) {</span>
<span class="lineNum">     587 </span>            :       PropagatePresentationDataFor(childFrame,
<span class="lineNum">     588 </span><span class="lineCov">          1 :         aFlagsValues, aFlagsToUpdate);</span>
<span class="lineNum">     589 </span>            :     }
<span class="lineNum">     590 </span>            :   }
<span class="lineNum">     591 </span>            : }
<a name="592"><span class="lineNum">     592 </span>            : </a>
<span class="lineNum">     593 </span>            : /* static */ void
<span class="lineNum">     594 </span><span class="lineCov">          1 : nsMathMLContainerFrame::PropagatePresentationDataFromChildAt(nsIFrame*       aParentFrame,</span>
<span class="lineNum">     595 </span>            :                                                              int32_t         aFirstChildIndex,
<span class="lineNum">     596 </span>            :                                                              int32_t         aLastChildIndex,
<span class="lineNum">     597 </span>            :                                                              uint32_t        aFlagsValues,
<span class="lineNum">     598 </span>            :                                                              uint32_t        aFlagsToUpdate)
<span class="lineNum">     599 </span>            : {
<span class="lineNum">     600 </span><span class="lineCov">          1 :   if (!aParentFrame || !aFlagsToUpdate)</span>
<span class="lineNum">     601 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     602 </span><span class="lineCov">          1 :   int32_t index = 0;</span>
<span class="lineNum">     603 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : aParentFrame-&gt;PrincipalChildList()) {</span>
<span class="lineNum">     604 </span><span class="lineCov">          1 :     if ((index &gt;= aFirstChildIndex) &amp;&amp;</span>
<span class="lineNum">     605 </span><span class="lineCov">          1 :         ((aLastChildIndex &lt;= 0) || ((aLastChildIndex &gt; 0) &amp;&amp;</span>
<span class="lineNum">     606 </span><span class="lineCov">          1 :          (index &lt;= aLastChildIndex)))) {</span>
<span class="lineNum">     607 </span>            :       PropagatePresentationDataFor(childFrame,
<span class="lineNum">     608 </span><span class="lineCov">          1 :         aFlagsValues, aFlagsToUpdate);</span>
<span class="lineNum">     609 </span>            :     }
<span class="lineNum">     610 </span><span class="lineCov">          1 :     index++;</span>
<span class="lineNum">     611 </span>            :   }
<span class="lineNum">     612 </span>            : }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            : /* //////////////////
<span class="lineNum">     615 </span>            :  * Frame construction
<span class="lineNum">     616 </span>            :  * =============================================================================
<span class="lineNum">     617 </span>            :  */
<span class="lineNum">     618 </span>            : 
<a name="619"><span class="lineNum">     619 </span>            : </a>
<span class="lineNum">     620 </span>            : void
<span class="lineNum">     621 </span><span class="lineCov">          1 : nsMathMLContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">     622 </span>            :                                          const nsRect&amp;           aDirtyRect,
<span class="lineNum">     623 </span>            :                                          const nsDisplayListSet&amp; aLists)
<span class="lineNum">     624 </span>            : {
<span class="lineNum">     625 </span>            :   // report an error if something wrong was found in this frame
<span class="lineNum">     626 </span><span class="lineCov">          1 :   if (NS_MATHML_HAS_ERROR(mPresentationData.flags)) {</span>
<span class="lineNum">     627 </span><span class="lineCov">          1 :     if (!IsVisibleForPainting(aBuilder))</span>
<span class="lineNum">     628 </span>            :       return;
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :     aLists.Content()-&gt;AppendNewToTop(
<span class="lineNum">     631 </span><span class="lineCov">          1 :       new (aBuilder) nsDisplayMathMLError(aBuilder, this));</span>
<span class="lineNum">     632 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     633 </span>            :   }
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineCov">          1 :   DisplayBorderBackgroundOutline(aBuilder, aLists);</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :   BuildDisplayListForNonBlockChildren(aBuilder, aDirtyRect, aLists,
<span class="lineNum">     638 </span><span class="lineCov">          1 :                                       DISPLAY_CHILD_INLINE);</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            : #if defined(DEBUG) &amp;&amp; defined(SHOW_BOUNDING_BOX)
<span class="lineNum">     641 </span>            :   // for visual debug
<span class="lineNum">     642 </span>            :   // ----------------
<span class="lineNum">     643 </span>            :   // if you want to see your bounding box, make sure to properly fill
<span class="lineNum">     644 </span>            :   // your mBoundingMetrics and mReference point, and set
<span class="lineNum">     645 </span>            :   // mPresentationData.flags |= NS_MATHML_SHOW_BOUNDING_METRICS
<span class="lineNum">     646 </span>            :   // in the Init() of your sub-class
<span class="lineNum">     647 </span>            :   DisplayBoundingMetrics(aBuilder, this, mReference, mBoundingMetrics, aLists);
<span class="lineNum">     648 </span>            : #endif
<span class="lineNum">     649 </span>            : }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : // Note that this method re-builds the automatic data in the children -- not
<span class="lineNum">     652 </span>            : // in aParentFrame itself (except for those particular operations that the
<a name="653"><span class="lineNum">     653 </span>            : // parent frame may do in its TransmitAutomaticData()).</a>
<span class="lineNum">     654 </span>            : /* static */ void
<span class="lineNum">     655 </span><span class="lineCov">          1 : nsMathMLContainerFrame::RebuildAutomaticDataForChildren(nsIFrame* aParentFrame)</span>
<span class="lineNum">     656 </span>            : {
<span class="lineNum">     657 </span>            :   // 1. As we descend the tree, make each child frame inherit data from
<span class="lineNum">     658 </span>            :   // the parent
<span class="lineNum">     659 </span>            :   // 2. As we ascend the tree, transmit any specific change that we want
<span class="lineNum">     660 </span>            :   // down the subtrees
<span class="lineNum">     661 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : aParentFrame-&gt;PrincipalChildList()) {</span>
<span class="lineNum">     662 </span><span class="lineCov">          1 :     nsIMathMLFrame* childMathMLFrame = do_QueryFrame(childFrame);</span>
<span class="lineNum">     663 </span><span class="lineCov">          1 :     if (childMathMLFrame) {</span>
<span class="lineNum">     664 </span><span class="lineCov">          1 :       childMathMLFrame-&gt;InheritAutomaticData(aParentFrame);</span>
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span><span class="lineCov">          1 :     RebuildAutomaticDataForChildren(childFrame);</span>
<span class="lineNum">     667 </span>            :   }
<span class="lineNum">     668 </span><span class="lineCov">          1 :   nsIMathMLFrame* mathMLFrame = do_QueryFrame(aParentFrame);</span>
<span class="lineNum">     669 </span><span class="lineCov">          1 :   if (mathMLFrame) {</span>
<span class="lineNum">     670 </span><span class="lineCov">          1 :     mathMLFrame-&gt;TransmitAutomaticData();</span>
<span class="lineNum">     671 </span>            :   }
<span class="lineNum">     672 </span><span class="lineCov">          1 : }</span>
<a name="673"><span class="lineNum">     673 </span>            : </a>
<span class="lineNum">     674 </span>            : /* static */ nsresult
<span class="lineNum">     675 </span><span class="lineNoCov">          0 : nsMathMLContainerFrame::ReLayoutChildren(nsIFrame* aParentFrame)</span>
<span class="lineNum">     676 </span>            : {
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   if (!aParentFrame)</span>
<span class="lineNum">     678 </span>            :     return NS_OK;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :   // walk-up to the first frame that is a MathML frame, stop if we reach &lt;math&gt;
<span class="lineNum">     681 </span>            :   nsIFrame* frame = aParentFrame;
<span class="lineNum">     682 </span>            :   while (1) {
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :      nsIFrame* parent = frame-&gt;GetParent();</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :      if (!parent || !parent-&gt;GetContent())</span>
<span class="lineNum">     685 </span>            :        break;
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :     // stop if it is a MathML frame
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     nsIMathMLFrame* mathMLFrame = do_QueryFrame(frame);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     if (mathMLFrame)</span>
<span class="lineNum">     690 </span>            :       break;
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     // stop if we reach the root &lt;math&gt; tag
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     nsIContent* content = frame-&gt;GetContent();</span>
<span class="lineNum">     694 </span>            :     NS_ASSERTION(content, &quot;dangling frame without a content node&quot;);
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     if (!content)</span>
<span class="lineNum">     696 </span>            :       break;
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     if (content-&gt;IsMathMLElement(nsGkAtoms::math))</span>
<span class="lineNum">     698 </span>            :       break;
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :     frame = parent;
<span class="lineNum">     701 </span>            :   }
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :   // re-sync the presentation data and embellishment data of our children
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   RebuildAutomaticDataForChildren(frame);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :   // Ask our parent frame to reflow us
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   nsIFrame* parent = frame-&gt;GetParent();</span>
<span class="lineNum">     708 </span>            :   NS_ASSERTION(parent, &quot;No parent to pass the reflow request up to&quot;);
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   if (!parent)</span>
<span class="lineNum">     710 </span>            :     return NS_OK;
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :   frame-&gt;PresContext()-&gt;PresShell()-&gt;
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     FrameNeedsReflow(frame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     716 </span>            : }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            : // There are precise rules governing children of a MathML frame,
<span class="lineNum">     719 </span>            : // and properties such as the scriptlevel depends on those rules.
<span class="lineNum">     720 </span>            : // Hence for things to work, callers must use Append/Insert/etc wisely.
<a name="721"><span class="lineNum">     721 </span>            : </a>
<span class="lineNum">     722 </span>            : nsresult
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : nsMathMLContainerFrame::ChildListChanged(int32_t aModType)</span>
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span>            :   // If this is an embellished frame we need to rebuild the
<span class="lineNum">     726 </span>            :   // embellished hierarchy by walking-up to the parent of the
<span class="lineNum">     727 </span>            :   // outermost embellished container.
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   nsIFrame* frame = this;</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   if (mEmbellishData.coreFrame) {</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     nsIFrame* parent = GetParent();</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     nsEmbellishData embellishData;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     for ( ; parent; frame = parent, parent = parent-&gt;GetParent()) {</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       GetEmbellishDataFrom(parent, embellishData);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :       if (embellishData.coreFrame != mEmbellishData.coreFrame)</span>
<span class="lineNum">     735 </span>            :         break;
<span class="lineNum">     736 </span>            :     }
<span class="lineNum">     737 </span>            :   }
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   return ReLayoutChildren(frame);</span>
<span class="lineNum">     739 </span>            : }
<a name="740"><span class="lineNum">     740 </span>            : </a>
<span class="lineNum">     741 </span>            : void
<span class="lineNum">     742 </span><span class="lineNoCov">          0 : nsMathMLContainerFrame::AppendFrames(ChildListID     aListID,</span>
<span class="lineNum">     743 </span>            :                                      nsFrameList&amp;    aFrameList)
<span class="lineNum">     744 </span>            : {
<span class="lineNum">     745 </span>            :   MOZ_ASSERT(aListID == kPrincipalList);
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   mFrames.AppendFrames(this, aFrameList);</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   ChildListChanged(nsIDOMMutationEvent::ADDITION);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 : }</span>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<span class="lineNum">     750 </span>            : void
<span class="lineNum">     751 </span><span class="lineNoCov">          0 : nsMathMLContainerFrame::InsertFrames(ChildListID     aListID,</span>
<span class="lineNum">     752 </span>            :                                      nsIFrame*       aPrevFrame,
<span class="lineNum">     753 </span>            :                                      nsFrameList&amp;    aFrameList)
<span class="lineNum">     754 </span>            : {
<span class="lineNum">     755 </span>            :   MOZ_ASSERT(aListID == kPrincipalList);
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   mFrames.InsertFrames(this, aPrevFrame, aFrameList);</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   ChildListChanged(nsIDOMMutationEvent::ADDITION);</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 : }</span>
<a name="759"><span class="lineNum">     759 </span>            : </a>
<span class="lineNum">     760 </span>            : void
<span class="lineNum">     761 </span><span class="lineNoCov">          0 : nsMathMLContainerFrame::RemoveFrame(ChildListID     aListID,</span>
<span class="lineNum">     762 </span>            :                                     nsIFrame*       aOldFrame)
<span class="lineNum">     763 </span>            : {
<span class="lineNum">     764 </span>            :   MOZ_ASSERT(aListID == kPrincipalList);
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   mFrames.DestroyFrame(aOldFrame);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   ChildListChanged(nsIDOMMutationEvent::REMOVAL);</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 : }</span>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<span class="lineNum">     769 </span>            : nsresult
<span class="lineNum">     770 </span><span class="lineNoCov">          0 : nsMathMLContainerFrame::AttributeChanged(int32_t         aNameSpaceID,</span>
<span class="lineNum">     771 </span>            :                                          nsIAtom*        aAttribute,
<span class="lineNum">     772 </span>            :                                          int32_t         aModType)
<span class="lineNum">     773 </span>            : {
<span class="lineNum">     774 </span>            :   // XXX Since they are numerous MathML attributes that affect layout, and
<span class="lineNum">     775 </span>            :   // we can't check all of them here, play safe by requesting a reflow.
<span class="lineNum">     776 </span>            :   // XXXldb This should only do work for attributes that cause changes!
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     781 </span>            : }
<a name="782"><span class="lineNum">     782 </span>            : </a>
<span class="lineNum">     783 </span>            : void
<span class="lineNum">     784 </span><span class="lineCov">          1 : nsMathMLContainerFrame::GatherAndStoreOverflow(ReflowOutput* aMetrics)</span>
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span><span class="lineCov">          1 :   mBlockStartAscent = aMetrics-&gt;BlockStartAscent();</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :   // nsIFrame::FinishAndStoreOverflow likes the overflow area to include the
<span class="lineNum">     789 </span>            :   // frame rectangle.
<span class="lineNum">     790 </span><span class="lineCov">          1 :   aMetrics-&gt;SetOverflowAreasToDesiredBounds();</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">          1 :   ComputeCustomOverflow(aMetrics-&gt;mOverflowAreas);</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :   // mBoundingMetrics does not necessarily include content of &lt;mpadded&gt;
<span class="lineNum">     795 </span>            :   // elements whose mBoundingMetrics may not be representative of the true
<span class="lineNum">     796 </span>            :   // bounds, and doesn't include the CSS2 outline rectangles of children, so
<span class="lineNum">     797 </span>            :   // make such to include child overflow areas.
<span class="lineNum">     798 </span><span class="lineCov">          1 :   UnionChildOverflow(aMetrics-&gt;mOverflowAreas);</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineCov">          1 :   FinishAndStoreOverflow(aMetrics);</span>
<span class="lineNum">     801 </span><span class="lineCov">          1 : }</span>
<a name="802"><span class="lineNum">     802 </span>            : </a>
<span class="lineNum">     803 </span>            : bool
<span class="lineNum">     804 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ComputeCustomOverflow(nsOverflowAreas&amp; aOverflowAreas)</span>
<span class="lineNum">     805 </span>            : {
<span class="lineNum">     806 </span>            :   // All non-child-frame content such as nsMathMLChars (and most child-frame
<span class="lineNum">     807 </span>            :   // content) is included in mBoundingMetrics.
<span class="lineNum">     808 </span>            :   nsRect boundingBox(mBoundingMetrics.leftBearing,
<span class="lineNum">     809 </span>            :                      mBlockStartAscent - mBoundingMetrics.ascent,
<span class="lineNum">     810 </span>            :                      mBoundingMetrics.rightBearing - mBoundingMetrics.leftBearing,
<span class="lineNum">     811 </span><span class="lineCov">          1 :                      mBoundingMetrics.ascent + mBoundingMetrics.descent);</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :   // REVIEW: Maybe this should contribute only to visual overflow
<span class="lineNum">     814 </span>            :   // and not scrollable?
<span class="lineNum">     815 </span><span class="lineCov">          1 :   aOverflowAreas.UnionAllWith(boundingBox);</span>
<span class="lineNum">     816 </span><span class="lineCov">          1 :   return nsContainerFrame::ComputeCustomOverflow(aOverflowAreas);</span>
<span class="lineNum">     817 </span>            : }
<a name="818"><span class="lineNum">     818 </span>            : </a>
<span class="lineNum">     819 </span>            : void
<span class="lineNum">     820 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ReflowChild(nsIFrame*                aChildFrame,</span>
<span class="lineNum">     821 </span>            :                                     nsPresContext*           aPresContext,
<span class="lineNum">     822 </span>            :                                     ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">     823 </span>            :                                     const ReflowInput&amp; aReflowInput,
<span class="lineNum">     824 </span>            :                                     nsReflowStatus&amp;          aStatus)
<span class="lineNum">     825 </span>            : {
<span class="lineNum">     826 </span>            :   // Having foreign/hybrid children, e.g., from html markups, is not defined by
<span class="lineNum">     827 </span>            :   // the MathML spec. But it can happen in practice, e.g., &lt;html:img&gt; allows us
<span class="lineNum">     828 </span>            :   // to do some cool demos... or we may have a child that is an nsInlineFrame
<span class="lineNum">     829 </span>            :   // from a generated content such as :before { content: open-quote } or 
<span class="lineNum">     830 </span>            :   // :after { content: close-quote }. Unfortunately, the other frames out-there
<span class="lineNum">     831 </span>            :   // may expect their own invariants that are not met when we mix things.
<span class="lineNum">     832 </span>            :   // Hence we do not claim their support, but we will nevertheless attempt to keep
<span class="lineNum">     833 </span>            :   // them in the flow, if we can get their desired size. We observed that most
<span class="lineNum">     834 </span>            :   // frames may be reflowed generically, but nsInlineFrames need extra care.
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : #ifdef DEBUG
<span class="lineNum">     837 </span>            :   nsInlineFrame* inlineFrame = do_QueryFrame(aChildFrame);
<span class="lineNum">     838 </span>            :   NS_ASSERTION(!inlineFrame, &quot;Inline frames should be wrapped in blocks&quot;);
<span class="lineNum">     839 </span>            : #endif
<span class="lineNum">     840 </span>            :   
<span class="lineNum">     841 </span>            :   nsContainerFrame::
<span class="lineNum">     842 </span>            :          ReflowChild(aChildFrame, aPresContext, aDesiredSize, aReflowInput,
<span class="lineNum">     843 </span><span class="lineCov">          1 :                      0, 0, NS_FRAME_NO_MOVE_FRAME, aStatus);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineCov">          1 :   if (aDesiredSize.BlockStartAscent() == ReflowOutput::ASK_FOR_BASELINE) {</span>
<span class="lineNum">     846 </span>            :     // This will be suitable for inline frames, which are wrapped in a block.
<span class="lineNum">     847 </span>            :     nscoord ascent;
<span class="lineNum">     848 </span><span class="lineCov">          1 :     WritingMode wm = aDesiredSize.GetWritingMode();</span>
<span class="lineNum">     849 </span><span class="lineCov">          1 :     if (!nsLayoutUtils::GetLastLineBaseline(wm, aChildFrame, &amp;ascent)) {</span>
<span class="lineNum">     850 </span>            :       // We don't expect any other block children so just place the frame on
<span class="lineNum">     851 </span>            :       // the baseline instead of going through DidReflow() and
<span class="lineNum">     852 </span>            :       // GetBaseline().  This is what nsFrame::GetBaseline() will do anyway.
<span class="lineNum">     853 </span><span class="lineCov">          1 :       aDesiredSize.SetBlockStartAscent(aDesiredSize.BSize(wm));</span>
<span class="lineNum">     854 </span>            :     } else {
<span class="lineNum">     855 </span><span class="lineCov">          1 :       aDesiredSize.SetBlockStartAscent(ascent);</span>
<span class="lineNum">     856 </span>            :     }
<span class="lineNum">     857 </span>            :   }
<span class="lineNum">     858 </span><span class="lineCov">          1 :   if (IsForeignChild(aChildFrame)) {</span>
<span class="lineNum">     859 </span>            :     // use ComputeTightBounds API as aDesiredSize.mBoundingMetrics is not set.
<span class="lineNum">     860 </span><span class="lineCov">          1 :     nsRect r = aChildFrame-&gt;ComputeTightBounds(aReflowInput.mRenderingContext-&gt;GetDrawTarget());</span>
<span class="lineNum">     861 </span><span class="lineCov">          1 :     aDesiredSize.mBoundingMetrics.leftBearing = r.x;</span>
<span class="lineNum">     862 </span><span class="lineCov">          1 :     aDesiredSize.mBoundingMetrics.rightBearing = r.XMost();</span>
<span class="lineNum">     863 </span><span class="lineCov">          1 :     aDesiredSize.mBoundingMetrics.ascent = aDesiredSize.BlockStartAscent() - r.y;</span>
<span class="lineNum">     864 </span><span class="lineCov">          1 :     aDesiredSize.mBoundingMetrics.descent = r.YMost() - aDesiredSize.BlockStartAscent();</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :     aDesiredSize.mBoundingMetrics.width = aDesiredSize.Width();</span>
<span class="lineNum">     866 </span>            :   }
<span class="lineNum">     867 </span><span class="lineCov">          1 : }</span>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<span class="lineNum">     869 </span>            : void
<span class="lineNum">     870 </span><span class="lineCov">          1 : nsMathMLContainerFrame::Reflow(nsPresContext*           aPresContext,</span>
<span class="lineNum">     871 </span>            :                                ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">     872 </span>            :                                const ReflowInput&amp; aReflowInput,
<span class="lineNum">     873 </span>            :                                nsReflowStatus&amp;          aStatus)
<span class="lineNum">     874 </span>            : {
<span class="lineNum">     875 </span><span class="lineCov">          1 :   MarkInReflow();</span>
<span class="lineNum">     876 </span><span class="lineCov">          1 :   mPresentationData.flags &amp;= ~NS_MATHML_ERROR;</span>
<span class="lineNum">     877 </span><span class="lineCov">          1 :   aDesiredSize.Width() = aDesiredSize.Height() = 0;</span>
<span class="lineNum">     878 </span><span class="lineCov">          1 :   aDesiredSize.SetBlockStartAscent(0);</span>
<span class="lineNum">     879 </span><span class="lineCov">          1 :   aDesiredSize.mBoundingMetrics = nsBoundingMetrics();</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :   /////////////
<span class="lineNum">     882 </span>            :   // Reflow children
<span class="lineNum">     883 </span>            :   // Asking each child to cache its bounding metrics
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineCov">          1 :   nsReflowStatus childStatus;</span>
<span class="lineNum">     886 </span><span class="lineCov">          1 :   nsIFrame* childFrame = mFrames.FirstChild();</span>
<span class="lineNum">     887 </span><span class="lineCov">          1 :   while (childFrame) {</span>
<span class="lineNum">     888 </span>            :     ReflowOutput childDesiredSize(aReflowInput, // ???
<span class="lineNum">     889 </span><span class="lineCov">          1 :                                          aDesiredSize.mFlags);</span>
<span class="lineNum">     890 </span><span class="lineCov">          1 :     WritingMode wm = childFrame-&gt;GetWritingMode();</span>
<span class="lineNum">     891 </span><span class="lineCov">          1 :     LogicalSize availSize = aReflowInput.ComputedSize(wm);</span>
<span class="lineNum">     892 </span><span class="lineCov">          1 :     availSize.BSize(wm) = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">     893 </span>            :     ReflowInput childReflowInput(aPresContext, aReflowInput,
<span class="lineNum">     894 </span><span class="lineCov">          1 :                                        childFrame, availSize);</span>
<span class="lineNum">     895 </span>            :     ReflowChild(childFrame, aPresContext, childDesiredSize,
<span class="lineNum">     896 </span><span class="lineCov">          1 :                 childReflowInput, childStatus);</span>
<span class="lineNum">     897 </span>            :     //NS_ASSERTION(childStatus.IsComplete(), &quot;bad status&quot;);
<span class="lineNum">     898 </span>            :     SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
<span class="lineNum">     899 </span><span class="lineCov">          1 :                                     childDesiredSize.mBoundingMetrics);</span>
<span class="lineNum">     900 </span><span class="lineCov">          1 :     childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">     901 </span>            :   }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :   /////////////
<span class="lineNum">     904 </span>            :   // If we are a container which is entitled to stretch its children, then we
<span class="lineNum">     905 </span>            :   // ask our stretchy children to stretch themselves
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            :   // The stretching of siblings of an embellished child is _deferred_ until
<span class="lineNum">     908 </span>            :   // after finishing the stretching of the embellished child - bug 117652
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineCov">          1 :   DrawTarget* drawTarget = aReflowInput.mRenderingContext-&gt;GetDrawTarget();</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span><span class="lineCov">          1 :   if (!NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) &amp;&amp;</span>
<span class="lineNum">     913 </span><span class="lineCov">          1 :       (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ||</span>
<span class="lineNum">     914 </span>            :        NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags))) {
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :     // get the stretchy direction
<span class="lineNum">     917 </span>            :     nsStretchDirection stretchDir =
<span class="lineNum">     918 </span><span class="lineCov">          1 :       NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) </span>
<span class="lineNum">     919 </span>            :       ? NS_STRETCH_DIRECTION_VERTICAL 
<span class="lineNum">     920 </span><span class="lineCov">          1 :       : NS_STRETCH_DIRECTION_HORIZONTAL;</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :     // what size should we use to stretch our stretchy children
<span class="lineNum">     923 </span>            :     // We don't use STRETCH_CONSIDER_ACTUAL_SIZE -- because our size is not known yet
<span class="lineNum">     924 </span>            :     // We don't use STRETCH_CONSIDER_EMBELLISHMENTS -- because we don't want to
<span class="lineNum">     925 </span>            :     // include them in the caculations of the size of stretchy elements
<span class="lineNum">     926 </span><span class="lineCov">          1 :     nsBoundingMetrics containerSize;</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :     GetPreferredStretchSize(drawTarget, 0, stretchDir, containerSize);</span>
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            :     // fire the stretch on each child
<span class="lineNum">     930 </span><span class="lineCov">          1 :     childFrame = mFrames.FirstChild();</span>
<span class="lineNum">     931 </span><span class="lineCov">          1 :     while (childFrame) {</span>
<span class="lineNum">     932 </span><span class="lineCov">          1 :       nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);</span>
<span class="lineNum">     933 </span><span class="lineCov">          1 :       if (mathMLFrame) {</span>
<span class="lineNum">     934 </span>            :         // retrieve the metrics that was stored at the previous pass
<span class="lineNum">     935 </span><span class="lineCov">          1 :         ReflowOutput childDesiredSize(aReflowInput);</span>
<span class="lineNum">     936 </span>            :         GetReflowAndBoundingMetricsFor(childFrame,
<span class="lineNum">     937 </span><span class="lineCov">          1 :           childDesiredSize, childDesiredSize.mBoundingMetrics);</span>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            :         mathMLFrame-&gt;Stretch(drawTarget, stretchDir,
<span class="lineNum">     940 </span><span class="lineCov">          1 :                              containerSize, childDesiredSize);</span>
<span class="lineNum">     941 </span>            :         // store the updated metrics
<span class="lineNum">     942 </span>            :         SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
<span class="lineNum">     943 </span><span class="lineCov">          1 :                                         childDesiredSize.mBoundingMetrics);</span>
<span class="lineNum">     944 </span>            :       }
<span class="lineNum">     945 </span><span class="lineCov">          1 :       childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">     946 </span>            :     }
<span class="lineNum">     947 </span>            :   }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            :   /////////////
<span class="lineNum">     950 </span>            :   // Place children now by re-adjusting the origins to align the baselines
<span class="lineNum">     951 </span><span class="lineCov">          1 :   FinalizeReflow(drawTarget, aDesiredSize);</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span><span class="lineCov">          1 :   aStatus.Reset();</span>
<span class="lineNum">     954 </span><span class="lineCov">          1 :   NS_FRAME_SET_TRUNCATION(aStatus, aReflowInput, aDesiredSize);</span>
<span class="lineNum">     955 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            : static nscoord AddInterFrameSpacingToSize(ReflowOutput&amp;    aDesiredSize,
<span class="lineNum">     958 </span>            :                                           nsMathMLContainerFrame* aFrame);
<a name="959"><span class="lineNum">     959 </span>            : </a>
<span class="lineNum">     960 </span>            : /* virtual */ void
<span class="lineNum">     961 </span><span class="lineCov">          1 : nsMathMLContainerFrame::MarkIntrinsicISizesDirty()</span>
<span class="lineNum">     962 </span>            : {
<span class="lineNum">     963 </span><span class="lineCov">          1 :   mIntrinsicWidth = NS_INTRINSIC_WIDTH_UNKNOWN;</span>
<span class="lineNum">     964 </span><span class="lineCov">          1 :   nsContainerFrame::MarkIntrinsicISizesDirty();</span>
<span class="lineNum">     965 </span><span class="lineCov">          1 : }</span>
<a name="966"><span class="lineNum">     966 </span>            : </a>
<span class="lineNum">     967 </span>            : void
<span class="lineNum">     968 </span><span class="lineCov">          1 : nsMathMLContainerFrame::UpdateIntrinsicWidth(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">     969 </span>            : {
<span class="lineNum">     970 </span><span class="lineCov">          1 :   if (mIntrinsicWidth == NS_INTRINSIC_WIDTH_UNKNOWN) {</span>
<span class="lineNum">     971 </span><span class="lineCov">          1 :     ReflowOutput desiredSize(GetWritingMode());</span>
<span class="lineNum">     972 </span><span class="lineCov">          1 :     GetIntrinsicISizeMetrics(aRenderingContext, desiredSize);</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :     // Include the additional width added by FixInterFrameSpacing to ensure
<span class="lineNum">     975 </span>            :     // consistent width calculations.
<span class="lineNum">     976 </span><span class="lineCov">          1 :     AddInterFrameSpacingToSize(desiredSize, this);</span>
<span class="lineNum">     977 </span><span class="lineCov">          1 :     mIntrinsicWidth = desiredSize.ISize(GetWritingMode());</span>
<span class="lineNum">     978 </span>            :   }
<span class="lineNum">     979 </span><span class="lineCov">          1 : }</span>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<span class="lineNum">     981 </span>            : /* virtual */ nscoord
<span class="lineNum">     982 </span><span class="lineCov">          1 : nsMathMLContainerFrame::GetMinISize(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">     983 </span>            : {
<span class="lineNum">     984 </span>            :   nscoord result;
<span class="lineNum">     985 </span>            :   DISPLAY_MIN_WIDTH(this, result);
<span class="lineNum">     986 </span><span class="lineCov">          1 :   UpdateIntrinsicWidth(aRenderingContext);</span>
<span class="lineNum">     987 </span><span class="lineCov">          1 :   result = mIntrinsicWidth;</span>
<span class="lineNum">     988 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">     989 </span>            : }
<a name="990"><span class="lineNum">     990 </span>            : </a>
<span class="lineNum">     991 </span>            : /* virtual */ nscoord
<span class="lineNum">     992 </span><span class="lineCov">          1 : nsMathMLContainerFrame::GetPrefISize(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">     993 </span>            : {
<span class="lineNum">     994 </span>            :   nscoord result;
<span class="lineNum">     995 </span>            :   DISPLAY_PREF_WIDTH(this, result);
<span class="lineNum">     996 </span><span class="lineCov">          1 :   UpdateIntrinsicWidth(aRenderingContext);</span>
<span class="lineNum">     997 </span><span class="lineCov">          1 :   result = mIntrinsicWidth;</span>
<span class="lineNum">     998 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">     999 </span>            : }
<a name="1000"><span class="lineNum">    1000 </span>            : </a>
<span class="lineNum">    1001 </span>            : /* virtual */ void
<span class="lineNum">    1002 </span><span class="lineCov">          1 : nsMathMLContainerFrame::GetIntrinsicISizeMetrics(nsRenderingContext* aRenderingContext,</span>
<span class="lineNum">    1003 </span>            :                                                  ReflowOutput&amp; aDesiredSize)
<span class="lineNum">    1004 </span>            : {
<span class="lineNum">    1005 </span>            :   // Get child widths
<span class="lineNum">    1006 </span><span class="lineCov">          1 :   nsIFrame* childFrame = mFrames.FirstChild();</span>
<span class="lineNum">    1007 </span><span class="lineCov">          1 :   while (childFrame) {</span>
<span class="lineNum">    1008 </span><span class="lineCov">          1 :     ReflowOutput childDesiredSize(GetWritingMode()); // ???</span>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineCov">          1 :     nsMathMLContainerFrame* containerFrame = do_QueryFrame(childFrame);</span>
<span class="lineNum">    1011 </span><span class="lineCov">          1 :     if (containerFrame) {</span>
<span class="lineNum">    1012 </span>            :       containerFrame-&gt;GetIntrinsicISizeMetrics(aRenderingContext,
<span class="lineNum">    1013 </span><span class="lineCov">          1 :                                                childDesiredSize);</span>
<span class="lineNum">    1014 </span>            :     } else {
<span class="lineNum">    1015 </span>            :       // XXX This includes margin while Reflow currently doesn't consider
<span class="lineNum">    1016 </span>            :       // margin, so we may end up with too much space, but, with stretchy
<span class="lineNum">    1017 </span>            :       // characters, this is an approximation anyway.
<span class="lineNum">    1018 </span>            :       nscoord width =
<span class="lineNum">    1019 </span>            :         nsLayoutUtils::IntrinsicForContainer(aRenderingContext, childFrame,
<span class="lineNum">    1020 </span><span class="lineCov">          1 :                                              nsLayoutUtils::PREF_ISIZE);</span>
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span><span class="lineCov">          1 :       childDesiredSize.Width() = width;</span>
<span class="lineNum">    1023 </span><span class="lineCov">          1 :       childDesiredSize.mBoundingMetrics.width = width;</span>
<span class="lineNum">    1024 </span><span class="lineCov">          1 :       childDesiredSize.mBoundingMetrics.leftBearing = 0;</span>
<span class="lineNum">    1025 </span><span class="lineCov">          1 :       childDesiredSize.mBoundingMetrics.rightBearing = width;</span>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :       nscoord x, xMost;
<span class="lineNum">    1028 </span><span class="lineCov">          1 :       if (NS_SUCCEEDED(childFrame-&gt;GetPrefWidthTightBounds(aRenderingContext,</span>
<span class="lineNum">    1029 </span>            :                                                            &amp;x, &amp;xMost))) {
<span class="lineNum">    1030 </span><span class="lineCov">          1 :         childDesiredSize.mBoundingMetrics.leftBearing = x;</span>
<span class="lineNum">    1031 </span><span class="lineCov">          1 :         childDesiredSize.mBoundingMetrics.rightBearing = xMost;</span>
<span class="lineNum">    1032 </span>            :       }
<span class="lineNum">    1033 </span>            :     }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :     SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
<span class="lineNum">    1036 </span><span class="lineCov">          1 :                                     childDesiredSize.mBoundingMetrics);</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">          1 :     childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">    1039 </span>            :   }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :   // Measure
<span class="lineNum">    1042 </span><span class="lineCov">          1 :   nsresult rv = MeasureForWidth(aRenderingContext-&gt;GetDrawTarget(), aDesiredSize);</span>
<span class="lineNum">    1043 </span><span class="lineCov">          1 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     ReflowError(aRenderingContext-&gt;GetDrawTarget(), aDesiredSize);</span>
<span class="lineNum">    1045 </span>            :   }
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineCov">          1 :   ClearSavedChildMetrics();</span>
<span class="lineNum">    1048 </span><span class="lineCov">          1 : }</span>
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<span class="lineNum">    1050 </span>            : /* virtual */ nsresult
<span class="lineNum">    1051 </span><span class="lineCov">          1 : nsMathMLContainerFrame::MeasureForWidth(DrawTarget* aDrawTarget,</span>
<span class="lineNum">    1052 </span>            :                                         ReflowOutput&amp; aDesiredSize)
<span class="lineNum">    1053 </span>            : {
<span class="lineNum">    1054 </span><span class="lineCov">          1 :   return Place(aDrawTarget, false, aDesiredSize);</span>
<span class="lineNum">    1055 </span>            : }
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            : // see spacing table in Chapter 18, TeXBook (p.170)
<span class="lineNum">    1059 </span>            : // Our table isn't quite identical to TeX because operators have 
<span class="lineNum">    1060 </span>            : // built-in values for lspace &amp; rspace in the Operator Dictionary.
<span class="lineNum">    1061 </span>            : static int32_t kInterFrameSpacingTable[eMathMLFrameType_COUNT][eMathMLFrameType_COUNT] =
<span class="lineNum">    1062 </span>            : {
<span class="lineNum">    1063 </span>            :   // in units of muspace.
<span class="lineNum">    1064 </span>            :   // upper half of the byte is set if the
<span class="lineNum">    1065 </span>            :   // spacing is not to be used for scriptlevel &gt; 0
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :   /*           Ord  OpOrd OpInv OpUsr Inner Italic Upright */
<span class="lineNum">    1068 </span>            :   /*Ord  */   {0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00},
<span class="lineNum">    1069 </span>            :   /*OpOrd*/   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
<span class="lineNum">    1070 </span>            :   /*OpInv*/   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
<span class="lineNum">    1071 </span>            :   /*OpUsr*/   {0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01},
<span class="lineNum">    1072 </span>            :   /*Inner*/   {0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01},
<span class="lineNum">    1073 </span>            :   /*Italic*/  {0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01},
<span class="lineNum">    1074 </span>            :   /*Upright*/ {0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00}
<span class="lineNum">    1075 </span>            : };
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            : #define GET_INTERSPACE(scriptlevel_, frametype1_, frametype2_, space_)  \
<span class="lineNum">    1078 </span>            :    /* no space if there is a frame that we know nothing about */        \
<span class="lineNum">    1079 </span>            :    if (frametype1_ == eMathMLFrameType_UNKNOWN ||                       \
<span class="lineNum">    1080 </span>            :        frametype2_ == eMathMLFrameType_UNKNOWN)                         \
<span class="lineNum">    1081 </span>            :     space_ = 0;                                                         \
<span class="lineNum">    1082 </span>            :   else {                                                                \
<span class="lineNum">    1083 </span>            :     space_ = kInterFrameSpacingTable[frametype1_][frametype2_];         \
<span class="lineNum">    1084 </span>            :     space_ = (scriptlevel_ &gt; 0 &amp;&amp; (space_ &amp; 0xF0))                      \
<span class="lineNum">    1085 </span>            :       ? 0 /* spacing is disabled */                                     \
<span class="lineNum">    1086 </span>            :       : space_ &amp; 0x0F;                                                  \
<span class="lineNum">    1087 </span>            :   }                                                                     \
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            : // This function computes the inter-space between two frames. However, 
<span class="lineNum">    1090 </span>            : // since invisible operators need special treatment, the inter-space may
<span class="lineNum">    1091 </span>            : // be delayed when an invisible operator is encountered. In this case,
<span class="lineNum">    1092 </span>            : // the function will carry the inter-space forward until it is determined
<span class="lineNum">    1093 </span>            : // that it can be applied properly (i.e., until we encounter a visible
<span class="lineNum">    1094 </span>            : // frame where to decide whether to accept or reject the inter-space).
<span class="lineNum">    1095 </span>            : // aFromFrameType: remembers the frame when the carry-forward initiated.
<span class="lineNum">    1096 </span>            : // aCarrySpace: keeps track of the inter-space that is delayed.
<span class="lineNum">    1097 </span>            : // @returns: current inter-space (which is 0 when the true inter-space is
<a name="1098"><span class="lineNum">    1098 </span>            : // delayed -- and thus has no effect since the frame is invisible anyway).</a>
<span class="lineNum">    1099 </span>            : static nscoord
<span class="lineNum">    1100 </span><span class="lineCov">          1 : GetInterFrameSpacing(int32_t           aScriptLevel,</span>
<span class="lineNum">    1101 </span>            :                      eMathMLFrameType  aFirstFrameType,
<span class="lineNum">    1102 </span>            :                      eMathMLFrameType  aSecondFrameType,
<span class="lineNum">    1103 </span>            :                      eMathMLFrameType* aFromFrameType, // IN/OUT
<span class="lineNum">    1104 </span>            :                      int32_t*          aCarrySpace)    // IN/OUT
<span class="lineNum">    1105 </span>            : {
<span class="lineNum">    1106 </span><span class="lineCov">          1 :   eMathMLFrameType firstType = aFirstFrameType;</span>
<span class="lineNum">    1107 </span><span class="lineCov">          1 :   eMathMLFrameType secondType = aSecondFrameType;</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :   int32_t space;
<span class="lineNum">    1110 </span><span class="lineCov">          1 :   GET_INTERSPACE(aScriptLevel, firstType, secondType, space);</span>
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            :   // feedback control to avoid the inter-space to be added when not necessary
<span class="lineNum">    1113 </span><span class="lineCov">          1 :   if (secondType == eMathMLFrameType_OperatorInvisible) {</span>
<span class="lineNum">    1114 </span>            :     // see if we should start to carry the space forward until we
<span class="lineNum">    1115 </span>            :     // encounter a visible frame
<span class="lineNum">    1116 </span><span class="lineCov">          1 :     if (*aFromFrameType == eMathMLFrameType_UNKNOWN) {</span>
<span class="lineNum">    1117 </span><span class="lineCov">          1 :       *aFromFrameType = firstType;</span>
<span class="lineNum">    1118 </span><span class="lineCov">          1 :       *aCarrySpace = space;</span>
<span class="lineNum">    1119 </span>            :     }
<span class="lineNum">    1120 </span>            :     // keep carrying *aCarrySpace forward, while returning 0 for this stage
<span class="lineNum">    1121 </span>            :     space = 0;
<span class="lineNum">    1122 </span>            :   }
<span class="lineNum">    1123 </span><span class="lineCov">          1 :   else if (*aFromFrameType != eMathMLFrameType_UNKNOWN) {</span>
<span class="lineNum">    1124 </span>            :     // no carry-forward anymore, get the real inter-space between
<span class="lineNum">    1125 </span>            :     // the two frames of interest
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineCov">          1 :     firstType = *aFromFrameType;</span>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span>            :     // But... the invisible operator that we encountered earlier could
<span class="lineNum">    1130 </span>            :     // be sitting between italic and upright identifiers, e.g.,
<span class="lineNum">    1131 </span>            :     //
<span class="lineNum">    1132 </span>            :     // 1. &lt;mi&gt;sin&lt;/mi&gt; &lt;mo&gt;&amp;ApplyFunction;&lt;/mo&gt; &lt;mi&gt;x&lt;/mi&gt;
<span class="lineNum">    1133 </span>            :     // 2. &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;&amp;InvisibileTime;&lt;/mo&gt; &lt;mi&gt;sin&lt;/mi&gt;
<span class="lineNum">    1134 </span>            :     //
<span class="lineNum">    1135 </span>            :     // the trick to get the inter-space in either situation
<span class="lineNum">    1136 </span>            :     // is to promote &quot;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;ApplyFunction;&lt;/mo&gt;&quot; and
<span class="lineNum">    1137 </span>            :     // &quot;&lt;mo&gt;&amp;InvisibileTime;&lt;/mo&gt;&lt;mi&gt;sin&lt;/mi&gt;&quot; to user-defined operators...
<span class="lineNum">    1138 </span><span class="lineCov">          1 :     if (firstType == eMathMLFrameType_UprightIdentifier) {</span>
<span class="lineNum">    1139 </span>            :       firstType = eMathMLFrameType_OperatorUserDefined;
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span><span class="lineCov">          1 :     else if (secondType == eMathMLFrameType_UprightIdentifier) {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :       secondType = eMathMLFrameType_OperatorUserDefined;</span>
<span class="lineNum">    1143 </span>            :     }
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineCov">          1 :     GET_INTERSPACE(aScriptLevel, firstType, secondType, space);</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :     // Now, we have two values: the computed space and the space that
<span class="lineNum">    1148 </span>            :     // has been carried forward until now. Which value do we pick?
<span class="lineNum">    1149 </span>            :     // If the second type is an operator (e.g., fence), it already has
<span class="lineNum">    1150 </span>            :     // built-in lspace &amp; rspace, so we let them win. Otherwise we pick
<span class="lineNum">    1151 </span>            :     // the max between the two values that we have.
<span class="lineNum">    1152 </span><span class="lineCov">          1 :     if (secondType != eMathMLFrameType_OperatorOrdinary &amp;&amp;</span>
<span class="lineNum">    1153 </span><span class="lineCov">          1 :         space &lt; *aCarrySpace)</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       space = *aCarrySpace;</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            :     // reset everything now that the carry-forward is done
<span class="lineNum">    1157 </span><span class="lineCov">          1 :     *aFromFrameType = eMathMLFrameType_UNKNOWN;</span>
<span class="lineNum">    1158 </span><span class="lineCov">          1 :     *aCarrySpace = 0;</span>
<span class="lineNum">    1159 </span>            :   }
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineCov">          1 :   return space;</span>
<a name="1162"><span class="lineNum">    1162 </span>            : }</a>
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span><span class="lineCov">          1 : static nscoord GetThinSpace(const nsStyleFont* aStyleFont)</span>
<span class="lineNum">    1165 </span>            : {
<span class="lineNum">    1166 </span><span class="lineCov">          1 :   return NSToCoordRound(float(aStyleFont-&gt;mFont.size)*float(3) / float(18));</span>
<span class="lineNum">    1167 </span>            : }
<span class="lineNum">    1168 </span>            : 
<a name="1169"><span class="lineNum">    1169 </span>            : class nsMathMLContainerFrame::RowChildFrameIterator {</a>
<span class="lineNum">    1170 </span>            : public:
<span class="lineNum">    1171 </span><span class="lineCov">          1 :   explicit RowChildFrameIterator(nsMathMLContainerFrame* aParentFrame) :</span>
<span class="lineNum">    1172 </span>            :     mParentFrame(aParentFrame),
<span class="lineNum">    1173 </span>            :     mReflowOutput(aParentFrame-&gt;GetWritingMode()),
<span class="lineNum">    1174 </span>            :     mX(0),
<span class="lineNum">    1175 </span>            :     mCarrySpace(0),
<span class="lineNum">    1176 </span>            :     mFromFrameType(eMathMLFrameType_UNKNOWN),
<span class="lineNum">    1177 </span><span class="lineCov">          1 :     mRTL(aParentFrame-&gt;StyleVisibility()-&gt;mDirection)</span>
<span class="lineNum">    1178 </span>            :   {
<span class="lineNum">    1179 </span><span class="lineCov">          1 :     if (!mRTL) {</span>
<span class="lineNum">    1180 </span><span class="lineCov">          1 :       mChildFrame = aParentFrame-&gt;mFrames.FirstChild();</span>
<span class="lineNum">    1181 </span>            :     } else {
<span class="lineNum">    1182 </span><span class="lineCov">          1 :       mChildFrame = aParentFrame-&gt;mFrames.LastChild();</span>
<span class="lineNum">    1183 </span>            :     }
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span><span class="lineCov">          1 :     if (!mChildFrame)</span>
<span class="lineNum">    1186 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineCov">          1 :     InitMetricsForChild();</span>
<a name="1189"><span class="lineNum">    1189 </span>            :   }</a>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineCov">          1 :   RowChildFrameIterator&amp; operator++()</span>
<span class="lineNum">    1192 </span>            :   {
<span class="lineNum">    1193 </span>            :     // add child size + italic correction
<span class="lineNum">    1194 </span><span class="lineCov">          1 :     mX += mReflowOutput.mBoundingMetrics.width + mItalicCorrection;</span>
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span><span class="lineCov">          1 :     if (!mRTL) {</span>
<span class="lineNum">    1197 </span><span class="lineCov">          1 :       mChildFrame = mChildFrame-&gt;GetNextSibling();</span>
<span class="lineNum">    1198 </span>            :     } else {
<span class="lineNum">    1199 </span><span class="lineCov">          1 :       mChildFrame = mChildFrame-&gt;GetPrevSibling();</span>
<span class="lineNum">    1200 </span>            :     }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineCov">          1 :     if (!mChildFrame)</span>
<span class="lineNum">    1203 </span>            :       return *this;
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span><span class="lineCov">          1 :     eMathMLFrameType prevFrameType = mChildFrameType;</span>
<span class="lineNum">    1206 </span><span class="lineCov">          1 :     InitMetricsForChild();</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :     // add inter frame spacing
<span class="lineNum">    1209 </span><span class="lineCov">          1 :     const nsStyleFont* font = mParentFrame-&gt;StyleFont();</span>
<span class="lineNum">    1210 </span>            :     nscoord space =
<span class="lineNum">    1211 </span>            :       GetInterFrameSpacing(font-&gt;mScriptLevel,
<span class="lineNum">    1212 </span>            :                            prevFrameType, mChildFrameType,
<span class="lineNum">    1213 </span><span class="lineCov">          1 :                            &amp;mFromFrameType, &amp;mCarrySpace);</span>
<span class="lineNum">    1214 </span><span class="lineCov">          1 :     mX += space * GetThinSpace(font);</span>
<span class="lineNum">    1215 </span><span class="lineCov">          1 :     return *this;</span>
<span class="lineNum">    1216 </span>            :   }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :   nsIFrame* Frame() const { return mChildFrame; }
<span class="lineNum">    1219 </span>            :   nscoord X() const { return mX; }
<a name="1220"><span class="lineNum">    1220 </span>            :   const ReflowOutput&amp; GetReflowOutput() const { return mReflowOutput; }</a>
<span class="lineNum">    1221 </span><span class="lineCov">          1 :   nscoord Ascent() const { return mReflowOutput.BlockStartAscent(); }</span>
<span class="lineNum">    1222 </span><span class="lineCov">          1 :   nscoord Descent() const { return mReflowOutput.Height() - mReflowOutput.BlockStartAscent(); }</span>
<span class="lineNum">    1223 </span>            :   const nsBoundingMetrics&amp; BoundingMetrics() const {
<span class="lineNum">    1224 </span>            :     return mReflowOutput.mBoundingMetrics;
<span class="lineNum">    1225 </span>            :   }
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            : private:
<span class="lineNum">    1228 </span>            :   const nsMathMLContainerFrame* mParentFrame;
<span class="lineNum">    1229 </span>            :   nsIFrame* mChildFrame;
<span class="lineNum">    1230 </span>            :   ReflowOutput mReflowOutput;
<span class="lineNum">    1231 </span>            :   nscoord mX;
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            :   nscoord mItalicCorrection;
<span class="lineNum">    1234 </span>            :   eMathMLFrameType mChildFrameType;
<span class="lineNum">    1235 </span>            :   int32_t mCarrySpace;
<span class="lineNum">    1236 </span>            :   eMathMLFrameType mFromFrameType;
<span class="lineNum">    1237 </span>            : 
<a name="1238"><span class="lineNum">    1238 </span>            :   bool mRTL;</a>
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span><span class="lineCov">          1 :   void InitMetricsForChild()</span>
<span class="lineNum">    1241 </span>            :   {
<span class="lineNum">    1242 </span>            :     GetReflowAndBoundingMetricsFor(mChildFrame, mReflowOutput, mReflowOutput.mBoundingMetrics,
<span class="lineNum">    1243 </span><span class="lineCov">          1 :                                    &amp;mChildFrameType);</span>
<span class="lineNum">    1244 </span>            :     nscoord leftCorrection, rightCorrection;
<span class="lineNum">    1245 </span>            :     GetItalicCorrection(mReflowOutput.mBoundingMetrics,
<span class="lineNum">    1246 </span><span class="lineCov">          1 :                         leftCorrection, rightCorrection);</span>
<span class="lineNum">    1247 </span><span class="lineCov">          1 :     if (!mChildFrame-&gt;GetPrevSibling() &amp;&amp;</span>
<span class="lineNum">    1248 </span><span class="lineCov">          1 :         mParentFrame-&gt;GetContent()-&gt;IsMathMLElement(nsGkAtoms::msqrt_)) {</span>
<span class="lineNum">    1249 </span>            :       // Remove leading correction in &lt;msqrt&gt; because the sqrt glyph itself is
<span class="lineNum">    1250 </span>            :       // there first.
<span class="lineNum">    1251 </span><span class="lineCov">          1 :       if (!mRTL) {</span>
<span class="lineNum">    1252 </span><span class="lineCov">          1 :         leftCorrection = 0;</span>
<span class="lineNum">    1253 </span>            :       } else {
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         rightCorrection = 0;</span>
<span class="lineNum">    1255 </span>            :       }
<span class="lineNum">    1256 </span>            :     }
<span class="lineNum">    1257 </span>            :     // add left correction -- this fixes the problem of the italic 'f'
<span class="lineNum">    1258 </span>            :     // e.g., &lt;mo&gt;q&lt;/mo&gt; &lt;mi&gt;f&lt;/mi&gt; &lt;mo&gt;I&lt;/mo&gt; 
<span class="lineNum">    1259 </span><span class="lineCov">          1 :     mX += leftCorrection;</span>
<span class="lineNum">    1260 </span><span class="lineCov">          1 :     mItalicCorrection = rightCorrection;</span>
<span class="lineNum">    1261 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1262 </span>            : };
<a name="1263"><span class="lineNum">    1263 </span>            : </a>
<span class="lineNum">    1264 </span>            : /* virtual */ nsresult
<span class="lineNum">    1265 </span><span class="lineCov">          1 : nsMathMLContainerFrame::Place(DrawTarget*          aDrawTarget,</span>
<span class="lineNum">    1266 </span>            :                               bool                 aPlaceOrigin,
<span class="lineNum">    1267 </span>            :                               ReflowOutput&amp; aDesiredSize)
<span class="lineNum">    1268 </span>            : {
<span class="lineNum">    1269 </span>            :   // This is needed in case this frame is empty (i.e., no child frames)
<span class="lineNum">    1270 </span><span class="lineCov">          1 :   mBoundingMetrics = nsBoundingMetrics();</span>
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineCov">          1 :   RowChildFrameIterator child(this);</span>
<span class="lineNum">    1273 </span><span class="lineCov">          1 :   nscoord ascent = 0, descent = 0;</span>
<span class="lineNum">    1274 </span><span class="lineCov">          1 :   while (child.Frame()) {</span>
<span class="lineNum">    1275 </span><span class="lineCov">          1 :     if (descent &lt; child.Descent())</span>
<span class="lineNum">    1276 </span><span class="lineCov">          1 :       descent = child.Descent();</span>
<span class="lineNum">    1277 </span><span class="lineCov">          1 :     if (ascent &lt; child.Ascent())</span>
<span class="lineNum">    1278 </span><span class="lineCov">          1 :       ascent = child.Ascent();</span>
<span class="lineNum">    1279 </span>            :     // add the child size
<span class="lineNum">    1280 </span><span class="lineCov">          1 :     mBoundingMetrics.width = child.X();</span>
<span class="lineNum">    1281 </span><span class="lineCov">          1 :     mBoundingMetrics += child.BoundingMetrics();</span>
<span class="lineNum">    1282 </span><span class="lineCov">          1 :     ++child;</span>
<span class="lineNum">    1283 </span>            :   }
<span class="lineNum">    1284 </span>            :   // Add the italic correction at the end (including the last child).
<span class="lineNum">    1285 </span>            :   // This gives a nice gap between math and non-math frames, and still
<span class="lineNum">    1286 </span>            :   // gives the same math inter-spacing in case this frame connects to
<span class="lineNum">    1287 </span>            :   // another math frame
<span class="lineNum">    1288 </span><span class="lineCov">          1 :   mBoundingMetrics.width = child.X();</span>
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineCov">          1 :   aDesiredSize.Width() = std::max(0, mBoundingMetrics.width);</span>
<span class="lineNum">    1291 </span><span class="lineCov">          1 :   aDesiredSize.Height() = ascent + descent;</span>
<span class="lineNum">    1292 </span><span class="lineCov">          1 :   aDesiredSize.SetBlockStartAscent(ascent);</span>
<span class="lineNum">    1293 </span><span class="lineCov">          1 :   aDesiredSize.mBoundingMetrics = mBoundingMetrics;</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span><span class="lineCov">          1 :   mReference.x = 0;</span>
<span class="lineNum">    1296 </span><span class="lineCov">          1 :   mReference.y = aDesiredSize.BlockStartAscent();</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :   //////////////////
<span class="lineNum">    1299 </span>            :   // Place Children
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineCov">          1 :   if (aPlaceOrigin) {</span>
<span class="lineNum">    1302 </span><span class="lineCov">          1 :     PositionRowChildFrames(0, aDesiredSize.BlockStartAscent());</span>
<span class="lineNum">    1303 </span>            :   }
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1306 </span>            : }
<a name="1307"><span class="lineNum">    1307 </span>            : </a>
<span class="lineNum">    1308 </span>            : void
<span class="lineNum">    1309 </span><span class="lineCov">          1 : nsMathMLContainerFrame::PositionRowChildFrames(nscoord aOffsetX,</span>
<span class="lineNum">    1310 </span>            :                                                nscoord aBaseline)
<span class="lineNum">    1311 </span>            : {
<span class="lineNum">    1312 </span><span class="lineCov">          1 :   RowChildFrameIterator child(this);</span>
<span class="lineNum">    1313 </span><span class="lineCov">          1 :   while (child.Frame()) {</span>
<span class="lineNum">    1314 </span><span class="lineCov">          1 :     nscoord dx = aOffsetX + child.X();</span>
<span class="lineNum">    1315 </span><span class="lineCov">          1 :     nscoord dy = aBaseline - child.Ascent();</span>
<span class="lineNum">    1316 </span>            :     FinishReflowChild(child.Frame(), PresContext(), child.GetReflowOutput(),
<span class="lineNum">    1317 </span><span class="lineCov">          1 :                       nullptr, dx, dy, 0);</span>
<span class="lineNum">    1318 </span><span class="lineCov">          1 :     ++child;</span>
<span class="lineNum">    1319 </span>            :   }
<span class="lineNum">    1320 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1321 </span>            : 
<a name="1322"><span class="lineNum">    1322 </span>            : class ForceReflow : public nsIReflowCallback {</a>
<span class="lineNum">    1323 </span>            : public:
<span class="lineNum">    1324 </span><span class="lineCov">          1 :   virtual bool ReflowFinished() override {</span>
<a name="1325"><span class="lineNum">    1325 </span><span class="lineCov">          1 :     return true;</span></a>
<span class="lineNum">    1326 </span>            :   }
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   virtual void ReflowCallbackCanceled() override {}</span>
<span class="lineNum">    1328 </span>            : };
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            : // We only need one of these so we just make it a static global, no need
<span class="lineNum">    1331 </span>            : // to dynamically allocate/destroy it.
<span class="lineNum">    1332 </span>            : static ForceReflow gForceReflow;
<a name="1333"><span class="lineNum">    1333 </span>            : </a>
<span class="lineNum">    1334 </span>            : void
<span class="lineNum">    1335 </span><span class="lineCov">          1 : nsMathMLContainerFrame::SetIncrementScriptLevel(int32_t aChildIndex, bool aIncrement)</span>
<span class="lineNum">    1336 </span>            : {
<span class="lineNum">    1337 </span><span class="lineCov">          1 :   nsIFrame* child = PrincipalChildList().FrameAt(aChildIndex);</span>
<span class="lineNum">    1338 </span><span class="lineCov">          1 :   if (!child)</span>
<span class="lineNum">    1339 </span>            :     return;
<span class="lineNum">    1340 </span><span class="lineCov">          1 :   nsIContent* content = child-&gt;GetContent();</span>
<span class="lineNum">    1341 </span><span class="lineCov">          1 :   if (!content-&gt;IsMathMLElement())</span>
<span class="lineNum">    1342 </span>            :     return;
<span class="lineNum">    1343 </span><span class="lineCov">          1 :   nsMathMLElement* element = static_cast&lt;nsMathMLElement*&gt;(content);</span>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineCov">          1 :   if (element-&gt;GetIncrementScriptLevel() == aIncrement)</span>
<span class="lineNum">    1346 </span>            :     return;
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            :   // XXXroc this does a ContentStatesChanged, is it safe to call here? If
<span class="lineNum">    1349 </span>            :   // not we should do it in a post-reflow callback.
<span class="lineNum">    1350 </span><span class="lineCov">          1 :   element-&gt;SetIncrementScriptLevel(aIncrement, true);</span>
<span class="lineNum">    1351 </span><span class="lineCov">          1 :   PresContext()-&gt;PresShell()-&gt;PostReflowCallback(&amp;gForceReflow);</span>
<span class="lineNum">    1352 </span>            : }
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span>            : // helpers to fix the inter-spacing when &lt;math&gt; is the only parent
<span class="lineNum">    1355 </span>            : // e.g., it fixes &lt;math&gt; &lt;mi&gt;f&lt;/mi&gt; &lt;mo&gt;q&lt;/mo&gt; &lt;mi&gt;f&lt;/mi&gt; &lt;mo&gt;I&lt;/mo&gt; &lt;/math&gt;
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<span class="lineNum">    1357 </span>            : static nscoord
<span class="lineNum">    1358 </span><span class="lineCov">          1 : GetInterFrameSpacingFor(int32_t         aScriptLevel,</span>
<span class="lineNum">    1359 </span>            :                         nsIFrame*       aParentFrame,
<span class="lineNum">    1360 </span>            :                         nsIFrame*       aChildFrame)
<span class="lineNum">    1361 </span>            : {
<span class="lineNum">    1362 </span><span class="lineCov">          1 :   nsIFrame* childFrame = aParentFrame-&gt;PrincipalChildList().FirstChild();</span>
<span class="lineNum">    1363 </span><span class="lineCov">          1 :   if (!childFrame || aChildFrame == childFrame)</span>
<span class="lineNum">    1364 </span>            :     return 0;
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">          1 :   int32_t carrySpace = 0;</span>
<span class="lineNum">    1367 </span><span class="lineCov">          1 :   eMathMLFrameType fromFrameType = eMathMLFrameType_UNKNOWN;</span>
<span class="lineNum">    1368 </span><span class="lineCov">          1 :   eMathMLFrameType prevFrameType = eMathMLFrameType_UNKNOWN;</span>
<span class="lineNum">    1369 </span><span class="lineCov">          1 :   eMathMLFrameType childFrameType = nsMathMLFrame::GetMathMLFrameTypeFor(childFrame);</span>
<span class="lineNum">    1370 </span><span class="lineCov">          1 :   childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">    1371 </span><span class="lineCov">          1 :   while (childFrame) {</span>
<span class="lineNum">    1372 </span><span class="lineCov">          1 :     prevFrameType = childFrameType;</span>
<span class="lineNum">    1373 </span><span class="lineCov">          1 :     childFrameType = nsMathMLFrame::GetMathMLFrameTypeFor(childFrame);</span>
<span class="lineNum">    1374 </span>            :     nscoord space = GetInterFrameSpacing(aScriptLevel,
<span class="lineNum">    1375 </span><span class="lineCov">          1 :       prevFrameType, childFrameType, &amp;fromFrameType, &amp;carrySpace);</span>
<span class="lineNum">    1376 </span><span class="lineCov">          1 :     if (aChildFrame == childFrame) {</span>
<span class="lineNum">    1377 </span>            :       // get thinspace
<span class="lineNum">    1378 </span><span class="lineCov">          1 :       nsStyleContext* parentContext = aParentFrame-&gt;StyleContext();</span>
<span class="lineNum">    1379 </span><span class="lineCov">          1 :       nscoord thinSpace = GetThinSpace(parentContext-&gt;StyleFont());</span>
<span class="lineNum">    1380 </span>            :       // we are done
<span class="lineNum">    1381 </span><span class="lineCov">          1 :       return space * thinSpace;</span>
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span><span class="lineCov">          1 :     childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">    1384 </span>            :   }
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :   NS_NOTREACHED(&quot;child not in the childlist of its parent&quot;);
<span class="lineNum">    1387 </span>            :   return 0;
<span class="lineNum">    1388 </span>            : }
<a name="1389"><span class="lineNum">    1389 </span>            : </a>
<span class="lineNum">    1390 </span>            : static nscoord
<span class="lineNum">    1391 </span><span class="lineCov">          1 : AddInterFrameSpacingToSize(ReflowOutput&amp;    aDesiredSize,</span>
<span class="lineNum">    1392 </span>            :                            nsMathMLContainerFrame* aFrame)
<span class="lineNum">    1393 </span>            : {
<span class="lineNum">    1394 </span><span class="lineCov">          1 :   nscoord gap = 0;</span>
<span class="lineNum">    1395 </span><span class="lineCov">          1 :   nsIFrame* parent = aFrame-&gt;GetParent();</span>
<span class="lineNum">    1396 </span><span class="lineCov">          1 :   nsIContent* parentContent = parent-&gt;GetContent();</span>
<span class="lineNum">    1397 </span><span class="lineCov">          1 :   if (MOZ_UNLIKELY(!parentContent)) {</span>
<span class="lineNum">    1398 </span>            :     return 0;
<span class="lineNum">    1399 </span>            :   }
<span class="lineNum">    1400 </span><span class="lineCov">          1 :   if (parentContent-&gt;IsAnyOfMathMLElements(nsGkAtoms::math,</span>
<span class="lineNum">    1401 </span><span class="lineCov">          1 :                                            nsGkAtoms::mtd_)) {</span>
<span class="lineNum">    1402 </span><span class="lineCov">          1 :     gap = GetInterFrameSpacingFor(aFrame-&gt;StyleFont()-&gt;mScriptLevel,</span>
<span class="lineNum">    1403 </span><span class="lineCov">          1 :                                   parent, aFrame);</span>
<span class="lineNum">    1404 </span>            :     // add our own italic correction
<span class="lineNum">    1405 </span><span class="lineCov">          1 :     nscoord leftCorrection = 0, italicCorrection = 0;</span>
<span class="lineNum">    1406 </span>            :     aFrame-&gt;GetItalicCorrection(aDesiredSize.mBoundingMetrics,
<span class="lineNum">    1407 </span><span class="lineCov">          1 :                                 leftCorrection, italicCorrection);</span>
<span class="lineNum">    1408 </span><span class="lineCov">          1 :     gap += leftCorrection;</span>
<span class="lineNum">    1409 </span><span class="lineCov">          1 :     if (gap) {</span>
<span class="lineNum">    1410 </span><span class="lineCov">          1 :       aDesiredSize.mBoundingMetrics.leftBearing += gap;</span>
<span class="lineNum">    1411 </span><span class="lineCov">          1 :       aDesiredSize.mBoundingMetrics.rightBearing += gap;</span>
<span class="lineNum">    1412 </span><span class="lineCov">          1 :       aDesiredSize.mBoundingMetrics.width += gap;</span>
<span class="lineNum">    1413 </span><span class="lineCov">          1 :       aDesiredSize.Width() += gap;</span>
<span class="lineNum">    1414 </span>            :     }
<span class="lineNum">    1415 </span><span class="lineCov">          1 :     aDesiredSize.mBoundingMetrics.width += italicCorrection;</span>
<span class="lineNum">    1416 </span><span class="lineCov">          1 :     aDesiredSize.Width() += italicCorrection;</span>
<span class="lineNum">    1417 </span>            :   }
<span class="lineNum">    1418 </span><span class="lineCov">          1 :   return gap;</span>
<span class="lineNum">    1419 </span>            : }
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<span class="lineNum">    1421 </span>            : nscoord
<span class="lineNum">    1422 </span><span class="lineCov">          1 : nsMathMLContainerFrame::FixInterFrameSpacing(ReflowOutput&amp; aDesiredSize)</span>
<span class="lineNum">    1423 </span>            : {
<span class="lineNum">    1424 </span><span class="lineCov">          1 :   nscoord gap = 0;</span>
<span class="lineNum">    1425 </span><span class="lineCov">          1 :   gap = AddInterFrameSpacingToSize(aDesiredSize, this);</span>
<span class="lineNum">    1426 </span><span class="lineCov">          1 :   if (gap) {</span>
<span class="lineNum">    1427 </span>            :     // Shift our children to account for the correction
<span class="lineNum">    1428 </span><span class="lineCov">          1 :     nsIFrame* childFrame = mFrames.FirstChild();</span>
<span class="lineNum">    1429 </span><span class="lineCov">          1 :     while (childFrame) {</span>
<span class="lineNum">    1430 </span><span class="lineCov">          1 :       childFrame-&gt;SetPosition(childFrame-&gt;GetPosition() + nsPoint(gap, 0));</span>
<span class="lineNum">    1431 </span><span class="lineCov">          1 :       childFrame = childFrame-&gt;GetNextSibling();</span>
<span class="lineNum">    1432 </span>            :     }
<span class="lineNum">    1433 </span>            :   }
<span class="lineNum">    1434 </span><span class="lineCov">          1 :   return gap;</span>
<span class="lineNum">    1435 </span>            : }
<a name="1436"><span class="lineNum">    1436 </span>            : </a>
<span class="lineNum">    1437 </span>            : /* static */ void
<span class="lineNum">    1438 </span><span class="lineCov">          1 : nsMathMLContainerFrame::DidReflowChildren(nsIFrame* aFirst, nsIFrame* aStop)</span>
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            : {
<span class="lineNum">    1441 </span><span class="lineCov">          1 :   if (MOZ_UNLIKELY(!aFirst))</span>
<span class="lineNum">    1442 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span><span class="lineCov">          1 :   for (nsIFrame* frame = aFirst;</span>
<span class="lineNum">    1445 </span>            :        frame != aStop;
<span class="lineNum">    1446 </span>            :        frame = frame-&gt;GetNextSibling()) {
<span class="lineNum">    1447 </span>            :     NS_ASSERTION(frame, &quot;aStop isn't a sibling&quot;);
<span class="lineNum">    1448 </span><span class="lineCov">          1 :     if (frame-&gt;GetStateBits() &amp; NS_FRAME_IN_REFLOW) {</span>
<span class="lineNum">    1449 </span>            :       // finish off principal descendants, too
<span class="lineNum">    1450 </span><span class="lineCov">          1 :       nsIFrame* grandchild = frame-&gt;PrincipalChildList().FirstChild();</span>
<span class="lineNum">    1451 </span><span class="lineCov">          1 :       if (grandchild)</span>
<span class="lineNum">    1452 </span><span class="lineCov">          1 :         DidReflowChildren(grandchild, nullptr);</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            :       frame-&gt;DidReflow(frame-&gt;PresContext(), nullptr,
<span class="lineNum">    1455 </span><span class="lineCov">          1 :                        nsDidReflowStatus::FINISHED);</span>
<span class="lineNum">    1456 </span>            :     }
<span class="lineNum">    1457 </span>            :   }
<span class="lineNum">    1458 </span>            : }
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            : // helper used by mstyle, mphantom, mpadded and mrow in their implementations
<a name="1461"><span class="lineNum">    1461 </span>            : // of TransmitAutomaticData().</a>
<span class="lineNum">    1462 </span>            : nsresult
<span class="lineNum">    1463 </span><span class="lineCov">          1 : nsMathMLContainerFrame::TransmitAutomaticDataForMrowLikeElement()</span>
<span class="lineNum">    1464 </span>            : {
<span class="lineNum">    1465 </span>            :   //
<span class="lineNum">    1466 </span>            :   // One loop to check both conditions below:
<span class="lineNum">    1467 </span>            :   //
<span class="lineNum">    1468 </span>            :   // 1) whether all the children of the mrow-like element are space-like.
<span class="lineNum">    1469 </span>            :   //
<span class="lineNum">    1470 </span>            :   //   The REC defines the following elements to be &quot;space-like&quot;:
<span class="lineNum">    1471 </span>            :   //   * an mstyle, mphantom, or mpadded element, all of whose direct
<span class="lineNum">    1472 </span>            :   //     sub-expressions are space-like;
<span class="lineNum">    1473 </span>            :   //   * an mrow all of whose direct sub-expressions are space-like.
<span class="lineNum">    1474 </span>            :   //
<span class="lineNum">    1475 </span>            :   // 2) whether all but one child of the mrow-like element are space-like and
<span class="lineNum">    1476 </span>            :   //    this non-space-like child is an embellished operator.
<span class="lineNum">    1477 </span>            :   //
<span class="lineNum">    1478 </span>            :   //   The REC defines the following elements to be embellished operators:
<span class="lineNum">    1479 </span>            :   //   * one of the elements mstyle, mphantom, or mpadded, such that an mrow
<span class="lineNum">    1480 </span>            :   //     containing the same arguments would be an embellished operator;
<span class="lineNum">    1481 </span>            :   //   * an mrow whose arguments consist (in any order) of one embellished
<span class="lineNum">    1482 </span>            :   //     operator and zero or more space-like elements.
<span class="lineNum">    1483 </span>            :   //
<span class="lineNum">    1484 </span>            :   nsIFrame *childFrame, *baseFrame;
<span class="lineNum">    1485 </span><span class="lineCov">          1 :   bool embellishedOpFound = false;</span>
<span class="lineNum">    1486 </span><span class="lineCov">          1 :   nsEmbellishData embellishData;</span>
<span class="lineNum">    1487 </span>            :   
<span class="lineNum">    1488 </span><span class="lineCov">          1 :   for (childFrame = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    1489 </span>            :        childFrame;
<span class="lineNum">    1490 </span>            :        childFrame = childFrame-&gt;GetNextSibling()) {
<span class="lineNum">    1491 </span><span class="lineCov">          1 :     nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);</span>
<span class="lineNum">    1492 </span><span class="lineCov">          1 :     if (!mathMLFrame) break;</span>
<span class="lineNum">    1493 </span><span class="lineCov">          1 :     if (!mathMLFrame-&gt;IsSpaceLike()) {</span>
<span class="lineNum">    1494 </span><span class="lineCov">          1 :       if (embellishedOpFound) break;</span>
<span class="lineNum">    1495 </span><span class="lineCov">          1 :       baseFrame = childFrame;</span>
<span class="lineNum">    1496 </span><span class="lineCov">          1 :       GetEmbellishDataFrom(baseFrame, embellishData);</span>
<span class="lineNum">    1497 </span><span class="lineCov">          1 :       if (!NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags)) break;</span>
<span class="lineNum">    1498 </span>            :       embellishedOpFound = true;
<span class="lineNum">    1499 </span>            :     }
<span class="lineNum">    1500 </span>            :   }
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span><span class="lineCov">          1 :   if (!childFrame) {</span>
<span class="lineNum">    1503 </span>            :     // we successfully went to the end of the loop. This means that one of
<span class="lineNum">    1504 </span>            :     // condition 1) or 2) holds.
<span class="lineNum">    1505 </span><span class="lineCov">          1 :     if (!embellishedOpFound) {</span>
<span class="lineNum">    1506 </span>            :       // the mrow-like element is space-like.
<span class="lineNum">    1507 </span><span class="lineCov">          1 :       mPresentationData.flags |= NS_MATHML_SPACE_LIKE;</span>
<span class="lineNum">    1508 </span>            :     } else {
<span class="lineNum">    1509 </span>            :       // the mrow-like element is an embellished operator.
<span class="lineNum">    1510 </span>            :       // let the state of the embellished operator found bubble to us.
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :       mPresentationData.baseFrame = baseFrame;</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :       mEmbellishData = embellishData;</span>
<span class="lineNum">    1513 </span>            :     }
<span class="lineNum">    1514 </span>            :   }
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineCov">          1 :   if (childFrame || !embellishedOpFound) {</span>
<span class="lineNum">    1517 </span>            :     // The element is not embellished operator
<span class="lineNum">    1518 </span><span class="lineCov">          1 :     mPresentationData.baseFrame = nullptr;</span>
<span class="lineNum">    1519 </span><span class="lineCov">          1 :     mEmbellishData.flags = 0;</span>
<span class="lineNum">    1520 </span><span class="lineCov">          1 :     mEmbellishData.coreFrame = nullptr;</span>
<span class="lineNum">    1521 </span><span class="lineCov">          1 :     mEmbellishData.direction = NS_STRETCH_DIRECTION_UNSUPPORTED;</span>
<span class="lineNum">    1522 </span><span class="lineCov">          1 :     mEmbellishData.leadingSpace = 0;</span>
<span class="lineNum">    1523 </span><span class="lineCov">          1 :     mEmbellishData.trailingSpace = 0;</span>
<span class="lineNum">    1524 </span>            :   }
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span><span class="lineCov">          1 :   if (childFrame || embellishedOpFound) {</span>
<span class="lineNum">    1527 </span>            :     // The element is not space-like
<span class="lineNum">    1528 </span><span class="lineCov">          1 :     mPresentationData.flags &amp;= ~NS_MATHML_SPACE_LIKE;</span>
<span class="lineNum">    1529 </span>            :   }
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1532 </span>            : }
<a name="1533"><span class="lineNum">    1533 </span>            : </a>
<span class="lineNum">    1534 </span>            : /*static*/ void
<span class="lineNum">    1535 </span><span class="lineCov">          1 : nsMathMLContainerFrame::PropagateFrameFlagFor(nsIFrame* aFrame,</span>
<span class="lineNum">    1536 </span>            :                                               nsFrameState  aFlags)
<span class="lineNum">    1537 </span>            : {
<span class="lineNum">    1538 </span><span class="lineCov">          1 :   if (!aFrame || !aFlags)</span>
<span class="lineNum">    1539 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            :   aFrame-&gt;AddStateBits(aFlags);
<span class="lineNum">    1542 </span><span class="lineCov">          1 :   for (nsIFrame* childFrame : aFrame-&gt;PrincipalChildList()) {</span>
<span class="lineNum">    1543 </span><span class="lineCov">          1 :     PropagateFrameFlagFor(childFrame, aFlags);</span>
<span class="lineNum">    1544 </span>            :   }
<span class="lineNum">    1545 </span>            : }
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<span class="lineNum">    1547 </span>            : nsresult
<span class="lineNum">    1548 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ReportErrorToConsole(const char*       errorMsgId,</span>
<span class="lineNum">    1549 </span>            :                                              const char16_t** aParams,
<span class="lineNum">    1550 </span>            :                                              uint32_t          aParamCount)
<span class="lineNum">    1551 </span>            : {
<span class="lineNum">    1552 </span>            :   return nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
<span class="lineNum">    1553 </span><span class="lineCov">          1 :                                          NS_LITERAL_CSTRING(&quot;Layout: MathML&quot;), mContent-&gt;OwnerDoc(),</span>
<span class="lineNum">    1554 </span>            :                                          nsContentUtils::eMATHML_PROPERTIES,
<span class="lineNum">    1555 </span><span class="lineCov">          1 :                                          errorMsgId, aParams, aParamCount);</span>
<span class="lineNum">    1556 </span>            : }
<a name="1557"><span class="lineNum">    1557 </span>            : </a>
<span class="lineNum">    1558 </span>            : nsresult
<span class="lineNum">    1559 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ReportParseError(const char16_t* aAttribute,</span>
<span class="lineNum">    1560 </span>            :                                          const char16_t* aValue)
<span class="lineNum">    1561 </span>            : {
<span class="lineNum">    1562 </span>            :   const char16_t* argv[] = 
<span class="lineNum">    1563 </span><span class="lineCov">          1 :     { aValue, aAttribute, mContent-&gt;NodeInfo()-&gt;NameAtom()-&gt;GetUTF16String() };</span>
<span class="lineNum">    1564 </span><span class="lineCov">          1 :   return ReportErrorToConsole(&quot;AttributeParsingError&quot;, argv, 3);</span>
<span class="lineNum">    1565 </span>            : }
<a name="1566"><span class="lineNum">    1566 </span>            : </a>
<span class="lineNum">    1567 </span>            : nsresult
<span class="lineNum">    1568 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ReportChildCountError()</span>
<span class="lineNum">    1569 </span>            : {
<span class="lineNum">    1570 </span><span class="lineCov">          1 :   const char16_t* arg = mContent-&gt;NodeInfo()-&gt;NameAtom()-&gt;GetUTF16String();</span>
<span class="lineNum">    1571 </span><span class="lineCov">          1 :   return ReportErrorToConsole(&quot;ChildCountIncorrect&quot;, &amp;arg, 1);</span>
<span class="lineNum">    1572 </span>            : }
<a name="1573"><span class="lineNum">    1573 </span>            : </a>
<span class="lineNum">    1574 </span>            : nsresult
<span class="lineNum">    1575 </span><span class="lineCov">          1 : nsMathMLContainerFrame::ReportInvalidChildError(nsIAtom* aChildTag)</span>
<span class="lineNum">    1576 </span>            : {
<span class="lineNum">    1577 </span>            :   const char16_t* argv[] =
<span class="lineNum">    1578 </span><span class="lineCov">          1 :     { aChildTag-&gt;GetUTF16String(),</span>
<span class="lineNum">    1579 </span><span class="lineCov">          1 :       mContent-&gt;NodeInfo()-&gt;NameAtom()-&gt;GetUTF16String() };</span>
<span class="lineNum">    1580 </span><span class="lineCov">          1 :   return ReportErrorToConsole(&quot;InvalidChild&quot;, argv, 2);</span>
<span class="lineNum">    1581 </span>            : }
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span>            : //==========================
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<span class="lineNum">    1585 </span>            : nsContainerFrame*
<span class="lineNum">    1586 </span><span class="lineCov">          1 : NS_NewMathMLmathBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)</span>
<span class="lineNum">    1587 </span>            : {
<span class="lineNum">    1588 </span><span class="lineCov">          1 :   return new (aPresShell) nsMathMLmathBlockFrame(aContext);</span>
<a name="1589"><span class="lineNum">    1589 </span>            : }</a>
<span class="lineNum">    1590 </span>            : 
<a name="1591"><span class="lineNum">    1591 </span><span class="lineCov">          1 : NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmathBlockFrame)</span></a>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineCov">          1 : NS_QUERYFRAME_HEAD(nsMathMLmathBlockFrame)</span>
<span class="lineNum">    1594 </span>            :   NS_QUERYFRAME_ENTRY(nsMathMLmathBlockFrame)
<span class="lineNum">    1595 </span><span class="lineCov">          1 : NS_QUERYFRAME_TAIL_INHERITING(nsBlockFrame)</span>
<a name="1596"><span class="lineNum">    1596 </span>            : </a>
<span class="lineNum">    1597 </span>            : nsContainerFrame*
<span class="lineNum">    1598 </span><span class="lineCov">          1 : NS_NewMathMLmathInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)</span>
<span class="lineNum">    1599 </span>            : {
<span class="lineNum">    1600 </span><span class="lineCov">          1 :   return new (aPresShell) nsMathMLmathInlineFrame(aContext);</span>
<a name="1601"><span class="lineNum">    1601 </span>            : }</a>
<span class="lineNum">    1602 </span>            : 
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">          1 : NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmathInlineFrame)</span></a>
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span><span class="lineCov">          1 : NS_QUERYFRAME_HEAD(nsMathMLmathInlineFrame)</span>
<span class="lineNum">    1606 </span><span class="lineCov">          1 :   NS_QUERYFRAME_ENTRY(nsIMathMLFrame)</span>
<span class="lineNum">    1607 </span><span class="lineCov">          1 : NS_QUERYFRAME_TAIL_INHERITING(nsInlineFrame)</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
