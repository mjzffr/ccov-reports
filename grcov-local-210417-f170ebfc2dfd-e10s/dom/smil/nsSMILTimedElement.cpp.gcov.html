<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - dom/smil/nsSMILTimedElement.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dom/smil</a> - nsSMILTimedElement.cpp<span style="font-size: 80%;"> (source / <a href="nsSMILTimedElement.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">783</td>
            <td class="headerCovTableEntry">825</td>
            <td class="headerCovTableEntryHi">94.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">96</td>
            <td class="headerCovTableEntry">102</td>
            <td class="headerCovTableEntryHi">94.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/ContentEvents.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/EventDispatcher.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/dom/SVGAnimationElement.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsAutoPtr.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsSMILTimedElement.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsAttrValueInlines.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsSMILAnimationFunction.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsSMILTimeValue.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsSMILTimeValueSpec.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsSMILInstanceTime.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsSMILParserUtils.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsSMILTimeContainer.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsReadableUtils.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsMathUtils.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsThreadUtils.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIPresShell.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;prdtoa.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;plstr.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;prtime.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;mozilla/AutoRestore.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsCharSeparatedTokenizer.h&quot;
<span class="lineNum">      32 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : using namespace mozilla;
<span class="lineNum">      35 </span>            : using namespace mozilla::dom;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : //----------------------------------------------------------------------
<span class="lineNum">      38 </span>            : // Helper class: InstanceTimeComparator
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : // Upon inserting an instance time into one of our instance time lists we assign
<span class="lineNum">      41 </span>            : // it a serial number. This allows us to sort the instance times in such a way
<span class="lineNum">      42 </span>            : // that where we have several equal instance times, the ones added later will
<span class="lineNum">      43 </span>            : // sort later. This means that when we call UpdateCurrentInterval during the
<span class="lineNum">      44 </span>            : // waiting state we won't unnecessarily change the begin instance.
<span class="lineNum">      45 </span>            : //
<span class="lineNum">      46 </span>            : // The serial number also means that every instance time has an unambiguous
<a name="47"><span class="lineNum">      47 </span>            : // position in the array so we can use RemoveElementSorted and the like.</a>
<span class="lineNum">      48 </span>            : bool
<span class="lineNum">      49 </span><span class="lineNoCov">          0 : nsSMILTimedElement::InstanceTimeComparator::Equals(</span>
<span class="lineNum">      50 </span>            :     const nsSMILInstanceTime* aElem1,
<span class="lineNum">      51 </span>            :     const nsSMILInstanceTime* aElem2) const
<span class="lineNum">      52 </span>            : {
<span class="lineNum">      53 </span>            :   MOZ_ASSERT(aElem1 &amp;&amp; aElem2,
<span class="lineNum">      54 </span>            :              &quot;Trying to compare null instance time pointers&quot;);
<span class="lineNum">      55 </span>            :   MOZ_ASSERT(aElem1-&gt;Serial() &amp;&amp; aElem2-&gt;Serial(),
<span class="lineNum">      56 </span>            :              &quot;Instance times have not been assigned serial numbers&quot;);
<span class="lineNum">      57 </span>            :   MOZ_ASSERT(aElem1 == aElem2 || aElem1-&gt;Serial() != aElem2-&gt;Serial(),
<span class="lineNum">      58 </span>            :              &quot;Serial numbers are not unique&quot;);
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span><span class="lineCov">          1 :   return aElem1-&gt;Serial() == aElem2-&gt;Serial();</span>
<span class="lineNum">      61 </span>            : }
<a name="62"><span class="lineNum">      62 </span>            : </a>
<span class="lineNum">      63 </span>            : bool
<span class="lineNum">      64 </span><span class="lineCov">          1 : nsSMILTimedElement::InstanceTimeComparator::LessThan(</span>
<span class="lineNum">      65 </span>            :     const nsSMILInstanceTime* aElem1,
<span class="lineNum">      66 </span>            :     const nsSMILInstanceTime* aElem2) const
<span class="lineNum">      67 </span>            : {
<span class="lineNum">      68 </span>            :   MOZ_ASSERT(aElem1 &amp;&amp; aElem2,
<span class="lineNum">      69 </span>            :              &quot;Trying to compare null instance time pointers&quot;);
<span class="lineNum">      70 </span>            :   MOZ_ASSERT(aElem1-&gt;Serial() &amp;&amp; aElem2-&gt;Serial(),
<span class="lineNum">      71 </span>            :              &quot;Instance times have not been assigned serial numbers&quot;);
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineCov">          1 :   int8_t cmp = aElem1-&gt;Time().CompareTo(aElem2-&gt;Time());</span>
<span class="lineNum">      74 </span><span class="lineCov">          1 :   return cmp == 0 ? aElem1-&gt;Serial() &lt; aElem2-&gt;Serial() : cmp &lt; 0;</span>
<span class="lineNum">      75 </span>            : }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : //----------------------------------------------------------------------
<span class="lineNum">      78 </span>            : // Helper class: AsyncTimeEventRunner
<span class="lineNum">      79 </span>            : 
<a name="80"><span class="lineNum">      80 </span>            : namespace</a>
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span><span class="lineCov">          1 :   class AsyncTimeEventRunner : public Runnable</span>
<span class="lineNum">      83 </span>            :   {
<span class="lineNum">      84 </span>            :   protected:
<span class="lineNum">      85 </span>            :     RefPtr&lt;nsIContent&gt; mTarget;
<span class="lineNum">      86 </span>            :     EventMessage         mMsg;
<span class="lineNum">      87 </span>            :     int32_t              mDetail;
<a name="88"><span class="lineNum">      88 </span>            : </a>
<span class="lineNum">      89 </span>            :   public:
<span class="lineNum">      90 </span><span class="lineCov">          1 :     AsyncTimeEventRunner(nsIContent* aTarget, EventMessage aMsg,</span>
<span class="lineNum">      91 </span>            :                          int32_t aDetail)
<span class="lineNum">      92 </span>            :       : mTarget(aTarget)
<span class="lineNum">      93 </span>            :       , mMsg(aMsg)
<span class="lineNum">      94 </span><span class="lineCov">          1 :       , mDetail(aDetail)</span>
<span class="lineNum">      95 </span>            :     {
<a name="96"><span class="lineNum">      96 </span><span class="lineCov">          1 :     }</span></a>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineCov">          1 :     NS_IMETHOD Run() override</span>
<span class="lineNum">      99 </span>            :     {
<span class="lineNum">     100 </span><span class="lineCov">          1 :       InternalSMILTimeEvent event(true, mMsg);</span>
<span class="lineNum">     101 </span><span class="lineCov">          1 :       event.mDetail = mDetail;</span>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span><span class="lineCov">          1 :       nsPresContext* context = nullptr;</span>
<span class="lineNum">     104 </span><span class="lineCov">          1 :       nsIDocument* doc = mTarget-&gt;GetUncomposedDoc();</span>
<span class="lineNum">     105 </span><span class="lineCov">          1 :       if (doc) {</span>
<span class="lineNum">     106 </span><span class="lineCov">          1 :         nsCOMPtr&lt;nsIPresShell&gt; shell = doc-&gt;GetShell();</span>
<span class="lineNum">     107 </span><span class="lineCov">          1 :         if (shell) {</span>
<span class="lineNum">     108 </span><span class="lineCov">          1 :           context = shell-&gt;GetPresContext();</span>
<span class="lineNum">     109 </span>            :         }
<span class="lineNum">     110 </span>            :       }
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineCov">          1 :       return EventDispatcher::Dispatch(mTarget, context, &amp;event);</span>
<span class="lineNum">     113 </span>            :     }
<span class="lineNum">     114 </span>            :   };
<span class="lineNum">     115 </span>            : } // namespace
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     118 </span>            : // Helper class: AutoIntervalUpdateBatcher
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : // Stack-based helper class to set the mDeferIntervalUpdates flag on an
<span class="lineNum">     121 </span>            : // nsSMILTimedElement and perform the UpdateCurrentInterval when the object is
<span class="lineNum">     122 </span>            : // destroyed.
<span class="lineNum">     123 </span>            : //
<span class="lineNum">     124 </span>            : // If several of these objects are allocated on the stack, the update will not
<span class="lineNum">     125 </span>            : // be performed until the last object for a given nsSMILTimedElement is
<span class="lineNum">     126 </span>            : // destroyed.
<span class="lineNum">     127 </span>            : class MOZ_STACK_CLASS nsSMILTimedElement::AutoIntervalUpdateBatcher
<span class="lineNum">     128 </span>            : {
<span class="lineNum">     129 </span>            : public:
<span class="lineNum">     130 </span>            :   explicit AutoIntervalUpdateBatcher(nsSMILTimedElement&amp; aTimedElement)
<span class="lineNum">     131 </span>            :     : mTimedElement(aTimedElement),
<span class="lineNum">     132 </span><span class="lineCov">          1 :       mDidSetFlag(!aTimedElement.mDeferIntervalUpdates)</span>
<span class="lineNum">     133 </span>            :   {
<span class="lineNum">     134 </span><span class="lineCov">          1 :     mTimedElement.mDeferIntervalUpdates = true;</span>
<a name="135"><span class="lineNum">     135 </span>            :   }</a>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineCov">          1 :   ~AutoIntervalUpdateBatcher()</span>
<span class="lineNum">     138 </span>            :   {
<span class="lineNum">     139 </span><span class="lineCov">          1 :     if (!mDidSetFlag)</span>
<span class="lineNum">     140 </span>            :       return;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineCov">          1 :     mTimedElement.mDeferIntervalUpdates = false;</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineCov">          1 :     if (mTimedElement.mDoDeferredUpdate) {</span>
<span class="lineNum">     145 </span><span class="lineCov">          1 :       mTimedElement.mDoDeferredUpdate = false;</span>
<span class="lineNum">     146 </span><span class="lineCov">          1 :       mTimedElement.UpdateCurrentInterval();</span>
<span class="lineNum">     147 </span>            :     }
<span class="lineNum">     148 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : private:
<span class="lineNum">     151 </span>            :   nsSMILTimedElement&amp; mTimedElement;
<span class="lineNum">     152 </span>            :   bool mDidSetFlag;
<span class="lineNum">     153 </span>            : };
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     156 </span>            : // Helper class: AutoIntervalUpdater
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : // Stack-based helper class to call UpdateCurrentInterval when it is destroyed
<span class="lineNum">     159 </span>            : // which helps avoid bugs where we forget to call UpdateCurrentInterval in the
<span class="lineNum">     160 </span>            : // case of early returns (e.g. due to parse errors).
<span class="lineNum">     161 </span>            : //
<span class="lineNum">     162 </span>            : // This can be safely used in conjunction with AutoIntervalUpdateBatcher; any
<span class="lineNum">     163 </span>            : // calls to UpdateCurrentInterval made by this class will simply be deferred if
<span class="lineNum">     164 </span>            : // there is an AutoIntervalUpdateBatcher on the stack.
<span class="lineNum">     165 </span>            : class MOZ_STACK_CLASS nsSMILTimedElement::AutoIntervalUpdater
<span class="lineNum">     166 </span>            : {
<span class="lineNum">     167 </span>            : public:
<span class="lineNum">     168 </span>            :   explicit AutoIntervalUpdater(nsSMILTimedElement&amp; aTimedElement)
<a name="169"><span class="lineNum">     169 </span><span class="lineCov">          1 :     : mTimedElement(aTimedElement) { }</span></a>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineCov">          1 :   ~AutoIntervalUpdater()</span>
<span class="lineNum">     172 </span>            :   {
<span class="lineNum">     173 </span><span class="lineCov">          1 :     mTimedElement.UpdateCurrentInterval();</span>
<span class="lineNum">     174 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : private:
<span class="lineNum">     177 </span>            :   nsSMILTimedElement&amp; mTimedElement;
<span class="lineNum">     178 </span>            : };
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     181 </span>            : // Templated helper functions
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : // Selectively remove elements from an array of type
<span class="lineNum">     184 </span>            : // nsTArray&lt;RefPtr&lt;nsSMILInstanceTime&gt; &gt; with O(n) performance.
<a name="185"><span class="lineNum">     185 </span>            : template &lt;class TestFunctor&gt;</a>
<span class="lineNum">     186 </span>            : void
<span class="lineNum">     187 </span><span class="lineCov">          1 : nsSMILTimedElement::RemoveInstanceTimes(InstanceTimeList&amp; aArray,</span>
<span class="lineNum">     188 </span>            :                                         TestFunctor&amp; aTest)
<span class="lineNum">     189 </span>            : {
<span class="lineNum">     190 </span>            :   InstanceTimeList newArray;
<span class="lineNum">     191 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; aArray.Length(); ++i) {</span>
<span class="lineNum">     192 </span><span class="lineCov">          1 :     nsSMILInstanceTime* item = aArray[i].get();</span>
<span class="lineNum">     193 </span><span class="lineCov">          1 :     if (aTest(item, i)) {</span>
<span class="lineNum">     194 </span>            :       // As per bugs 665334 and 669225 we should be careful not to remove the
<span class="lineNum">     195 </span>            :       // instance time that corresponds to the previous interval's end time.
<span class="lineNum">     196 </span>            :       //
<span class="lineNum">     197 </span>            :       // Most functors supplied here fulfil this condition by checking if the
<span class="lineNum">     198 </span>            :       // instance time is marked as &quot;ShouldPreserve&quot; and if so, not deleting it.
<span class="lineNum">     199 </span>            :       //
<span class="lineNum">     200 </span>            :       // However, when filtering instance times, we sometimes need to drop even
<span class="lineNum">     201 </span>            :       // instance times marked as &quot;ShouldPreserve&quot;. In that case we take special
<span class="lineNum">     202 </span>            :       // care not to delete the end instance time of the previous interval.
<span class="lineNum">     203 </span>            :       MOZ_ASSERT(!GetPreviousInterval() || item != GetPreviousInterval()-&gt;End(),
<span class="lineNum">     204 </span>            :                  &quot;Removing end instance time of previous interval&quot;);
<span class="lineNum">     205 </span><span class="lineCov">          1 :       item-&gt;Unlink();</span>
<span class="lineNum">     206 </span>            :     } else {
<span class="lineNum">     207 </span><span class="lineCov">          1 :       newArray.AppendElement(item);</span>
<span class="lineNum">     208 </span>            :     }
<span class="lineNum">     209 </span>            :   }
<span class="lineNum">     210 </span><span class="lineCov">          1 :   aArray.Clear();</span>
<span class="lineNum">     211 </span><span class="lineCov">          1 :   aArray.SwapElements(newArray);</span>
<span class="lineNum">     212 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     215 </span>            : // Static members
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : nsAttrValue::EnumTable nsSMILTimedElement::sFillModeTable[] = {
<span class="lineNum">     218 </span>            :       {&quot;remove&quot;, FILL_REMOVE},
<span class="lineNum">     219 </span>            :       {&quot;freeze&quot;, FILL_FREEZE},
<span class="lineNum">     220 </span>            :       {nullptr, 0}
<span class="lineNum">     221 </span>            : };
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : nsAttrValue::EnumTable nsSMILTimedElement::sRestartModeTable[] = {
<span class="lineNum">     224 </span>            :       {&quot;always&quot;, RESTART_ALWAYS},
<span class="lineNum">     225 </span>            :       {&quot;whenNotActive&quot;, RESTART_WHENNOTACTIVE},
<span class="lineNum">     226 </span>            :       {&quot;never&quot;, RESTART_NEVER},
<span class="lineNum">     227 </span>            :       {nullptr, 0}
<span class="lineNum">     228 </span>            : };
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : const nsSMILMilestone nsSMILTimedElement::sMaxMilestone(INT64_MAX, false);
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : // The thresholds at which point we start filtering intervals and instance times
<span class="lineNum">     233 </span>            : // indiscriminately.
<span class="lineNum">     234 </span>            : // See FilterIntervals and FilterInstanceTimes.
<span class="lineNum">     235 </span>            : const uint8_t nsSMILTimedElement::sMaxNumIntervals = 20;
<span class="lineNum">     236 </span>            : const uint8_t nsSMILTimedElement::sMaxNumInstanceTimes = 100;
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : // Detect if we arrive in some sort of undetected recursive syncbase dependency
<span class="lineNum">     239 </span>            : // relationship
<span class="lineNum">     240 </span>            : const uint8_t nsSMILTimedElement::sMaxUpdateIntervalRecursionDepth = 20;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : //----------------------------------------------------------------------
<a name="243"><span class="lineNum">     243 </span>            : // Ctor, dtor</a>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineCov">          1 : nsSMILTimedElement::nsSMILTimedElement()</span>
<span class="lineNum">     246 </span>            : :
<span class="lineNum">     247 </span>            :   mAnimationElement(nullptr),
<span class="lineNum">     248 </span>            :   mFillMode(FILL_REMOVE),
<span class="lineNum">     249 </span>            :   mRestartMode(RESTART_ALWAYS),
<span class="lineNum">     250 </span>            :   mInstanceSerialIndex(0),
<span class="lineNum">     251 </span>            :   mClient(nullptr),
<span class="lineNum">     252 </span>            :   mCurrentInterval(nullptr),
<span class="lineNum">     253 </span>            :   mCurrentRepeatIteration(0),
<span class="lineNum">     254 </span>            :   mPrevRegisteredMilestone(sMaxMilestone),
<span class="lineNum">     255 </span>            :   mElementState(STATE_STARTUP),
<span class="lineNum">     256 </span>            :   mSeekState(SEEK_NOT_SEEKING),
<span class="lineNum">     257 </span>            :   mDeferIntervalUpdates(false),
<span class="lineNum">     258 </span>            :   mDoDeferredUpdate(false),
<span class="lineNum">     259 </span>            :   mIsDisabled(false),
<span class="lineNum">     260 </span>            :   mDeleteCount(0),
<span class="lineNum">     261 </span><span class="lineCov">          1 :   mUpdateIntervalRecursionDepth(0)</span>
<span class="lineNum">     262 </span>            : {
<span class="lineNum">     263 </span><span class="lineCov">          1 :   mSimpleDur.SetIndefinite();</span>
<span class="lineNum">     264 </span><span class="lineCov">          1 :   mMin.SetMillis(0L);</span>
<span class="lineNum">     265 </span><span class="lineCov">          1 :   mMax.SetIndefinite();</span>
<a name="266"><span class="lineNum">     266 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineCov">          1 : nsSMILTimedElement::~nsSMILTimedElement()</span>
<span class="lineNum">     269 </span>            : {
<span class="lineNum">     270 </span>            :   // Unlink all instance times from dependent intervals
<span class="lineNum">     271 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; mBeginInstances.Length(); ++i) {</span>
<span class="lineNum">     272 </span><span class="lineCov">          1 :     mBeginInstances[i]-&gt;Unlink();</span>
<span class="lineNum">     273 </span>            :   }
<span class="lineNum">     274 </span><span class="lineCov">          1 :   mBeginInstances.Clear();</span>
<span class="lineNum">     275 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; mEndInstances.Length(); ++i) {</span>
<span class="lineNum">     276 </span><span class="lineCov">          1 :     mEndInstances[i]-&gt;Unlink();</span>
<span class="lineNum">     277 </span>            :   }
<span class="lineNum">     278 </span><span class="lineCov">          1 :   mEndInstances.Clear();</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :   // Notify anyone listening to our intervals that they're gone
<span class="lineNum">     281 </span>            :   // (We shouldn't get any callbacks from this because all our instance times
<span class="lineNum">     282 </span>            :   // are now disassociated with any intervals)
<span class="lineNum">     283 </span><span class="lineCov">          1 :   ClearIntervals();</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   // The following assertions are important in their own right (for checking
<span class="lineNum">     286 </span>            :   // correct behavior) but also because AutoIntervalUpdateBatcher holds pointers
<span class="lineNum">     287 </span>            :   // to class so if they fail there's the possibility we might have dangling
<span class="lineNum">     288 </span>            :   // pointers.
<span class="lineNum">     289 </span>            :   MOZ_ASSERT(!mDeferIntervalUpdates,
<span class="lineNum">     290 </span>            :              &quot;Interval updates should no longer be blocked when an &quot;
<span class="lineNum">     291 </span>            :              &quot;nsSMILTimedElement disappears&quot;);
<span class="lineNum">     292 </span>            :   MOZ_ASSERT(!mDoDeferredUpdate,
<span class="lineNum">     293 </span>            :              &quot;There should no longer be any pending updates when an &quot;
<span class="lineNum">     294 </span>            :              &quot;nsSMILTimedElement disappears&quot;);
<span class="lineNum">     295 </span><span class="lineCov">          1 : }</span>
<a name="296"><span class="lineNum">     296 </span>            : </a>
<span class="lineNum">     297 </span>            : void
<span class="lineNum">     298 </span><span class="lineCov">          1 : nsSMILTimedElement::SetAnimationElement(SVGAnimationElement* aElement)</span>
<span class="lineNum">     299 </span>            : {
<span class="lineNum">     300 </span>            :   MOZ_ASSERT(aElement, &quot;NULL owner element&quot;);
<span class="lineNum">     301 </span>            :   MOZ_ASSERT(!mAnimationElement, &quot;Re-setting owner&quot;);
<span class="lineNum">     302 </span><span class="lineCov">          1 :   mAnimationElement = aElement;</span>
<span class="lineNum">     303 </span><span class="lineCov">          1 : }</span>
<a name="304"><span class="lineNum">     304 </span>            : </a>
<span class="lineNum">     305 </span>            : nsSMILTimeContainer*
<span class="lineNum">     306 </span><span class="lineCov">          1 : nsSMILTimedElement::GetTimeContainer()</span>
<span class="lineNum">     307 </span>            : {
<span class="lineNum">     308 </span><span class="lineCov">          1 :   return mAnimationElement ? mAnimationElement-&gt;GetTimeContainer() : nullptr;</span>
<span class="lineNum">     309 </span>            : }
<a name="310"><span class="lineNum">     310 </span>            : </a>
<span class="lineNum">     311 </span>            : dom::Element*
<span class="lineNum">     312 </span><span class="lineCov">          1 : nsSMILTimedElement::GetTargetElement()</span>
<span class="lineNum">     313 </span>            : {
<span class="lineNum">     314 </span>            :   return mAnimationElement ?
<span class="lineNum">     315 </span>            :       mAnimationElement-&gt;GetTargetElementContent() :
<span class="lineNum">     316 </span><span class="lineCov">          1 :       nullptr;</span>
<span class="lineNum">     317 </span>            : }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     320 </span>            : // nsIDOMElementTimeControl methods
<span class="lineNum">     321 </span>            : //
<span class="lineNum">     322 </span>            : // The definition of the ElementTimeControl interface differs between SMIL
<span class="lineNum">     323 </span>            : // Animation and SVG 1.1. In SMIL Animation all methods have a void return
<span class="lineNum">     324 </span>            : // type and the new instance time is simply added to the list and restart
<span class="lineNum">     325 </span>            : // semantics are applied as with any other instance time. In the SVG definition
<span class="lineNum">     326 </span>            : // the methods return a bool depending on the restart mode.
<span class="lineNum">     327 </span>            : //
<span class="lineNum">     328 </span>            : // This inconsistency has now been addressed by an erratum in SVG 1.1:
<span class="lineNum">     329 </span>            : //
<span class="lineNum">     330 </span>            : // http://www.w3.org/2003/01/REC-SVG11-20030114-errata#elementtimecontrol-interface
<span class="lineNum">     331 </span>            : //
<span class="lineNum">     332 </span>            : // which favours the definition in SMIL, i.e. instance times are just added
<span class="lineNum">     333 </span>            : // without first checking the restart mode.
<a name="334"><span class="lineNum">     334 </span>            : </a>
<span class="lineNum">     335 </span>            : nsresult
<span class="lineNum">     336 </span><span class="lineCov">          1 : nsSMILTimedElement::BeginElementAt(double aOffsetSeconds)</span>
<span class="lineNum">     337 </span>            : {
<span class="lineNum">     338 </span><span class="lineCov">          1 :   nsSMILTimeContainer* container = GetTimeContainer();</span>
<span class="lineNum">     339 </span><span class="lineCov">          1 :   if (!container)</span>
<span class="lineNum">     340 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineCov">          1 :   nsSMILTime currentTime = container-&gt;GetCurrentTime();</span>
<span class="lineNum">     343 </span><span class="lineCov">          1 :   return AddInstanceTimeFromCurrentTime(currentTime, aOffsetSeconds, true);</span>
<span class="lineNum">     344 </span>            : }
<a name="345"><span class="lineNum">     345 </span>            : </a>
<span class="lineNum">     346 </span>            : nsresult
<span class="lineNum">     347 </span><span class="lineCov">          1 : nsSMILTimedElement::EndElementAt(double aOffsetSeconds)</span>
<span class="lineNum">     348 </span>            : {
<span class="lineNum">     349 </span><span class="lineCov">          1 :   nsSMILTimeContainer* container = GetTimeContainer();</span>
<span class="lineNum">     350 </span><span class="lineCov">          1 :   if (!container)</span>
<span class="lineNum">     351 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineCov">          1 :   nsSMILTime currentTime = container-&gt;GetCurrentTime();</span>
<span class="lineNum">     354 </span><span class="lineCov">          1 :   return AddInstanceTimeFromCurrentTime(currentTime, aOffsetSeconds, false);</span>
<span class="lineNum">     355 </span>            : }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     358 </span>            : // nsSVGAnimationElement methods
<a name="359"><span class="lineNum">     359 </span>            : </a>
<span class="lineNum">     360 </span>            : nsSMILTimeValue
<span class="lineNum">     361 </span><span class="lineCov">          1 : nsSMILTimedElement::GetStartTime() const</span>
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span><span class="lineCov">          1 :   return mElementState == STATE_WAITING || mElementState == STATE_ACTIVE</span>
<span class="lineNum">     364 </span><span class="lineCov">          1 :          ? mCurrentInterval-&gt;Begin()-&gt;Time()</span>
<span class="lineNum">     365 </span><span class="lineCov">          1 :          : nsSMILTimeValue();</span>
<span class="lineNum">     366 </span>            : }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     369 </span>            : // Hyperlinking support
<a name="370"><span class="lineNum">     370 </span>            : </a>
<span class="lineNum">     371 </span>            : nsSMILTimeValue
<span class="lineNum">     372 </span><span class="lineCov">          1 : nsSMILTimedElement::GetHyperlinkTime() const</span>
<span class="lineNum">     373 </span>            : {
<span class="lineNum">     374 </span>            :   nsSMILTimeValue hyperlinkTime; // Default ctor creates unresolved time
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineCov">          1 :   if (mElementState == STATE_ACTIVE) {</span>
<span class="lineNum">     377 </span><span class="lineCov">          1 :     hyperlinkTime = mCurrentInterval-&gt;Begin()-&gt;Time();</span>
<span class="lineNum">     378 </span><span class="lineCov">          1 :   } else if (!mBeginInstances.IsEmpty()) {</span>
<span class="lineNum">     379 </span><span class="lineCov">          1 :     hyperlinkTime = mBeginInstances[0]-&gt;Time();</span>
<span class="lineNum">     380 </span>            :   }
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineCov">          1 :   return hyperlinkTime;</span>
<span class="lineNum">     383 </span>            : }
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     386 </span>            : // nsSMILTimedElement
<a name="387"><span class="lineNum">     387 </span>            : </a>
<span class="lineNum">     388 </span>            : void
<span class="lineNum">     389 </span><span class="lineCov">          1 : nsSMILTimedElement::AddInstanceTime(nsSMILInstanceTime* aInstanceTime,</span>
<span class="lineNum">     390 </span>            :                                     bool aIsBegin)
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            :   MOZ_ASSERT(aInstanceTime, &quot;Attempting to add null instance time&quot;);
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   // Event-sensitivity: If an element is not active (but the parent time
<span class="lineNum">     395 </span>            :   // container is), then events are only handled for begin specifications.
<span class="lineNum">     396 </span><span class="lineCov">          1 :   if (mElementState != STATE_ACTIVE &amp;&amp; !aIsBegin &amp;&amp;</span>
<span class="lineNum">     397 </span><span class="lineCov">          1 :       aInstanceTime-&gt;IsDynamic())</span>
<span class="lineNum">     398 </span>            :   {
<span class="lineNum">     399 </span>            :     // No need to call Unlink here--dynamic instance times shouldn't be linked
<span class="lineNum">     400 </span>            :     // to anything that's going to miss them
<span class="lineNum">     401 </span>            :     MOZ_ASSERT(!aInstanceTime-&gt;GetBaseInterval(),
<span class="lineNum">     402 </span>            :                &quot;Dynamic instance time has a base interval--we probably need &quot;
<span class="lineNum">     403 </span>            :                &quot;to unlink it if we're not going to use it&quot;);
<span class="lineNum">     404 </span>            :     return;
<span class="lineNum">     405 </span>            :   }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">          1 :   aInstanceTime-&gt;SetSerial(++mInstanceSerialIndex);</span>
<span class="lineNum">     408 </span><span class="lineCov">          1 :   InstanceTimeList&amp; instanceList = aIsBegin ? mBeginInstances : mEndInstances;</span>
<span class="lineNum">     409 </span>            :   RefPtr&lt;nsSMILInstanceTime&gt;* inserted =
<span class="lineNum">     410 </span><span class="lineCov">          1 :     instanceList.InsertElementSorted(aInstanceTime, InstanceTimeComparator());</span>
<span class="lineNum">     411 </span><span class="lineCov">          1 :   if (!inserted) {</span>
<span class="lineNum">     412 </span>            :     NS_WARNING(&quot;Insufficient memory to insert instance time&quot;);
<span class="lineNum">     413 </span>            :     return;
<span class="lineNum">     414 </span>            :   }
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">     417 </span>            : }
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : void
<span class="lineNum">     420 </span><span class="lineCov">          1 : nsSMILTimedElement::UpdateInstanceTime(nsSMILInstanceTime* aInstanceTime,</span>
<span class="lineNum">     421 </span>            :                                        nsSMILTimeValue&amp; aUpdatedTime,
<span class="lineNum">     422 </span>            :                                        bool aIsBegin)
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span>            :   MOZ_ASSERT(aInstanceTime, &quot;Attempting to update null instance time&quot;);
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :   // The reason we update the time here and not in the nsSMILTimeValueSpec is
<span class="lineNum">     427 </span>            :   // that it means we *could* re-sort more efficiently by doing a sorted remove
<span class="lineNum">     428 </span>            :   // and insert but currently this doesn't seem to be necessary given how
<span class="lineNum">     429 </span>            :   // infrequently we get these change notices.
<span class="lineNum">     430 </span>            :   aInstanceTime-&gt;DependentUpdate(aUpdatedTime);
<span class="lineNum">     431 </span><span class="lineCov">          1 :   InstanceTimeList&amp; instanceList = aIsBegin ? mBeginInstances : mEndInstances;</span>
<span class="lineNum">     432 </span><span class="lineCov">          1 :   instanceList.Sort(InstanceTimeComparator());</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   // Generally speaking, UpdateCurrentInterval makes changes to the current
<span class="lineNum">     435 </span>            :   // interval and sends changes notices itself. However, in this case because
<span class="lineNum">     436 </span>            :   // instance times are shared between the instance time list and the intervals
<span class="lineNum">     437 </span>            :   // we are effectively changing the current interval outside
<span class="lineNum">     438 </span>            :   // UpdateCurrentInterval so we need to explicitly signal that we've made
<span class="lineNum">     439 </span>            :   // a change.
<span class="lineNum">     440 </span>            :   //
<span class="lineNum">     441 </span>            :   // This wouldn't be necessary if we cloned instance times on adding them to
<span class="lineNum">     442 </span>            :   // the current interval but this introduces other complications (particularly
<span class="lineNum">     443 </span>            :   // detecting which instance time is being used to define the begin of the
<span class="lineNum">     444 </span>            :   // current interval when doing a Reset).
<span class="lineNum">     445 </span><span class="lineCov">          1 :   bool changedCurrentInterval = mCurrentInterval &amp;&amp;</span>
<span class="lineNum">     446 </span><span class="lineCov">          1 :     (mCurrentInterval-&gt;Begin() == aInstanceTime ||</span>
<span class="lineNum">     447 </span><span class="lineCov">          1 :      mCurrentInterval-&gt;End() == aInstanceTime);</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineCov">          1 :   UpdateCurrentInterval(changedCurrentInterval);</span>
<span class="lineNum">     450 </span><span class="lineCov">          1 : }</span>
<a name="451"><span class="lineNum">     451 </span>            : </a>
<span class="lineNum">     452 </span>            : void
<span class="lineNum">     453 </span><span class="lineCov">          1 : nsSMILTimedElement::RemoveInstanceTime(nsSMILInstanceTime* aInstanceTime,</span>
<span class="lineNum">     454 </span>            :                                        bool aIsBegin)
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span>            :   MOZ_ASSERT(aInstanceTime, &quot;Attempting to remove null instance time&quot;);
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :   // If the instance time should be kept (because it is or was the fixed end
<span class="lineNum">     459 </span>            :   // point of an interval) then just disassociate it from the creator.
<span class="lineNum">     460 </span><span class="lineCov">          1 :   if (aInstanceTime-&gt;ShouldPreserve()) {</span>
<span class="lineNum">     461 </span><span class="lineCov">          1 :     aInstanceTime-&gt;Unlink();</span>
<span class="lineNum">     462 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     463 </span>            :   }
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineCov">          1 :   InstanceTimeList&amp; instanceList = aIsBegin ? mBeginInstances : mEndInstances;</span>
<span class="lineNum">     466 </span>            :   mozilla::DebugOnly&lt;bool&gt; found =
<span class="lineNum">     467 </span><span class="lineCov">          1 :     instanceList.RemoveElementSorted(aInstanceTime, InstanceTimeComparator());</span>
<span class="lineNum">     468 </span>            :   MOZ_ASSERT(found, &quot;Couldn't find instance time to delete&quot;);
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">     471 </span>            : }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : namespace
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span>            :   class MOZ_STACK_CLASS RemoveByCreator
<span class="lineNum">     476 </span>            :   {
<span class="lineNum">     477 </span>            :   public:
<span class="lineNum">     478 </span><span class="lineCov">          1 :     explicit RemoveByCreator(const nsSMILTimeValueSpec* aCreator) : mCreator(aCreator)</span>
<a name="479"><span class="lineNum">     479 </span>            :     { }</a>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">          1 :     bool operator()(nsSMILInstanceTime* aInstanceTime, uint32_t /*aIndex*/)</span>
<span class="lineNum">     482 </span>            :     {
<span class="lineNum">     483 </span><span class="lineCov">          1 :       if (aInstanceTime-&gt;GetCreator() != mCreator)</span>
<span class="lineNum">     484 </span>            :         return false;
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :       // If the instance time should be kept (because it is or was the fixed end
<span class="lineNum">     487 </span>            :       // point of an interval) then just disassociate it from the creator.
<span class="lineNum">     488 </span><span class="lineCov">          1 :       if (aInstanceTime-&gt;ShouldPreserve()) {</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :         aInstanceTime-&gt;Unlink();</span>
<span class="lineNum">     490 </span>            :         return false;
<span class="lineNum">     491 </span>            :       }
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :       return true;
<span class="lineNum">     494 </span>            :     }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :   private:
<span class="lineNum">     497 </span>            :     const nsSMILTimeValueSpec* mCreator;
<span class="lineNum">     498 </span>            :   };
<span class="lineNum">     499 </span>            : } // namespace
<a name="500"><span class="lineNum">     500 </span>            : </a>
<span class="lineNum">     501 </span>            : void
<span class="lineNum">     502 </span><span class="lineCov">          1 : nsSMILTimedElement::RemoveInstanceTimesForCreator(</span>
<span class="lineNum">     503 </span>            :     const nsSMILTimeValueSpec* aCreator, bool aIsBegin)
<span class="lineNum">     504 </span>            : {
<span class="lineNum">     505 </span>            :   MOZ_ASSERT(aCreator, &quot;Creator not set&quot;);
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">          1 :   InstanceTimeList&amp; instances = aIsBegin ? mBeginInstances : mEndInstances;</span>
<span class="lineNum">     508 </span>            :   RemoveByCreator removeByCreator(aCreator);
<span class="lineNum">     509 </span><span class="lineCov">          1 :   RemoveInstanceTimes(instances, removeByCreator);</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">     512 </span><span class="lineCov">          1 : }</span>
<a name="513"><span class="lineNum">     513 </span>            : </a>
<span class="lineNum">     514 </span>            : void
<span class="lineNum">     515 </span><span class="lineCov">          1 : nsSMILTimedElement::SetTimeClient(nsSMILAnimationFunction* aClient)</span>
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span>            :   //
<span class="lineNum">     518 </span>            :   // No need to check for nullptr. A nullptr parameter simply means to remove the
<span class="lineNum">     519 </span>            :   // previous client which we do by setting to nullptr anyway.
<span class="lineNum">     520 </span>            :   //
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineCov">          1 :   mClient = aClient;</span>
<span class="lineNum">     523 </span><span class="lineCov">          1 : }</span>
<a name="524"><span class="lineNum">     524 </span>            : </a>
<span class="lineNum">     525 </span>            : void
<span class="lineNum">     526 </span><span class="lineCov">          1 : nsSMILTimedElement::SampleAt(nsSMILTime aContainerTime)</span>
<span class="lineNum">     527 </span>            : {
<span class="lineNum">     528 </span><span class="lineCov">          1 :   if (mIsDisabled)</span>
<span class="lineNum">     529 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :   // Milestones are cleared before a sample
<span class="lineNum">     532 </span><span class="lineCov">          1 :   mPrevRegisteredMilestone = sMaxMilestone;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineCov">          1 :   DoSampleAt(aContainerTime, false);</span>
<span class="lineNum">     535 </span>            : }
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : void
<span class="lineNum">     538 </span><span class="lineCov">          1 : nsSMILTimedElement::SampleEndAt(nsSMILTime aContainerTime)</span>
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span><span class="lineCov">          1 :   if (mIsDisabled)</span>
<span class="lineNum">     541 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   // Milestones are cleared before a sample
<span class="lineNum">     544 </span><span class="lineCov">          1 :   mPrevRegisteredMilestone = sMaxMilestone;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   // If the current interval changes, we don't bother trying to remove any old
<span class="lineNum">     547 </span>            :   // milestones we'd registered. So it's possible to get a call here to end an
<span class="lineNum">     548 </span>            :   // interval at a time that no longer reflects the end of the current interval.
<span class="lineNum">     549 </span>            :   //
<span class="lineNum">     550 </span>            :   // For now we just check that we're actually in an interval but note that the
<span class="lineNum">     551 </span>            :   // initial sample we use to initialise the model is an end sample. This is
<span class="lineNum">     552 </span>            :   // because we want to resolve all the instance times before committing to an
<span class="lineNum">     553 </span>            :   // initial interval. Therefore an end sample from the startup state is also
<span class="lineNum">     554 </span>            :   // acceptable.
<span class="lineNum">     555 </span><span class="lineCov">          1 :   if (mElementState == STATE_ACTIVE || mElementState == STATE_STARTUP) {</span>
<span class="lineNum">     556 </span><span class="lineCov">          1 :     DoSampleAt(aContainerTime, true); // End sample</span>
<span class="lineNum">     557 </span>            :   } else {
<span class="lineNum">     558 </span>            :     // Even if this was an unnecessary milestone sample we want to be sure that
<span class="lineNum">     559 </span>            :     // our next real milestone is registered.
<span class="lineNum">     560 </span><span class="lineCov">          1 :     RegisterMilestone();</span>
<span class="lineNum">     561 </span>            :   }
<span class="lineNum">     562 </span>            : }
<a name="563"><span class="lineNum">     563 </span>            : </a>
<span class="lineNum">     564 </span>            : void
<span class="lineNum">     565 </span><span class="lineCov">          1 : nsSMILTimedElement::DoSampleAt(nsSMILTime aContainerTime, bool aEndOnly)</span>
<span class="lineNum">     566 </span>            : {
<span class="lineNum">     567 </span>            :   MOZ_ASSERT(mAnimationElement,
<span class="lineNum">     568 </span>            :              &quot;Got sample before being registered with an animation element&quot;);
<span class="lineNum">     569 </span>            :   MOZ_ASSERT(GetTimeContainer(),
<span class="lineNum">     570 </span>            :              &quot;Got sample without being registered with a time container&quot;);
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :   // This could probably happen if we later implement externalResourcesRequired
<span class="lineNum">     573 </span>            :   // (bug 277955) and whilst waiting for those resources (and the animation to
<span class="lineNum">     574 </span>            :   // start) we transfer a node from another document fragment that has already
<span class="lineNum">     575 </span>            :   // started. In such a case we might receive milestone samples registered with
<span class="lineNum">     576 </span>            :   // the already active container.
<span class="lineNum">     577 </span><span class="lineCov">          1 :   if (GetTimeContainer()-&gt;IsPausedByType(nsSMILTimeContainer::PAUSE_BEGIN))</span>
<span class="lineNum">     578 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :   // We use an end-sample to start animation since an end-sample lets us
<span class="lineNum">     581 </span>            :   // tentatively create an interval without committing to it (by transitioning
<span class="lineNum">     582 </span>            :   // to the ACTIVE state) and this is necessary because we might have
<span class="lineNum">     583 </span>            :   // dependencies on other animations that are yet to start. After these
<span class="lineNum">     584 </span>            :   // other animations start, it may be necessary to revise our initial interval.
<span class="lineNum">     585 </span>            :   //
<span class="lineNum">     586 </span>            :   // However, sometimes instead of an end-sample we can get a regular sample
<span class="lineNum">     587 </span>            :   // during STARTUP state. This can happen, for example, if we register
<span class="lineNum">     588 </span>            :   // a milestone before time t=0 and are then re-bound to the tree (which sends
<span class="lineNum">     589 </span>            :   // us back to the STARTUP state). In such a case we should just ignore the
<span class="lineNum">     590 </span>            :   // sample and wait for our real initial sample which will be an end-sample.
<span class="lineNum">     591 </span><span class="lineCov">          1 :   if (mElementState == STATE_STARTUP &amp;&amp; !aEndOnly)</span>
<span class="lineNum">     592 </span>            :     return;
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">          1 :   bool finishedSeek = false;</span>
<span class="lineNum">     595 </span><span class="lineCov">          1 :   if (GetTimeContainer()-&gt;IsSeeking() &amp;&amp; mSeekState == SEEK_NOT_SEEKING) {</span>
<span class="lineNum">     596 </span><span class="lineCov">          1 :     mSeekState = mElementState == STATE_ACTIVE ?</span>
<span class="lineNum">     597 </span>            :                  SEEK_FORWARD_FROM_ACTIVE :
<span class="lineNum">     598 </span><span class="lineCov">          1 :                  SEEK_FORWARD_FROM_INACTIVE;</span>
<span class="lineNum">     599 </span><span class="lineCov">          1 :   } else if (mSeekState != SEEK_NOT_SEEKING &amp;&amp;</span>
<span class="lineNum">     600 </span><span class="lineCov">          1 :              !GetTimeContainer()-&gt;IsSeeking()) {</span>
<span class="lineNum">     601 </span><span class="lineCov">          1 :     finishedSeek = true;</span>
<span class="lineNum">     602 </span>            :   }
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   bool            stateChanged;
<span class="lineNum">     605 </span>            :   nsSMILTimeValue sampleTime(aContainerTime);
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineCov">          1 :   do {</span>
<span class="lineNum">     608 </span>            : #ifdef DEBUG
<span class="lineNum">     609 </span>            :     // Check invariant
<span class="lineNum">     610 </span>            :     if (mElementState == STATE_STARTUP || mElementState == STATE_POSTACTIVE) {
<span class="lineNum">     611 </span>            :       MOZ_ASSERT(!mCurrentInterval,
<span class="lineNum">     612 </span>            :                  &quot;Shouldn't have current interval in startup or postactive &quot;
<span class="lineNum">     613 </span>            :                  &quot;states&quot;);
<span class="lineNum">     614 </span>            :     } else {
<span class="lineNum">     615 </span>            :       MOZ_ASSERT(mCurrentInterval,
<span class="lineNum">     616 </span>            :                  &quot;Should have current interval in waiting and active states&quot;);
<span class="lineNum">     617 </span>            :     }
<span class="lineNum">     618 </span>            : #endif
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">          1 :     stateChanged = false;</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineCov">          1 :     switch (mElementState)</span>
<span class="lineNum">     623 </span>            :     {
<span class="lineNum">     624 </span>            :     case STATE_STARTUP:
<span class="lineNum">     625 </span>            :       {
<span class="lineNum">     626 </span><span class="lineCov">          1 :         nsSMILInterval firstInterval;</span>
<span class="lineNum">     627 </span><span class="lineCov">          1 :         mElementState = GetNextInterval(nullptr, nullptr, nullptr, firstInterval)</span>
<span class="lineNum">     628 </span>            :          ? STATE_WAITING
<span class="lineNum">     629 </span><span class="lineCov">          1 :          : STATE_POSTACTIVE;</span>
<span class="lineNum">     630 </span><span class="lineCov">          1 :         stateChanged = true;</span>
<span class="lineNum">     631 </span><span class="lineCov">          1 :         if (mElementState == STATE_WAITING) {</span>
<span class="lineNum">     632 </span><span class="lineCov">          1 :           mCurrentInterval = new nsSMILInterval(firstInterval);</span>
<span class="lineNum">     633 </span><span class="lineCov">          1 :           NotifyNewInterval();</span>
<span class="lineNum">     634 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     635 </span>            :       }
<span class="lineNum">     636 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :     case STATE_WAITING:
<span class="lineNum">     639 </span>            :       {
<span class="lineNum">     640 </span><span class="lineCov">          1 :         if (mCurrentInterval-&gt;Begin()-&gt;Time() &lt;= sampleTime) {</span>
<span class="lineNum">     641 </span><span class="lineCov">          1 :           mElementState = STATE_ACTIVE;</span>
<span class="lineNum">     642 </span><span class="lineCov">          1 :           mCurrentInterval-&gt;FixBegin();</span>
<span class="lineNum">     643 </span><span class="lineCov">          1 :           if (mClient) {</span>
<span class="lineNum">     644 </span><span class="lineCov">          1 :             mClient-&gt;Activate(mCurrentInterval-&gt;Begin()-&gt;Time().GetMillis());</span>
<span class="lineNum">     645 </span>            :           }
<span class="lineNum">     646 </span><span class="lineCov">          1 :           if (mSeekState == SEEK_NOT_SEEKING) {</span>
<span class="lineNum">     647 </span><span class="lineCov">          1 :             FireTimeEventAsync(eSMILBeginEvent, 0);</span>
<span class="lineNum">     648 </span>            :           }
<span class="lineNum">     649 </span><span class="lineCov">          1 :           if (HasPlayed()) {</span>
<span class="lineNum">     650 </span><span class="lineCov">          1 :             Reset(); // Apply restart behaviour</span>
<span class="lineNum">     651 </span>            :             // The call to Reset() may mean that the end point of our current
<span class="lineNum">     652 </span>            :             // interval should be changed and so we should update the interval
<span class="lineNum">     653 </span>            :             // now. However, calling UpdateCurrentInterval could result in the
<span class="lineNum">     654 </span>            :             // interval getting deleted (perhaps through some web of syncbase
<span class="lineNum">     655 </span>            :             // dependencies) therefore we make updating the interval the last
<span class="lineNum">     656 </span>            :             // thing we do. There is no guarantee that mCurrentInterval is set
<span class="lineNum">     657 </span>            :             // after this.
<span class="lineNum">     658 </span><span class="lineCov">          1 :             UpdateCurrentInterval();</span>
<span class="lineNum">     659 </span>            :           }
<span class="lineNum">     660 </span>            :           stateChanged = true;
<span class="lineNum">     661 </span>            :         }
<span class="lineNum">     662 </span>            :       }
<span class="lineNum">     663 </span>            :       break;
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :     case STATE_ACTIVE:
<span class="lineNum">     666 </span>            :       {
<span class="lineNum">     667 </span>            :         // Ending early will change the interval but we don't notify dependents
<span class="lineNum">     668 </span>            :         // of the change until we have closed off the current interval (since we
<span class="lineNum">     669 </span>            :         // don't want dependencies to un-end our early end).
<span class="lineNum">     670 </span><span class="lineCov">          1 :         bool didApplyEarlyEnd = ApplyEarlyEnd(sampleTime);</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineCov">          1 :         if (mCurrentInterval-&gt;End()-&gt;Time() &lt;= sampleTime) {</span>
<span class="lineNum">     673 </span><span class="lineCov">          1 :           nsSMILInterval newInterval;</span>
<span class="lineNum">     674 </span>            :           mElementState =
<span class="lineNum">     675 </span><span class="lineCov">          1 :             GetNextInterval(mCurrentInterval, nullptr, nullptr, newInterval)</span>
<span class="lineNum">     676 </span>            :             ? STATE_WAITING
<span class="lineNum">     677 </span><span class="lineCov">          1 :             : STATE_POSTACTIVE;</span>
<span class="lineNum">     678 </span><span class="lineCov">          1 :           if (mClient) {</span>
<span class="lineNum">     679 </span><span class="lineCov">          1 :             mClient-&gt;Inactivate(mFillMode == FILL_FREEZE);</span>
<span class="lineNum">     680 </span>            :           }
<span class="lineNum">     681 </span><span class="lineCov">          1 :           mCurrentInterval-&gt;FixEnd();</span>
<span class="lineNum">     682 </span><span class="lineCov">          1 :           if (mSeekState == SEEK_NOT_SEEKING) {</span>
<span class="lineNum">     683 </span><span class="lineCov">          1 :             FireTimeEventAsync(eSMILEndEvent, 0);</span>
<span class="lineNum">     684 </span>            :           }
<span class="lineNum">     685 </span><span class="lineCov">          1 :           mCurrentRepeatIteration = 0;</span>
<span class="lineNum">     686 </span><span class="lineCov">          1 :           mOldIntervals.AppendElement(mCurrentInterval.forget());</span>
<span class="lineNum">     687 </span><span class="lineCov">          1 :           SampleFillValue();</span>
<span class="lineNum">     688 </span><span class="lineCov">          1 :           if (mElementState == STATE_WAITING) {</span>
<span class="lineNum">     689 </span><span class="lineCov">          1 :             mCurrentInterval = new nsSMILInterval(newInterval);</span>
<span class="lineNum">     690 </span>            :           }
<span class="lineNum">     691 </span>            :           // We are now in a consistent state to dispatch notifications
<span class="lineNum">     692 </span><span class="lineCov">          1 :           if (didApplyEarlyEnd) {</span>
<span class="lineNum">     693 </span>            :             NotifyChangedInterval(
<span class="lineNum">     694 </span><span class="lineCov">          1 :                 mOldIntervals[mOldIntervals.Length() - 1], false, true);</span>
<span class="lineNum">     695 </span>            :           }
<span class="lineNum">     696 </span><span class="lineCov">          1 :           if (mElementState == STATE_WAITING) {</span>
<span class="lineNum">     697 </span><span class="lineCov">          1 :             NotifyNewInterval();</span>
<span class="lineNum">     698 </span>            :           }
<span class="lineNum">     699 </span><span class="lineCov">          1 :           FilterHistory();</span>
<span class="lineNum">     700 </span><span class="lineCov">          1 :           stateChanged = true;</span>
<span class="lineNum">     701 </span>            :         } else {
<span class="lineNum">     702 </span>            :           MOZ_ASSERT(!didApplyEarlyEnd,
<span class="lineNum">     703 </span>            :                      &quot;We got an early end, but didn't end&quot;);
<span class="lineNum">     704 </span><span class="lineCov">          1 :           nsSMILTime beginTime = mCurrentInterval-&gt;Begin()-&gt;Time().GetMillis();</span>
<span class="lineNum">     705 </span>            :           NS_ASSERTION(aContainerTime &gt;= beginTime,
<span class="lineNum">     706 </span>            :                        &quot;Sample time should not precede current interval&quot;);
<span class="lineNum">     707 </span><span class="lineCov">          1 :           nsSMILTime activeTime = aContainerTime - beginTime;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :           // The 'min' attribute can cause the active interval to be longer than
<span class="lineNum">     710 </span>            :           // the 'repeating interval'.
<span class="lineNum">     711 </span>            :           // In that extended period we apply the fill mode.
<span class="lineNum">     712 </span><span class="lineCov">          1 :           if (GetRepeatDuration() &lt;= nsSMILTimeValue(activeTime)) {</span>
<span class="lineNum">     713 </span><span class="lineCov">          1 :             if (mClient &amp;&amp; mClient-&gt;IsActive()) {</span>
<span class="lineNum">     714 </span><span class="lineCov">          1 :               mClient-&gt;Inactivate(mFillMode == FILL_FREEZE);</span>
<span class="lineNum">     715 </span>            :             }
<span class="lineNum">     716 </span><span class="lineCov">          1 :             SampleFillValue();</span>
<span class="lineNum">     717 </span>            :           } else {
<span class="lineNum">     718 </span><span class="lineCov">          1 :             SampleSimpleTime(activeTime);</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :             // We register our repeat times as milestones (except when we're
<span class="lineNum">     721 </span>            :             // seeking) so we should get a sample at exactly the time we repeat.
<span class="lineNum">     722 </span>            :             // (And even when we are seeking we want to update
<span class="lineNum">     723 </span>            :             // mCurrentRepeatIteration so we do that first before testing the
<span class="lineNum">     724 </span>            :             // seek state.)
<span class="lineNum">     725 </span><span class="lineCov">          1 :             uint32_t prevRepeatIteration = mCurrentRepeatIteration;</span>
<span class="lineNum">     726 </span><span class="lineCov">          1 :             if (</span>
<span class="lineNum">     727 </span><span class="lineCov">          1 :               ActiveTimeToSimpleTime(activeTime, mCurrentRepeatIteration)==0 &amp;&amp;</span>
<span class="lineNum">     728 </span><span class="lineCov">          1 :               mCurrentRepeatIteration != prevRepeatIteration &amp;&amp;</span>
<span class="lineNum">     729 </span><span class="lineCov">          1 :               mCurrentRepeatIteration &amp;&amp;</span>
<span class="lineNum">     730 </span><span class="lineCov">          1 :               mSeekState == SEEK_NOT_SEEKING) {</span>
<span class="lineNum">     731 </span>            :               FireTimeEventAsync(eSMILRepeatEvent,
<span class="lineNum">     732 </span><span class="lineCov">          1 :                             static_cast&lt;int32_t&gt;(mCurrentRepeatIteration));</span>
<span class="lineNum">     733 </span>            :             }
<span class="lineNum">     734 </span>            :           }
<span class="lineNum">     735 </span>            :         }
<span class="lineNum">     736 </span>            :       }
<span class="lineNum">     737 </span>            :       break;
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :     case STATE_POSTACTIVE:
<span class="lineNum">     740 </span>            :       break;
<span class="lineNum">     741 </span>            :     }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :   // Generally we continue driving the state machine so long as we have changed
<span class="lineNum">     744 </span>            :   // state. However, for end samples we only drive the state machine as far as
<span class="lineNum">     745 </span>            :   // the waiting or postactive state because we don't want to commit to any new
<span class="lineNum">     746 </span>            :   // interval (by transitioning to the active state) until all the end samples
<span class="lineNum">     747 </span>            :   // have finished and we then have complete information about the available
<span class="lineNum">     748 </span>            :   // instance times upon which to base our next interval.
<span class="lineNum">     749 </span><span class="lineCov">          1 :   } while (stateChanged &amp;&amp; (!aEndOnly || (mElementState != STATE_WAITING &amp;&amp;</span>
<span class="lineNum">     750 </span>            :                                           mElementState != STATE_POSTACTIVE)));
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineCov">          1 :   if (finishedSeek) {</span>
<span class="lineNum">     753 </span><span class="lineCov">          1 :     DoPostSeek();</span>
<span class="lineNum">     754 </span>            :   }
<span class="lineNum">     755 </span><span class="lineCov">          1 :   RegisterMilestone();</span>
<span class="lineNum">     756 </span>            : }
<a name="757"><span class="lineNum">     757 </span>            : </a>
<span class="lineNum">     758 </span>            : void
<span class="lineNum">     759 </span><span class="lineCov">          1 : nsSMILTimedElement::HandleContainerTimeChange()</span>
<span class="lineNum">     760 </span>            : {
<span class="lineNum">     761 </span>            :   // In future we could possibly introduce a separate change notice for time
<span class="lineNum">     762 </span>            :   // container changes and only notify those dependents who live in other time
<span class="lineNum">     763 </span>            :   // containers. For now we don't bother because when we re-resolve the time in
<span class="lineNum">     764 </span>            :   // the nsSMILTimeValueSpec we'll check if anything has changed and if not, we
<span class="lineNum">     765 </span>            :   // won't go any further.
<span class="lineNum">     766 </span><span class="lineCov">          1 :   if (mElementState == STATE_WAITING || mElementState == STATE_ACTIVE) {</span>
<span class="lineNum">     767 </span><span class="lineCov">          1 :     NotifyChangedInterval(mCurrentInterval, false, false);</span>
<span class="lineNum">     768 </span>            :   }
<span class="lineNum">     769 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            : namespace
<a name="772"><span class="lineNum">     772 </span>            : {</a>
<span class="lineNum">     773 </span>            :   bool
<span class="lineNum">     774 </span><span class="lineCov">          1 :   RemoveNonDynamic(nsSMILInstanceTime* aInstanceTime)</span>
<span class="lineNum">     775 </span>            :   {
<span class="lineNum">     776 </span>            :     // Generally dynamically-generated instance times (DOM calls, event-based
<span class="lineNum">     777 </span>            :     // times) are not associated with their creator nsSMILTimeValueSpec since
<span class="lineNum">     778 </span>            :     // they may outlive them.
<span class="lineNum">     779 </span>            :     MOZ_ASSERT(!aInstanceTime-&gt;IsDynamic() || !aInstanceTime-&gt;GetCreator(),
<span class="lineNum">     780 </span>            :                &quot;Dynamic instance time should be unlinked from its creator&quot;);
<span class="lineNum">     781 </span><span class="lineCov">          1 :     return !aInstanceTime-&gt;IsDynamic() &amp;&amp; !aInstanceTime-&gt;ShouldPreserve();</span>
<span class="lineNum">     782 </span>            :   }
<span class="lineNum">     783 </span>            : } // namespace
<a name="784"><span class="lineNum">     784 </span>            : </a>
<span class="lineNum">     785 </span>            : void
<span class="lineNum">     786 </span><span class="lineCov">          1 : nsSMILTimedElement::Rewind()</span>
<span class="lineNum">     787 </span>            : {
<span class="lineNum">     788 </span>            :   MOZ_ASSERT(mAnimationElement,
<span class="lineNum">     789 </span>            :              &quot;Got rewind request before being attached to an animation &quot;
<span class="lineNum">     790 </span>            :              &quot;element&quot;);
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :   // It's possible to get a rewind request whilst we're already in the middle of
<span class="lineNum">     793 </span>            :   // a backwards seek. This can happen when we're performing tree surgery and
<span class="lineNum">     794 </span>            :   // seeking containers at the same time because we can end up requesting
<span class="lineNum">     795 </span>            :   // a local rewind on an element after binding it to a new container and then
<span class="lineNum">     796 </span>            :   // performing a rewind on that container as a whole without sampling in
<span class="lineNum">     797 </span>            :   // between.
<span class="lineNum">     798 </span>            :   //
<span class="lineNum">     799 </span>            :   // However, it should currently be impossible to get a rewind in the middle of
<span class="lineNum">     800 </span>            :   // a forwards seek since forwards seeks are detected and processed within the
<span class="lineNum">     801 </span>            :   // same (re)sample.
<span class="lineNum">     802 </span><span class="lineCov">          1 :   if (mSeekState == SEEK_NOT_SEEKING) {</span>
<span class="lineNum">     803 </span><span class="lineCov">          1 :     mSeekState = mElementState == STATE_ACTIVE ?</span>
<span class="lineNum">     804 </span>            :                  SEEK_BACKWARD_FROM_ACTIVE :
<span class="lineNum">     805 </span><span class="lineCov">          1 :                  SEEK_BACKWARD_FROM_INACTIVE;</span>
<span class="lineNum">     806 </span>            :   }
<span class="lineNum">     807 </span>            :   MOZ_ASSERT(mSeekState == SEEK_BACKWARD_FROM_INACTIVE ||
<span class="lineNum">     808 </span>            :              mSeekState == SEEK_BACKWARD_FROM_ACTIVE,
<span class="lineNum">     809 </span>            :              &quot;Rewind in the middle of a forwards seek?&quot;);
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span><span class="lineCov">          1 :   ClearTimingState(RemoveNonDynamic);</span>
<span class="lineNum">     812 </span><span class="lineCov">          1 :   RebuildTimingState(RemoveNonDynamic);</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :   MOZ_ASSERT(!mCurrentInterval,
<span class="lineNum">     815 </span>            :              &quot;Current interval is set at end of rewind&quot;);
<span class="lineNum">     816 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : namespace
<a name="819"><span class="lineNum">     819 </span>            : {</a>
<span class="lineNum">     820 </span>            :   bool
<span class="lineNum">     821 </span><span class="lineCov">          1 :   RemoveAll(nsSMILInstanceTime* aInstanceTime)</span>
<span class="lineNum">     822 </span>            :   {
<span class="lineNum">     823 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">     824 </span>            :   }
<span class="lineNum">     825 </span>            : } // namespace
<a name="826"><span class="lineNum">     826 </span>            : </a>
<span class="lineNum">     827 </span>            : bool
<span class="lineNum">     828 </span><span class="lineCov">          1 : nsSMILTimedElement::SetIsDisabled(bool aIsDisabled)</span>
<span class="lineNum">     829 </span>            : {
<span class="lineNum">     830 </span><span class="lineCov">          1 :   if (mIsDisabled == aIsDisabled)</span>
<span class="lineNum">     831 </span>            :     return false;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineCov">          1 :   if (aIsDisabled) {</span>
<span class="lineNum">     834 </span><span class="lineCov">          1 :     mIsDisabled = true;</span>
<span class="lineNum">     835 </span><span class="lineCov">          1 :     ClearTimingState(RemoveAll);</span>
<span class="lineNum">     836 </span>            :   } else {
<span class="lineNum">     837 </span><span class="lineCov">          1 :     RebuildTimingState(RemoveAll);</span>
<span class="lineNum">     838 </span><span class="lineCov">          1 :     mIsDisabled = false;</span>
<span class="lineNum">     839 </span>            :   }
<span class="lineNum">     840 </span>            :   return true;
<span class="lineNum">     841 </span>            : }
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : namespace
<a name="844"><span class="lineNum">     844 </span>            : {</a>
<span class="lineNum">     845 </span>            :   bool
<span class="lineNum">     846 </span><span class="lineCov">          1 :   RemoveNonDOM(nsSMILInstanceTime* aInstanceTime)</span>
<span class="lineNum">     847 </span>            :   {
<span class="lineNum">     848 </span><span class="lineCov">          1 :     return !aInstanceTime-&gt;FromDOM() &amp;&amp; !aInstanceTime-&gt;ShouldPreserve();</span>
<span class="lineNum">     849 </span>            :   }
<span class="lineNum">     850 </span>            : } // namespace
<a name="851"><span class="lineNum">     851 </span>            : </a>
<span class="lineNum">     852 </span>            : bool
<span class="lineNum">     853 </span><span class="lineCov">          1 : nsSMILTimedElement::SetAttr(nsIAtom* aAttribute, const nsAString&amp; aValue,</span>
<span class="lineNum">     854 </span>            :                             nsAttrValue&amp; aResult,
<span class="lineNum">     855 </span>            :                             Element* aContextNode,
<span class="lineNum">     856 </span>            :                             nsresult* aParseResult)
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span><span class="lineCov">          1 :   bool foundMatch = true;</span>
<span class="lineNum">     859 </span><span class="lineCov">          1 :   nsresult parseResult = NS_OK;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::begin) {</span>
<span class="lineNum">     862 </span><span class="lineCov">          1 :     parseResult = SetBeginSpec(aValue, aContextNode, RemoveNonDOM);</span>
<span class="lineNum">     863 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::dur) {</span>
<span class="lineNum">     864 </span><span class="lineCov">          1 :     parseResult = SetSimpleDuration(aValue);</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::end) {</span>
<span class="lineNum">     866 </span><span class="lineCov">          1 :     parseResult = SetEndSpec(aValue, aContextNode, RemoveNonDOM);</span>
<span class="lineNum">     867 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::fill) {</span>
<span class="lineNum">     868 </span><span class="lineCov">          1 :     parseResult = SetFillMode(aValue);</span>
<span class="lineNum">     869 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::max) {</span>
<span class="lineNum">     870 </span><span class="lineCov">          1 :     parseResult = SetMax(aValue);</span>
<span class="lineNum">     871 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::min) {</span>
<span class="lineNum">     872 </span><span class="lineCov">          1 :     parseResult = SetMin(aValue);</span>
<span class="lineNum">     873 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::repeatCount) {</span>
<span class="lineNum">     874 </span><span class="lineCov">          1 :     parseResult = SetRepeatCount(aValue);</span>
<span class="lineNum">     875 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::repeatDur) {</span>
<span class="lineNum">     876 </span><span class="lineCov">          1 :     parseResult = SetRepeatDur(aValue);</span>
<span class="lineNum">     877 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::restart) {</span>
<span class="lineNum">     878 </span><span class="lineCov">          1 :     parseResult = SetRestart(aValue);</span>
<span class="lineNum">     879 </span>            :   } else {
<span class="lineNum">     880 </span>            :     foundMatch = false;
<span class="lineNum">     881 </span>            :   }
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span><span class="lineCov">          1 :   if (foundMatch) {</span>
<span class="lineNum">     884 </span><span class="lineCov">          1 :     aResult.SetTo(aValue);</span>
<span class="lineNum">     885 </span><span class="lineCov">          1 :     if (aParseResult) {</span>
<span class="lineNum">     886 </span><span class="lineCov">          1 :       *aParseResult = parseResult;</span>
<span class="lineNum">     887 </span>            :     }
<span class="lineNum">     888 </span>            :   }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">          1 :   return foundMatch;</span>
<span class="lineNum">     891 </span>            : }
<a name="892"><span class="lineNum">     892 </span>            : </a>
<span class="lineNum">     893 </span>            : bool
<span class="lineNum">     894 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetAttr(nsIAtom* aAttribute)</span>
<span class="lineNum">     895 </span>            : {
<span class="lineNum">     896 </span><span class="lineCov">          1 :   bool foundMatch = true;</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::begin) {</span>
<span class="lineNum">     899 </span><span class="lineCov">          1 :     UnsetBeginSpec(RemoveNonDOM);</span>
<span class="lineNum">     900 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::dur) {</span>
<span class="lineNum">     901 </span><span class="lineCov">          1 :     UnsetSimpleDuration();</span>
<span class="lineNum">     902 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::end) {</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     UnsetEndSpec(RemoveNonDOM);</span>
<span class="lineNum">     904 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::fill) {</span>
<span class="lineNum">     905 </span><span class="lineCov">          1 :     UnsetFillMode();</span>
<span class="lineNum">     906 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::max) {</span>
<span class="lineNum">     907 </span><span class="lineCov">          1 :     UnsetMax();</span>
<span class="lineNum">     908 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::min) {</span>
<span class="lineNum">     909 </span><span class="lineCov">          1 :     UnsetMin();</span>
<span class="lineNum">     910 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::repeatCount) {</span>
<span class="lineNum">     911 </span><span class="lineCov">          1 :     UnsetRepeatCount();</span>
<span class="lineNum">     912 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::repeatDur) {</span>
<span class="lineNum">     913 </span><span class="lineCov">          1 :     UnsetRepeatDur();</span>
<span class="lineNum">     914 </span><span class="lineCov">          1 :   } else if (aAttribute == nsGkAtoms::restart) {</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     UnsetRestart();</span>
<span class="lineNum">     916 </span>            :   } else {
<span class="lineNum">     917 </span>            :     foundMatch = false;
<span class="lineNum">     918 </span>            :   }
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineCov">          1 :   return foundMatch;</span>
<span class="lineNum">     921 </span>            : }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     924 </span>            : // Setters and unsetters
<a name="925"><span class="lineNum">     925 </span>            : </a>
<span class="lineNum">     926 </span>            : nsresult
<span class="lineNum">     927 </span><span class="lineCov">          1 : nsSMILTimedElement::SetBeginSpec(const nsAString&amp; aBeginSpec,</span>
<span class="lineNum">     928 </span>            :                                  Element* aContextNode,
<span class="lineNum">     929 </span>            :                                  RemovalTestFunction aRemove)
<span class="lineNum">     930 </span>            : {
<span class="lineNum">     931 </span>            :   return SetBeginOrEndSpec(aBeginSpec, aContextNode, true /*isBegin*/,
<span class="lineNum">     932 </span><span class="lineCov">          1 :                            aRemove);</span>
<span class="lineNum">     933 </span>            : }
<a name="934"><span class="lineNum">     934 </span>            : </a>
<span class="lineNum">     935 </span>            : void
<span class="lineNum">     936 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetBeginSpec(RemovalTestFunction aRemove)</span>
<span class="lineNum">     937 </span>            : {
<span class="lineNum">     938 </span><span class="lineCov">          1 :   ClearSpecs(mBeginSpecs, mBeginInstances, aRemove);</span>
<span class="lineNum">     939 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">     940 </span><span class="lineCov">          1 : }</span>
<a name="941"><span class="lineNum">     941 </span>            : </a>
<span class="lineNum">     942 </span>            : nsresult
<span class="lineNum">     943 </span><span class="lineCov">          1 : nsSMILTimedElement::SetEndSpec(const nsAString&amp; aEndSpec,</span>
<span class="lineNum">     944 </span>            :                                Element* aContextNode,
<span class="lineNum">     945 </span>            :                                RemovalTestFunction aRemove)
<span class="lineNum">     946 </span>            : {
<span class="lineNum">     947 </span>            :   return SetBeginOrEndSpec(aEndSpec, aContextNode, false /*!isBegin*/,
<span class="lineNum">     948 </span><span class="lineCov">          1 :                            aRemove);</span>
<span class="lineNum">     949 </span>            : }
<a name="950"><span class="lineNum">     950 </span>            : </a>
<span class="lineNum">     951 </span>            : void
<span class="lineNum">     952 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetEndSpec(RemovalTestFunction aRemove)</span>
<span class="lineNum">     953 </span>            : {
<span class="lineNum">     954 </span><span class="lineCov">          1 :   ClearSpecs(mEndSpecs, mEndInstances, aRemove);</span>
<span class="lineNum">     955 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">     956 </span><span class="lineCov">          1 : }</span>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<span class="lineNum">     958 </span>            : nsresult
<span class="lineNum">     959 </span><span class="lineCov">          1 : nsSMILTimedElement::SetSimpleDuration(const nsAString&amp; aDurSpec)</span>
<span class="lineNum">     960 </span>            : {
<span class="lineNum">     961 </span>            :   // Update the current interval before returning
<span class="lineNum">     962 </span>            :   AutoIntervalUpdater updater(*this);
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :   nsSMILTimeValue duration;
<span class="lineNum">     965 </span><span class="lineCov">          1 :   const nsAString&amp; dur = nsSMILParserUtils::TrimWhitespace(aDurSpec);</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :   // SVG-specific: &quot;For SVG's animation elements, if &quot;media&quot; is specified, the
<span class="lineNum">     968 </span>            :   // attribute will be ignored.&quot; (SVG 1.1, section 19.2.6)
<span class="lineNum">     969 </span><span class="lineCov">          1 :   if (dur.EqualsLiteral(&quot;media&quot;) || dur.EqualsLiteral(&quot;indefinite&quot;)) {</span>
<span class="lineNum">     970 </span>            :     duration.SetIndefinite();
<span class="lineNum">     971 </span>            :   } else {
<span class="lineNum">     972 </span><span class="lineCov">          1 :     if (!nsSMILParserUtils::ParseClockValue(dur, &amp;duration) ||</span>
<span class="lineNum">     973 </span><span class="lineCov">          1 :         duration.GetMillis() == 0L) {</span>
<span class="lineNum">     974 </span><span class="lineCov">          1 :       mSimpleDur.SetIndefinite();</span>
<span class="lineNum">     975 </span><span class="lineCov">          1 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">     976 </span>            :     }
<span class="lineNum">     977 </span>            :   }
<span class="lineNum">     978 </span>            :   // mSimpleDur should never be unresolved. ParseClockValue will either set
<span class="lineNum">     979 </span>            :   // duration to resolved or will return false.
<span class="lineNum">     980 </span>            :   MOZ_ASSERT(duration.IsResolved(),
<span class="lineNum">     981 </span>            :              &quot;Setting unresolved simple duration&quot;);
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineCov">          1 :   mSimpleDur = duration;</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     986 </span>            : }
<a name="987"><span class="lineNum">     987 </span>            : </a>
<span class="lineNum">     988 </span>            : void
<span class="lineNum">     989 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetSimpleDuration()</span>
<span class="lineNum">     990 </span>            : {
<span class="lineNum">     991 </span><span class="lineCov">          1 :   mSimpleDur.SetIndefinite();</span>
<span class="lineNum">     992 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">     993 </span><span class="lineCov">          1 : }</span>
<a name="994"><span class="lineNum">     994 </span>            : </a>
<span class="lineNum">     995 </span>            : nsresult
<span class="lineNum">     996 </span><span class="lineCov">          1 : nsSMILTimedElement::SetMin(const nsAString&amp; aMinSpec)</span>
<span class="lineNum">     997 </span>            : {
<span class="lineNum">     998 </span>            :   // Update the current interval before returning
<span class="lineNum">     999 </span>            :   AutoIntervalUpdater updater(*this);
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :   nsSMILTimeValue duration;
<span class="lineNum">    1002 </span><span class="lineCov">          1 :   const nsAString&amp; min = nsSMILParserUtils::TrimWhitespace(aMinSpec);</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineCov">          1 :   if (min.EqualsLiteral(&quot;media&quot;)) {</span>
<span class="lineNum">    1005 </span>            :     duration.SetMillis(0L);
<span class="lineNum">    1006 </span>            :   } else {
<span class="lineNum">    1007 </span><span class="lineCov">          1 :     if (!nsSMILParserUtils::ParseClockValue(min, &amp;duration)) {</span>
<span class="lineNum">    1008 </span><span class="lineCov">          1 :       mMin.SetMillis(0L);</span>
<span class="lineNum">    1009 </span><span class="lineCov">          1 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">    1010 </span>            :     }
<span class="lineNum">    1011 </span>            :   }
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :   MOZ_ASSERT(duration.GetMillis() &gt;= 0L, &quot;Invalid duration&quot;);
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span><span class="lineCov">          1 :   mMin = duration;</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1018 </span>            : }
<a name="1019"><span class="lineNum">    1019 </span>            : </a>
<span class="lineNum">    1020 </span>            : void
<span class="lineNum">    1021 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetMin()</span>
<span class="lineNum">    1022 </span>            : {
<span class="lineNum">    1023 </span><span class="lineCov">          1 :   mMin.SetMillis(0L);</span>
<span class="lineNum">    1024 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">    1025 </span><span class="lineCov">          1 : }</span>
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<span class="lineNum">    1027 </span>            : nsresult
<span class="lineNum">    1028 </span><span class="lineCov">          1 : nsSMILTimedElement::SetMax(const nsAString&amp; aMaxSpec)</span>
<span class="lineNum">    1029 </span>            : {
<span class="lineNum">    1030 </span>            :   // Update the current interval before returning
<span class="lineNum">    1031 </span>            :   AutoIntervalUpdater updater(*this);
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :   nsSMILTimeValue duration;
<span class="lineNum">    1034 </span><span class="lineCov">          1 :   const nsAString&amp; max = nsSMILParserUtils::TrimWhitespace(aMaxSpec);</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span><span class="lineCov">          1 :   if (max.EqualsLiteral(&quot;media&quot;) || max.EqualsLiteral(&quot;indefinite&quot;)) {</span>
<span class="lineNum">    1037 </span>            :     duration.SetIndefinite();
<span class="lineNum">    1038 </span>            :   } else {
<span class="lineNum">    1039 </span><span class="lineCov">          1 :     if (!nsSMILParserUtils::ParseClockValue(max, &amp;duration) ||</span>
<span class="lineNum">    1040 </span><span class="lineCov">          1 :         duration.GetMillis() == 0L) {</span>
<span class="lineNum">    1041 </span><span class="lineCov">          1 :       mMax.SetIndefinite();</span>
<span class="lineNum">    1042 </span><span class="lineCov">          1 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">    1043 </span>            :     }
<span class="lineNum">    1044 </span>            :     MOZ_ASSERT(duration.GetMillis() &gt; 0L, &quot;Invalid duration&quot;);
<span class="lineNum">    1045 </span>            :   }
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineCov">          1 :   mMax = duration;</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1050 </span>            : }
<a name="1051"><span class="lineNum">    1051 </span>            : </a>
<span class="lineNum">    1052 </span>            : void
<span class="lineNum">    1053 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetMax()</span>
<span class="lineNum">    1054 </span>            : {
<span class="lineNum">    1055 </span><span class="lineCov">          1 :   mMax.SetIndefinite();</span>
<span class="lineNum">    1056 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">    1057 </span><span class="lineCov">          1 : }</span>
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<span class="lineNum">    1059 </span>            : nsresult
<span class="lineNum">    1060 </span><span class="lineCov">          1 : nsSMILTimedElement::SetRestart(const nsAString&amp; aRestartSpec)</span>
<span class="lineNum">    1061 </span>            : {
<span class="lineNum">    1062 </span><span class="lineCov">          1 :   nsAttrValue temp;</span>
<span class="lineNum">    1063 </span>            :   bool parseResult
<span class="lineNum">    1064 </span><span class="lineCov">          1 :     = temp.ParseEnumValue(aRestartSpec, sRestartModeTable, true);</span>
<span class="lineNum">    1065 </span>            :   mRestartMode = parseResult
<span class="lineNum">    1066 </span><span class="lineCov">          1 :                ? nsSMILRestartMode(temp.GetEnumValue())</span>
<span class="lineNum">    1067 </span><span class="lineCov">          1 :                : RESTART_ALWAYS;</span>
<span class="lineNum">    1068 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">    1069 </span><span class="lineCov">          1 :   return parseResult ? NS_OK : NS_ERROR_FAILURE;</span>
<span class="lineNum">    1070 </span>            : }
<a name="1071"><span class="lineNum">    1071 </span>            : </a>
<span class="lineNum">    1072 </span>            : void
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 : nsSMILTimedElement::UnsetRestart()</span>
<span class="lineNum">    1074 </span>            : {
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :   mRestartMode = RESTART_ALWAYS;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   UpdateCurrentInterval();</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 : }</span>
<a name="1078"><span class="lineNum">    1078 </span>            : </a>
<span class="lineNum">    1079 </span>            : nsresult
<span class="lineNum">    1080 </span><span class="lineCov">          1 : nsSMILTimedElement::SetRepeatCount(const nsAString&amp; aRepeatCountSpec)</span>
<span class="lineNum">    1081 </span>            : {
<span class="lineNum">    1082 </span>            :   // Update the current interval before returning
<span class="lineNum">    1083 </span>            :   AutoIntervalUpdater updater(*this);
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :   nsSMILRepeatCount newRepeatCount;
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineCov">          1 :   if (nsSMILParserUtils::ParseRepeatCount(aRepeatCountSpec, newRepeatCount)) {</span>
<span class="lineNum">    1088 </span><span class="lineCov">          1 :     mRepeatCount = newRepeatCount;</span>
<span class="lineNum">    1089 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">    1090 </span>            :   }
<span class="lineNum">    1091 </span><span class="lineCov">          1 :   mRepeatCount.Unset();</span>
<span class="lineNum">    1092 </span><span class="lineCov">          1 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">    1093 </span>            : }
<a name="1094"><span class="lineNum">    1094 </span>            : </a>
<span class="lineNum">    1095 </span>            : void
<span class="lineNum">    1096 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetRepeatCount()</span>
<span class="lineNum">    1097 </span>            : {
<span class="lineNum">    1098 </span><span class="lineCov">          1 :   mRepeatCount.Unset();</span>
<span class="lineNum">    1099 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">    1100 </span><span class="lineCov">          1 : }</span>
<a name="1101"><span class="lineNum">    1101 </span>            : </a>
<span class="lineNum">    1102 </span>            : nsresult
<span class="lineNum">    1103 </span><span class="lineCov">          1 : nsSMILTimedElement::SetRepeatDur(const nsAString&amp; aRepeatDurSpec)</span>
<span class="lineNum">    1104 </span>            : {
<span class="lineNum">    1105 </span>            :   // Update the current interval before returning
<span class="lineNum">    1106 </span>            :   AutoIntervalUpdater updater(*this);
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            :   nsSMILTimeValue duration;
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            :   const nsAString&amp; repeatDur =
<span class="lineNum">    1111 </span><span class="lineCov">          1 :     nsSMILParserUtils::TrimWhitespace(aRepeatDurSpec);</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">          1 :   if (repeatDur.EqualsLiteral(&quot;indefinite&quot;)) {</span>
<span class="lineNum">    1114 </span>            :     duration.SetIndefinite();
<span class="lineNum">    1115 </span>            :   } else {
<span class="lineNum">    1116 </span><span class="lineCov">          1 :     if (!nsSMILParserUtils::ParseClockValue(repeatDur, &amp;duration)) {</span>
<span class="lineNum">    1117 </span><span class="lineCov">          1 :       mRepeatDur.SetUnresolved();</span>
<span class="lineNum">    1118 </span><span class="lineCov">          1 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">    1119 </span>            :     }
<span class="lineNum">    1120 </span>            :   }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineCov">          1 :   mRepeatDur = duration;</span>
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1125 </span>            : }
<a name="1126"><span class="lineNum">    1126 </span>            : </a>
<span class="lineNum">    1127 </span>            : void
<span class="lineNum">    1128 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetRepeatDur()</span>
<span class="lineNum">    1129 </span>            : {
<span class="lineNum">    1130 </span><span class="lineCov">          1 :   mRepeatDur.SetUnresolved();</span>
<span class="lineNum">    1131 </span><span class="lineCov">          1 :   UpdateCurrentInterval();</span>
<span class="lineNum">    1132 </span><span class="lineCov">          1 : }</span>
<a name="1133"><span class="lineNum">    1133 </span>            : </a>
<span class="lineNum">    1134 </span>            : nsresult
<span class="lineNum">    1135 </span><span class="lineCov">          1 : nsSMILTimedElement::SetFillMode(const nsAString&amp; aFillModeSpec)</span>
<span class="lineNum">    1136 </span>            : {
<span class="lineNum">    1137 </span><span class="lineCov">          1 :   uint16_t previousFillMode = mFillMode;</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineCov">          1 :   nsAttrValue temp;</span>
<span class="lineNum">    1140 </span>            :   bool parseResult =
<span class="lineNum">    1141 </span><span class="lineCov">          1 :     temp.ParseEnumValue(aFillModeSpec, sFillModeTable, true);</span>
<span class="lineNum">    1142 </span>            :   mFillMode = parseResult
<span class="lineNum">    1143 </span><span class="lineCov">          1 :             ? nsSMILFillMode(temp.GetEnumValue())</span>
<span class="lineNum">    1144 </span><span class="lineCov">          1 :             : FILL_REMOVE;</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :   // Update fill mode of client
<span class="lineNum">    1147 </span><span class="lineCov">          1 :   if (mFillMode != previousFillMode &amp;&amp; HasClientInFillRange()) {</span>
<span class="lineNum">    1148 </span><span class="lineCov">          1 :     mClient-&gt;Inactivate(mFillMode == FILL_FREEZE);</span>
<span class="lineNum">    1149 </span><span class="lineCov">          1 :     SampleFillValue();</span>
<span class="lineNum">    1150 </span>            :   }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineCov">          1 :   return parseResult ? NS_OK : NS_ERROR_FAILURE;</span>
<span class="lineNum">    1153 </span>            : }
<a name="1154"><span class="lineNum">    1154 </span>            : </a>
<span class="lineNum">    1155 </span>            : void
<span class="lineNum">    1156 </span><span class="lineCov">          1 : nsSMILTimedElement::UnsetFillMode()</span>
<span class="lineNum">    1157 </span>            : {
<span class="lineNum">    1158 </span><span class="lineCov">          1 :   uint16_t previousFillMode = mFillMode;</span>
<span class="lineNum">    1159 </span><span class="lineCov">          1 :   mFillMode = FILL_REMOVE;</span>
<span class="lineNum">    1160 </span><span class="lineCov">          1 :   if (previousFillMode == FILL_FREEZE &amp;&amp; HasClientInFillRange()) {</span>
<span class="lineNum">    1161 </span><span class="lineCov">          1 :     mClient-&gt;Inactivate(false);</span>
<span class="lineNum">    1162 </span>            :   }
<span class="lineNum">    1163 </span><span class="lineCov">          1 : }</span>
<a name="1164"><span class="lineNum">    1164 </span>            : </a>
<span class="lineNum">    1165 </span>            : void
<span class="lineNum">    1166 </span><span class="lineCov">          1 : nsSMILTimedElement::AddDependent(nsSMILTimeValueSpec&amp; aDependent)</span>
<span class="lineNum">    1167 </span>            : {
<span class="lineNum">    1168 </span>            :   // There's probably no harm in attempting to register a dependent
<span class="lineNum">    1169 </span>            :   // nsSMILTimeValueSpec twice, but we're not expecting it to happen.
<span class="lineNum">    1170 </span>            :   MOZ_ASSERT(!mTimeDependents.GetEntry(&amp;aDependent),
<span class="lineNum">    1171 </span>            :              &quot;nsSMILTimeValueSpec is already registered as a dependency&quot;);
<span class="lineNum">    1172 </span><span class="lineCov">          1 :   mTimeDependents.PutEntry(&amp;aDependent);</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :   // Add current interval. We could add historical intervals too but that would
<span class="lineNum">    1175 </span>            :   // cause unpredictable results since some intervals may have been filtered.
<span class="lineNum">    1176 </span>            :   // SMIL doesn't say what to do here so for simplicity and consistency we
<span class="lineNum">    1177 </span>            :   // simply add the current interval if there is one.
<span class="lineNum">    1178 </span>            :   //
<span class="lineNum">    1179 </span>            :   // It's not necessary to call SyncPauseTime since we're dealing with
<span class="lineNum">    1180 </span>            :   // historical instance times not newly added ones.
<span class="lineNum">    1181 </span><span class="lineCov">          1 :   if (mCurrentInterval) {</span>
<span class="lineNum">    1182 </span><span class="lineCov">          1 :     aDependent.HandleNewInterval(*mCurrentInterval, GetTimeContainer());</span>
<span class="lineNum">    1183 </span>            :   }
<span class="lineNum">    1184 </span><span class="lineCov">          1 : }</span>
<a name="1185"><span class="lineNum">    1185 </span>            : </a>
<span class="lineNum">    1186 </span>            : void
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 : nsSMILTimedElement::RemoveDependent(nsSMILTimeValueSpec&amp; aDependent)</span>
<span class="lineNum">    1188 </span>            : {
<span class="lineNum">    1189 </span><span class="lineCov">          1 :   mTimeDependents.RemoveEntry(&amp;aDependent);</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 : }</span>
<a name="1191"><span class="lineNum">    1191 </span>            : </a>
<span class="lineNum">    1192 </span>            : bool
<span class="lineNum">    1193 </span><span class="lineCov">          1 : nsSMILTimedElement::IsTimeDependent(const nsSMILTimedElement&amp; aOther) const</span>
<span class="lineNum">    1194 </span>            : {
<span class="lineNum">    1195 </span><span class="lineCov">          1 :   const nsSMILInstanceTime* thisBegin = GetEffectiveBeginInstance();</span>
<span class="lineNum">    1196 </span><span class="lineCov">          1 :   const nsSMILInstanceTime* otherBegin = aOther.GetEffectiveBeginInstance();</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineCov">          1 :   if (!thisBegin || !otherBegin)</span>
<span class="lineNum">    1199 </span>            :     return false;
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span><span class="lineCov">          1 :   return thisBegin-&gt;IsDependentOn(*otherBegin);</span>
<span class="lineNum">    1202 </span>            : }
<a name="1203"><span class="lineNum">    1203 </span>            : </a>
<span class="lineNum">    1204 </span>            : void
<span class="lineNum">    1205 </span><span class="lineCov">          1 : nsSMILTimedElement::BindToTree(nsIContent* aContextNode)</span>
<span class="lineNum">    1206 </span>            : {
<span class="lineNum">    1207 </span>            :   // Reset previously registered milestone since we may be registering with
<span class="lineNum">    1208 </span>            :   // a different time container now.
<span class="lineNum">    1209 </span><span class="lineCov">          1 :   mPrevRegisteredMilestone = sMaxMilestone;</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :   // If we were already active then clear all our timing information and start
<span class="lineNum">    1212 </span>            :   // afresh
<span class="lineNum">    1213 </span><span class="lineCov">          1 :   if (mElementState != STATE_STARTUP) {</span>
<span class="lineNum">    1214 </span><span class="lineCov">          1 :     mSeekState = SEEK_NOT_SEEKING;</span>
<span class="lineNum">    1215 </span><span class="lineCov">          1 :     Rewind();</span>
<span class="lineNum">    1216 </span>            :   }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :   // Scope updateBatcher to last only for the ResolveReferences calls:
<span class="lineNum">    1219 </span>            :   {
<span class="lineNum">    1220 </span>            :     AutoIntervalUpdateBatcher updateBatcher(*this);
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            :     // Resolve references to other parts of the tree
<span class="lineNum">    1223 </span><span class="lineCov">          1 :     uint32_t count = mBeginSpecs.Length();</span>
<span class="lineNum">    1224 </span><span class="lineCov">          1 :     for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1225 </span><span class="lineCov">          1 :       mBeginSpecs[i]-&gt;ResolveReferences(aContextNode);</span>
<span class="lineNum">    1226 </span>            :     }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineCov">          1 :     count = mEndSpecs.Length();</span>
<span class="lineNum">    1229 </span><span class="lineCov">          1 :     for (uint32_t j = 0; j &lt; count; ++j) {</span>
<span class="lineNum">    1230 </span><span class="lineCov">          1 :       mEndSpecs[j]-&gt;ResolveReferences(aContextNode);</span>
<span class="lineNum">    1231 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    1232 </span>            :   }
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineCov">          1 :   RegisterMilestone();</span>
<span class="lineNum">    1235 </span><span class="lineCov">          1 : }</span>
<a name="1236"><span class="lineNum">    1236 </span>            : </a>
<span class="lineNum">    1237 </span>            : void
<span class="lineNum">    1238 </span><span class="lineCov">          1 : nsSMILTimedElement::HandleTargetElementChange(Element* aNewTarget)</span>
<span class="lineNum">    1239 </span>            : {
<span class="lineNum">    1240 </span>            :   AutoIntervalUpdateBatcher updateBatcher(*this);
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span><span class="lineCov">          1 :   uint32_t count = mBeginSpecs.Length();</span>
<span class="lineNum">    1243 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     mBeginSpecs[i]-&gt;HandleTargetElementChange(aNewTarget);</span>
<span class="lineNum">    1245 </span>            :   }
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineCov">          1 :   count = mEndSpecs.Length();</span>
<span class="lineNum">    1248 </span><span class="lineCov">          1 :   for (uint32_t j = 0; j &lt; count; ++j) {</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     mEndSpecs[j]-&gt;HandleTargetElementChange(aNewTarget);</span>
<span class="lineNum">    1250 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1251 </span><span class="lineCov">          1 : }</span>
<a name="1252"><span class="lineNum">    1252 </span>            : </a>
<span class="lineNum">    1253 </span>            : void
<span class="lineNum">    1254 </span><span class="lineCov">          1 : nsSMILTimedElement::Traverse(nsCycleCollectionTraversalCallback* aCallback)</span>
<span class="lineNum">    1255 </span>            : {
<span class="lineNum">    1256 </span><span class="lineCov">          1 :   uint32_t count = mBeginSpecs.Length();</span>
<span class="lineNum">    1257 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1258 </span><span class="lineCov">          1 :     nsSMILTimeValueSpec* beginSpec = mBeginSpecs[i];</span>
<span class="lineNum">    1259 </span>            :     MOZ_ASSERT(beginSpec,
<span class="lineNum">    1260 </span>            :                &quot;null nsSMILTimeValueSpec in list of begin specs&quot;);
<span class="lineNum">    1261 </span>            :     beginSpec-&gt;Traverse(aCallback);
<span class="lineNum">    1262 </span>            :   }
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineCov">          1 :   count = mEndSpecs.Length();</span>
<span class="lineNum">    1265 </span><span class="lineCov">          1 :   for (uint32_t j = 0; j &lt; count; ++j) {</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :     nsSMILTimeValueSpec* endSpec = mEndSpecs[j];</span>
<span class="lineNum">    1267 </span>            :     MOZ_ASSERT(endSpec, &quot;null nsSMILTimeValueSpec in list of end specs&quot;);
<span class="lineNum">    1268 </span>            :     endSpec-&gt;Traverse(aCallback);
<span class="lineNum">    1269 </span>            :   }
<span class="lineNum">    1270 </span><span class="lineCov">          1 : }</span>
<a name="1271"><span class="lineNum">    1271 </span>            : </a>
<span class="lineNum">    1272 </span>            : void
<span class="lineNum">    1273 </span><span class="lineCov">          1 : nsSMILTimedElement::Unlink()</span>
<span class="lineNum">    1274 </span>            : {
<span class="lineNum">    1275 </span>            :   AutoIntervalUpdateBatcher updateBatcher(*this);
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            :   // Remove dependencies on other elements
<span class="lineNum">    1278 </span><span class="lineCov">          1 :   uint32_t count = mBeginSpecs.Length();</span>
<span class="lineNum">    1279 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1280 </span><span class="lineCov">          1 :     nsSMILTimeValueSpec* beginSpec = mBeginSpecs[i];</span>
<span class="lineNum">    1281 </span>            :     MOZ_ASSERT(beginSpec,
<span class="lineNum">    1282 </span>            :                &quot;null nsSMILTimeValueSpec in list of begin specs&quot;);
<span class="lineNum">    1283 </span><span class="lineCov">          1 :     beginSpec-&gt;Unlink();</span>
<span class="lineNum">    1284 </span>            :   }
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineCov">          1 :   count = mEndSpecs.Length();</span>
<span class="lineNum">    1287 </span><span class="lineCov">          1 :   for (uint32_t j = 0; j &lt; count; ++j) {</span>
<span class="lineNum">    1288 </span><span class="lineCov">          1 :     nsSMILTimeValueSpec* endSpec = mEndSpecs[j];</span>
<span class="lineNum">    1289 </span>            :     MOZ_ASSERT(endSpec, &quot;null nsSMILTimeValueSpec in list of end specs&quot;);
<span class="lineNum">    1290 </span><span class="lineCov">          1 :     endSpec-&gt;Unlink();</span>
<span class="lineNum">    1291 </span>            :   }
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span><span class="lineCov">          1 :   ClearIntervals();</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :   // Make sure we don't notify other elements of new intervals
<span class="lineNum">    1296 </span><span class="lineCov">          1 :   mTimeDependents.Clear();</span>
<span class="lineNum">    1297 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1300 </span>            : // Implementation helpers
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<span class="lineNum">    1302 </span>            : nsresult
<span class="lineNum">    1303 </span><span class="lineCov">          1 : nsSMILTimedElement::SetBeginOrEndSpec(const nsAString&amp; aSpec,</span>
<span class="lineNum">    1304 </span>            :                                       Element* aContextNode,
<span class="lineNum">    1305 </span>            :                                       bool aIsBegin,
<span class="lineNum">    1306 </span>            :                                       RemovalTestFunction aRemove)
<span class="lineNum">    1307 </span>            : {
<span class="lineNum">    1308 </span><span class="lineCov">          1 :   TimeValueSpecList&amp; timeSpecsList = aIsBegin ? mBeginSpecs : mEndSpecs;</span>
<span class="lineNum">    1309 </span><span class="lineCov">          1 :   InstanceTimeList&amp; instances = aIsBegin ? mBeginInstances : mEndInstances;</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineCov">          1 :   ClearSpecs(timeSpecsList, instances, aRemove);</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            :   AutoIntervalUpdateBatcher updateBatcher(*this);
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span>            :   nsCharSeparatedTokenizer tokenizer(aSpec, ';');
<span class="lineNum">    1316 </span><span class="lineCov">          1 :   if (!tokenizer.hasMoreTokens()) { // Empty list</span>
<span class="lineNum">    1317 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">    1318 </span>            :   }
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            :   nsresult rv = NS_OK;
<span class="lineNum">    1321 </span><span class="lineCov">          1 :   while (tokenizer.hasMoreTokens() &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">    1322 </span>            :     nsAutoPtr&lt;nsSMILTimeValueSpec&gt;
<span class="lineNum">    1323 </span><span class="lineCov">          1 :       spec(new nsSMILTimeValueSpec(*this, aIsBegin));</span>
<span class="lineNum">    1324 </span><span class="lineCov">          1 :     rv = spec-&gt;SetSpec(tokenizer.nextToken(), aContextNode);</span>
<span class="lineNum">    1325 </span><span class="lineCov">          1 :     if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">    1326 </span><span class="lineCov">          1 :       timeSpecsList.AppendElement(spec.forget());</span>
<span class="lineNum">    1327 </span>            :     }
<span class="lineNum">    1328 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineCov">          1 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1331 </span><span class="lineCov">          1 :     ClearSpecs(timeSpecsList, instances, aRemove);</span>
<span class="lineNum">    1332 </span>            :   }
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span><span class="lineCov">          1 :   return rv;</span>
<span class="lineNum">    1335 </span>            : }
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            : namespace
<span class="lineNum">    1338 </span>            : {
<span class="lineNum">    1339 </span>            :   // Adaptor functor for RemoveInstanceTimes that allows us to use function
<span class="lineNum">    1340 </span>            :   // pointers instead.
<span class="lineNum">    1341 </span>            :   // Without this we'd have to either templatize ClearSpecs and all its callers
<span class="lineNum">    1342 </span>            :   // or pass bool flags around to specify which removal function to use here.
<span class="lineNum">    1343 </span>            :   class MOZ_STACK_CLASS RemoveByFunction
<span class="lineNum">    1344 </span>            :   {
<span class="lineNum">    1345 </span>            :   public:
<a name="1346"><span class="lineNum">    1346 </span>            :     explicit RemoveByFunction(nsSMILTimedElement::RemovalTestFunction aFunction)</a>
<span class="lineNum">    1347 </span><span class="lineCov">          1 :       : mFunction(aFunction) { }</span>
<span class="lineNum">    1348 </span><span class="lineCov">          1 :     bool operator()(nsSMILInstanceTime* aInstanceTime, uint32_t /*aIndex*/)</span>
<span class="lineNum">    1349 </span>            :     {
<span class="lineNum">    1350 </span><span class="lineCov">          1 :       return mFunction(aInstanceTime);</span>
<span class="lineNum">    1351 </span>            :     }
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :   private:
<span class="lineNum">    1354 </span>            :     nsSMILTimedElement::RemovalTestFunction mFunction;
<span class="lineNum">    1355 </span>            :   };
<span class="lineNum">    1356 </span>            : } // namespace
<a name="1357"><span class="lineNum">    1357 </span>            : </a>
<span class="lineNum">    1358 </span>            : void
<span class="lineNum">    1359 </span><span class="lineCov">          1 : nsSMILTimedElement::ClearSpecs(TimeValueSpecList&amp; aSpecs,</span>
<span class="lineNum">    1360 </span>            :                                InstanceTimeList&amp; aInstances,
<span class="lineNum">    1361 </span>            :                                RemovalTestFunction aRemove)
<span class="lineNum">    1362 </span>            : {
<span class="lineNum">    1363 </span>            :   AutoIntervalUpdateBatcher updateBatcher(*this);
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; aSpecs.Length(); ++i) {</span>
<span class="lineNum">    1366 </span><span class="lineCov">          1 :     aSpecs[i]-&gt;Unlink();</span>
<span class="lineNum">    1367 </span>            :   }
<span class="lineNum">    1368 </span><span class="lineCov">          1 :   aSpecs.Clear();</span>
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :   RemoveByFunction removeByFunction(aRemove);
<span class="lineNum">    1371 </span><span class="lineCov">          1 :   RemoveInstanceTimes(aInstances, removeByFunction);</span>
<span class="lineNum">    1372 </span><span class="lineCov">          1 : }</span>
<a name="1373"><span class="lineNum">    1373 </span>            : </a>
<span class="lineNum">    1374 </span>            : void
<span class="lineNum">    1375 </span><span class="lineCov">          1 : nsSMILTimedElement::ClearIntervals()</span>
<span class="lineNum">    1376 </span>            : {
<span class="lineNum">    1377 </span><span class="lineCov">          1 :   if (mElementState != STATE_STARTUP) {</span>
<span class="lineNum">    1378 </span><span class="lineCov">          1 :     mElementState = STATE_POSTACTIVE;</span>
<span class="lineNum">    1379 </span>            :   }
<span class="lineNum">    1380 </span><span class="lineCov">          1 :   mCurrentRepeatIteration = 0;</span>
<span class="lineNum">    1381 </span><span class="lineCov">          1 :   ResetCurrentInterval();</span>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            :   // Remove old intervals
<span class="lineNum">    1384 </span><span class="lineCov">          1 :   for (int32_t i = mOldIntervals.Length() - 1; i &gt;= 0; --i) {</span>
<span class="lineNum">    1385 </span><span class="lineCov">          1 :     mOldIntervals[i]-&gt;Unlink();</span>
<span class="lineNum">    1386 </span>            :   }
<span class="lineNum">    1387 </span><span class="lineCov">          1 :   mOldIntervals.Clear();</span>
<span class="lineNum">    1388 </span><span class="lineCov">          1 : }</span>
<a name="1389"><span class="lineNum">    1389 </span>            : </a>
<span class="lineNum">    1390 </span>            : bool
<span class="lineNum">    1391 </span><span class="lineCov">          1 : nsSMILTimedElement::ApplyEarlyEnd(const nsSMILTimeValue&amp; aSampleTime)</span>
<span class="lineNum">    1392 </span>            : {
<span class="lineNum">    1393 </span>            :   // This should only be called within DoSampleAt as a helper function
<span class="lineNum">    1394 </span>            :   MOZ_ASSERT(mElementState == STATE_ACTIVE,
<span class="lineNum">    1395 </span>            :              &quot;Unexpected state to try to apply an early end&quot;);
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineCov">          1 :   bool updated = false;</span>
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span>            :   // Only apply an early end if we're not already ending.
<span class="lineNum">    1400 </span><span class="lineCov">          1 :   if (mCurrentInterval-&gt;End()-&gt;Time() &gt; aSampleTime) {</span>
<span class="lineNum">    1401 </span><span class="lineCov">          1 :     nsSMILInstanceTime* earlyEnd = CheckForEarlyEnd(aSampleTime);</span>
<span class="lineNum">    1402 </span><span class="lineCov">          1 :     if (earlyEnd) {</span>
<span class="lineNum">    1403 </span><span class="lineCov">          1 :       if (earlyEnd-&gt;IsDependent()) {</span>
<span class="lineNum">    1404 </span>            :         // Generate a new instance time for the early end since the
<span class="lineNum">    1405 </span>            :         // existing instance time is part of some dependency chain that we
<span class="lineNum">    1406 </span>            :         // don't want to participate in.
<span class="lineNum">    1407 </span>            :         RefPtr&lt;nsSMILInstanceTime&gt; newEarlyEnd =
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :           new nsSMILInstanceTime(earlyEnd-&gt;Time());</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :         mCurrentInterval-&gt;SetEnd(*newEarlyEnd);</span>
<span class="lineNum">    1410 </span>            :       } else {
<span class="lineNum">    1411 </span><span class="lineCov">          1 :         mCurrentInterval-&gt;SetEnd(*earlyEnd);</span>
<span class="lineNum">    1412 </span>            :       }
<span class="lineNum">    1413 </span>            :       updated = true;
<span class="lineNum">    1414 </span>            :     }
<span class="lineNum">    1415 </span>            :   }
<span class="lineNum">    1416 </span><span class="lineCov">          1 :   return updated;</span>
<span class="lineNum">    1417 </span>            : }
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            : namespace
<span class="lineNum">    1420 </span>            : {
<span class="lineNum">    1421 </span>            :   class MOZ_STACK_CLASS RemoveReset
<span class="lineNum">    1422 </span>            :   {
<span class="lineNum">    1423 </span>            :   public:
<a name="1424"><span class="lineNum">    1424 </span>            :     explicit RemoveReset(const nsSMILInstanceTime* aCurrentIntervalBegin)</a>
<span class="lineNum">    1425 </span><span class="lineCov">          1 :       : mCurrentIntervalBegin(aCurrentIntervalBegin) { }</span>
<span class="lineNum">    1426 </span><span class="lineCov">          1 :     bool operator()(nsSMILInstanceTime* aInstanceTime, uint32_t /*aIndex*/)</span>
<span class="lineNum">    1427 </span>            :     {
<span class="lineNum">    1428 </span>            :       // SMIL 3.0 section 5.4.3, 'Resetting element state':
<span class="lineNum">    1429 </span>            :       //   Any instance times associated with past Event-values, Repeat-values,
<span class="lineNum">    1430 </span>            :       //   Accesskey-values or added via DOM method calls are removed from the
<span class="lineNum">    1431 </span>            :       //   dependent begin and end instance times lists. In effect, all events
<span class="lineNum">    1432 </span>            :       //   and DOM methods calls in the past are cleared. This does not apply to
<span class="lineNum">    1433 </span>            :       //   an instance time that defines the begin of the current interval.
<span class="lineNum">    1434 </span><span class="lineCov">          1 :       return aInstanceTime-&gt;IsDynamic() &amp;&amp;</span>
<span class="lineNum">    1435 </span><span class="lineCov">          1 :              !aInstanceTime-&gt;ShouldPreserve() &amp;&amp;</span>
<span class="lineNum">    1436 </span><span class="lineCov">          1 :              (!mCurrentIntervalBegin || aInstanceTime != mCurrentIntervalBegin);</span>
<span class="lineNum">    1437 </span>            :     }
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span>            :   private:
<span class="lineNum">    1440 </span>            :     const nsSMILInstanceTime* mCurrentIntervalBegin;
<span class="lineNum">    1441 </span>            :   };
<span class="lineNum">    1442 </span>            : } // namespace
<a name="1443"><span class="lineNum">    1443 </span>            : </a>
<span class="lineNum">    1444 </span>            : void
<span class="lineNum">    1445 </span><span class="lineCov">          1 : nsSMILTimedElement::Reset()</span>
<span class="lineNum">    1446 </span>            : {
<span class="lineNum">    1447 </span><span class="lineCov">          1 :   RemoveReset resetBegin(mCurrentInterval ? mCurrentInterval-&gt;Begin() : nullptr);</span>
<span class="lineNum">    1448 </span><span class="lineCov">          1 :   RemoveInstanceTimes(mBeginInstances, resetBegin);</span>
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            :   RemoveReset resetEnd(nullptr);
<span class="lineNum">    1451 </span><span class="lineCov">          1 :   RemoveInstanceTimes(mEndInstances, resetEnd);</span>
<span class="lineNum">    1452 </span><span class="lineCov">          1 : }</span>
<a name="1453"><span class="lineNum">    1453 </span>            : </a>
<span class="lineNum">    1454 </span>            : void
<span class="lineNum">    1455 </span><span class="lineCov">          1 : nsSMILTimedElement::ClearTimingState(RemovalTestFunction aRemove)</span>
<span class="lineNum">    1456 </span>            : {
<span class="lineNum">    1457 </span><span class="lineCov">          1 :   mElementState = STATE_STARTUP;</span>
<span class="lineNum">    1458 </span><span class="lineCov">          1 :   ClearIntervals();</span>
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineCov">          1 :   UnsetBeginSpec(aRemove);</span>
<span class="lineNum">    1461 </span><span class="lineCov">          1 :   UnsetEndSpec(aRemove);</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineCov">          1 :   if (mClient) {</span>
<span class="lineNum">    1464 </span><span class="lineCov">          1 :     mClient-&gt;Inactivate(false);</span>
<span class="lineNum">    1465 </span>            :   }
<span class="lineNum">    1466 </span><span class="lineCov">          1 : }</span>
<a name="1467"><span class="lineNum">    1467 </span>            : </a>
<span class="lineNum">    1468 </span>            : void
<span class="lineNum">    1469 </span><span class="lineCov">          1 : nsSMILTimedElement::RebuildTimingState(RemovalTestFunction aRemove)</span>
<span class="lineNum">    1470 </span>            : {
<span class="lineNum">    1471 </span>            :   MOZ_ASSERT(mAnimationElement,
<span class="lineNum">    1472 </span>            :              &quot;Attempting to enable a timed element not attached to an &quot;
<span class="lineNum">    1473 </span>            :              &quot;animation element&quot;);
<span class="lineNum">    1474 </span>            :   MOZ_ASSERT(mElementState == STATE_STARTUP,
<span class="lineNum">    1475 </span>            :              &quot;Rebuilding timing state from non-startup state&quot;);
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineCov">          1 :   if (mAnimationElement-&gt;HasAnimAttr(nsGkAtoms::begin)) {</span>
<span class="lineNum">    1478 </span><span class="lineCov">          1 :     nsAutoString attValue;</span>
<span class="lineNum">    1479 </span><span class="lineCov">          1 :     mAnimationElement-&gt;GetAnimAttr(nsGkAtoms::begin, attValue);</span>
<span class="lineNum">    1480 </span><span class="lineCov">          1 :     SetBeginSpec(attValue, mAnimationElement, aRemove);</span>
<span class="lineNum">    1481 </span>            :   }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">          1 :   if (mAnimationElement-&gt;HasAnimAttr(nsGkAtoms::end)) {</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :     nsAutoString attValue;</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     mAnimationElement-&gt;GetAnimAttr(nsGkAtoms::end, attValue);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :     SetEndSpec(attValue, mAnimationElement, aRemove);</span>
<span class="lineNum">    1487 </span>            :   }
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span><span class="lineCov">          1 :   mPrevRegisteredMilestone = sMaxMilestone;</span>
<span class="lineNum">    1490 </span><span class="lineCov">          1 :   RegisterMilestone();</span>
<span class="lineNum">    1491 </span><span class="lineCov">          1 : }</span>
<a name="1492"><span class="lineNum">    1492 </span>            : </a>
<span class="lineNum">    1493 </span>            : void
<span class="lineNum">    1494 </span><span class="lineCov">          1 : nsSMILTimedElement::DoPostSeek()</span>
<span class="lineNum">    1495 </span>            : {
<span class="lineNum">    1496 </span>            :   // Finish backwards seek
<span class="lineNum">    1497 </span><span class="lineCov">          1 :   if (mSeekState == SEEK_BACKWARD_FROM_INACTIVE ||</span>
<span class="lineNum">    1498 </span>            :       mSeekState == SEEK_BACKWARD_FROM_ACTIVE) {
<span class="lineNum">    1499 </span>            :     // Previously some dynamic instance times may have been marked to be
<span class="lineNum">    1500 </span>            :     // preserved because they were endpoints of an historic interval (which may
<span class="lineNum">    1501 </span>            :     // or may not have been filtered). Now that we've finished a seek we should
<span class="lineNum">    1502 </span>            :     // clear that flag for those instance times whose intervals are no longer
<span class="lineNum">    1503 </span>            :     // historic.
<span class="lineNum">    1504 </span><span class="lineCov">          1 :     UnpreserveInstanceTimes(mBeginInstances);</span>
<span class="lineNum">    1505 </span><span class="lineCov">          1 :     UnpreserveInstanceTimes(mEndInstances);</span>
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span>            :     // Now that the times have been unmarked perform a reset. This might seem
<span class="lineNum">    1508 </span>            :     // counter-intuitive when we're only doing a seek within an interval but
<span class="lineNum">    1509 </span>            :     // SMIL seems to require this. SMIL 3.0, 'Hyperlinks and timing':
<span class="lineNum">    1510 </span>            :     //   Resolved end times associated with events, Repeat-values,
<span class="lineNum">    1511 </span>            :     //   Accesskey-values or added via DOM method calls are cleared when seeking
<span class="lineNum">    1512 </span>            :     //   to time earlier than the resolved end time.
<span class="lineNum">    1513 </span><span class="lineCov">          1 :     Reset();</span>
<span class="lineNum">    1514 </span><span class="lineCov">          1 :     UpdateCurrentInterval();</span>
<span class="lineNum">    1515 </span>            :   }
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span><span class="lineCov">          1 :   switch (mSeekState)</span>
<span class="lineNum">    1518 </span>            :   {
<span class="lineNum">    1519 </span>            :   case SEEK_FORWARD_FROM_ACTIVE:
<span class="lineNum">    1520 </span>            :   case SEEK_BACKWARD_FROM_ACTIVE:
<span class="lineNum">    1521 </span><span class="lineCov">          1 :     if (mElementState != STATE_ACTIVE) {</span>
<span class="lineNum">    1522 </span><span class="lineCov">          1 :       FireTimeEventAsync(eSMILEndEvent, 0);</span>
<span class="lineNum">    1523 </span>            :     }
<span class="lineNum">    1524 </span>            :     break;
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :   case SEEK_FORWARD_FROM_INACTIVE:
<span class="lineNum">    1527 </span>            :   case SEEK_BACKWARD_FROM_INACTIVE:
<span class="lineNum">    1528 </span><span class="lineCov">          1 :     if (mElementState == STATE_ACTIVE) {</span>
<span class="lineNum">    1529 </span><span class="lineCov">          1 :       FireTimeEventAsync(eSMILBeginEvent, 0);</span>
<span class="lineNum">    1530 </span>            :     }
<span class="lineNum">    1531 </span>            :     break;
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            :   case SEEK_NOT_SEEKING:
<span class="lineNum">    1534 </span>            :     /* Do nothing */
<span class="lineNum">    1535 </span>            :     break;
<span class="lineNum">    1536 </span>            :   }
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span><span class="lineCov">          1 :   mSeekState = SEEK_NOT_SEEKING;</span>
<span class="lineNum">    1539 </span><span class="lineCov">          1 : }</span>
<a name="1540"><span class="lineNum">    1540 </span>            : </a>
<span class="lineNum">    1541 </span>            : void
<span class="lineNum">    1542 </span><span class="lineCov">          1 : nsSMILTimedElement::UnpreserveInstanceTimes(InstanceTimeList&amp; aList)</span>
<span class="lineNum">    1543 </span>            : {
<span class="lineNum">    1544 </span><span class="lineCov">          1 :   const nsSMILInterval* prevInterval = GetPreviousInterval();</span>
<span class="lineNum">    1545 </span>            :   const nsSMILInstanceTime* cutoff = mCurrentInterval ?
<span class="lineNum">    1546 </span><span class="lineCov">          1 :       mCurrentInterval-&gt;Begin() :</span>
<span class="lineNum">    1547 </span><span class="lineCov">          1 :       prevInterval ? prevInterval-&gt;Begin() : nullptr;</span>
<span class="lineNum">    1548 </span><span class="lineCov">          1 :   uint32_t count = aList.Length();</span>
<span class="lineNum">    1549 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1550 </span><span class="lineCov">          1 :     nsSMILInstanceTime* instance = aList[i].get();</span>
<span class="lineNum">    1551 </span><span class="lineCov">          1 :     if (!cutoff || cutoff-&gt;Time().CompareTo(instance-&gt;Time()) &lt; 0) {</span>
<span class="lineNum">    1552 </span><span class="lineCov">          1 :       instance-&gt;UnmarkShouldPreserve();</span>
<span class="lineNum">    1553 </span>            :     }
<span class="lineNum">    1554 </span>            :   }
<span class="lineNum">    1555 </span><span class="lineCov">          1 : }</span>
<a name="1556"><span class="lineNum">    1556 </span>            : </a>
<span class="lineNum">    1557 </span>            : void
<span class="lineNum">    1558 </span><span class="lineCov">          1 : nsSMILTimedElement::FilterHistory()</span>
<span class="lineNum">    1559 </span>            : {
<span class="lineNum">    1560 </span>            :   // We should filter the intervals first, since instance times still used in an
<span class="lineNum">    1561 </span>            :   // interval won't be filtered.
<span class="lineNum">    1562 </span><span class="lineCov">          1 :   FilterIntervals();</span>
<span class="lineNum">    1563 </span><span class="lineCov">          1 :   FilterInstanceTimes(mBeginInstances);</span>
<span class="lineNum">    1564 </span><span class="lineCov">          1 :   FilterInstanceTimes(mEndInstances);</span>
<span class="lineNum">    1565 </span><span class="lineCov">          1 : }</span>
<a name="1566"><span class="lineNum">    1566 </span>            : </a>
<span class="lineNum">    1567 </span>            : void
<span class="lineNum">    1568 </span><span class="lineCov">          1 : nsSMILTimedElement::FilterIntervals()</span>
<span class="lineNum">    1569 </span>            : {
<span class="lineNum">    1570 </span>            :   // We can filter old intervals that:
<span class="lineNum">    1571 </span>            :   //
<span class="lineNum">    1572 </span>            :   // a) are not the previous interval; AND
<span class="lineNum">    1573 </span>            :   // b) are not in the middle of a dependency chain; AND
<span class="lineNum">    1574 </span>            :   // c) are not the first interval
<span class="lineNum">    1575 </span>            :   //
<span class="lineNum">    1576 </span>            :   // Condition (a) is necessary since the previous interval is used for applying
<span class="lineNum">    1577 </span>            :   // fill effects and updating the current interval.
<span class="lineNum">    1578 </span>            :   //
<span class="lineNum">    1579 </span>            :   // Condition (b) is necessary since even if this interval itself is not
<span class="lineNum">    1580 </span>            :   // active, it may be part of a dependency chain that includes active
<span class="lineNum">    1581 </span>            :   // intervals. Such chains are used to establish priorities within the
<span class="lineNum">    1582 </span>            :   // animation sandwich.
<span class="lineNum">    1583 </span>            :   //
<span class="lineNum">    1584 </span>            :   // Condition (c) is necessary to support hyperlinks that target animations
<span class="lineNum">    1585 </span>            :   // since in some cases the defined behavior is to seek the document back to
<span class="lineNum">    1586 </span>            :   // the first resolved begin time. Presumably the intention here is not
<span class="lineNum">    1587 </span>            :   // actually to use the first resolved begin time, the
<span class="lineNum">    1588 </span>            :   // _the_first_resolved_begin_time_that_produced_an_interval. That is,
<span class="lineNum">    1589 </span>            :   // if we have begin=&quot;-5s; -3s; 1s; 3s&quot; with a duration on 1s, we should seek
<span class="lineNum">    1590 </span>            :   // to 1s. The spec doesn't say this but I'm pretty sure that is the intention.
<span class="lineNum">    1591 </span>            :   // It seems negative times were simply not considered.
<span class="lineNum">    1592 </span>            :   //
<span class="lineNum">    1593 </span>            :   // Although the above conditions allow us to safely filter intervals for most
<span class="lineNum">    1594 </span>            :   // scenarios they do not cover all cases and there will still be scenarios
<span class="lineNum">    1595 </span>            :   // that generate intervals indefinitely. In such a case we simply set
<span class="lineNum">    1596 </span>            :   // a maximum number of intervals and drop any intervals beyond that threshold.
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">          1 :   uint32_t threshold = mOldIntervals.Length() &gt; sMaxNumIntervals ?</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :                        mOldIntervals.Length() - sMaxNumIntervals :</span>
<span class="lineNum">    1600 </span><span class="lineCov">          1 :                        0;</span>
<span class="lineNum">    1601 </span>            :   IntervalList filteredList;
<span class="lineNum">    1602 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; mOldIntervals.Length(); ++i)</span>
<span class="lineNum">    1603 </span>            :   {
<span class="lineNum">    1604 </span><span class="lineCov">          1 :     nsSMILInterval* interval = mOldIntervals[i].get();</span>
<span class="lineNum">    1605 </span><span class="lineCov">          1 :     if (i != 0 &amp;&amp; /*skip first interval*/</span>
<span class="lineNum">    1606 </span><span class="lineCov">          1 :         i + 1 &lt; mOldIntervals.Length() &amp;&amp; /*skip previous interval*/</span>
<span class="lineNum">    1607 </span><span class="lineCov">          1 :         (i &lt; threshold || !interval-&gt;IsDependencyChainLink())) {</span>
<span class="lineNum">    1608 </span><span class="lineCov">          1 :       interval-&gt;Unlink(true /*filtered, not deleted*/);</span>
<span class="lineNum">    1609 </span>            :     } else {
<span class="lineNum">    1610 </span><span class="lineCov">          1 :       filteredList.AppendElement(mOldIntervals[i].forget());</span>
<span class="lineNum">    1611 </span>            :     }
<span class="lineNum">    1612 </span>            :   }
<span class="lineNum">    1613 </span><span class="lineCov">          1 :   mOldIntervals.Clear();</span>
<span class="lineNum">    1614 </span><span class="lineCov">          1 :   mOldIntervals.SwapElements(filteredList);</span>
<span class="lineNum">    1615 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            : namespace
<span class="lineNum">    1618 </span>            : {
<span class="lineNum">    1619 </span>            :   class MOZ_STACK_CLASS RemoveFiltered
<span class="lineNum">    1620 </span>            :   {
<a name="1621"><span class="lineNum">    1621 </span>            :   public:</a>
<span class="lineNum">    1622 </span><span class="lineCov">          1 :     explicit RemoveFiltered(nsSMILTimeValue aCutoff) : mCutoff(aCutoff) { }</span>
<span class="lineNum">    1623 </span><span class="lineCov">          1 :     bool operator()(nsSMILInstanceTime* aInstanceTime, uint32_t /*aIndex*/)</span>
<span class="lineNum">    1624 </span>            :     {
<span class="lineNum">    1625 </span>            :       // We can filter instance times that:
<span class="lineNum">    1626 </span>            :       // a) Precede the end point of the previous interval; AND
<span class="lineNum">    1627 </span>            :       // b) Are NOT syncbase times that might be updated to a time after the end
<span class="lineNum">    1628 </span>            :       //    point of the previous interval; AND
<span class="lineNum">    1629 </span>            :       // c) Are NOT fixed end points in any remaining interval.
<span class="lineNum">    1630 </span><span class="lineCov">          1 :       return aInstanceTime-&gt;Time() &lt; mCutoff &amp;&amp;</span>
<span class="lineNum">    1631 </span><span class="lineCov">          1 :              aInstanceTime-&gt;IsFixedTime() &amp;&amp;</span>
<span class="lineNum">    1632 </span><span class="lineCov">          1 :              !aInstanceTime-&gt;ShouldPreserve();</span>
<span class="lineNum">    1633 </span>            :     }
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            :   private:
<span class="lineNum">    1636 </span>            :     nsSMILTimeValue mCutoff;
<span class="lineNum">    1637 </span>            :   };
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span>            :   class MOZ_STACK_CLASS RemoveBelowThreshold
<span class="lineNum">    1640 </span>            :   {
<span class="lineNum">    1641 </span>            :   public:
<span class="lineNum">    1642 </span>            :     RemoveBelowThreshold(uint32_t aThreshold,
<span class="lineNum">    1643 </span>            :                          nsTArray&lt;const nsSMILInstanceTime *&gt;&amp; aTimesToKeep)
<a name="1644"><span class="lineNum">    1644 </span>            :       : mThreshold(aThreshold),</a>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :         mTimesToKeep(aTimesToKeep) { }</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :     bool operator()(nsSMILInstanceTime* aInstanceTime, uint32_t aIndex)</span>
<span class="lineNum">    1647 </span>            :     {
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :       return aIndex &lt; mThreshold &amp;&amp; !mTimesToKeep.Contains(aInstanceTime);</span>
<span class="lineNum">    1649 </span>            :     }
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            :   private:
<span class="lineNum">    1652 </span>            :     uint32_t mThreshold;
<span class="lineNum">    1653 </span>            :     nsTArray&lt;const nsSMILInstanceTime *&gt;&amp; mTimesToKeep;
<span class="lineNum">    1654 </span>            :   };
<span class="lineNum">    1655 </span>            : } // namespace
<a name="1656"><span class="lineNum">    1656 </span>            : </a>
<span class="lineNum">    1657 </span>            : void
<span class="lineNum">    1658 </span><span class="lineCov">          1 : nsSMILTimedElement::FilterInstanceTimes(InstanceTimeList&amp; aList)</span>
<span class="lineNum">    1659 </span>            : {
<span class="lineNum">    1660 </span><span class="lineCov">          1 :   if (GetPreviousInterval()) {</span>
<span class="lineNum">    1661 </span><span class="lineCov">          1 :     RemoveFiltered removeFiltered(GetPreviousInterval()-&gt;End()-&gt;Time());</span>
<span class="lineNum">    1662 </span><span class="lineCov">          1 :     RemoveInstanceTimes(aList, removeFiltered);</span>
<span class="lineNum">    1663 </span>            :   }
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            :   // As with intervals it is possible to create a document that, even despite
<span class="lineNum">    1666 </span>            :   // our most aggressive filtering, will generate instance times indefinitely
<span class="lineNum">    1667 </span>            :   // (e.g. cyclic dependencies with TimeEvents---we can't filter such times as
<span class="lineNum">    1668 </span>            :   // they're unpredictable due to the possibility of seeking the document which
<span class="lineNum">    1669 </span>            :   // may prevent some events from being generated). Therefore we introduce
<span class="lineNum">    1670 </span>            :   // a hard cutoff at which point we just drop the oldest instance times.
<span class="lineNum">    1671 </span><span class="lineCov">          1 :   if (aList.Length() &gt; sMaxNumInstanceTimes) {</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :     uint32_t threshold = aList.Length() - sMaxNumInstanceTimes;</span>
<span class="lineNum">    1673 </span>            :     // There are a few instance times we should keep though, notably:
<span class="lineNum">    1674 </span>            :     // - the current interval begin time,
<span class="lineNum">    1675 </span>            :     // - the previous interval end time (see note in RemoveInstanceTimes)
<span class="lineNum">    1676 </span>            :     // - the first interval begin time (see note in FilterIntervals)
<span class="lineNum">    1677 </span>            :     nsTArray&lt;const nsSMILInstanceTime *&gt; timesToKeep;
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     if (mCurrentInterval) {</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :       timesToKeep.AppendElement(mCurrentInterval-&gt;Begin());</span>
<span class="lineNum">    1680 </span>            :     }
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     const nsSMILInterval* prevInterval = GetPreviousInterval();</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     if (prevInterval) {</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :       timesToKeep.AppendElement(prevInterval-&gt;End());</span>
<span class="lineNum">    1684 </span>            :     }
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :     if (!mOldIntervals.IsEmpty()) {</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :       timesToKeep.AppendElement(mOldIntervals[0]-&gt;Begin());</span>
<span class="lineNum">    1687 </span>            :     }
<span class="lineNum">    1688 </span>            :     RemoveBelowThreshold removeBelowThreshold(threshold, timesToKeep);
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :     RemoveInstanceTimes(aList, removeBelowThreshold);</span>
<span class="lineNum">    1690 </span>            :   }
<span class="lineNum">    1691 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            : //
<span class="lineNum">    1694 </span>            : // This method is based on the pseudocode given in the SMILANIM spec.
<span class="lineNum">    1695 </span>            : //
<span class="lineNum">    1696 </span>            : // See:
<span class="lineNum">    1697 </span>            : // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#Timing-BeginEnd-LC-Start
<a name="1698"><span class="lineNum">    1698 </span>            : //</a>
<span class="lineNum">    1699 </span>            : bool
<span class="lineNum">    1700 </span><span class="lineCov">          1 : nsSMILTimedElement::GetNextInterval(const nsSMILInterval* aPrevInterval,</span>
<span class="lineNum">    1701 </span>            :                                     const nsSMILInterval* aReplacedInterval,
<span class="lineNum">    1702 </span>            :                                     const nsSMILInstanceTime* aFixedBeginTime,
<span class="lineNum">    1703 </span>            :                                     nsSMILInterval&amp; aResult) const
<span class="lineNum">    1704 </span>            : {
<span class="lineNum">    1705 </span>            :   MOZ_ASSERT(!aFixedBeginTime || aFixedBeginTime-&gt;Time().IsDefinite(),
<span class="lineNum">    1706 </span>            :              &quot;Unresolved or indefinite begin time given for interval start&quot;);
<span class="lineNum">    1707 </span><span class="lineCov">          1 :   static const nsSMILTimeValue zeroTime(0L);</span>
<span class="lineNum">    1708 </span>            : 
<span class="lineNum">    1709 </span><span class="lineCov">          1 :   if (mRestartMode == RESTART_NEVER &amp;&amp; aPrevInterval)</span>
<span class="lineNum">    1710 </span>            :     return false;
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            :   // Calc starting point
<span class="lineNum">    1713 </span>            :   nsSMILTimeValue beginAfter;
<span class="lineNum">    1714 </span><span class="lineCov">          1 :   bool prevIntervalWasZeroDur = false;</span>
<span class="lineNum">    1715 </span><span class="lineCov">          1 :   if (aPrevInterval) {</span>
<span class="lineNum">    1716 </span><span class="lineCov">          1 :     beginAfter = aPrevInterval-&gt;End()-&gt;Time();</span>
<span class="lineNum">    1717 </span>            :     prevIntervalWasZeroDur
<span class="lineNum">    1718 </span><span class="lineCov">          1 :       = aPrevInterval-&gt;End()-&gt;Time() == aPrevInterval-&gt;Begin()-&gt;Time();</span>
<span class="lineNum">    1719 </span>            :   } else {
<span class="lineNum">    1720 </span>            :     beginAfter.SetMillis(INT64_MIN);
<span class="lineNum">    1721 </span>            :   }
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            :   RefPtr&lt;nsSMILInstanceTime&gt; tempBegin;
<span class="lineNum">    1724 </span><span class="lineCov">          1 :   RefPtr&lt;nsSMILInstanceTime&gt; tempEnd;</span>
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :   while (true) {
<span class="lineNum">    1727 </span>            :     // Calculate begin time
<span class="lineNum">    1728 </span><span class="lineCov">          1 :     if (aFixedBeginTime) {</span>
<span class="lineNum">    1729 </span><span class="lineCov">          1 :       if (aFixedBeginTime-&gt;Time() &lt; beginAfter) {</span>
<span class="lineNum">    1730 </span>            :         return false;
<span class="lineNum">    1731 </span>            :       }
<span class="lineNum">    1732 </span>            :       // our ref-counting is not const-correct
<span class="lineNum">    1733 </span>            :       tempBegin = const_cast&lt;nsSMILInstanceTime*&gt;(aFixedBeginTime);
<span class="lineNum">    1734 </span><span class="lineCov">          1 :     } else if ((!mAnimationElement ||</span>
<span class="lineNum">    1735 </span><span class="lineCov">          1 :                 !mAnimationElement-&gt;HasAnimAttr(nsGkAtoms::begin)) &amp;&amp;</span>
<span class="lineNum">    1736 </span><span class="lineCov">          1 :                beginAfter &lt;= zeroTime) {</span>
<span class="lineNum">    1737 </span><span class="lineCov">          1 :       tempBegin = new nsSMILInstanceTime(nsSMILTimeValue(0));</span>
<span class="lineNum">    1738 </span>            :     } else {
<span class="lineNum">    1739 </span><span class="lineCov">          1 :       int32_t beginPos = 0;</span>
<span class="lineNum">    1740 </span><span class="lineCov">          1 :       do {</span>
<span class="lineNum">    1741 </span><span class="lineCov">          1 :         tempBegin =</span>
<span class="lineNum">    1742 </span>            :           GetNextGreaterOrEqual(mBeginInstances, beginAfter, beginPos);
<span class="lineNum">    1743 </span><span class="lineCov">          1 :         if (!tempBegin || !tempBegin-&gt;Time().IsDefinite()) {</span>
<span class="lineNum">    1744 </span><span class="lineCov">          1 :           return false;</span>
<span class="lineNum">    1745 </span>            :         }
<span class="lineNum">    1746 </span>            :       // If we're updating the current interval then skip any begin time that is
<span class="lineNum">    1747 </span>            :       // dependent on the current interval's begin time. e.g.
<span class="lineNum">    1748 </span>            :       //   &lt;animate id=&quot;a&quot; begin=&quot;b.begin; a.begin+2s&quot;...
<span class="lineNum">    1749 </span>            :       // If b's interval disappears whilst 'a' is in the waiting state the begin
<span class="lineNum">    1750 </span>            :       // time at &quot;a.begin+2s&quot; should be skipped since 'a' never begun.
<span class="lineNum">    1751 </span><span class="lineCov">          1 :       } while (aReplacedInterval &amp;&amp;</span>
<span class="lineNum">    1752 </span><span class="lineCov">          1 :                tempBegin-&gt;GetBaseTime() == aReplacedInterval-&gt;Begin());</span>
<span class="lineNum">    1753 </span>            :     }
<span class="lineNum">    1754 </span>            :     MOZ_ASSERT(tempBegin &amp;&amp; tempBegin-&gt;Time().IsDefinite() &amp;&amp;
<span class="lineNum">    1755 </span>            :                tempBegin-&gt;Time() &gt;= beginAfter,
<span class="lineNum">    1756 </span>            :                &quot;Got a bad begin time while fetching next interval&quot;);
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :     // Calculate end time
<span class="lineNum">    1759 </span>            :     {
<span class="lineNum">    1760 </span><span class="lineCov">          1 :       int32_t endPos = 0;</span>
<span class="lineNum">    1761 </span><span class="lineCov">          1 :       do {</span>
<span class="lineNum">    1762 </span><span class="lineCov">          1 :         tempEnd =</span>
<span class="lineNum">    1763 </span><span class="lineCov">          1 :           GetNextGreaterOrEqual(mEndInstances, tempBegin-&gt;Time(), endPos);</span>
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            :         // SMIL doesn't allow for coincident zero-duration intervals, so if the
<span class="lineNum">    1766 </span>            :         // previous interval was zero-duration, and tempEnd is going to give us
<span class="lineNum">    1767 </span>            :         // another zero duration interval, then look for another end to use
<span class="lineNum">    1768 </span>            :         // instead.
<span class="lineNum">    1769 </span><span class="lineCov">          1 :         if (tempEnd &amp;&amp; prevIntervalWasZeroDur &amp;&amp;</span>
<span class="lineNum">    1770 </span><span class="lineCov">          1 :             tempEnd-&gt;Time() == beginAfter) {</span>
<span class="lineNum">    1771 </span><span class="lineCov">          1 :           tempEnd = GetNextGreater(mEndInstances, tempBegin-&gt;Time(), endPos);</span>
<span class="lineNum">    1772 </span>            :         }
<span class="lineNum">    1773 </span>            :       // As above with begin times, avoid creating self-referential loops
<span class="lineNum">    1774 </span>            :       // between instance times by checking that the newly found end instance
<span class="lineNum">    1775 </span>            :       // time is not already dependent on the end of the current interval.
<span class="lineNum">    1776 </span><span class="lineCov">          1 :       } while (tempEnd &amp;&amp; aReplacedInterval &amp;&amp;</span>
<span class="lineNum">    1777 </span><span class="lineCov">          1 :                tempEnd-&gt;GetBaseTime() == aReplacedInterval-&gt;End());</span>
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span><span class="lineCov">          1 :       if (!tempEnd) {</span>
<span class="lineNum">    1780 </span>            :         // If all the ends are before the beginning we have a bad interval
<span class="lineNum">    1781 </span>            :         // UNLESS:
<span class="lineNum">    1782 </span>            :         // a) We never had any end attribute to begin with (the SMIL pseudocode
<span class="lineNum">    1783 </span>            :         //    places this condition earlier in the flow but that fails to allow
<span class="lineNum">    1784 </span>            :         //    for DOM calls when no &quot;indefinite&quot; condition is given), OR
<span class="lineNum">    1785 </span>            :         // b) We never had any end instance times to begin with, OR
<span class="lineNum">    1786 </span>            :         // c) We have end events which leave the interval open-ended.
<span class="lineNum">    1787 </span><span class="lineCov">          1 :         bool openEndedIntervalOk = mEndSpecs.IsEmpty() ||</span>
<span class="lineNum">    1788 </span><span class="lineCov">          1 :                                    mEndInstances.IsEmpty() ||</span>
<span class="lineNum">    1789 </span><span class="lineCov">          1 :                                    EndHasEventConditions();</span>
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :         // The above conditions correspond with the SMIL pseudocode but SMIL
<span class="lineNum">    1792 </span>            :         // doesn't address self-dependent instance times which we choose to
<span class="lineNum">    1793 </span>            :         // ignore.
<span class="lineNum">    1794 </span>            :         //
<span class="lineNum">    1795 </span>            :         // Therefore we add a qualification of (b) above that even if
<span class="lineNum">    1796 </span>            :         // there are end instance times but they all depend on the end of the
<span class="lineNum">    1797 </span>            :         // current interval we should act as if they didn't exist and allow the
<span class="lineNum">    1798 </span>            :         // open-ended interval.
<span class="lineNum">    1799 </span>            :         //
<span class="lineNum">    1800 </span>            :         // In the following condition we don't use |= because it doesn't provide
<span class="lineNum">    1801 </span>            :         // short-circuit behavior.
<span class="lineNum">    1802 </span><span class="lineCov">          1 :         openEndedIntervalOk = openEndedIntervalOk ||</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :                              (aReplacedInterval &amp;&amp;</span>
<span class="lineNum">    1804 </span><span class="lineCov">          1 :                               AreEndTimesDependentOn(aReplacedInterval-&gt;End()));</span>
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span><span class="lineCov">          1 :         if (!openEndedIntervalOk) {</span>
<span class="lineNum">    1807 </span><span class="lineCov">          1 :           return false; // Bad interval</span>
<span class="lineNum">    1808 </span>            :         }
<span class="lineNum">    1809 </span>            :       }
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span>            :       nsSMILTimeValue intervalEnd = tempEnd
<span class="lineNum">    1812 </span><span class="lineCov">          1 :                                   ? tempEnd-&gt;Time() : nsSMILTimeValue();</span>
<span class="lineNum">    1813 </span><span class="lineCov">          1 :       nsSMILTimeValue activeEnd = CalcActiveEnd(tempBegin-&gt;Time(), intervalEnd);</span>
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span><span class="lineCov">          1 :       if (!tempEnd || intervalEnd != activeEnd) {</span>
<span class="lineNum">    1816 </span><span class="lineCov">          1 :         tempEnd = new nsSMILInstanceTime(activeEnd);</span>
<span class="lineNum">    1817 </span>            :       }
<span class="lineNum">    1818 </span>            :     }
<span class="lineNum">    1819 </span>            :     MOZ_ASSERT(tempEnd, &quot;Failed to get end point for next interval&quot;);
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            :     // When we choose the interval endpoints, we don't allow coincident
<span class="lineNum">    1822 </span>            :     // zero-duration intervals, so if we arrive here and we have a zero-duration
<span class="lineNum">    1823 </span>            :     // interval starting at the same point as a previous zero-duration interval,
<span class="lineNum">    1824 </span>            :     // then it must be because we've applied constraints to the active duration.
<span class="lineNum">    1825 </span>            :     // In that case, we will potentially run into an infinite loop, so we break
<span class="lineNum">    1826 </span>            :     // it by searching for the next interval that starts AFTER our current
<span class="lineNum">    1827 </span>            :     // zero-duration interval.
<span class="lineNum">    1828 </span><span class="lineCov">          1 :     if (prevIntervalWasZeroDur &amp;&amp; tempEnd-&gt;Time() == beginAfter) {</span>
<span class="lineNum">    1829 </span><span class="lineCov">          1 :       if (prevIntervalWasZeroDur) {</span>
<span class="lineNum">    1830 </span><span class="lineCov">          1 :         beginAfter.SetMillis(tempBegin-&gt;Time().GetMillis() + 1);</span>
<span class="lineNum">    1831 </span><span class="lineCov">          1 :         prevIntervalWasZeroDur = false;</span>
<span class="lineNum">    1832 </span><span class="lineCov">          1 :         continue;</span>
<span class="lineNum">    1833 </span>            :       }
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span><span class="lineCov">          1 :     prevIntervalWasZeroDur = tempBegin-&gt;Time() == tempEnd-&gt;Time();</span>
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :     // Check for valid interval
<span class="lineNum">    1838 </span><span class="lineCov">          1 :     if (tempEnd-&gt;Time() &gt; zeroTime ||</span>
<span class="lineNum">    1839 </span><span class="lineCov">          1 :        (tempBegin-&gt;Time() == zeroTime &amp;&amp; tempEnd-&gt;Time() == zeroTime)) {</span>
<span class="lineNum">    1840 </span><span class="lineCov">          1 :       aResult.Set(*tempBegin, *tempEnd);</span>
<span class="lineNum">    1841 </span><span class="lineCov">          1 :       return true;</span>
<span class="lineNum">    1842 </span>            :     }
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span><span class="lineCov">          1 :     if (mRestartMode == RESTART_NEVER) {</span>
<span class="lineNum">    1845 </span>            :       // tempEnd &lt;= 0 so we're going to loop which effectively means restarting
<span class="lineNum">    1846 </span>            :       return false;
<span class="lineNum">    1847 </span>            :     }
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span><span class="lineCov">          1 :     beginAfter = tempEnd-&gt;Time();</span>
<span class="lineNum">    1850 </span>            :   }
<span class="lineNum">    1851 </span>            :   NS_NOTREACHED(&quot;Hmm... we really shouldn't be here&quot;);
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span><span class="lineCov">          1 :   return false;</span>
<span class="lineNum">    1854 </span>            : }
<a name="1855"><span class="lineNum">    1855 </span>            : </a>
<span class="lineNum">    1856 </span>            : nsSMILInstanceTime*
<span class="lineNum">    1857 </span><span class="lineCov">          1 : nsSMILTimedElement::GetNextGreater(const InstanceTimeList&amp; aList,</span>
<span class="lineNum">    1858 </span>            :                                    const nsSMILTimeValue&amp; aBase,
<span class="lineNum">    1859 </span>            :                                    int32_t&amp; aPosition) const
<span class="lineNum">    1860 </span>            : {
<span class="lineNum">    1861 </span><span class="lineCov">          1 :   nsSMILInstanceTime* result = nullptr;</span>
<span class="lineNum">    1862 </span><span class="lineCov">          1 :   while ((result = GetNextGreaterOrEqual(aList, aBase, aPosition)) &amp;&amp;</span>
<span class="lineNum">    1863 </span><span class="lineCov">          1 :          result-&gt;Time() == aBase) { }</span>
<span class="lineNum">    1864 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">    1865 </span>            : }
<a name="1866"><span class="lineNum">    1866 </span>            : </a>
<span class="lineNum">    1867 </span>            : nsSMILInstanceTime*
<span class="lineNum">    1868 </span><span class="lineCov">          1 : nsSMILTimedElement::GetNextGreaterOrEqual(const InstanceTimeList&amp; aList,</span>
<span class="lineNum">    1869 </span>            :                                           const nsSMILTimeValue&amp; aBase,
<span class="lineNum">    1870 </span>            :                                           int32_t&amp; aPosition) const
<span class="lineNum">    1871 </span>            : {
<span class="lineNum">    1872 </span><span class="lineCov">          1 :   nsSMILInstanceTime* result = nullptr;</span>
<span class="lineNum">    1873 </span><span class="lineCov">          1 :   int32_t count = aList.Length();</span>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineCov">          1 :   for (; aPosition &lt; count &amp;&amp; !result; ++aPosition) {</span>
<span class="lineNum">    1876 </span><span class="lineCov">          1 :     nsSMILInstanceTime* val = aList[aPosition].get();</span>
<span class="lineNum">    1877 </span>            :     MOZ_ASSERT(val, &quot;NULL instance time in list&quot;);
<span class="lineNum">    1878 </span><span class="lineCov">          1 :     if (val-&gt;Time() &gt;= aBase) {</span>
<span class="lineNum">    1879 </span><span class="lineCov">          1 :       result = val;</span>
<span class="lineNum">    1880 </span>            :     }
<span class="lineNum">    1881 </span>            :   }
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">    1884 </span>            : }
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            : /**
<span class="lineNum">    1887 </span>            :  * @see SMILANIM 3.3.4
<a name="1888"><span class="lineNum">    1888 </span>            :  */</a>
<span class="lineNum">    1889 </span>            : nsSMILTimeValue
<span class="lineNum">    1890 </span><span class="lineCov">          1 : nsSMILTimedElement::CalcActiveEnd(const nsSMILTimeValue&amp; aBegin,</span>
<span class="lineNum">    1891 </span>            :                                   const nsSMILTimeValue&amp; aEnd) const
<span class="lineNum">    1892 </span>            : {
<span class="lineNum">    1893 </span>            :   nsSMILTimeValue result;
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span>            :   MOZ_ASSERT(mSimpleDur.IsResolved(),
<span class="lineNum">    1896 </span>            :              &quot;Unresolved simple duration in CalcActiveEnd&quot;);
<span class="lineNum">    1897 </span>            :   MOZ_ASSERT(aBegin.IsDefinite(),
<span class="lineNum">    1898 </span>            :              &quot;Indefinite or unresolved begin time in CalcActiveEnd&quot;);
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span><span class="lineCov">          1 :   result = GetRepeatDuration();</span>
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span><span class="lineCov">          1 :   if (aEnd.IsDefinite()) {</span>
<span class="lineNum">    1903 </span><span class="lineCov">          1 :     nsSMILTime activeDur = aEnd.GetMillis() - aBegin.GetMillis();</span>
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span><span class="lineCov">          1 :     if (result.IsDefinite()) {</span>
<span class="lineNum">    1906 </span><span class="lineCov">          1 :       result.SetMillis(std::min(result.GetMillis(), activeDur));</span>
<span class="lineNum">    1907 </span>            :     } else {
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :       result.SetMillis(activeDur);</span>
<span class="lineNum">    1909 </span>            :     }
<span class="lineNum">    1910 </span>            :   }
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span><span class="lineCov">          1 :   result = ApplyMinAndMax(result);</span>
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span><span class="lineCov">          1 :   if (result.IsDefinite()) {</span>
<span class="lineNum">    1915 </span><span class="lineCov">          1 :     nsSMILTime activeEnd = result.GetMillis() + aBegin.GetMillis();</span>
<span class="lineNum">    1916 </span>            :     result.SetMillis(activeEnd);
<span class="lineNum">    1917 </span>            :   }
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">    1920 </span>            : }
<a name="1921"><span class="lineNum">    1921 </span>            : </a>
<span class="lineNum">    1922 </span>            : nsSMILTimeValue
<span class="lineNum">    1923 </span><span class="lineCov">          1 : nsSMILTimedElement::GetRepeatDuration() const</span>
<span class="lineNum">    1924 </span>            : {
<span class="lineNum">    1925 </span>            :   nsSMILTimeValue multipliedDuration;
<span class="lineNum">    1926 </span><span class="lineCov">          1 :   if (mRepeatCount.IsDefinite() &amp;&amp; mSimpleDur.IsDefinite()) {</span>
<span class="lineNum">    1927 </span>            :     multipliedDuration.SetMillis(
<span class="lineNum">    1928 </span><span class="lineCov">          1 :       nsSMILTime(mRepeatCount * double(mSimpleDur.GetMillis())));</span>
<span class="lineNum">    1929 </span>            :   } else {
<span class="lineNum">    1930 </span>            :     multipliedDuration.SetIndefinite();
<span class="lineNum">    1931 </span>            :   }
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span>            :   nsSMILTimeValue repeatDuration;
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span><span class="lineCov">          1 :   if (mRepeatDur.IsResolved()) {</span>
<span class="lineNum">    1936 </span><span class="lineCov">          1 :     repeatDuration = std::min(multipliedDuration, mRepeatDur);</span>
<span class="lineNum">    1937 </span><span class="lineCov">          1 :   } else if (mRepeatCount.IsSet()) {</span>
<span class="lineNum">    1938 </span><span class="lineCov">          1 :     repeatDuration = multipliedDuration;</span>
<span class="lineNum">    1939 </span>            :   } else {
<span class="lineNum">    1940 </span><span class="lineCov">          1 :     repeatDuration = mSimpleDur;</span>
<span class="lineNum">    1941 </span>            :   }
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span><span class="lineCov">          1 :   return repeatDuration;</span>
<span class="lineNum">    1944 </span>            : }
<a name="1945"><span class="lineNum">    1945 </span>            : </a>
<span class="lineNum">    1946 </span>            : nsSMILTimeValue
<span class="lineNum">    1947 </span><span class="lineCov">          1 : nsSMILTimedElement::ApplyMinAndMax(const nsSMILTimeValue&amp; aDuration) const</span>
<span class="lineNum">    1948 </span>            : {
<span class="lineNum">    1949 </span><span class="lineCov">          1 :   if (!aDuration.IsResolved()) {</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :     return aDuration;</span>
<span class="lineNum">    1951 </span>            :   }
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span><span class="lineCov">          1 :   if (mMax &lt; mMin) {</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :     return aDuration;</span>
<span class="lineNum">    1955 </span>            :   }
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            :   nsSMILTimeValue result;
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span><span class="lineCov">          1 :   if (aDuration &gt; mMax) {</span>
<span class="lineNum">    1960 </span><span class="lineCov">          1 :     result = mMax;</span>
<span class="lineNum">    1961 </span><span class="lineCov">          1 :   } else if (aDuration &lt; mMin) {</span>
<span class="lineNum">    1962 </span><span class="lineCov">          1 :     result = mMin;</span>
<span class="lineNum">    1963 </span>            :   } else {
<span class="lineNum">    1964 </span><span class="lineCov">          1 :     result = aDuration;</span>
<span class="lineNum">    1965 </span>            :   }
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">    1968 </span>            : }
<a name="1969"><span class="lineNum">    1969 </span>            : </a>
<span class="lineNum">    1970 </span>            : nsSMILTime
<span class="lineNum">    1971 </span><span class="lineCov">          1 : nsSMILTimedElement::ActiveTimeToSimpleTime(nsSMILTime aActiveTime,</span>
<span class="lineNum">    1972 </span>            :                                            uint32_t&amp; aRepeatIteration)
<span class="lineNum">    1973 </span>            : {
<span class="lineNum">    1974 </span>            :   nsSMILTime result;
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            :   MOZ_ASSERT(mSimpleDur.IsResolved(),
<span class="lineNum">    1977 </span>            :              &quot;Unresolved simple duration in ActiveTimeToSimpleTime&quot;);
<span class="lineNum">    1978 </span>            :   MOZ_ASSERT(aActiveTime &gt;= 0, &quot;Expecting non-negative active time&quot;);
<span class="lineNum">    1979 </span>            :   // Note that a negative aActiveTime will give us a negative value for
<span class="lineNum">    1980 </span>            :   // aRepeatIteration, which is bad because aRepeatIteration is unsigned
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineCov">          1 :   if (mSimpleDur.IsIndefinite() || mSimpleDur.GetMillis() == 0L) {</span>
<span class="lineNum">    1983 </span><span class="lineCov">          1 :     aRepeatIteration = 0;</span>
<span class="lineNum">    1984 </span><span class="lineCov">          1 :     result = aActiveTime;</span>
<span class="lineNum">    1985 </span>            :   } else {
<span class="lineNum">    1986 </span><span class="lineCov">          1 :     result = aActiveTime % mSimpleDur.GetMillis();</span>
<span class="lineNum">    1987 </span><span class="lineCov">          1 :     aRepeatIteration = (uint32_t)(aActiveTime / mSimpleDur.GetMillis());</span>
<span class="lineNum">    1988 </span>            :   }
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">    1991 </span>            : }
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span>            : //
<span class="lineNum">    1994 </span>            : // Although in many cases it would be possible to check for an early end and
<span class="lineNum">    1995 </span>            : // adjust the current interval well in advance the SMIL Animation spec seems to
<span class="lineNum">    1996 </span>            : // indicate that we should only apply an early end at the latest possible
<span class="lineNum">    1997 </span>            : // moment. In particular, this paragraph from section 3.6.8:
<span class="lineNum">    1998 </span>            : //
<span class="lineNum">    1999 </span>            : // 'If restart  is set to &quot;always&quot;, then the current interval will end early if
<span class="lineNum">    2000 </span>            : // there is an instance time in the begin list that is before (i.e. earlier
<span class="lineNum">    2001 </span>            : // than) the defined end for the current interval. Ending in this manner will
<span class="lineNum">    2002 </span>            : // also send a changed time notice to all time dependents for the current
<span class="lineNum">    2003 </span>            : // interval end.'
<a name="2004"><span class="lineNum">    2004 </span>            : //</a>
<span class="lineNum">    2005 </span>            : nsSMILInstanceTime*
<span class="lineNum">    2006 </span><span class="lineCov">          1 : nsSMILTimedElement::CheckForEarlyEnd(</span>
<span class="lineNum">    2007 </span>            :     const nsSMILTimeValue&amp; aContainerTime) const
<span class="lineNum">    2008 </span>            : {
<span class="lineNum">    2009 </span>            :   MOZ_ASSERT(mCurrentInterval,
<span class="lineNum">    2010 </span>            :              &quot;Checking for an early end but the current interval is not set&quot;);
<span class="lineNum">    2011 </span><span class="lineCov">          1 :   if (mRestartMode != RESTART_ALWAYS)</span>
<span class="lineNum">    2012 </span>            :     return nullptr;
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineCov">          1 :   int32_t position = 0;</span>
<span class="lineNum">    2015 </span>            :   nsSMILInstanceTime* nextBegin =
<span class="lineNum">    2016 </span><span class="lineCov">          1 :     GetNextGreater(mBeginInstances, mCurrentInterval-&gt;Begin()-&gt;Time(),</span>
<span class="lineNum">    2017 </span><span class="lineCov">          1 :                    position);</span>
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineCov">          1 :   if (nextBegin &amp;&amp;</span>
<span class="lineNum">    2020 </span><span class="lineCov">          1 :       nextBegin-&gt;Time() &gt; mCurrentInterval-&gt;Begin()-&gt;Time() &amp;&amp;</span>
<span class="lineNum">    2021 </span><span class="lineCov">          1 :       nextBegin-&gt;Time() &lt; mCurrentInterval-&gt;End()-&gt;Time() &amp;&amp;</span>
<span class="lineNum">    2022 </span><span class="lineCov">          1 :       nextBegin-&gt;Time() &lt;= aContainerTime) {</span>
<span class="lineNum">    2023 </span><span class="lineCov">          1 :     return nextBegin;</span>
<span class="lineNum">    2024 </span>            :   }
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span>            :   return nullptr;
<span class="lineNum">    2027 </span>            : }
<a name="2028"><span class="lineNum">    2028 </span>            : </a>
<span class="lineNum">    2029 </span>            : void
<span class="lineNum">    2030 </span><span class="lineCov">          1 : nsSMILTimedElement::UpdateCurrentInterval(bool aForceChangeNotice)</span>
<span class="lineNum">    2031 </span>            : {
<span class="lineNum">    2032 </span>            :   // Check if updates are currently blocked (batched)
<span class="lineNum">    2033 </span><span class="lineCov">          1 :   if (mDeferIntervalUpdates) {</span>
<span class="lineNum">    2034 </span><span class="lineCov">          1 :     mDoDeferredUpdate = true;</span>
<span class="lineNum">    2035 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    2036 </span>            :   }
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            :   // We adopt the convention of not resolving intervals until the first
<span class="lineNum">    2039 </span>            :   // sample. Otherwise, every time each attribute is set we'll re-resolve the
<span class="lineNum">    2040 </span>            :   // current interval and notify all our time dependents of the change.
<span class="lineNum">    2041 </span>            :   //
<span class="lineNum">    2042 </span>            :   // The disadvantage of deferring resolving the interval is that DOM calls to
<span class="lineNum">    2043 </span>            :   // to getStartTime will throw an INVALID_STATE_ERR exception until the
<span class="lineNum">    2044 </span>            :   // document timeline begins since the start time has not yet been resolved.
<span class="lineNum">    2045 </span><span class="lineCov">          1 :   if (mElementState == STATE_STARTUP)</span>
<span class="lineNum">    2046 </span>            :     return;
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span>            :   // Although SMIL gives rules for detecting cycles in change notifications,
<span class="lineNum">    2049 </span>            :   // some configurations can lead to create-delete-create-delete-etc. cycles
<span class="lineNum">    2050 </span>            :   // which SMIL does not consider.
<span class="lineNum">    2051 </span>            :   //
<span class="lineNum">    2052 </span>            :   // In order to provide consistent behavior in such cases, we detect two
<span class="lineNum">    2053 </span>            :   // deletes in a row and then refuse to create any further intervals. That is,
<span class="lineNum">    2054 </span>            :   // we say the configuration is invalid.
<span class="lineNum">    2055 </span><span class="lineCov">          1 :   if (mDeleteCount &gt; 1) {</span>
<span class="lineNum">    2056 </span>            :     // When we update the delete count we also set the state to post active, so
<span class="lineNum">    2057 </span>            :     // if we're not post active here then something other than
<span class="lineNum">    2058 </span>            :     // UpdateCurrentInterval has updated the element state in between and all
<span class="lineNum">    2059 </span>            :     // bets are off.
<span class="lineNum">    2060 </span>            :     MOZ_ASSERT(mElementState == STATE_POSTACTIVE,
<span class="lineNum">    2061 </span>            :                &quot;Expected to be in post-active state after performing double &quot;
<span class="lineNum">    2062 </span>            :                &quot;delete&quot;);
<span class="lineNum">    2063 </span>            :     return;
<span class="lineNum">    2064 </span>            :   }
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span>            :   // Check that we aren't stuck in infinite recursion updating some syncbase
<span class="lineNum">    2067 </span>            :   // dependencies. Generally such situations should be detected in advance and
<span class="lineNum">    2068 </span>            :   // the chain broken in a sensible and predictable manner, so if we're hitting
<span class="lineNum">    2069 </span>            :   // this assertion we need to work out how to detect the case that's causing
<span class="lineNum">    2070 </span>            :   // it. In release builds, just bail out before we overflow the stack.
<span class="lineNum">    2071 </span><span class="lineCov">          1 :   AutoRestore&lt;uint8_t&gt; depthRestorer(mUpdateIntervalRecursionDepth);</span>
<span class="lineNum">    2072 </span><span class="lineCov">          1 :   if (++mUpdateIntervalRecursionDepth &gt; sMaxUpdateIntervalRecursionDepth) {</span>
<span class="lineNum">    2073 </span>            :     MOZ_ASSERT(false,
<span class="lineNum">    2074 </span>            :                &quot;Update current interval recursion depth exceeded threshold&quot;);
<span class="lineNum">    2075 </span>            :     return;
<span class="lineNum">    2076 </span>            :   }
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            :   // If the interval is active the begin time is fixed.
<span class="lineNum">    2079 </span>            :   const nsSMILInstanceTime* beginTime = mElementState == STATE_ACTIVE
<span class="lineNum">    2080 </span><span class="lineCov">          1 :                                       ? mCurrentInterval-&gt;Begin()</span>
<span class="lineNum">    2081 </span><span class="lineCov">          1 :                                       : nullptr;</span>
<span class="lineNum">    2082 </span><span class="lineCov">          1 :   nsSMILInterval updatedInterval;</span>
<span class="lineNum">    2083 </span><span class="lineCov">          1 :   if (GetNextInterval(GetPreviousInterval(), mCurrentInterval,</span>
<span class="lineNum">    2084 </span><span class="lineCov">          1 :                       beginTime, updatedInterval)) {</span>
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span><span class="lineCov">          1 :     if (mElementState == STATE_POSTACTIVE) {</span>
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span>            :       MOZ_ASSERT(!mCurrentInterval,
<span class="lineNum">    2089 </span>            :                  &quot;In postactive state but the interval has been set&quot;);
<span class="lineNum">    2090 </span><span class="lineCov">          1 :       mCurrentInterval = new nsSMILInterval(updatedInterval);</span>
<span class="lineNum">    2091 </span><span class="lineCov">          1 :       mElementState = STATE_WAITING;</span>
<span class="lineNum">    2092 </span><span class="lineCov">          1 :       NotifyNewInterval();</span>
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            :     } else {
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span><span class="lineCov">          1 :       bool beginChanged = false;</span>
<span class="lineNum">    2097 </span><span class="lineCov">          1 :       bool endChanged   = false;</span>
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span><span class="lineCov">          1 :       if (mElementState != STATE_ACTIVE &amp;&amp;</span>
<span class="lineNum">    2100 </span>            :           !updatedInterval.Begin()-&gt;SameTimeAndBase(
<span class="lineNum">    2101 </span><span class="lineCov">          1 :             *mCurrentInterval-&gt;Begin())) {</span>
<span class="lineNum">    2102 </span><span class="lineCov">          1 :         mCurrentInterval-&gt;SetBegin(*updatedInterval.Begin());</span>
<span class="lineNum">    2103 </span><span class="lineCov">          1 :         beginChanged = true;</span>
<span class="lineNum">    2104 </span>            :       }
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span><span class="lineCov">          1 :       if (!updatedInterval.End()-&gt;SameTimeAndBase(*mCurrentInterval-&gt;End())) {</span>
<span class="lineNum">    2107 </span><span class="lineCov">          1 :         mCurrentInterval-&gt;SetEnd(*updatedInterval.End());</span>
<span class="lineNum">    2108 </span><span class="lineCov">          1 :         endChanged = true;</span>
<span class="lineNum">    2109 </span>            :       }
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineCov">          1 :       if (beginChanged || endChanged || aForceChangeNotice) {</span>
<span class="lineNum">    2112 </span><span class="lineCov">          1 :         NotifyChangedInterval(mCurrentInterval, beginChanged, endChanged);</span>
<span class="lineNum">    2113 </span>            :       }
<span class="lineNum">    2114 </span>            :     }
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            :     // There's a chance our next milestone has now changed, so update the time
<span class="lineNum">    2117 </span>            :     // container
<span class="lineNum">    2118 </span><span class="lineCov">          1 :     RegisterMilestone();</span>
<span class="lineNum">    2119 </span>            :   } else { // GetNextInterval failed: Current interval is no longer valid
<span class="lineNum">    2120 </span><span class="lineCov">          1 :     if (mElementState == STATE_ACTIVE) {</span>
<span class="lineNum">    2121 </span>            :       // The interval is active so we can't just delete it, instead trim it so
<span class="lineNum">    2122 </span>            :       // that begin==end.
<span class="lineNum">    2123 </span><span class="lineCov">          1 :       if (!mCurrentInterval-&gt;End()-&gt;SameTimeAndBase(*mCurrentInterval-&gt;Begin()))</span>
<span class="lineNum">    2124 </span>            :       {
<span class="lineNum">    2125 </span><span class="lineCov">          1 :         mCurrentInterval-&gt;SetEnd(*mCurrentInterval-&gt;Begin());</span>
<span class="lineNum">    2126 </span><span class="lineCov">          1 :         NotifyChangedInterval(mCurrentInterval, false, true);</span>
<span class="lineNum">    2127 </span>            :       }
<span class="lineNum">    2128 </span>            :       // The transition to the postactive state will take place on the next
<span class="lineNum">    2129 </span>            :       // sample (along with firing end events, clearing intervals etc.)
<span class="lineNum">    2130 </span><span class="lineCov">          1 :       RegisterMilestone();</span>
<span class="lineNum">    2131 </span><span class="lineCov">          1 :     } else if (mElementState == STATE_WAITING) {</span>
<span class="lineNum">    2132 </span><span class="lineCov">          1 :       AutoRestore&lt;uint8_t&gt; deleteCountRestorer(mDeleteCount);</span>
<span class="lineNum">    2133 </span><span class="lineCov">          1 :       ++mDeleteCount;</span>
<span class="lineNum">    2134 </span><span class="lineCov">          1 :       mElementState = STATE_POSTACTIVE;</span>
<span class="lineNum">    2135 </span><span class="lineCov">          1 :       ResetCurrentInterval();</span>
<span class="lineNum">    2136 </span>            :     }
<span class="lineNum">    2137 </span>            :   }
<span class="lineNum">    2138 </span>            : }
<a name="2139"><span class="lineNum">    2139 </span>            : </a>
<span class="lineNum">    2140 </span>            : void
<span class="lineNum">    2141 </span><span class="lineCov">          1 : nsSMILTimedElement::SampleSimpleTime(nsSMILTime aActiveTime)</span>
<span class="lineNum">    2142 </span>            : {
<span class="lineNum">    2143 </span><span class="lineCov">          1 :   if (mClient) {</span>
<span class="lineNum">    2144 </span>            :     uint32_t repeatIteration;
<span class="lineNum">    2145 </span>            :     nsSMILTime simpleTime =
<span class="lineNum">    2146 </span><span class="lineCov">          1 :       ActiveTimeToSimpleTime(aActiveTime, repeatIteration);</span>
<span class="lineNum">    2147 </span><span class="lineCov">          1 :     mClient-&gt;SampleAt(simpleTime, mSimpleDur, repeatIteration);</span>
<span class="lineNum">    2148 </span>            :   }
<span class="lineNum">    2149 </span><span class="lineCov">          1 : }</span>
<a name="2150"><span class="lineNum">    2150 </span>            : </a>
<span class="lineNum">    2151 </span>            : void
<span class="lineNum">    2152 </span><span class="lineCov">          1 : nsSMILTimedElement::SampleFillValue()</span>
<span class="lineNum">    2153 </span>            : {
<span class="lineNum">    2154 </span><span class="lineCov">          1 :   if (mFillMode != FILL_FREEZE || !mClient)</span>
<span class="lineNum">    2155 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    2156 </span>            : 
<span class="lineNum">    2157 </span>            :   nsSMILTime activeTime;
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span><span class="lineCov">          1 :   if (mElementState == STATE_WAITING || mElementState == STATE_POSTACTIVE) {</span>
<span class="lineNum">    2160 </span><span class="lineCov">          1 :     const nsSMILInterval* prevInterval = GetPreviousInterval();</span>
<span class="lineNum">    2161 </span>            :     MOZ_ASSERT(prevInterval,
<span class="lineNum">    2162 </span>            :                &quot;Attempting to sample fill value but there is no previous &quot;
<span class="lineNum">    2163 </span>            :                &quot;interval&quot;);
<span class="lineNum">    2164 </span>            :     MOZ_ASSERT(prevInterval-&gt;End()-&gt;Time().IsDefinite() &amp;&amp;
<span class="lineNum">    2165 </span>            :                prevInterval-&gt;End()-&gt;IsFixedTime(),
<span class="lineNum">    2166 </span>            :                &quot;Attempting to sample fill value but the endpoint of the &quot;
<span class="lineNum">    2167 </span>            :                &quot;previous interval is not resolved and fixed&quot;);
<span class="lineNum">    2168 </span>            : 
<span class="lineNum">    2169 </span><span class="lineCov">          1 :     activeTime = prevInterval-&gt;End()-&gt;Time().GetMillis() -</span>
<span class="lineNum">    2170 </span><span class="lineCov">          1 :                  prevInterval-&gt;Begin()-&gt;Time().GetMillis();</span>
<span class="lineNum">    2171 </span>            : 
<span class="lineNum">    2172 </span>            :     // If the interval's repeat duration was shorter than its active duration,
<span class="lineNum">    2173 </span>            :     // use the end of the repeat duration to determine the frozen animation's
<span class="lineNum">    2174 </span>            :     // state.
<span class="lineNum">    2175 </span><span class="lineCov">          1 :     nsSMILTimeValue repeatDuration = GetRepeatDuration();</span>
<span class="lineNum">    2176 </span><span class="lineCov">          1 :     if (repeatDuration.IsDefinite()) {</span>
<span class="lineNum">    2177 </span><span class="lineCov">          1 :       activeTime = std::min(repeatDuration.GetMillis(), activeTime);</span>
<span class="lineNum">    2178 </span>            :     }
<span class="lineNum">    2179 </span>            :   } else {
<span class="lineNum">    2180 </span>            :     MOZ_ASSERT(mElementState == STATE_ACTIVE,
<span class="lineNum">    2181 </span>            :         &quot;Attempting to sample fill value when we're in an unexpected state &quot;
<span class="lineNum">    2182 </span>            :         &quot;(probably STATE_STARTUP)&quot;);
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span>            :     // If we are being asked to sample the fill value while active we *must*
<span class="lineNum">    2185 </span>            :     // have a repeat duration shorter than the active duration so use that.
<span class="lineNum">    2186 </span>            :     MOZ_ASSERT(GetRepeatDuration().IsDefinite(),
<span class="lineNum">    2187 </span>            :         &quot;Attempting to sample fill value of an active animation with &quot;
<span class="lineNum">    2188 </span>            :         &quot;an indefinite repeat duration&quot;);
<span class="lineNum">    2189 </span><span class="lineCov">          1 :     activeTime = GetRepeatDuration().GetMillis();</span>
<span class="lineNum">    2190 </span>            :   }
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span>            :   uint32_t repeatIteration;
<span class="lineNum">    2193 </span>            :   nsSMILTime simpleTime =
<span class="lineNum">    2194 </span><span class="lineCov">          1 :     ActiveTimeToSimpleTime(activeTime, repeatIteration);</span>
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span><span class="lineCov">          1 :   if (simpleTime == 0L &amp;&amp; repeatIteration) {</span>
<span class="lineNum">    2197 </span><span class="lineCov">          1 :     mClient-&gt;SampleLastValue(--repeatIteration);</span>
<span class="lineNum">    2198 </span>            :   } else {
<span class="lineNum">    2199 </span><span class="lineCov">          1 :     mClient-&gt;SampleAt(simpleTime, mSimpleDur, repeatIteration);</span>
<span class="lineNum">    2200 </span>            :   }
<span class="lineNum">    2201 </span>            : }
<a name="2202"><span class="lineNum">    2202 </span>            : </a>
<span class="lineNum">    2203 </span>            : nsresult
<span class="lineNum">    2204 </span><span class="lineCov">          1 : nsSMILTimedElement::AddInstanceTimeFromCurrentTime(nsSMILTime aCurrentTime,</span>
<span class="lineNum">    2205 </span>            :     double aOffsetSeconds, bool aIsBegin)
<span class="lineNum">    2206 </span>            : {
<span class="lineNum">    2207 </span><span class="lineCov">          1 :   double offset = aOffsetSeconds * PR_MSEC_PER_SEC;</span>
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span>            :   // Check we won't overflow the range of nsSMILTime
<span class="lineNum">    2210 </span><span class="lineCov">          1 :   if (aCurrentTime + NS_round(offset) &gt; INT64_MAX)</span>
<span class="lineNum">    2211 </span>            :     return NS_ERROR_ILLEGAL_VALUE;
<span class="lineNum">    2212 </span>            : 
<span class="lineNum">    2213 </span><span class="lineCov">          1 :   nsSMILTimeValue timeVal(aCurrentTime + int64_t(NS_round(offset)));</span>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            :   RefPtr&lt;nsSMILInstanceTime&gt; instanceTime =
<span class="lineNum">    2216 </span><span class="lineCov">          1 :     new nsSMILInstanceTime(timeVal, nsSMILInstanceTime::SOURCE_DOM);</span>
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span><span class="lineCov">          1 :   AddInstanceTime(instanceTime, aIsBegin);</span>
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    2221 </span>            : }
<a name="2222"><span class="lineNum">    2222 </span>            : </a>
<span class="lineNum">    2223 </span>            : void
<span class="lineNum">    2224 </span><span class="lineCov">          1 : nsSMILTimedElement::RegisterMilestone()</span>
<span class="lineNum">    2225 </span>            : {
<span class="lineNum">    2226 </span><span class="lineCov">          1 :   nsSMILTimeContainer* container = GetTimeContainer();</span>
<span class="lineNum">    2227 </span><span class="lineCov">          1 :   if (!container)</span>
<span class="lineNum">    2228 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    2229 </span>            :   MOZ_ASSERT(mAnimationElement,
<span class="lineNum">    2230 </span>            :              &quot;Got a time container without an owning animation element&quot;);
<span class="lineNum">    2231 </span>            : 
<span class="lineNum">    2232 </span>            :   nsSMILMilestone nextMilestone;
<span class="lineNum">    2233 </span><span class="lineCov">          1 :   if (!GetNextMilestone(nextMilestone))</span>
<span class="lineNum">    2234 </span>            :     return;
<span class="lineNum">    2235 </span>            : 
<span class="lineNum">    2236 </span>            :   // This method is called every time we might possibly have updated our
<span class="lineNum">    2237 </span>            :   // current interval, but since nsSMILTimeContainer makes no attempt to filter
<span class="lineNum">    2238 </span>            :   // out redundant milestones we do some rudimentary filtering here. It's not
<span class="lineNum">    2239 </span>            :   // perfect, but unnecessary samples are fairly cheap.
<span class="lineNum">    2240 </span><span class="lineCov">          1 :   if (nextMilestone &gt;= mPrevRegisteredMilestone)</span>
<span class="lineNum">    2241 </span>            :     return;
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span><span class="lineCov">          1 :   container-&gt;AddMilestone(nextMilestone, *mAnimationElement);</span>
<span class="lineNum">    2244 </span><span class="lineCov">          1 :   mPrevRegisteredMilestone = nextMilestone;</span>
<span class="lineNum">    2245 </span>            : }
<a name="2246"><span class="lineNum">    2246 </span>            : </a>
<span class="lineNum">    2247 </span>            : bool
<span class="lineNum">    2248 </span><span class="lineCov">          1 : nsSMILTimedElement::GetNextMilestone(nsSMILMilestone&amp; aNextMilestone) const</span>
<span class="lineNum">    2249 </span>            : {
<span class="lineNum">    2250 </span>            :   // Return the next key moment in our lifetime.
<span class="lineNum">    2251 </span>            :   //
<span class="lineNum">    2252 </span>            :   // XXX It may be possible in future to optimise this so that we only register
<span class="lineNum">    2253 </span>            :   // for milestones if:
<span class="lineNum">    2254 </span>            :   // a) We have time dependents, or
<span class="lineNum">    2255 </span>            :   // b) We are dependent on events or syncbase relationships, or
<span class="lineNum">    2256 </span>            :   // c) There are registered listeners for our events
<span class="lineNum">    2257 </span>            :   //
<span class="lineNum">    2258 </span>            :   // Then for the simple case where everything uses offset values we could
<span class="lineNum">    2259 </span>            :   // ignore milestones altogether.
<span class="lineNum">    2260 </span>            :   //
<span class="lineNum">    2261 </span>            :   // We'd need to be careful, however, that if one of those conditions became
<span class="lineNum">    2262 </span>            :   // true in between samples that we registered our next milestone at that
<span class="lineNum">    2263 </span>            :   // point.
<span class="lineNum">    2264 </span>            : 
<span class="lineNum">    2265 </span><span class="lineCov">          1 :   switch (mElementState)</span>
<span class="lineNum">    2266 </span>            :   {
<span class="lineNum">    2267 </span>            :   case STATE_STARTUP:
<span class="lineNum">    2268 </span>            :     // All elements register for an initial end sample at t=0 where we resolve
<span class="lineNum">    2269 </span>            :     // our initial interval.
<span class="lineNum">    2270 </span><span class="lineCov">          1 :     aNextMilestone.mIsEnd = true; // Initial sample should be an end sample</span>
<span class="lineNum">    2271 </span><span class="lineCov">          1 :     aNextMilestone.mTime = 0;</span>
<span class="lineNum">    2272 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span>            :   case STATE_WAITING:
<span class="lineNum">    2275 </span>            :     MOZ_ASSERT(mCurrentInterval,
<span class="lineNum">    2276 </span>            :                &quot;In waiting state but the current interval has not been set&quot;);
<span class="lineNum">    2277 </span><span class="lineCov">          1 :     aNextMilestone.mIsEnd = false;</span>
<span class="lineNum">    2278 </span><span class="lineCov">          1 :     aNextMilestone.mTime = mCurrentInterval-&gt;Begin()-&gt;Time().GetMillis();</span>
<span class="lineNum">    2279 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span>            :   case STATE_ACTIVE:
<span class="lineNum">    2282 </span>            :     {
<span class="lineNum">    2283 </span>            :       // Work out what comes next: the interval end or the next repeat iteration
<span class="lineNum">    2284 </span>            :       nsSMILTimeValue nextRepeat;
<span class="lineNum">    2285 </span><span class="lineCov">          1 :       if (mSeekState == SEEK_NOT_SEEKING &amp;&amp; mSimpleDur.IsDefinite()) {</span>
<span class="lineNum">    2286 </span>            :         nsSMILTime nextRepeatActiveTime =
<span class="lineNum">    2287 </span><span class="lineCov">          1 :           (mCurrentRepeatIteration + 1) * mSimpleDur.GetMillis();</span>
<span class="lineNum">    2288 </span>            :         // Check that the repeat fits within the repeat duration
<span class="lineNum">    2289 </span><span class="lineCov">          1 :         if (nsSMILTimeValue(nextRepeatActiveTime) &lt; GetRepeatDuration()) {</span>
<span class="lineNum">    2290 </span><span class="lineCov">          1 :           nextRepeat.SetMillis(mCurrentInterval-&gt;Begin()-&gt;Time().GetMillis() +</span>
<span class="lineNum">    2291 </span><span class="lineCov">          1 :                                nextRepeatActiveTime);</span>
<span class="lineNum">    2292 </span>            :         }
<span class="lineNum">    2293 </span>            :       }
<span class="lineNum">    2294 </span>            :       nsSMILTimeValue nextMilestone =
<span class="lineNum">    2295 </span><span class="lineCov">          1 :         std::min(mCurrentInterval-&gt;End()-&gt;Time(), nextRepeat);</span>
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span>            :       // Check for an early end before that time
<span class="lineNum">    2298 </span><span class="lineCov">          1 :       nsSMILInstanceTime* earlyEnd = CheckForEarlyEnd(nextMilestone);</span>
<span class="lineNum">    2299 </span><span class="lineCov">          1 :       if (earlyEnd) {</span>
<span class="lineNum">    2300 </span><span class="lineCov">          1 :         aNextMilestone.mIsEnd = true;</span>
<span class="lineNum">    2301 </span><span class="lineCov">          1 :         aNextMilestone.mTime = earlyEnd-&gt;Time().GetMillis();</span>
<span class="lineNum">    2302 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    2303 </span>            :       }
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span>            :       // Apply the previously calculated milestone
<span class="lineNum">    2306 </span><span class="lineCov">          1 :       if (nextMilestone.IsDefinite()) {</span>
<span class="lineNum">    2307 </span><span class="lineCov">          1 :         aNextMilestone.mIsEnd = nextMilestone != nextRepeat;</span>
<span class="lineNum">    2308 </span><span class="lineCov">          1 :         aNextMilestone.mTime = nextMilestone.GetMillis();</span>
<span class="lineNum">    2309 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    2310 </span>            :       }
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            :       return false;
<span class="lineNum">    2313 </span>            :     }
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            :   case STATE_POSTACTIVE:
<span class="lineNum">    2316 </span>            :     return false;
<span class="lineNum">    2317 </span>            :   }
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :   MOZ_CRASH(&quot;Invalid element state&quot;);</span>
<span class="lineNum">    2319 </span>            : }
<a name="2320"><span class="lineNum">    2320 </span>            : </a>
<span class="lineNum">    2321 </span>            : void
<span class="lineNum">    2322 </span><span class="lineCov">          1 : nsSMILTimedElement::NotifyNewInterval()</span>
<span class="lineNum">    2323 </span>            : {
<span class="lineNum">    2324 </span>            :   MOZ_ASSERT(mCurrentInterval,
<span class="lineNum">    2325 </span>            :              &quot;Attempting to notify dependents of a new interval but the &quot;
<span class="lineNum">    2326 </span>            :              &quot;interval is not set&quot;);
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineCov">          1 :   nsSMILTimeContainer* container = GetTimeContainer();</span>
<span class="lineNum">    2329 </span><span class="lineCov">          1 :   if (container) {</span>
<span class="lineNum">    2330 </span><span class="lineCov">          1 :     container-&gt;SyncPauseTime();</span>
<span class="lineNum">    2331 </span>            :   }
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span><span class="lineCov">          1 :   for (auto iter = mTimeDependents.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    2334 </span><span class="lineCov">          1 :     nsSMILInterval* interval = mCurrentInterval;</span>
<span class="lineNum">    2335 </span>            :     // It's possible that in notifying one new time dependent of a new interval
<span class="lineNum">    2336 </span>            :     // that a chain reaction is triggered which results in the original
<span class="lineNum">    2337 </span>            :     // interval disappearing. If that's the case we can skip sending further
<span class="lineNum">    2338 </span>            :     // notifications.
<span class="lineNum">    2339 </span><span class="lineCov">          1 :     if (!interval) {</span>
<span class="lineNum">    2340 </span>            :       break;
<span class="lineNum">    2341 </span>            :     }
<span class="lineNum">    2342 </span><span class="lineCov">          1 :     nsSMILTimeValueSpec* spec = iter.Get()-&gt;GetKey();</span>
<span class="lineNum">    2343 </span><span class="lineCov">          1 :     spec-&gt;HandleNewInterval(*interval, container);</span>
<span class="lineNum">    2344 </span>            :   }
<span class="lineNum">    2345 </span><span class="lineCov">          1 : }</span>
<a name="2346"><span class="lineNum">    2346 </span>            : </a>
<span class="lineNum">    2347 </span>            : void
<span class="lineNum">    2348 </span><span class="lineCov">          1 : nsSMILTimedElement::NotifyChangedInterval(nsSMILInterval* aInterval,</span>
<span class="lineNum">    2349 </span>            :                                           bool aBeginObjectChanged,
<span class="lineNum">    2350 </span>            :                                           bool aEndObjectChanged)
<span class="lineNum">    2351 </span>            : {
<span class="lineNum">    2352 </span>            :   MOZ_ASSERT(aInterval, &quot;Null interval for change notification&quot;);
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span><span class="lineCov">          1 :   nsSMILTimeContainer* container = GetTimeContainer();</span>
<span class="lineNum">    2355 </span><span class="lineCov">          1 :   if (container) {</span>
<span class="lineNum">    2356 </span><span class="lineCov">          1 :     container-&gt;SyncPauseTime();</span>
<span class="lineNum">    2357 </span>            :   }
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            :   // Copy the instance times list since notifying the instance times can result
<span class="lineNum">    2360 </span>            :   // in a chain reaction whereby our own interval gets deleted along with its
<span class="lineNum">    2361 </span>            :   // instance times.
<span class="lineNum">    2362 </span>            :   InstanceTimeList times;
<span class="lineNum">    2363 </span><span class="lineCov">          1 :   aInterval-&gt;GetDependentTimes(times);</span>
<span class="lineNum">    2364 </span>            : 
<span class="lineNum">    2365 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; times.Length(); ++i) {</span>
<span class="lineNum">    2366 </span><span class="lineCov">          1 :     times[i]-&gt;HandleChangedInterval(container, aBeginObjectChanged,</span>
<span class="lineNum">    2367 </span><span class="lineCov">          1 :                                     aEndObjectChanged);</span>
<span class="lineNum">    2368 </span>            :   }
<span class="lineNum">    2369 </span><span class="lineCov">          1 : }</span>
<a name="2370"><span class="lineNum">    2370 </span>            : </a>
<span class="lineNum">    2371 </span>            : void
<span class="lineNum">    2372 </span><span class="lineCov">          1 : nsSMILTimedElement::FireTimeEventAsync(EventMessage aMsg, int32_t aDetail)</span>
<span class="lineNum">    2373 </span>            : {
<span class="lineNum">    2374 </span><span class="lineCov">          1 :   if (!mAnimationElement)</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            :   nsCOMPtr&lt;nsIRunnable&gt; event =
<span class="lineNum">    2378 </span><span class="lineCov">          1 :     new AsyncTimeEventRunner(mAnimationElement, aMsg, aDetail);</span>
<span class="lineNum">    2379 </span><span class="lineCov">          1 :   NS_DispatchToMainThread(event);</span>
<span class="lineNum">    2380 </span>            : }
<a name="2381"><span class="lineNum">    2381 </span>            : </a>
<span class="lineNum">    2382 </span>            : const nsSMILInstanceTime*
<span class="lineNum">    2383 </span><span class="lineCov">          1 : nsSMILTimedElement::GetEffectiveBeginInstance() const</span>
<span class="lineNum">    2384 </span>            : {
<span class="lineNum">    2385 </span><span class="lineCov">          1 :   switch (mElementState)</span>
<span class="lineNum">    2386 </span>            :   {
<span class="lineNum">    2387 </span>            :   case STATE_STARTUP:
<span class="lineNum">    2388 </span>            :     return nullptr;
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span>            :   case STATE_ACTIVE:
<span class="lineNum">    2391 </span><span class="lineCov">          1 :     return mCurrentInterval-&gt;Begin();</span>
<span class="lineNum">    2392 </span>            : 
<span class="lineNum">    2393 </span>            :   case STATE_WAITING:
<span class="lineNum">    2394 </span>            :   case STATE_POSTACTIVE:
<span class="lineNum">    2395 </span>            :     {
<span class="lineNum">    2396 </span><span class="lineCov">          1 :       const nsSMILInterval* prevInterval = GetPreviousInterval();</span>
<span class="lineNum">    2397 </span><span class="lineCov">          1 :       return prevInterval ? prevInterval-&gt;Begin() : nullptr;</span>
<span class="lineNum">    2398 </span>            :     }
<span class="lineNum">    2399 </span>            :   }
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :   MOZ_CRASH(&quot;Invalid element state&quot;);</span>
<span class="lineNum">    2401 </span>            : }
<a name="2402"><span class="lineNum">    2402 </span>            : </a>
<span class="lineNum">    2403 </span>            : const nsSMILInterval*
<span class="lineNum">    2404 </span><span class="lineCov">          1 : nsSMILTimedElement::GetPreviousInterval() const</span>
<span class="lineNum">    2405 </span>            : {
<span class="lineNum">    2406 </span><span class="lineCov">          1 :   return mOldIntervals.IsEmpty()</span>
<span class="lineNum">    2407 </span>            :     ? nullptr
<span class="lineNum">    2408 </span><span class="lineCov">          1 :     : mOldIntervals[mOldIntervals.Length()-1].get();</span>
<span class="lineNum">    2409 </span>            : }
<a name="2410"><span class="lineNum">    2410 </span>            : </a>
<span class="lineNum">    2411 </span>            : bool
<span class="lineNum">    2412 </span><span class="lineCov">          1 : nsSMILTimedElement::HasClientInFillRange() const</span>
<span class="lineNum">    2413 </span>            : {
<span class="lineNum">    2414 </span>            :   // Returns true if we have a client that is in the range where it will fill
<span class="lineNum">    2415 </span><span class="lineCov">          1 :   return mClient &amp;&amp;</span>
<span class="lineNum">    2416 </span><span class="lineCov">          1 :          ((mElementState != STATE_ACTIVE &amp;&amp; HasPlayed()) ||</span>
<span class="lineNum">    2417 </span><span class="lineCov">          1 :           (mElementState == STATE_ACTIVE &amp;&amp; !mClient-&gt;IsActive()));</span>
<span class="lineNum">    2418 </span>            : }
<a name="2419"><span class="lineNum">    2419 </span>            : </a>
<span class="lineNum">    2420 </span>            : bool
<span class="lineNum">    2421 </span><span class="lineCov">          1 : nsSMILTimedElement::EndHasEventConditions() const</span>
<span class="lineNum">    2422 </span>            : {
<span class="lineNum">    2423 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; mEndSpecs.Length(); ++i) {</span>
<span class="lineNum">    2424 </span><span class="lineCov">          1 :     if (mEndSpecs[i]-&gt;IsEventBased())</span>
<span class="lineNum">    2425 </span>            :       return true;
<span class="lineNum">    2426 </span>            :   }
<span class="lineNum">    2427 </span>            :   return false;
<span class="lineNum">    2428 </span>            : }
<a name="2429"><span class="lineNum">    2429 </span>            : </a>
<span class="lineNum">    2430 </span>            : bool
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 : nsSMILTimedElement::AreEndTimesDependentOn(</span>
<span class="lineNum">    2432 </span>            :   const nsSMILInstanceTime* aBase) const
<span class="lineNum">    2433 </span>            : {
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :   if (mEndInstances.IsEmpty())</span>
<span class="lineNum">    2435 </span>            :     return false;
<span class="lineNum">    2436 </span>            : 
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mEndInstances.Length(); ++i) {</span>
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :     if (mEndInstances[i]-&gt;GetBaseTime() != aBase) {</span>
<span class="lineNum">    2439 </span>            :       return false;
<span class="lineNum">    2440 </span>            :     }
<span class="lineNum">    2441 </span>            :   }
<span class="lineNum">    2442 </span>            :   return true;
<span class="lineNum">    2443 </span>            : }
<span class="lineNum">    2444 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
