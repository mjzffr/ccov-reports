<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/layers/ImageContainer.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/layers</a> - ImageContainer.h<span style="font-size: 80%;"> (source / <a href="ImageContainer.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">83</td>
            <td class="headerCovTableEntry">97</td>
            <td class="headerCovTableEntryMed">85.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntry">63</td>
            <td class="headerCovTableEntryLo">73.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #ifndef GFX_IMAGECONTAINER_H
<span class="lineNum">       7 </span>            : #define GFX_IMAGECONTAINER_H
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &lt;stdint.h&gt;                     // for uint32_t, uint8_t, uint64_t
<span class="lineNum">      10 </span>            : #include &lt;sys/types.h&gt;                  // for int32_t
<span class="lineNum">      11 </span>            : #include &quot;gfxTypes.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;ImageTypes.h&quot;                 // for ImageFormat, etc
<span class="lineNum">      13 </span>            : #include &quot;mozilla/Assertions.h&quot;         // for MOZ_ASSERT_HELPER2
<span class="lineNum">      14 </span>            : #include &quot;mozilla/Mutex.h&quot;              // for Mutex
<span class="lineNum">      15 </span>            : #include &quot;mozilla/ReentrantMonitor.h&quot;   // for ReentrantMonitorAutoEnter, etc
<span class="lineNum">      16 </span>            : #include &quot;mozilla/TimeStamp.h&quot;          // for TimeStamp
<span class="lineNum">      17 </span>            : #include &quot;mozilla/gfx/Point.h&quot;          // For IntSize
<span class="lineNum">      18 </span>            : #include &quot;mozilla/layers/LayersTypes.h&quot;  // for LayersBackend, etc
<span class="lineNum">      19 </span>            : #include &quot;mozilla/layers/CompositorTypes.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/mozalloc.h&quot;           // for operator delete, etc
<span class="lineNum">      21 </span>            : #include &quot;nsAutoPtr.h&quot;                  // for nsRefPtr, nsAutoArrayPtr, etc
<span class="lineNum">      22 </span>            : #include &quot;nsAutoRef.h&quot;                  // for nsCountedRef
<span class="lineNum">      23 </span>            : #include &quot;nsCOMPtr.h&quot;                   // for already_AddRefed
<span class="lineNum">      24 </span>            : #include &quot;nsDebug.h&quot;                    // for NS_ASSERTION
<span class="lineNum">      25 </span>            : #include &quot;nsISupportsImpl.h&quot;            // for Image::Release, etc
<span class="lineNum">      26 </span>            : #include &quot;nsRect.h&quot;                     // for mozilla::gfx::IntRect
<span class="lineNum">      27 </span>            : #include &quot;nsTArray.h&quot;                   // for nsTArray
<span class="lineNum">      28 </span>            : #include &quot;mozilla/Atomics.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;mozilla/WeakPtr.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsThreadUtils.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;nsDataHashtable.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/EnumeratedArray.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #ifndef XPCOM_GLUE_AVOID_NSPR
<span class="lineNum">      37 </span>            : /**
<span class="lineNum">      38 </span>            :  * We need to be able to hold a reference to a Moz2D SourceSurface from Image
<span class="lineNum">      39 </span>            :  * subclasses. This is potentially a problem since Images can be addrefed
<span class="lineNum">      40 </span>            :  * or released off the main thread. We can ensure that we never AddRef
<span class="lineNum">      41 </span>            :  * a SourceSurface off the main thread, but we might want to Release due
<span class="lineNum">      42 </span>            :  * to an Image being destroyed off the main thread.
<span class="lineNum">      43 </span>            :  *
<span class="lineNum">      44 </span>            :  * We use nsCountedRef&lt;nsMainThreadSourceSurfaceRef&gt; to reference the
<span class="lineNum">      45 </span>            :  * SourceSurface. When AddRefing, we assert that we're on the main thread.
<span class="lineNum">      46 </span>            :  * When Releasing, if we're not on the main thread, we post an event to
<span class="lineNum">      47 </span>            :  * the main thread to do the actual release.
<span class="lineNum">      48 </span>            :  */
<span class="lineNum">      49 </span>            : class nsMainThreadSourceSurfaceRef;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : template &lt;&gt;
<span class="lineNum">      52 </span>            : class nsAutoRefTraits&lt;nsMainThreadSourceSurfaceRef&gt; {
<span class="lineNum">      53 </span>            : public:
<span class="lineNum">      54 </span>            :   typedef mozilla::gfx::SourceSurface* RawRef;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :   /**
<a name="57"><span class="lineNum">      57 </span>            :    * The XPCOM event that will do the actual release on the main thread.</a>
<span class="lineNum">      58 </span>            :    */
<a name="59"><span class="lineNum">      59 </span><span class="lineCov">          1 :   class SurfaceReleaser : public mozilla::Runnable {</span></a>
<a name="60"><span class="lineNum">      60 </span>            :   public:</a>
<span class="lineNum">      61 </span><span class="lineCov">          1 :     explicit SurfaceReleaser(RawRef aRef) : mRef(aRef) {}</span>
<span class="lineNum">      62 </span><span class="lineCov">          1 :     NS_IMETHOD Run() override {</span>
<span class="lineNum">      63 </span><span class="lineCov">          1 :       mRef-&gt;Release();</span>
<span class="lineNum">      64 </span><span class="lineCov">          1 :       return NS_OK;</span>
<span class="lineNum">      65 </span>            :     }
<span class="lineNum">      66 </span>            :     RawRef mRef;
<span class="lineNum">      67 </span>            :   };
<a name="68"><span class="lineNum">      68 </span>            : </a>
<span class="lineNum">      69 </span>            :   static RawRef Void() { return nullptr; }
<span class="lineNum">      70 </span><span class="lineCov">          1 :   static void Release(RawRef aRawRef)</span>
<span class="lineNum">      71 </span>            :   {
<span class="lineNum">      72 </span><span class="lineCov">          1 :     if (NS_IsMainThread()) {</span>
<span class="lineNum">      73 </span><span class="lineCov">          1 :       aRawRef-&gt;Release();</span>
<span class="lineNum">      74 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">      75 </span>            :     }
<span class="lineNum">      76 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsIRunnable&gt; runnable = new SurfaceReleaser(aRawRef);</span>
<span class="lineNum">      77 </span><span class="lineCov">          1 :     NS_DispatchToMainThread(runnable);</span>
<span class="lineNum">      78 </span>            :   }
<span class="lineNum">      79 </span>            :   static void AddRef(RawRef aRawRef)
<span class="lineNum">      80 </span>            :   {
<span class="lineNum">      81 </span>            :     NS_ASSERTION(NS_IsMainThread(),
<span class="lineNum">      82 </span>            :                  &quot;Can only add a reference on the main thread&quot;);
<span class="lineNum">      83 </span><span class="lineCov">          1 :     aRawRef-&gt;AddRef();</span>
<span class="lineNum">      84 </span>            :   }
<span class="lineNum">      85 </span>            : };
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : class nsOwningThreadSourceSurfaceRef;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : template &lt;&gt;
<span class="lineNum">      90 </span><span class="lineCov">          1 : class nsAutoRefTraits&lt;nsOwningThreadSourceSurfaceRef&gt; {</span>
<span class="lineNum">      91 </span>            : public:
<span class="lineNum">      92 </span>            :   typedef mozilla::gfx::SourceSurface* RawRef;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            :   /**
<a name="95"><span class="lineNum">      95 </span>            :    * The XPCOM event that will do the actual release on the creation thread.</a>
<span class="lineNum">      96 </span>            :    */
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">          1 :   class SurfaceReleaser : public mozilla::Runnable {</span></a>
<a name="98"><span class="lineNum">      98 </span>            :   public:</a>
<span class="lineNum">      99 </span><span class="lineCov">          1 :     explicit SurfaceReleaser(RawRef aRef) : mRef(aRef) {}</span>
<span class="lineNum">     100 </span><span class="lineCov">          1 :     NS_IMETHOD Run() override {</span>
<span class="lineNum">     101 </span><span class="lineCov">          1 :       mRef-&gt;Release();</span>
<span class="lineNum">     102 </span><span class="lineCov">          1 :       return NS_OK;</span>
<span class="lineNum">     103 </span>            :     }
<span class="lineNum">     104 </span>            :     RawRef mRef;
<span class="lineNum">     105 </span>            :   };
<a name="106"><span class="lineNum">     106 </span>            : </a>
<span class="lineNum">     107 </span>            :   static RawRef Void() { return nullptr; }
<span class="lineNum">     108 </span><span class="lineCov">          1 :   void Release(RawRef aRawRef)</span>
<span class="lineNum">     109 </span>            :   {
<span class="lineNum">     110 </span>            :     MOZ_ASSERT(mOwningThread);
<span class="lineNum">     111 </span>            :     bool current;
<span class="lineNum">     112 </span><span class="lineCov">          1 :     mOwningThread-&gt;IsOnCurrentThread(&amp;current);</span>
<span class="lineNum">     113 </span><span class="lineCov">          1 :     if (current) {</span>
<span class="lineNum">     114 </span><span class="lineCov">          1 :       aRawRef-&gt;Release();</span>
<span class="lineNum">     115 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     116 </span>            :     }
<span class="lineNum">     117 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsIRunnable&gt; runnable = new SurfaceReleaser(aRawRef);</span>
<a name="118"><span class="lineNum">     118 </span><span class="lineCov">          1 :     mOwningThread-&gt;Dispatch(runnable, nsIThread::DISPATCH_NORMAL);</span></a>
<span class="lineNum">     119 </span>            :   }
<span class="lineNum">     120 </span><span class="lineCov">          1 :   void AddRef(RawRef aRawRef)</span>
<span class="lineNum">     121 </span>            :   {
<span class="lineNum">     122 </span>            :     MOZ_ASSERT(!mOwningThread);
<span class="lineNum">     123 </span><span class="lineCov">          1 :     NS_GetCurrentThread(getter_AddRefs(mOwningThread));</span>
<span class="lineNum">     124 </span><span class="lineCov">          1 :     aRawRef-&gt;AddRef();</span>
<span class="lineNum">     125 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : private:
<span class="lineNum">     128 </span>            :   nsCOMPtr&lt;nsIThread&gt; mOwningThread;
<span class="lineNum">     129 </span>            : };
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : #endif
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : #ifdef XP_WIN
<span class="lineNum">     134 </span>            : struct ID3D10Texture2D;
<span class="lineNum">     135 </span>            : struct ID3D10Device;
<span class="lineNum">     136 </span>            : struct ID3D10ShaderResourceView;
<span class="lineNum">     137 </span>            : #endif
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : typedef void* HANDLE;
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : namespace mozilla {
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : namespace layers {
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : class ImageClient;
<span class="lineNum">     147 </span>            : class ImageCompositeNotification;
<span class="lineNum">     148 </span>            : class ImageContainer;
<span class="lineNum">     149 </span>            : class ImageContainerChild;
<span class="lineNum">     150 </span>            : class SharedPlanarYCbCrImage;
<span class="lineNum">     151 </span>            : class PlanarYCbCrImage;
<span class="lineNum">     152 </span>            : class TextureClient;
<span class="lineNum">     153 </span>            : class KnowsCompositor;
<span class="lineNum">     154 </span>            : class NVImage;
<span class="lineNum">     155 </span>            : 
<a name="156"><span class="lineNum">     156 </span>            : struct ImageBackendData</a>
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   virtual ~ImageBackendData() {}</span>
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            : protected:
<span class="lineNum">     161 </span>            :   ImageBackendData() {}
<span class="lineNum">     162 </span>            : };
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* Forward declarations for Image derivatives. */
<span class="lineNum">     165 </span>            : class GLImage;
<span class="lineNum">     166 </span>            : class EGLImageImage;
<span class="lineNum">     167 </span>            : class SharedRGBImage;
<span class="lineNum">     168 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     169 </span>            : class SurfaceTextureImage;
<span class="lineNum">     170 </span>            : #elif defined(XP_MACOSX)
<span class="lineNum">     171 </span>            : class MacIOSurfaceImage;
<span class="lineNum">     172 </span>            : #endif
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : /**
<span class="lineNum">     175 </span>            :  * A class representing a buffer of pixel data. The data can be in one
<span class="lineNum">     176 </span>            :  * of various formats including YCbCr.
<span class="lineNum">     177 </span>            :  *
<span class="lineNum">     178 </span>            :  * Create an image using an ImageContainer. Fill the image with data, and
<span class="lineNum">     179 </span>            :  * then call ImageContainer::SetImage to display it. An image must not be
<span class="lineNum">     180 </span>            :  * modified after calling SetImage. Image implementations do not need to
<span class="lineNum">     181 </span>            :  * perform locking; when filling an Image, the Image client is responsible
<span class="lineNum">     182 </span>            :  * for ensuring only one thread accesses the Image at a time, and after
<span class="lineNum">     183 </span>            :  * SetImage the image is immutable.
<span class="lineNum">     184 </span>            :  *
<span class="lineNum">     185 </span>            :  * When resampling an Image, only pixels within the buffer should be
<span class="lineNum">     186 </span>            :  * sampled. For example, cairo images should be sampled in EXTEND_PAD mode.
<a name="187"><span class="lineNum">     187 </span>            :  */</a>
<span class="lineNum">     188 </span>            : class Image {
<span class="lineNum">     189 </span><span class="lineCov">          1 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(Image)</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : public:
<span class="lineNum">     192 </span>            :   ImageFormat GetFormat() { return mFormat; }
<span class="lineNum">     193 </span>            :   void* GetImplData() { return mImplData; }
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            :   virtual gfx::IntSize GetSize() = 0;
<span class="lineNum">     196 </span><span class="lineCov">          1 :   virtual gfx::IntPoint GetOrigin()</span>
<span class="lineNum">     197 </span>            :   {
<a name="198"><span class="lineNum">     198 </span><span class="lineCov">          1 :     return gfx::IntPoint(0, 0);</span></a>
<span class="lineNum">     199 </span>            :   }
<span class="lineNum">     200 </span><span class="lineCov">          1 :   virtual gfx::IntRect GetPictureRect()</span>
<span class="lineNum">     201 </span>            :   {
<span class="lineNum">     202 </span><span class="lineCov">          1 :     return gfx::IntRect(GetOrigin().x, GetOrigin().y, GetSize().width, GetSize().height);</span>
<span class="lineNum">     203 </span>            :   }
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   ImageBackendData* GetBackendData(LayersBackend aBackend)
<span class="lineNum">     206 </span>            :   { return mBackendData[aBackend]; }
<span class="lineNum">     207 </span>            :   void SetBackendData(LayersBackend aBackend, ImageBackendData* aData)
<span class="lineNum">     208 </span>            :   { mBackendData[aBackend] = aData; }
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :   int32_t GetSerial() { return mSerial; }
<span class="lineNum">     211 </span>            : 
<a name="212"><span class="lineNum">     212 </span>            :   virtual already_AddRefed&lt;gfx::SourceSurface&gt; GetAsSourceSurface() = 0;</a>
<span class="lineNum">     213 </span>            : 
<a name="214"><span class="lineNum">     214 </span><span class="lineCov">          1 :   virtual bool IsValid() { return true; }</span></a>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   virtual uint8_t* GetBuffer() { return nullptr; }</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :   /**
<span class="lineNum">     219 </span>            :    * For use with the TextureForwarder only (so that the later can
<a name="220"><span class="lineNum">     220 </span>            :    * synchronize the TextureClient with the TextureHost).</a>
<span class="lineNum">     221 </span>            :    */
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   virtual TextureClient* GetTextureClient(KnowsCompositor* aForwarder) { return nullptr; }</span>
<a name="223"><span class="lineNum">     223 </span>            : </a>
<a name="224"><span class="lineNum">     224 </span>            :   /* Access to derived classes. */</a>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   virtual EGLImageImage* AsEGLImageImage() { return nullptr; }</span>
<span class="lineNum">     226 </span><span class="lineCov">          1 :   virtual GLImage* AsGLImage() { return nullptr; }</span>
<span class="lineNum">     227 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     228 </span>            :   virtual SurfaceTextureImage* AsSurfaceTextureImage() { return nullptr; }
<span class="lineNum">     229 </span>            : #endif
<span class="lineNum">     230 </span>            : #ifdef XP_MACOSX
<a name="231"><span class="lineNum">     231 </span>            :   virtual MacIOSurfaceImage* AsMacIOSurfaceImage() { return nullptr; }</a>
<span class="lineNum">     232 </span>            : #endif
<a name="233"><span class="lineNum">     233 </span><span class="lineNoCov">          0 :   virtual PlanarYCbCrImage* AsPlanarYCbCrImage() { return nullptr; }</span></a>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   virtual NVImage* AsNVImage() { return nullptr; }</span>
<a name="236"><span class="lineNum">     236 </span>            : </a>
<span class="lineNum">     237 </span>            : protected:
<span class="lineNum">     238 </span><span class="lineCov">          1 :   Image(void* aImplData, ImageFormat aFormat) :</span>
<span class="lineNum">     239 </span>            :     mImplData(aImplData),
<span class="lineNum">     240 </span><span class="lineCov">          1 :     mSerial(++sSerialCounter),</span>
<span class="lineNum">     241 </span><span class="lineCov">          1 :     mFormat(aFormat)</span>
<span class="lineNum">     242 </span><span class="lineCov">          1 :   {}</span>
<a name="243"><span class="lineNum">     243 </span>            : </a>
<span class="lineNum">     244 </span>            :   // Protected destructor, to discourage deletion outside of Release():
<span class="lineNum">     245 </span><span class="lineCov">          1 :   virtual ~Image() {}</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :   mozilla::EnumeratedArray&lt;mozilla::layers::LayersBackend,
<span class="lineNum">     248 </span>            :                            mozilla::layers::LayersBackend::LAYERS_LAST,
<span class="lineNum">     249 </span>            :                            nsAutoPtr&lt;ImageBackendData&gt;&gt;
<span class="lineNum">     250 </span>            :     mBackendData;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   void* mImplData;
<span class="lineNum">     253 </span>            :   int32_t mSerial;
<span class="lineNum">     254 </span>            :   ImageFormat mFormat;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :   static mozilla::Atomic&lt;int32_t&gt; sSerialCounter;
<span class="lineNum">     257 </span>            : };
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /**
<span class="lineNum">     260 </span>            :  * A RecycleBin is owned by an ImageContainer. We store buffers in it that we
<span class="lineNum">     261 </span>            :  * want to recycle from one image to the next.It's a separate object from
<span class="lineNum">     262 </span>            :  * ImageContainer because images need to store a strong ref to their RecycleBin
<span class="lineNum">     263 </span>            :  * and we must avoid creating a reference loop between an ImageContainer and
<span class="lineNum">     264 </span>            :  * its active image.
<a name="265"><span class="lineNum">     265 </span>            :  */</a>
<span class="lineNum">     266 </span>            : class BufferRecycleBin final {
<span class="lineNum">     267 </span><span class="lineCov">          1 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(BufferRecycleBin)</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :   //typedef mozilla::gl::GLContext GLContext;
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : public:
<span class="lineNum">     272 </span>            :   BufferRecycleBin();
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :   void RecycleBuffer(mozilla::UniquePtr&lt;uint8_t[]&gt; aBuffer, uint32_t aSize);
<span class="lineNum">     275 </span>            :   // Returns a recycled buffer of the right size, or allocates a new buffer.
<span class="lineNum">     276 </span>            :   mozilla::UniquePtr&lt;uint8_t[]&gt; GetBuffer(uint32_t aSize);
<span class="lineNum">     277 </span>            :   virtual void ClearRecycledBuffers();
<span class="lineNum">     278 </span>            : private:
<span class="lineNum">     279 </span>            :   typedef mozilla::Mutex Mutex;
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            :   // Private destructor, to discourage deletion outside of Release():
<span class="lineNum">     282 </span><span class="lineCov">          1 :   ~BufferRecycleBin()</span>
<span class="lineNum">     283 </span><span class="lineCov">          1 :   {</span>
<span class="lineNum">     284 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :   // This protects mRecycledBuffers, mRecycledBufferSize, mRecycledTextures
<span class="lineNum">     287 </span>            :   // and mRecycledTextureSizes
<span class="lineNum">     288 </span>            :   Mutex mLock;
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :   // We should probably do something to prune this list on a timer so we don't
<span class="lineNum">     291 </span>            :   // eat excess memory while video is paused...
<span class="lineNum">     292 </span>            :   nsTArray&lt;mozilla::UniquePtr&lt;uint8_t[]&gt;&gt; mRecycledBuffers;
<span class="lineNum">     293 </span>            :   // This is only valid if mRecycledBuffers is non-empty
<span class="lineNum">     294 </span>            :   uint32_t mRecycledBufferSize;
<span class="lineNum">     295 </span>            : };
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : /**
<span class="lineNum">     298 </span>            :  * A class that manages Image creation for a LayerManager. The only reason
<span class="lineNum">     299 </span>            :  * we need a separate class here is that LayerManagers aren't threadsafe
<span class="lineNum">     300 </span>            :  * (because layers can only be used on the main thread) and we want to
<span class="lineNum">     301 </span>            :  * be able to create images from any thread, to facilitate video playback
<span class="lineNum">     302 </span>            :  * without involving the main thread, for example.
<span class="lineNum">     303 </span>            :  * Different layer managers can implement child classes of this making it
<span class="lineNum">     304 </span>            :  * possible to create layer manager specific images.
<span class="lineNum">     305 </span>            :  * This class is not meant to be used directly but rather can be set on an
<span class="lineNum">     306 </span>            :  * image container. This is usually done by the layer system internally and
<span class="lineNum">     307 </span>            :  * not explicitly by users. For PlanarYCbCr or Cairo images the default
<span class="lineNum">     308 </span>            :  * implementation will creates images whose data lives in system memory, for
<span class="lineNum">     309 </span>            :  * MacIOSurfaces the default implementation will be a simple MacIOSurface
<span class="lineNum">     310 </span>            :  * wrapper.
<span class="lineNum">     311 </span>            :  */
<span class="lineNum">     312 </span>            : 
<a name="313"><span class="lineNum">     313 </span>            : class ImageFactory</a>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span><span class="lineCov">          1 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageFactory)</span>
<span class="lineNum">     316 </span>            : protected:
<span class="lineNum">     317 </span>            :   friend class ImageContainer;
<a name="318"><span class="lineNum">     318 </span>            : </a>
<span class="lineNum">     319 </span><span class="lineCov">          1 :   ImageFactory() {}</span>
<span class="lineNum">     320 </span><span class="lineCov">          1 :   virtual ~ImageFactory() {}</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :   virtual RefPtr&lt;PlanarYCbCrImage&gt; CreatePlanarYCbCrImage(
<span class="lineNum">     323 </span>            :     const gfx::IntSize&amp; aScaleHint,
<span class="lineNum">     324 </span>            :     BufferRecycleBin *aRecycleBin);
<span class="lineNum">     325 </span>            : };
<span class="lineNum">     326 </span>            : 
<a name="327"><span class="lineNum">     327 </span>            : // Used to notify ImageContainer::NotifyComposite()</a>
<span class="lineNum">     328 </span>            : class ImageContainerListener final {
<span class="lineNum">     329 </span><span class="lineCov">          1 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageContainerListener)</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : public:
<span class="lineNum">     332 </span>            :   explicit ImageContainerListener(ImageContainer* aImageContainer);
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   void NotifyComposite(const ImageCompositeNotification&amp; aNotification);
<span class="lineNum">     335 </span>            :   void ClearImageContainer();
<span class="lineNum">     336 </span>            : private:
<span class="lineNum">     337 </span>            :   typedef mozilla::Mutex Mutex;
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   ~ImageContainerListener();
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :   Mutex mLock;
<span class="lineNum">     342 </span>            :   ImageContainer* mImageContainer;
<span class="lineNum">     343 </span>            : };
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : /**
<span class="lineNum">     346 </span>            :  * A class that manages Images for an ImageLayer. The only reason
<span class="lineNum">     347 </span>            :  * we need a separate class here is that ImageLayers aren't threadsafe
<span class="lineNum">     348 </span>            :  * (because layers can only be used on the main thread) and we want to
<span class="lineNum">     349 </span>            :  * be able to set the current Image from any thread, to facilitate
<span class="lineNum">     350 </span>            :  * video playback without involving the main thread, for example.
<span class="lineNum">     351 </span>            :  *
<span class="lineNum">     352 </span>            :  * An ImageContainer can operate in one of these modes:
<span class="lineNum">     353 </span>            :  * 1) Normal. Triggered by constructing the ImageContainer with
<span class="lineNum">     354 </span>            :  * DISABLE_ASYNC or when compositing is happening on the main thread.
<span class="lineNum">     355 </span>            :  * SetCurrentImages changes ImageContainer state but nothing is sent to the
<span class="lineNum">     356 </span>            :  * compositor until the next layer transaction.
<span class="lineNum">     357 </span>            :  * 2) Asynchronous. Initiated by constructing the ImageContainer with
<span class="lineNum">     358 </span>            :  * ENABLE_ASYNC when compositing is happening on the main thread.
<span class="lineNum">     359 </span>            :  * SetCurrentImages sends a message through the ImageBridge to the compositor
<span class="lineNum">     360 </span>            :  * thread to update the image, without going through the main thread or
<span class="lineNum">     361 </span>            :  * a layer transaction.
<span class="lineNum">     362 </span>            :  * The ImageContainer uses a shared memory block containing a cross-process mutex
<span class="lineNum">     363 </span>            :  * to communicate with the compositor thread. SetCurrentImage synchronously
<span class="lineNum">     364 </span>            :  * updates the shared state to point to the new image and the old image
<span class="lineNum">     365 </span>            :  * is immediately released (not true in Normal or Asynchronous modes).
<span class="lineNum">     366 </span>            :  */
<span class="lineNum">     367 </span>            : class ImageContainer final : public SupportsWeakPtr&lt;ImageContainer&gt;
<span class="lineNum">     368 </span>            : {
<a name="369"><span class="lineNum">     369 </span>            :   friend class ImageContainerChild;</a>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineCov">          1 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageContainer)</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : public:
<span class="lineNum">     374 </span>            :   MOZ_DECLARE_WEAKREFERENCE_TYPENAME(ImageContainer)
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   enum Mode { SYNCHRONOUS = 0x0, ASYNCHRONOUS = 0x01 };
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            :   static const uint64_t sInvalidAsyncContainerId = 0;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :   explicit ImageContainer(ImageContainer::Mode flag = SYNCHRONOUS);
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   /**
<span class="lineNum">     383 </span>            :    * Create ImageContainer just to hold another ASYNCHRONOUS ImageContainer's
<span class="lineNum">     384 </span>            :    * async container ID.
<span class="lineNum">     385 </span>            :    * @param aAsyncContainerID async container ID for which we are a proxy
<span class="lineNum">     386 </span>            :    */
<span class="lineNum">     387 </span>            :   explicit ImageContainer(const CompositableHandle&amp; aHandle);
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   typedef uint32_t FrameID;
<span class="lineNum">     390 </span>            :   typedef uint32_t ProducerID;
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   RefPtr&lt;PlanarYCbCrImage&gt; CreatePlanarYCbCrImage();
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   // Factory methods for shared image types.
<span class="lineNum">     395 </span>            :   RefPtr&lt;SharedRGBImage&gt; CreateSharedRGBImage();
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :   struct NonOwningImage {
<span class="lineNum">     398 </span>            :     explicit NonOwningImage(Image* aImage = nullptr,
<span class="lineNum">     399 </span>            :                             TimeStamp aTimeStamp = TimeStamp(),
<span class="lineNum">     400 </span>            :                             FrameID aFrameID = 0,
<span class="lineNum">     401 </span>            :                             ProducerID aProducerID = 0)
<span class="lineNum">     402 </span>            :       : mImage(aImage), mTimeStamp(aTimeStamp), mFrameID(aFrameID),
<span class="lineNum">     403 </span><span class="lineCov">          1 :         mProducerID(aProducerID) {}</span>
<span class="lineNum">     404 </span>            :     Image* mImage;
<span class="lineNum">     405 </span>            :     TimeStamp mTimeStamp;
<span class="lineNum">     406 </span>            :     FrameID mFrameID;
<span class="lineNum">     407 </span>            :     ProducerID mProducerID;
<span class="lineNum">     408 </span>            :   };
<span class="lineNum">     409 </span>            :   /**
<span class="lineNum">     410 </span>            :    * Set aImages as the list of timestamped to display. The Images must have
<span class="lineNum">     411 </span>            :    * been created by this ImageContainer.
<span class="lineNum">     412 </span>            :    * Can be called on any thread. This method takes mReentrantMonitor
<span class="lineNum">     413 </span>            :    * when accessing thread-shared state.
<span class="lineNum">     414 </span>            :    * aImages must be non-empty. The first timestamp in the list may be
<span class="lineNum">     415 </span>            :    * null but the others must not be, and the timestamps must increase.
<span class="lineNum">     416 </span>            :    * Every element of aImages must have non-null mImage.
<span class="lineNum">     417 </span>            :    * mFrameID can be zero, in which case you won't get meaningful
<span class="lineNum">     418 </span>            :    * painted/dropped frame counts. Otherwise you should use a unique and
<span class="lineNum">     419 </span>            :    * increasing ID for each decoded and submitted frame (but it's OK to
<span class="lineNum">     420 </span>            :    * pass the same frame to SetCurrentImages).
<span class="lineNum">     421 </span>            :    * mProducerID is a unique ID for the stream of images. A change in the
<span class="lineNum">     422 </span>            :    * mProducerID means changing to a new mFrameID namespace. All frames in
<span class="lineNum">     423 </span>            :    * aImages must have the same mProducerID.
<span class="lineNum">     424 </span>            :    *
<span class="lineNum">     425 </span>            :    * The Image data must not be modified after this method is called!
<span class="lineNum">     426 </span>            :    * Note that this must not be called if ENABLE_ASYNC has not been set.
<span class="lineNum">     427 </span>            :    *
<span class="lineNum">     428 </span>            :    * The implementation calls CurrentImageChanged() while holding
<span class="lineNum">     429 </span>            :    * mReentrantMonitor.
<span class="lineNum">     430 </span>            :    *
<span class="lineNum">     431 </span>            :    * If this ImageContainer has an ImageClient for async video:
<span class="lineNum">     432 </span>            :    * Schedule a task to send the image to the compositor using the
<span class="lineNum">     433 </span>            :    * PImageBridge protcol without using the main thread.
<span class="lineNum">     434 </span>            :    */
<span class="lineNum">     435 </span>            :   void SetCurrentImages(const nsTArray&lt;NonOwningImage&gt;&amp; aImages);
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   /**
<span class="lineNum">     438 </span>            :    * Clear all images. Let ImageClient release all TextureClients.
<span class="lineNum">     439 </span>            :    */
<span class="lineNum">     440 </span>            :   void ClearAllImages();
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :   /**
<span class="lineNum">     443 </span>            :    * Clear any resources that are not immediately necessary. This may be called
<span class="lineNum">     444 </span>            :    * in low-memory conditions.
<span class="lineNum">     445 </span>            :    */
<span class="lineNum">     446 </span>            :   void ClearCachedResources();
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :   /**
<span class="lineNum">     449 </span>            :    * Clear the current images.
<span class="lineNum">     450 </span>            :    * This function is expect to be called only from a CompositableClient
<span class="lineNum">     451 </span>            :    * that belongs to ImageBridgeChild. Created to prevent dead lock.
<span class="lineNum">     452 </span>            :    * See Bug 901224.
<span class="lineNum">     453 </span>            :    */
<span class="lineNum">     454 </span>            :   void ClearImagesFromImageBridge();
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   /**
<span class="lineNum">     457 </span>            :    * Set an Image as the current image to display. The Image must have
<span class="lineNum">     458 </span>            :    * been created by this ImageContainer.
<span class="lineNum">     459 </span>            :    * Must be called on the main thread, within a layers transaction.
<span class="lineNum">     460 </span>            :    *
<span class="lineNum">     461 </span>            :    * This method takes mReentrantMonitor
<span class="lineNum">     462 </span>            :    * when accessing thread-shared state.
<span class="lineNum">     463 </span>            :    * aImage can be null. While it's null, nothing will be painted.
<span class="lineNum">     464 </span>            :    *
<span class="lineNum">     465 </span>            :    * The Image data must not be modified after this method is called!
<span class="lineNum">     466 </span>            :    * Note that this must not be called if ENABLE_ASYNC been set.
<span class="lineNum">     467 </span>            :    *
<span class="lineNum">     468 </span>            :    * You won't get meaningful painted/dropped counts when using this method.
<span class="lineNum">     469 </span>            :    */
<span class="lineNum">     470 </span>            :   void SetCurrentImageInTransaction(Image* aImage);
<span class="lineNum">     471 </span>            :   void SetCurrentImagesInTransaction(const nsTArray&lt;NonOwningImage&gt;&amp; aImages);
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :   /**
<span class="lineNum">     474 </span>            :    * Returns true if this ImageContainer uses the ImageBridge IPDL protocol.
<span class="lineNum">     475 </span>            :    *
<span class="lineNum">     476 </span>            :    * Can be called from any thread.
<span class="lineNum">     477 </span>            :    */
<span class="lineNum">     478 </span>            :   bool IsAsync() const;
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   /**
<span class="lineNum">     481 </span>            :    * If this ImageContainer uses ImageBridge, returns the ID associated to
<span class="lineNum">     482 </span>            :    * this container, for use in the ImageBridge protocol.
<span class="lineNum">     483 </span>            :    * Returns 0 if this ImageContainer does not use ImageBridge. Note that
<span class="lineNum">     484 </span>            :    * 0 is always an invalid ID for asynchronous image containers.
<span class="lineNum">     485 </span>            :    *
<span class="lineNum">     486 </span>            :    * Can be called from any thread.
<span class="lineNum">     487 </span>            :    */
<span class="lineNum">     488 </span>            :   CompositableHandle GetAsyncContainerHandle();
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :   /**
<span class="lineNum">     491 </span>            :    * Returns if the container currently has an image.
<span class="lineNum">     492 </span>            :    * Can be called on any thread. This method takes mReentrantMonitor
<span class="lineNum">     493 </span>            :    * when accessing thread-shared state.
<span class="lineNum">     494 </span>            :    */
<a name="495"><span class="lineNum">     495 </span>            :   bool HasCurrentImage();</a>
<a name="496"><span class="lineNum">     496 </span>            : </a>
<span class="lineNum">     497 </span><span class="lineCov">          1 :   struct OwningImage {</span>
<span class="lineNum">     498 </span><span class="lineCov">          1 :     OwningImage() : mFrameID(0), mProducerID(0), mComposited(false) {}</span>
<span class="lineNum">     499 </span>            :     RefPtr&lt;Image&gt; mImage;
<span class="lineNum">     500 </span>            :     TimeStamp mTimeStamp;
<span class="lineNum">     501 </span>            :     FrameID mFrameID;
<span class="lineNum">     502 </span>            :     ProducerID mProducerID;
<span class="lineNum">     503 </span>            :     bool mComposited;
<span class="lineNum">     504 </span>            :   };
<span class="lineNum">     505 </span>            :   /**
<span class="lineNum">     506 </span>            :    * Copy the current Image list to aImages.
<span class="lineNum">     507 </span>            :    * This has to add references since otherwise there are race conditions
<span class="lineNum">     508 </span>            :    * where the current image is destroyed before the caller can add
<span class="lineNum">     509 </span>            :    * a reference.
<span class="lineNum">     510 </span>            :    * Can be called on any thread.
<span class="lineNum">     511 </span>            :    * May return an empty list to indicate there is no current image.
<span class="lineNum">     512 </span>            :    * If aGenerationCounter is non-null, sets *aGenerationCounter to a value
<span class="lineNum">     513 </span>            :    * that's unique for this ImageContainer state.
<span class="lineNum">     514 </span>            :    */
<span class="lineNum">     515 </span>            :   void GetCurrentImages(nsTArray&lt;OwningImage&gt;* aImages,
<span class="lineNum">     516 </span>            :                         uint32_t* aGenerationCounter = nullptr);
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :   /**
<span class="lineNum">     519 </span>            :    * Returns the size of the image in pixels.
<span class="lineNum">     520 </span>            :    * Can be called on any thread. This method takes mReentrantMonitor when accessing
<span class="lineNum">     521 </span>            :    * thread-shared state.
<span class="lineNum">     522 </span>            :    */
<span class="lineNum">     523 </span>            :   gfx::IntSize GetCurrentSize();
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            :   /**
<span class="lineNum">     526 </span>            :    * Sets a size that the image is expected to be rendered at.
<span class="lineNum">     527 </span>            :    * This is a hint for image backends to optimize scaling.
<span class="lineNum">     528 </span>            :    * Default implementation in this class is to ignore the hint.
<span class="lineNum">     529 </span>            :    * Can be called on any thread. This method takes mReentrantMonitor
<span class="lineNum">     530 </span>            :    * when accessing thread-shared state.
<span class="lineNum">     531 </span>            :    */
<span class="lineNum">     532 </span>            :   void SetScaleHint(const gfx::IntSize&amp; aScaleHint)
<a name="533"><span class="lineNum">     533 </span>            :   { mScaleHint = aScaleHint; }</a>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineCov">          1 :   void SetImageFactory(ImageFactory *aFactory)</span>
<span class="lineNum">     536 </span>            :   {
<span class="lineNum">     537 </span><span class="lineCov">          1 :     ReentrantMonitorAutoEnter mon(mReentrantMonitor);</span>
<span class="lineNum">     538 </span><span class="lineCov">          1 :     mImageFactory = aFactory ? aFactory : new ImageFactory();</span>
<span class="lineNum">     539 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :   ImageFactory* GetImageFactory() const
<span class="lineNum">     542 </span>            :   {
<span class="lineNum">     543 </span><span class="lineCov">          1 :     return mImageFactory;</span>
<span class="lineNum">     544 </span>            :   }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   /**
<span class="lineNum">     547 </span>            :    * Returns the delay between the last composited image's presentation
<span class="lineNum">     548 </span>            :    * timestamp and when it was first composited. It's possible for the delay
<span class="lineNum">     549 </span>            :    * to be negative if the first image in the list passed to SetCurrentImages
<span class="lineNum">     550 </span>            :    * has a presentation timestamp greater than &quot;now&quot;.
<span class="lineNum">     551 </span>            :    * Returns 0 if the composited image had a null timestamp, or if no
<span class="lineNum">     552 </span>            :    * image has been composited yet.
<span class="lineNum">     553 </span>            :    */
<span class="lineNum">     554 </span>            :   TimeDuration GetPaintDelay()
<span class="lineNum">     555 </span>            :   {
<span class="lineNum">     556 </span>            :     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
<span class="lineNum">     557 </span>            :     return mPaintDelay;
<span class="lineNum">     558 </span>            :   }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :   /**
<span class="lineNum">     561 </span>            :    * Returns the number of images which have been contained in this container
<span class="lineNum">     562 </span>            :    * and painted at least once.  Can be called from any thread.
<span class="lineNum">     563 </span>            :    */
<span class="lineNum">     564 </span>            :   uint32_t GetPaintCount() {
<span class="lineNum">     565 </span>            :     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
<span class="lineNum">     566 </span>            :     return mPaintCount;
<span class="lineNum">     567 </span>            :   }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :   /**
<span class="lineNum">     570 </span>            :    * An entry in the current image list &quot;expires&quot; when the entry has an
<span class="lineNum">     571 </span>            :    * non-null timestamp, and in a SetCurrentImages call the new image list is
<span class="lineNum">     572 </span>            :    * non-empty, the timestamp of the first new image is non-null and greater
<span class="lineNum">     573 </span>            :    * than the timestamp associated with the image, and the first new image's
<span class="lineNum">     574 </span>            :    * frameID is not the same as the entry's.
<span class="lineNum">     575 </span>            :    * Every expired image that is never composited is counted as dropped.
<span class="lineNum">     576 </span>            :    */
<span class="lineNum">     577 </span>            :   uint32_t GetDroppedImageCount()
<span class="lineNum">     578 </span>            :   {
<span class="lineNum">     579 </span>            :     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
<span class="lineNum">     580 </span>            :     return mDroppedImageCount;
<span class="lineNum">     581 </span>            :   }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :   void NotifyComposite(const ImageCompositeNotification&amp; aNotification);
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :   ImageContainerListener* GetImageContainerListener()
<span class="lineNum">     586 </span>            :   {
<span class="lineNum">     587 </span><span class="lineCov">          1 :     return mNotifyCompositeListener;</span>
<span class="lineNum">     588 </span>            :   }
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   /**
<span class="lineNum">     591 </span>            :    * Main thread only.
<span class="lineNum">     592 </span>            :    */
<span class="lineNum">     593 </span>            :   static ProducerID AllocateProducerID();
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : private:
<span class="lineNum">     596 </span>            :   typedef mozilla::ReentrantMonitor ReentrantMonitor;
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   // Private destructor, to discourage deletion outside of Release():
<span class="lineNum">     599 </span>            :   ~ImageContainer();
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   void SetCurrentImageInternal(const nsTArray&lt;NonOwningImage&gt;&amp; aImages);
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :   // This is called to ensure we have an active image, this may not be true
<span class="lineNum">     604 </span>            :   // when we're storing image information in a RemoteImageData structure.
<span class="lineNum">     605 </span>            :   // NOTE: If we have remote data mRemoteDataMutex should be locked when
<span class="lineNum">     606 </span>            :   // calling this function!
<span class="lineNum">     607 </span>            :   void EnsureActiveImage();
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :   void EnsureImageClient();
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :   // ReentrantMonitor to protect thread safe access to the &quot;current
<span class="lineNum">     612 </span>            :   // image&quot;, and any other state which is shared between threads.
<span class="lineNum">     613 </span>            :   ReentrantMonitor mReentrantMonitor;
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :   nsTArray&lt;OwningImage&gt; mCurrentImages;
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :   // Updates every time mActiveImage changes
<span class="lineNum">     618 </span>            :   uint32_t mGenerationCounter;
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :   // Number of contained images that have been painted at least once.  It's up
<span class="lineNum">     621 </span>            :   // to the ImageContainer implementation to ensure accesses to this are
<span class="lineNum">     622 </span>            :   // threadsafe.
<span class="lineNum">     623 </span>            :   uint32_t mPaintCount;
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            :   // See GetPaintDelay. Accessed only with mReentrantMonitor held.
<span class="lineNum">     626 </span>            :   TimeDuration mPaintDelay;
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :   // See GetDroppedImageCount. Accessed only with mReentrantMonitor held.
<span class="lineNum">     629 </span>            :   uint32_t mDroppedImageCount;
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :   // This is the image factory used by this container, layer managers using
<span class="lineNum">     632 </span>            :   // this container can set an alternative image factory that will be used to
<span class="lineNum">     633 </span>            :   // create images for this container.
<span class="lineNum">     634 </span>            :   RefPtr&lt;ImageFactory&gt; mImageFactory;
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :   gfx::IntSize mScaleHint;
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :   RefPtr&lt;BufferRecycleBin&gt; mRecycleBin;
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :   // This member points to an ImageClient if this ImageContainer was
<span class="lineNum">     641 </span>            :   // sucessfully created with ENABLE_ASYNC, or points to null otherwise.
<span class="lineNum">     642 </span>            :   // 'unsuccessful' in this case only means that the ImageClient could not
<span class="lineNum">     643 </span>            :   // be created, most likely because off-main-thread compositing is not enabled.
<span class="lineNum">     644 </span>            :   // In this case the ImageContainer is perfectly usable, but it will forward
<span class="lineNum">     645 </span>            :   // frames to the compositor through transactions in the main thread rather than
<span class="lineNum">     646 </span>            :   // asynchronusly using the ImageBridge IPDL protocol.
<span class="lineNum">     647 </span>            :   RefPtr&lt;ImageClient&gt; mImageClient;
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :   bool mIsAsync;
<span class="lineNum">     650 </span>            :   CompositableHandle mAsyncContainerHandle;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   nsTArray&lt;FrameID&gt; mFrameIDsNotYetComposited;
<span class="lineNum">     653 </span>            :   // ProducerID for last current image(s), including the frames in
<span class="lineNum">     654 </span>            :   // mFrameIDsNotYetComposited
<span class="lineNum">     655 </span>            :   ProducerID mCurrentProducerID;
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :   RefPtr&lt;ImageContainerListener&gt; mNotifyCompositeListener;
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   static mozilla::Atomic&lt;uint32_t&gt; sGenerationCounter;
<span class="lineNum">     660 </span>            : };
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">          1 : class AutoLockImage</span>
<a name="663"><span class="lineNum">     663 </span>            : {</a>
<span class="lineNum">     664 </span>            : public:
<span class="lineNum">     665 </span><span class="lineCov">          1 :   explicit AutoLockImage(ImageContainer *aContainer)</span>
<span class="lineNum">     666 </span><span class="lineCov">          1 :   {</span>
<span class="lineNum">     667 </span><span class="lineCov">          1 :     aContainer-&gt;GetCurrentImages(&amp;mImages);</span>
<span class="lineNum">     668 </span><span class="lineCov">          1 :   }</span>
<a name="669"><span class="lineNum">     669 </span>            : </a>
<span class="lineNum">     670 </span><span class="lineCov">          1 :   bool HasImage() const { return !mImages.IsEmpty(); }</span>
<span class="lineNum">     671 </span><span class="lineCov">          1 :   Image* GetImage() const</span>
<span class="lineNum">     672 </span>            :   {
<span class="lineNum">     673 </span><span class="lineCov">          1 :     return mImages.IsEmpty() ? nullptr : mImages[0].mImage.get();</span>
<span class="lineNum">     674 </span>            :   }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : private:
<span class="lineNum">     677 </span>            :   AutoTArray&lt;ImageContainer::OwningImage,4&gt; mImages;
<span class="lineNum">     678 </span>            : };
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : struct PlanarYCbCrData {
<span class="lineNum">     681 </span>            :   // Luminance buffer
<span class="lineNum">     682 </span>            :   uint8_t* mYChannel;
<span class="lineNum">     683 </span>            :   int32_t mYStride;
<span class="lineNum">     684 </span>            :   gfx::IntSize mYSize;
<span class="lineNum">     685 </span>            :   int32_t mYSkip;
<span class="lineNum">     686 </span>            :   // Chroma buffers
<span class="lineNum">     687 </span>            :   uint8_t* mCbChannel;
<span class="lineNum">     688 </span>            :   uint8_t* mCrChannel;
<span class="lineNum">     689 </span>            :   int32_t mCbCrStride;
<span class="lineNum">     690 </span>            :   gfx::IntSize mCbCrSize;
<span class="lineNum">     691 </span>            :   int32_t mCbSkip;
<span class="lineNum">     692 </span>            :   int32_t mCrSkip;
<span class="lineNum">     693 </span>            :   // Picture region
<span class="lineNum">     694 </span>            :   uint32_t mPicX;
<span class="lineNum">     695 </span>            :   uint32_t mPicY;
<span class="lineNum">     696 </span>            :   gfx::IntSize mPicSize;
<span class="lineNum">     697 </span>            :   StereoMode mStereoMode;
<a name="698"><span class="lineNum">     698 </span>            :   YUVColorSpace mYUVColorSpace;</a>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   gfx::IntRect GetPictureRect() const {</span>
<span class="lineNum">     701 </span>            :     return gfx::IntRect(mPicX, mPicY,
<span class="lineNum">     702 </span>            :                      mPicSize.width,
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                      mPicSize.height);</span>
<a name="704"><span class="lineNum">     704 </span>            :   }</a>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineCov">          1 :   PlanarYCbCrData()</span>
<span class="lineNum">     707 </span>            :     : mYChannel(nullptr), mYStride(0), mYSize(0, 0), mYSkip(0)
<span class="lineNum">     708 </span>            :     , mCbChannel(nullptr), mCrChannel(nullptr)
<span class="lineNum">     709 </span>            :     , mCbCrStride(0), mCbCrSize(0, 0) , mCbSkip(0), mCrSkip(0)
<span class="lineNum">     710 </span>            :     , mPicX(0), mPicY(0), mPicSize(0, 0), mStereoMode(StereoMode::MONO)
<span class="lineNum">     711 </span><span class="lineCov">          1 :     , mYUVColorSpace(YUVColorSpace::BT601)</span>
<span class="lineNum">     712 </span><span class="lineCov">          1 :   {}</span>
<span class="lineNum">     713 </span>            : };
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            : /****** Image subtypes for the different formats ******/
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : /**
<span class="lineNum">     718 </span>            :  * We assume that the image data is in the REC 470M color space (see
<span class="lineNum">     719 </span>            :  * Theora specification, section 4.3.1).
<span class="lineNum">     720 </span>            :  *
<span class="lineNum">     721 </span>            :  * The YCbCr format can be:
<span class="lineNum">     722 </span>            :  *
<span class="lineNum">     723 </span>            :  * 4:4:4 - CbCr width/height are the same as Y.
<span class="lineNum">     724 </span>            :  * 4:2:2 - CbCr width is half that of Y. Height is the same.
<span class="lineNum">     725 </span>            :  * 4:2:0 - CbCr width and height is half that of Y.
<span class="lineNum">     726 </span>            :  *
<span class="lineNum">     727 </span>            :  * The color format is detected based on the height/width ratios
<span class="lineNum">     728 </span>            :  * defined above.
<span class="lineNum">     729 </span>            :  *
<span class="lineNum">     730 </span>            :  * The Image that is rendered is the picture region defined by
<span class="lineNum">     731 </span>            :  * mPicX, mPicY and mPicSize. The size of the rendered image is
<span class="lineNum">     732 </span>            :  * mPicSize, not mYSize or mCbCrSize.
<span class="lineNum">     733 </span>            :  *
<span class="lineNum">     734 </span>            :  * mYSkip, mCbSkip, mCrSkip are added to support various output
<span class="lineNum">     735 </span>            :  * formats from hardware decoder. They are per-pixel skips in the
<span class="lineNum">     736 </span>            :  * source image.
<span class="lineNum">     737 </span>            :  *
<span class="lineNum">     738 </span>            :  * For example when image width is 640, mYStride is 670, mYSkip is 3,
<span class="lineNum">     739 </span>            :  * the mYChannel buffer looks like:
<span class="lineNum">     740 </span>            :  *
<span class="lineNum">     741 </span>            :  * |&lt;----------------------- mYStride -----------------------------&gt;|
<span class="lineNum">     742 </span>            :  * |&lt;----------------- mYSize.width ---------------&gt;|
<span class="lineNum">     743 </span>            :  *  0   3   6   9   12  15  18  21                659             669
<span class="lineNum">     744 </span>            :  * |----------------------------------------------------------------|
<span class="lineNum">     745 </span>            :  * |Y___Y___Y___Y___Y___Y___Y___Y...                      |%%%%%%%%%|
<span class="lineNum">     746 </span>            :  * |Y___Y___Y___Y___Y___Y___Y___Y...                      |%%%%%%%%%|
<span class="lineNum">     747 </span>            :  * |Y___Y___Y___Y___Y___Y___Y___Y...                      |%%%%%%%%%|
<span class="lineNum">     748 </span>            :  * |            |&lt;-&gt;|
<span class="lineNum">     749 </span>            :  *                mYSkip
<span class="lineNum">     750 </span>            :  */
<span class="lineNum">     751 </span>            : class PlanarYCbCrImage : public Image {
<span class="lineNum">     752 </span>            : public:
<span class="lineNum">     753 </span>            :   typedef PlanarYCbCrData Data;
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            :   enum {
<span class="lineNum">     756 </span>            :     MAX_DIMENSION = 16384
<a name="757"><span class="lineNum">     757 </span>            :   };</a>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineCov">          1 :   virtual ~PlanarYCbCrImage() {}</span>
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :   /**
<span class="lineNum">     762 </span>            :    * This makes a copy of the data buffers, in order to support functioning
<span class="lineNum">     763 </span>            :    * in all different layer managers.
<span class="lineNum">     764 </span>            :    */
<span class="lineNum">     765 </span>            :   virtual bool CopyData(const Data&amp; aData) = 0;
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :   /**
<span class="lineNum">     768 </span>            :    * This doesn't make a copy of the data buffers. Can be used when mBuffer is
<span class="lineNum">     769 </span>            :    * pre allocated with AllocateAndGetNewBuffer(size) and then AdoptData is
<span class="lineNum">     770 </span>            :    * called to only update the picture size, planes etc. fields in mData.
<span class="lineNum">     771 </span>            :    * The GStreamer media backend uses this to decode into PlanarYCbCrImage(s)
<span class="lineNum">     772 </span>            :    * directly.
<span class="lineNum">     773 </span>            :    */
<span class="lineNum">     774 </span>            :   virtual bool AdoptData(const Data &amp;aData);
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :   /**
<span class="lineNum">     777 </span>            :    * This allocates and returns a new buffer
<span class="lineNum">     778 </span>            :    */
<span class="lineNum">     779 </span>            :   virtual uint8_t* AllocateAndGetNewBuffer(uint32_t aSize) = 0;
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :   /**
<span class="lineNum">     782 </span>            :    * Ask this Image to not convert YUV to RGB during SetData, and make
<span class="lineNum">     783 </span>            :    * the original data available through GetData. This is optional,
<a name="784"><span class="lineNum">     784 </span>            :    * and not all PlanarYCbCrImages will support it.</a>
<span class="lineNum">     785 </span>            :    */
<span class="lineNum">     786 </span><span class="lineCov">          1 :   virtual void SetDelayedConversion(bool aDelayed) { }</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :   /**
<a name="789"><span class="lineNum">     789 </span>            :    * Grab the original YUV data. This is optional.</a>
<span class="lineNum">     790 </span>            :    */
<span class="lineNum">     791 </span><span class="lineCov">          1 :   virtual const Data* GetData() { return &amp;mData; }</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :   /**
<a name="794"><span class="lineNum">     794 </span>            :    * Return the number of bytes of heap memory used to store this image.</a>
<span class="lineNum">     795 </span>            :    */
<a name="796"><span class="lineNum">     796 </span><span class="lineCov">          1 :   virtual uint32_t GetDataSize() { return mBufferSize; }</span></a>
<span class="lineNum">     797 </span>            : 
<a name="798"><span class="lineNum">     798 </span><span class="lineNoCov">          0 :   virtual bool IsValid() { return !!mBufferSize; }</span></a>
<span class="lineNum">     799 </span>            : 
<a name="800"><span class="lineNum">     800 </span><span class="lineCov">          1 :   virtual gfx::IntSize GetSize() { return mSize; }</span></a>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">          1 :   virtual gfx::IntPoint GetOrigin() { return mOrigin; }</span>
<span class="lineNum">     803 </span>            : 
<a name="804"><span class="lineNum">     804 </span>            :   explicit PlanarYCbCrImage();</a>
<span class="lineNum">     805 </span>            : 
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :   virtual SharedPlanarYCbCrImage *AsSharedPlanarYCbCrImage() { return nullptr; }</span></a>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   virtual size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const {</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">     810 </span>            :   }
<span class="lineNum">     811 </span>            : 
<a name="812"><span class="lineNum">     812 </span>            :   virtual size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const = 0;</a>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineCov">          1 :   PlanarYCbCrImage* AsPlanarYCbCrImage() { return this; }</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            : protected:
<span class="lineNum">     817 </span>            :   already_AddRefed&lt;gfx::SourceSurface&gt; GetAsSourceSurface();
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   void SetOffscreenFormat(gfxImageFormat aFormat) { mOffscreenFormat = aFormat; }</span>
<span class="lineNum">     820 </span>            :   gfxImageFormat GetOffscreenFormat();
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :   Data mData;
<span class="lineNum">     823 </span>            :   gfx::IntPoint mOrigin;
<span class="lineNum">     824 </span>            :   gfx::IntSize mSize;
<span class="lineNum">     825 </span>            :   gfxImageFormat mOffscreenFormat;
<span class="lineNum">     826 </span>            :   nsCountedRef&lt;nsMainThreadSourceSurfaceRef&gt; mSourceSurface;
<span class="lineNum">     827 </span>            :   uint32_t mBufferSize;
<span class="lineNum">     828 </span>            : };
<span class="lineNum">     829 </span>            : 
<a name="830"><span class="lineNum">     830 </span>            : class RecyclingPlanarYCbCrImage: public PlanarYCbCrImage {</a>
<span class="lineNum">     831 </span>            : public:
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   explicit RecyclingPlanarYCbCrImage(BufferRecycleBin *aRecycleBin) : mRecycleBin(aRecycleBin) {}</span>
<span class="lineNum">     833 </span>            :   virtual ~RecyclingPlanarYCbCrImage() override;
<span class="lineNum">     834 </span>            :   virtual bool CopyData(const Data&amp; aData) override;
<span class="lineNum">     835 </span>            :   virtual uint8_t* AllocateAndGetNewBuffer(uint32_t aSize) override;
<span class="lineNum">     836 </span>            :   virtual size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const override;
<span class="lineNum">     837 </span>            : protected:
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :   /**
<span class="lineNum">     840 </span>            :    * Return a buffer to store image data in.
<span class="lineNum">     841 </span>            :    */
<span class="lineNum">     842 </span>            :   mozilla::UniquePtr&lt;uint8_t[]&gt; AllocateBuffer(uint32_t aSize);
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   RefPtr&lt;BufferRecycleBin&gt; mRecycleBin;
<span class="lineNum">     845 </span>            :   mozilla::UniquePtr&lt;uint8_t[]&gt; mBuffer;
<span class="lineNum">     846 </span>            : };
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : /**
<span class="lineNum">     849 </span>            :  * NVImage is used to store YUV420SP_NV12 and YUV420SP_NV21 data natively, which
<span class="lineNum">     850 </span>            :  * are not supported by PlanarYCbCrImage. (PlanarYCbCrImage only stores YUV444P,
<span class="lineNum">     851 </span>            :  * YUV422P and YUV420P, it converts YUV420SP_NV12 and YUV420SP_NV21 data into
<span class="lineNum">     852 </span>            :  * YUV420P in its PlanarYCbCrImage::SetData() method.)
<span class="lineNum">     853 </span>            :  *
<span class="lineNum">     854 </span>            :  * PlanarYCbCrData is able to express all the YUV family and so we keep use it
<a name="855"><span class="lineNum">     855 </span>            :  * in NVImage.</a>
<span class="lineNum">     856 </span>            :  */
<span class="lineNum">     857 </span><span class="lineCov">          1 : class NVImage: public Image {</span>
<span class="lineNum">     858 </span>            :   typedef PlanarYCbCrData Data;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : public:
<span class="lineNum">     861 </span>            :   explicit NVImage();
<span class="lineNum">     862 </span>            :   virtual ~NVImage() override;
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :   // Methods inherited from layers::Image.
<span class="lineNum">     865 </span>            :   virtual gfx::IntSize GetSize() override;
<span class="lineNum">     866 </span>            :   virtual gfx::IntRect GetPictureRect() override;
<span class="lineNum">     867 </span>            :   virtual already_AddRefed&lt;gfx::SourceSurface&gt; GetAsSourceSurface() override;
<span class="lineNum">     868 </span>            :   virtual bool IsValid() override;
<span class="lineNum">     869 </span>            :   virtual NVImage* AsNVImage() override;
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :   // Methods mimic layers::PlanarYCbCrImage.
<span class="lineNum">     872 </span>            :   virtual bool SetData(const Data&amp; aData);
<span class="lineNum">     873 </span>            :   virtual const Data* GetData() const;
<span class="lineNum">     874 </span>            :   virtual uint32_t GetBufferSize() const;
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : protected:
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   /**
<span class="lineNum">     879 </span>            :    * Return a buffer to store image data in.
<span class="lineNum">     880 </span>            :    */
<span class="lineNum">     881 </span>            :   mozilla::UniquePtr&lt;uint8_t&gt; AllocateBuffer(uint32_t aSize);
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :   mozilla::UniquePtr&lt;uint8_t&gt; mBuffer;
<span class="lineNum">     884 </span>            :   uint32_t mBufferSize;
<span class="lineNum">     885 </span>            :   gfx::IntSize mSize;
<span class="lineNum">     886 </span>            :   Data mData;
<span class="lineNum">     887 </span>            :   nsCountedRef&lt;nsMainThreadSourceSurfaceRef&gt; mSourceSurface;
<span class="lineNum">     888 </span>            : };
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            : /**
<span class="lineNum">     891 </span>            :  * Currently, the data in a SourceSurfaceImage surface is treated as being in the
<span class="lineNum">     892 </span>            :  * device output color space. This class is very simple as all backends
<a name="893"><span class="lineNum">     893 </span>            :  * have to know about how to deal with drawing a cairo image.</a>
<span class="lineNum">     894 </span>            :  */
<a name="895"><span class="lineNum">     895 </span><span class="lineCov">          1 : class SourceSurfaceImage final : public Image {</span></a>
<span class="lineNum">     896 </span>            : public:
<span class="lineNum">     897 </span><span class="lineCov">          1 :   virtual already_AddRefed&lt;gfx::SourceSurface&gt; GetAsSourceSurface() override</span>
<span class="lineNum">     898 </span>            :   {
<span class="lineNum">     899 </span><span class="lineCov">          1 :     RefPtr&lt;gfx::SourceSurface&gt; surface(mSourceSurface);</span>
<span class="lineNum">     900 </span><span class="lineCov">          1 :     return surface.forget();</span>
<span class="lineNum">     901 </span>            :   }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :   void SetTextureFlags(TextureFlags aTextureFlags) { mTextureFlags = aTextureFlags; }
<a name="904"><span class="lineNum">     904 </span>            :   virtual TextureClient* GetTextureClient(KnowsCompositor* aForwarder) override;</a>
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineCov">          1 :   virtual gfx::IntSize GetSize() override { return mSize; }</span>
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :   SourceSurfaceImage(const gfx::IntSize&amp; aSize, gfx::SourceSurface* aSourceSurface);
<span class="lineNum">     909 </span>            :   explicit SourceSurfaceImage(gfx::SourceSurface* aSourceSurface);
<span class="lineNum">     910 </span>            :   ~SourceSurfaceImage();
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            : private:
<span class="lineNum">     913 </span>            :   gfx::IntSize mSize;
<span class="lineNum">     914 </span>            :   nsCountedRef&lt;nsOwningThreadSourceSurfaceRef&gt; mSourceSurface;
<span class="lineNum">     915 </span>            :   nsDataHashtable&lt;nsUint32HashKey, RefPtr&lt;TextureClient&gt; &gt;  mTextureClients;
<span class="lineNum">     916 </span>            :   TextureFlags mTextureFlags;
<span class="lineNum">     917 </span>            : };
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : } // namespace layers
<span class="lineNum">     920 </span>            : } // namespace mozilla
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
