<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/gpu/GrPathUtils.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/gpu</a> - GrPathUtils.cpp<span style="font-size: 80%;"> (source / <a href="GrPathUtils.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">434</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:24:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2011 Google Inc.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;GrPathUtils.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;GrTypes.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;SkGeometry.h&quot;
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;SkMathPriv.h&quot;</a>
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span><span class="lineNoCov">          0 : SkScalar GrPathUtils::scaleToleranceToSrc(SkScalar devTol,</span>
<span class="lineNum">      15 </span>            :                                           const SkMatrix&amp; viewM,
<span class="lineNum">      16 </span>            :                                           const SkRect&amp; pathBounds) {
<span class="lineNum">      17 </span>            :     // In order to tesselate the path we get a bound on how much the matrix can
<span class="lineNum">      18 </span>            :     // scale when mapping to screen coordinates.
<span class="lineNum">      19 </span><span class="lineNoCov">          0 :     SkScalar stretch = viewM.getMaxScale();</span>
<span class="lineNum">      20 </span><span class="lineNoCov">          0 :     SkScalar srcTol = devTol;</span>
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span><span class="lineNoCov">          0 :     if (stretch &lt; 0) {</span>
<span class="lineNum">      23 </span>            :         // take worst case mapRadius amoung four corners.
<span class="lineNum">      24 </span>            :         // (less than perfect)
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 4; ++i) {</span>
<span class="lineNum">      26 </span>            :             SkMatrix mat;
<span class="lineNum">      27 </span>            :             mat.setTranslate((i % 2) ? pathBounds.fLeft : pathBounds.fRight,
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :                              (i &lt; 2) ? pathBounds.fTop : pathBounds.fBottom);</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :             mat.postConcat(viewM);</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :             stretch = SkMaxScalar(stretch, mat.mapRadius(SK_Scalar1));</span>
<span class="lineNum">      31 </span>            :         }
<span class="lineNum">      32 </span>            :     }
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :     return srcTol / stretch;</span>
<span class="lineNum">      34 </span>            : }
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : static const int MAX_POINTS_PER_CURVE = 1 &lt;&lt; 10;
<a name="37"><span class="lineNum">      37 </span>            : static const SkScalar gMinCurveTol = 0.0001f;</a>
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span><span class="lineNoCov">          0 : uint32_t GrPathUtils::quadraticPointCount(const SkPoint points[],</span>
<span class="lineNum">      40 </span>            :                                           SkScalar tol) {
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :     if (tol &lt; gMinCurveTol) {</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :         tol = gMinCurveTol;</span>
<span class="lineNum">      43 </span>            :     }
<span class="lineNum">      44 </span>            :     SkASSERT(tol &gt; 0);
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :     SkScalar d = points[1].distanceToLineSegmentBetween(points[0], points[2]);</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :     if (!SkScalarIsFinite(d)) {</span>
<span class="lineNum">      48 </span>            :         return MAX_POINTS_PER_CURVE;
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :     } else if (d &lt;= tol) {</span>
<span class="lineNum">      50 </span>            :         return 1;
<span class="lineNum">      51 </span>            :     } else {
<span class="lineNum">      52 </span>            :         // Each time we subdivide, d should be cut in 4. So we need to
<span class="lineNum">      53 </span>            :         // subdivide x = log4(d/tol) times. x subdivisions creates 2^(x)
<span class="lineNum">      54 </span>            :         // points.
<span class="lineNum">      55 </span>            :         // 2^(log4(x)) = sqrt(x);
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :         SkScalar divSqrt = SkScalarSqrt(d / tol);</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :         if (((SkScalar)SK_MaxS32) &lt;= divSqrt) {</span>
<span class="lineNum">      58 </span>            :             return MAX_POINTS_PER_CURVE;
<span class="lineNum">      59 </span>            :         } else {
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :             int temp = SkScalarCeilToInt(divSqrt);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :             int pow2 = GrNextPow2(temp);</span>
<span class="lineNum">      62 </span>            :             // Because of NaNs &amp; INFs we can wind up with a degenerate temp
<span class="lineNum">      63 </span>            :             // such that pow2 comes out negative. Also, our point generator
<span class="lineNum">      64 </span>            :             // will always output at least one pt.
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :             if (pow2 &lt; 1) {</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :                 pow2 = 1;</span>
<span class="lineNum">      67 </span>            :             }
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :             return SkTMin(pow2, MAX_POINTS_PER_CURVE);</span>
<span class="lineNum">      69 </span>            :         }
<span class="lineNum">      70 </span>            :     }
<a name="71"><span class="lineNum">      71 </span>            : }</a>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineNoCov">          0 : uint32_t GrPathUtils::generateQuadraticPoints(const SkPoint&amp; p0,</span>
<span class="lineNum">      74 </span>            :                                               const SkPoint&amp; p1,
<span class="lineNum">      75 </span>            :                                               const SkPoint&amp; p2,
<span class="lineNum">      76 </span>            :                                               SkScalar tolSqd,
<span class="lineNum">      77 </span>            :                                               SkPoint** points,
<span class="lineNum">      78 </span>            :                                               uint32_t pointsLeft) {
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     if (pointsLeft &lt; 2 ||</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :         (p1.distanceToLineSegmentBetweenSqd(p0, p2)) &lt; tolSqd) {</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :         (*points)[0] = p2;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :         *points += 1;</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">      84 </span>            :     }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :     SkPoint q[] = {
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         { SkScalarAve(p0.fX, p1.fX), SkScalarAve(p0.fY, p1.fY) },</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :         { SkScalarAve(p1.fX, p2.fX), SkScalarAve(p1.fY, p2.fY) },</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     SkPoint r = { SkScalarAve(q[0].fX, q[1].fX), SkScalarAve(q[0].fY, q[1].fY) };</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     pointsLeft &gt;&gt;= 1;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     uint32_t a = generateQuadraticPoints(p0, q[0], r, tolSqd, points, pointsLeft);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     uint32_t b = generateQuadraticPoints(r, q[1], p2, tolSqd, points, pointsLeft);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     return a + b;</span>
<a name="96"><span class="lineNum">      96 </span>            : }</a>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 : uint32_t GrPathUtils::cubicPointCount(const SkPoint points[],</span>
<span class="lineNum">      99 </span>            :                                            SkScalar tol) {
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     if (tol &lt; gMinCurveTol) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         tol = gMinCurveTol;</span>
<span class="lineNum">     102 </span>            :     }
<span class="lineNum">     103 </span>            :     SkASSERT(tol &gt; 0);
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :     SkScalar d = SkTMax(
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :         points[1].distanceToLineSegmentBetweenSqd(points[0], points[3]),</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         points[2].distanceToLineSegmentBetweenSqd(points[0], points[3]));</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     d = SkScalarSqrt(d);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     if (!SkScalarIsFinite(d)) {</span>
<span class="lineNum">     110 </span>            :         return MAX_POINTS_PER_CURVE;
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     } else if (d &lt;= tol) {</span>
<span class="lineNum">     112 </span>            :         return 1;
<span class="lineNum">     113 </span>            :     } else {
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :         SkScalar divSqrt = SkScalarSqrt(d / tol);</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         if (((SkScalar)SK_MaxS32) &lt;= divSqrt) {</span>
<span class="lineNum">     116 </span>            :             return MAX_POINTS_PER_CURVE;
<span class="lineNum">     117 </span>            :         } else {
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :             int temp = SkScalarCeilToInt(SkScalarSqrt(d / tol));</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :             int pow2 = GrNextPow2(temp);</span>
<span class="lineNum">     120 </span>            :             // Because of NaNs &amp; INFs we can wind up with a degenerate temp
<span class="lineNum">     121 </span>            :             // such that pow2 comes out negative. Also, our point generator
<span class="lineNum">     122 </span>            :             // will always output at least one pt.
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             if (pow2 &lt; 1) {</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                 pow2 = 1;</span>
<span class="lineNum">     125 </span>            :             }
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :             return SkTMin(pow2, MAX_POINTS_PER_CURVE);</span>
<span class="lineNum">     127 </span>            :         }
<span class="lineNum">     128 </span>            :     }
<a name="129"><span class="lineNum">     129 </span>            : }</a>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : uint32_t GrPathUtils::generateCubicPoints(const SkPoint&amp; p0,</span>
<span class="lineNum">     132 </span>            :                                           const SkPoint&amp; p1,
<span class="lineNum">     133 </span>            :                                           const SkPoint&amp; p2,
<span class="lineNum">     134 </span>            :                                           const SkPoint&amp; p3,
<span class="lineNum">     135 </span>            :                                           SkScalar tolSqd,
<span class="lineNum">     136 </span>            :                                           SkPoint** points,
<span class="lineNum">     137 </span>            :                                           uint32_t pointsLeft) {
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     if (pointsLeft &lt; 2 ||</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         (p1.distanceToLineSegmentBetweenSqd(p0, p3) &lt; tolSqd &amp;&amp;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :          p2.distanceToLineSegmentBetweenSqd(p0, p3) &lt; tolSqd)) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         (*points)[0] = p3;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         *points += 1;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     144 </span>            :     }
<span class="lineNum">     145 </span>            :     SkPoint q[] = {
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         { SkScalarAve(p0.fX, p1.fX), SkScalarAve(p0.fY, p1.fY) },</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :         { SkScalarAve(p1.fX, p2.fX), SkScalarAve(p1.fY, p2.fY) },</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :         { SkScalarAve(p2.fX, p3.fX), SkScalarAve(p2.fY, p3.fY) }</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">     150 </span>            :     SkPoint r[] = {
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         { SkScalarAve(q[0].fX, q[1].fX), SkScalarAve(q[0].fY, q[1].fY) },</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         { SkScalarAve(q[1].fX, q[2].fX), SkScalarAve(q[1].fY, q[2].fY) }</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     SkPoint s = { SkScalarAve(r[0].fX, r[1].fX), SkScalarAve(r[0].fY, r[1].fY) };</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     pointsLeft &gt;&gt;= 1;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     uint32_t a = generateCubicPoints(p0, q[0], r[0], s, tolSqd, points, pointsLeft);</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     uint32_t b = generateCubicPoints(s, r[1], q[2], p3, tolSqd, points, pointsLeft);</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     return a + b;</span>
<a name="159"><span class="lineNum">     159 </span>            : }</a>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : int GrPathUtils::worstCasePointCount(const SkPath&amp; path, int* subpaths,</span>
<span class="lineNum">     162 </span>            :                                      SkScalar tol) {
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     if (tol &lt; gMinCurveTol) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :         tol = gMinCurveTol;</span>
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span>            :     SkASSERT(tol &gt; 0);
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     int pointCount = 0;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     *subpaths = 1;</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     bool first = true;</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     SkPath::Iter iter(path, false);</span>
<span class="lineNum">     174 </span>            :     SkPath::Verb verb;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :     SkPoint pts[4];
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     while ((verb = iter.next(pts)) != SkPath::kDone_Verb) {</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         switch (verb) {</span>
<span class="lineNum">     180 </span>            :             case SkPath::kLine_Verb:
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :                 pointCount += 1;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     183 </span>            :             case SkPath::kConic_Verb: {
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :                 SkScalar weight = iter.conicWeight();</span>
<span class="lineNum">     185 </span>            :                 SkAutoConicToQuads converter;
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                 const SkPoint* quadPts = converter.computeQuads(pts, weight, 0.25f);</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :                 for (int i = 0; i &lt; converter.countQuads(); ++i) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :                     pointCount += quadraticPointCount(quadPts + 2*i, tol);</span>
<span class="lineNum">     189 </span>            :                 }
<span class="lineNum">     190 </span>            :             }
<span class="lineNum">     191 </span>            :             case SkPath::kQuad_Verb:
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :                 pointCount += quadraticPointCount(pts, tol);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     194 </span>            :             case SkPath::kCubic_Verb:
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :                 pointCount += cubicPointCount(pts, tol);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     197 </span>            :             case SkPath::kMove_Verb:
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :                 pointCount += 1;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 if (!first) {</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :                     ++(*subpaths);</span>
<span class="lineNum">     201 </span>            :                 }
<span class="lineNum">     202 </span>            :                 break;
<span class="lineNum">     203 </span>            :             default:
<span class="lineNum">     204 </span>            :                 break;
<span class="lineNum">     205 </span>            :         }
<span class="lineNum">     206 </span>            :         first = false;
<span class="lineNum">     207 </span>            :     }
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     return pointCount;</span>
<a name="209"><span class="lineNum">     209 </span>            : }</a>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineNoCov">          0 : void GrPathUtils::QuadUVMatrix::set(const SkPoint qPts[3]) {</span>
<span class="lineNum">     212 </span>            :     SkMatrix m;
<span class="lineNum">     213 </span>            :     // We want M such that M * xy_pt = uv_pt
<span class="lineNum">     214 </span>            :     // We know M * control_pts = [0  1/2 1]
<span class="lineNum">     215 </span>            :     //                           [0  0   1]
<span class="lineNum">     216 </span>            :     //                           [1  1   1]
<span class="lineNum">     217 </span>            :     // And control_pts = [x0 x1 x2]
<span class="lineNum">     218 </span>            :     //                   [y0 y1 y2]
<span class="lineNum">     219 </span>            :     //                   [1  1  1 ]
<span class="lineNum">     220 </span>            :     // We invert the control pt matrix and post concat to both sides to get M.
<span class="lineNum">     221 </span>            :     // Using the known form of the control point matrix and the result, we can
<span class="lineNum">     222 </span>            :     // optimize and improve precision.
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     double x0 = qPts[0].fX;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     double y0 = qPts[0].fY;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     double x1 = qPts[1].fX;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     double y1 = qPts[1].fY;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     double x2 = qPts[2].fX;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     double y2 = qPts[2].fY;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     double det = x0*y1 - y0*x1 + x2*y0 - y2*x0 + x1*y2 - y1*x2;</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (!sk_float_isfinite(det)</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         || SkScalarNearlyZero((float)det, SK_ScalarNearlyZero * SK_ScalarNearlyZero)) {</span>
<span class="lineNum">     234 </span>            :         // The quad is degenerate. Hopefully this is rare. Find the pts that are
<span class="lineNum">     235 </span>            :         // farthest apart to compute a line (unless it is really a pt).
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         SkScalar maxD = qPts[0].distanceToSqd(qPts[1]);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         int maxEdge = 0;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         SkScalar d = qPts[1].distanceToSqd(qPts[2]);</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         if (d &gt; maxD) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :             maxD = d;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :             maxEdge = 1;</span>
<span class="lineNum">     242 </span>            :         }
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         d = qPts[2].distanceToSqd(qPts[0]);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         if (d &gt; maxD) {</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :             maxD = d;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :             maxEdge = 2;</span>
<span class="lineNum">     247 </span>            :         }
<span class="lineNum">     248 </span>            :         // We could have a tolerance here, not sure if it would improve anything
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         if (maxD &gt; 0) {</span>
<span class="lineNum">     250 </span>            :             // Set the matrix to give (u = 0, v = distance_to_line)
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :             SkVector lineVec = qPts[(maxEdge + 1)%3] - qPts[maxEdge];</span>
<span class="lineNum">     252 </span>            :             // when looking from the point 0 down the line we want positive
<span class="lineNum">     253 </span>            :             // distances to be to the left. This matches the non-degenerate
<span class="lineNum">     254 </span>            :             // case.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             lineVec.setOrthog(lineVec, SkPoint::kLeft_Side);</span>
<span class="lineNum">     256 </span>            :             // first row
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :             fM[0] = 0;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             fM[1] = 0;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :             fM[2] = 0;</span>
<span class="lineNum">     260 </span>            :             // second row
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :             fM[3] = lineVec.fX;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :             fM[4] = lineVec.fY;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :             fM[5] = -lineVec.dot(qPts[maxEdge]);</span>
<span class="lineNum">     264 </span>            :         } else {
<span class="lineNum">     265 </span>            :             // It's a point. It should cover zero area. Just set the matrix such
<span class="lineNum">     266 </span>            :             // that (u, v) will always be far away from the quad.
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :             fM[0] = 0; fM[1] = 0; fM[2] = 100.f;</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :             fM[3] = 0; fM[4] = 0; fM[5] = 100.f;</span>
<span class="lineNum">     269 </span>            :         }
<span class="lineNum">     270 </span>            :     } else {
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         double scale = 1.0/det;</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :         // compute adjugate matrix
<span class="lineNum">     274 </span>            :         double a2, a3, a4, a5, a6, a7, a8;
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         a2 = x1*y2-x2*y1;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :         a3 = y2-y0;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         a4 = x0-x2;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         a5 = x2*y0-x0*y2;</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         a6 = y0-y1;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :         a7 = x1-x0;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         a8 = x0*y1-x1*y0;</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :         // this performs the uv_pts*adjugate(control_pts) multiply,
<span class="lineNum">     286 </span>            :         // then does the scale by 1/det afterwards to improve precision
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMScaleX] = (float)((0.5*a3 + a6)*scale);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMSkewX]  = (float)((0.5*a4 + a7)*scale);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMTransX] = (float)((0.5*a5 + a8)*scale);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMSkewY]  = (float)(a6*scale);</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMScaleY] = (float)(a7*scale);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMTransY] = (float)(a8*scale);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :         // kMPersp0 &amp; kMPersp1 should algebraically be zero
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMPersp0] = 0.0f;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMPersp1] = 0.0f;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         m[SkMatrix::kMPersp2] = (float)((a2 + a5 + a8)*scale);</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :         // It may not be normalized to have 1.0 in the bottom right
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         float m33 = m.get(SkMatrix::kMPersp2);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         if (1.f != m33) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :             m33 = 1.f / m33;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :             fM[0] = m33 * m.get(SkMatrix::kMScaleX);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :             fM[1] = m33 * m.get(SkMatrix::kMSkewX);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :             fM[2] = m33 * m.get(SkMatrix::kMTransX);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :             fM[3] = m33 * m.get(SkMatrix::kMSkewY);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :             fM[4] = m33 * m.get(SkMatrix::kMScaleY);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :             fM[5] = m33 * m.get(SkMatrix::kMTransY);</span>
<span class="lineNum">     310 </span>            :         } else {
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :             fM[0] = m.get(SkMatrix::kMScaleX);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :             fM[1] = m.get(SkMatrix::kMSkewX);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :             fM[2] = m.get(SkMatrix::kMTransX);</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             fM[3] = m.get(SkMatrix::kMSkewY);</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :             fM[4] = m.get(SkMatrix::kMScaleY);</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :             fM[5] = m.get(SkMatrix::kMTransY);</span>
<span class="lineNum">     317 </span>            :         }
<span class="lineNum">     318 </span>            :     }
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : // k = (y2 - y0, x0 - x2, (x2 - x0)*y0 - (y2 - y0)*x0 )
<a name="324"><span class="lineNum">     324 </span>            : // l = (2*w * (y1 - y0), 2*w * (x0 - x1), 2*w * (x1*y0 - x0*y1))</a>
<span class="lineNum">     325 </span>            : // m = (2*w * (y2 - y1), 2*w * (x1 - x2), 2*w * (x2*y1 - x1*y2))
<span class="lineNum">     326 </span><span class="lineNoCov">          0 : void GrPathUtils::getConicKLM(const SkPoint p[3], const SkScalar weight, SkScalar klm[9]) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     const SkScalar w2 = 2.f * weight;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     klm[0] = p[2].fY - p[0].fY;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     klm[1] = p[0].fX - p[2].fX;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     klm[2] = (p[2].fX - p[0].fX) * p[0].fY - (p[2].fY - p[0].fY) * p[0].fX;</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     klm[3] = w2 * (p[1].fY - p[0].fY);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     klm[4] = w2 * (p[0].fX - p[1].fX);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     klm[5] = w2 * (p[1].fX * p[0].fY - p[0].fX * p[1].fY);</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     klm[6] = w2 * (p[2].fY - p[1].fY);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     klm[7] = w2 * (p[1].fX - p[2].fX);</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     klm[8] = w2 * (p[2].fX * p[1].fY - p[1].fX * p[2].fY);</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :     // scale the max absolute value of coeffs to 10
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     SkScalar scale = 0.f;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 9; ++i) {</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :        scale = SkMaxScalar(scale, SkScalarAbs(klm[i]));</span>
<span class="lineNum">     344 </span>            :     }
<span class="lineNum">     345 </span>            :     SkASSERT(scale &gt; 0.f);
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     scale = 10.f / scale;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 9; ++i) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         klm[i] *= scale;</span>
<span class="lineNum">     349 </span>            :     }
<span class="lineNum">     350 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : namespace {
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : // a is the first control point of the cubic.
<span class="lineNum">     357 </span>            : // ab is the vector from a to the second control point.
<span class="lineNum">     358 </span>            : // dc is the vector from the fourth to the third control point.
<span class="lineNum">     359 </span>            : // d is the fourth control point.
<a name="360"><span class="lineNum">     360 </span>            : // p is the candidate quadratic control point.</a>
<span class="lineNum">     361 </span>            : // this assumes that the cubic doesn't inflect and is simple
<span class="lineNum">     362 </span><span class="lineNoCov">          0 : bool is_point_within_cubic_tangents(const SkPoint&amp; a,</span>
<span class="lineNum">     363 </span>            :                                     const SkVector&amp; ab,
<span class="lineNum">     364 </span>            :                                     const SkVector&amp; dc,
<span class="lineNum">     365 </span>            :                                     const SkPoint&amp; d,
<span class="lineNum">     366 </span>            :                                     SkPathPriv::FirstDirection dir,
<span class="lineNum">     367 </span>            :                                     const SkPoint p) {
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     SkVector ap = p - a;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     SkScalar apXab = ap.cross(ab);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     if (SkPathPriv::kCW_FirstDirection == dir) {</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         if (apXab &gt; 0) {</span>
<span class="lineNum">     372 </span>            :             return false;
<span class="lineNum">     373 </span>            :         }
<span class="lineNum">     374 </span>            :     } else {
<span class="lineNum">     375 </span>            :         SkASSERT(SkPathPriv::kCCW_FirstDirection == dir);
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         if (apXab &lt; 0) {</span>
<span class="lineNum">     377 </span>            :             return false;
<span class="lineNum">     378 </span>            :         }
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     SkVector dp = p - d;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     SkScalar dpXdc = dp.cross(dc);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     if (SkPathPriv::kCW_FirstDirection == dir) {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         if (dpXdc &lt; 0) {</span>
<span class="lineNum">     385 </span>            :             return false;
<span class="lineNum">     386 </span>            :         }
<span class="lineNum">     387 </span>            :     } else {
<span class="lineNum">     388 </span>            :         SkASSERT(SkPathPriv::kCCW_FirstDirection == dir);
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         if (dpXdc &gt; 0) {</span>
<span class="lineNum">     390 </span>            :             return false;
<span class="lineNum">     391 </span>            :         }
<span class="lineNum">     392 </span>            :     }
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="394"><span class="lineNum">     394 </span>            : }</a>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 : void convert_noninflect_cubic_to_quads(const SkPoint p[4],</span>
<span class="lineNum">     397 </span>            :                                        SkScalar toleranceSqd,
<span class="lineNum">     398 </span>            :                                        bool constrainWithinTangents,
<span class="lineNum">     399 </span>            :                                        SkPathPriv::FirstDirection dir,
<span class="lineNum">     400 </span>            :                                        SkTArray&lt;SkPoint, true&gt;* quads,
<span class="lineNum">     401 </span>            :                                        int sublevel = 0) {
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :     // Notation: Point a is always p[0]. Point b is p[1] unless p[1] == p[0], in which case it is
<span class="lineNum">     404 </span>            :     // p[2]. Point d is always p[3]. Point c is p[2] unless p[2] == p[3], in which case it is p[1].
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     SkVector ab = p[1] - p[0];</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     SkVector dc = p[2] - p[3];</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     if (ab.lengthSqd() &lt; SK_ScalarNearlyZero) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         if (dc.lengthSqd() &lt; SK_ScalarNearlyZero) {</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :             SkPoint* degQuad = quads-&gt;push_back_n(3);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :             degQuad[0] = p[0];</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :             degQuad[1] = p[0];</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :             degQuad[2] = p[3];</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     416 </span>            :         }
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         ab = p[2] - p[0];</span>
<span class="lineNum">     418 </span>            :     }
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     if (dc.lengthSqd() &lt; SK_ScalarNearlyZero) {</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         dc = p[1] - p[3];</span>
<span class="lineNum">     421 </span>            :     }
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            :     // When the ab and cd tangents are degenerate or nearly parallel with vector from d to a the
<span class="lineNum">     424 </span>            :     // constraint that the quad point falls between the tangents becomes hard to enforce and we are
<span class="lineNum">     425 </span>            :     // likely to hit the max subdivision count. However, in this case the cubic is approaching a
<span class="lineNum">     426 </span>            :     // line and the accuracy of the quad point isn't so important. We check if the two middle cubic
<span class="lineNum">     427 </span>            :     // control points are very close to the baseline vector. If so then we just pick quadratic
<span class="lineNum">     428 </span>            :     // points on the control polygon.
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     if (constrainWithinTangents) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         SkVector da = p[0] - p[3];</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         bool doQuads = dc.lengthSqd() &lt; SK_ScalarNearlyZero ||</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :                        ab.lengthSqd() &lt; SK_ScalarNearlyZero;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         if (!doQuads) {</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :             SkScalar invDALengthSqd = da.lengthSqd();</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :             if (invDALengthSqd &gt; SK_ScalarNearlyZero) {</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                 invDALengthSqd = SkScalarInvert(invDALengthSqd);</span>
<span class="lineNum">     438 </span>            :                 // cross(ab, da)^2/length(da)^2 == sqd distance from b to line from d to a.
<span class="lineNum">     439 </span>            :                 // same goes for point c using vector cd.
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                 SkScalar detABSqd = ab.cross(da);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                 detABSqd = SkScalarSquare(detABSqd);</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                 SkScalar detDCSqd = dc.cross(da);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                 detDCSqd = SkScalarSquare(detDCSqd);</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                 if (SkScalarMul(detABSqd, invDALengthSqd) &lt; toleranceSqd &amp;&amp;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                     SkScalarMul(detDCSqd, invDALengthSqd) &lt; toleranceSqd) {</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                     doQuads = true;</span>
<span class="lineNum">     447 </span>            :                 }
<span class="lineNum">     448 </span>            :             }
<span class="lineNum">     449 </span>            :         }
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         if (doQuads) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :             SkPoint b = p[0] + ab;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :             SkPoint c = p[3] + dc;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :             SkPoint mid = b + c;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :             mid.scale(SK_ScalarHalf);</span>
<span class="lineNum">     455 </span>            :             // Insert two quadratics to cover the case when ab points away from d and/or dc
<span class="lineNum">     456 </span>            :             // points away from a.
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :             if (SkVector::DotProduct(da, dc) &lt; 0 || SkVector::DotProduct(ab,da) &gt; 0) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 SkPoint* qpts = quads-&gt;push_back_n(6);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                 qpts[0] = p[0];</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                 qpts[1] = b;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                 qpts[2] = mid;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                 qpts[3] = mid;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :                 qpts[4] = c;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                 qpts[5] = p[3];</span>
<span class="lineNum">     465 </span>            :             } else {
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                 SkPoint* qpts = quads-&gt;push_back_n(3);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                 qpts[0] = p[0];</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                 qpts[1] = mid;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                 qpts[2] = p[3];</span>
<span class="lineNum">     470 </span>            :             }
<span class="lineNum">     471 </span>            :             return;
<span class="lineNum">     472 </span>            :         }
<span class="lineNum">     473 </span>            :     }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :     static const SkScalar kLengthScale = 3 * SK_Scalar1 / 2;
<span class="lineNum">     476 </span>            :     static const int kMaxSubdivs = 10;
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     ab.scale(kLengthScale);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     dc.scale(kLengthScale);</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :     // e0 and e1 are extrapolations along vectors ab and dc.
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     SkVector c0 = p[0];</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     c0 += ab;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     SkVector c1 = p[3];</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     c1 += dc;</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     SkScalar dSqd = sublevel &gt; kMaxSubdivs ? 0 : c0.distanceToSqd(c1);</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     if (dSqd &lt; toleranceSqd) {</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :         SkPoint cAvg = c0;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         cAvg += c1;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         cAvg.scale(SK_ScalarHalf);</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         bool subdivide = false;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         if (constrainWithinTangents &amp;&amp;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :             !is_point_within_cubic_tangents(p[0], ab, dc, p[3], dir, cAvg)) {</span>
<span class="lineNum">     497 </span>            :             // choose a new cAvg that is the intersection of the two tangent lines.
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :             ab.setOrthog(ab);</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :             SkScalar z0 = -ab.dot(p[0]);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :             dc.setOrthog(dc);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :             SkScalar z1 = -dc.dot(p[3]);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :             cAvg.fX = SkScalarMul(ab.fY, z1) - SkScalarMul(z0, dc.fY);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :             cAvg.fY = SkScalarMul(z0, dc.fX) - SkScalarMul(ab.fX, z1);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :             SkScalar z = SkScalarMul(ab.fX, dc.fY) - SkScalarMul(ab.fY, dc.fX);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :             z = SkScalarInvert(z);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             cAvg.fX *= z;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :             cAvg.fY *= z;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :             if (sublevel &lt;= kMaxSubdivs) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                 SkScalar d0Sqd = c0.distanceToSqd(cAvg);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                 SkScalar d1Sqd = c1.distanceToSqd(cAvg);</span>
<span class="lineNum">     511 </span>            :                 // We need to subdivide if d0 + d1 &gt; tolerance but we have the sqd values. We know
<span class="lineNum">     512 </span>            :                 // the distances and tolerance can't be negative.
<span class="lineNum">     513 </span>            :                 // (d0 + d1)^2 &gt; toleranceSqd
<span class="lineNum">     514 </span>            :                 // d0Sqd + 2*d0*d1 + d1Sqd &gt; toleranceSqd
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                 SkScalar d0d1 = SkScalarSqrt(SkScalarMul(d0Sqd, d1Sqd));</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                 subdivide = 2 * d0d1 + d0Sqd + d1Sqd &gt; toleranceSqd;</span>
<span class="lineNum">     517 </span>            :             }
<span class="lineNum">     518 </span>            :         }
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         if (!subdivide) {</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :             SkPoint* pts = quads-&gt;push_back_n(3);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :             pts[0] = p[0];</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :             pts[1] = cAvg;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :             pts[2] = p[3];</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     525 </span>            :         }
<span class="lineNum">     526 </span>            :     }
<span class="lineNum">     527 </span>            :     SkPoint choppedPts[7];
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     SkChopCubicAtHalf(p, choppedPts);</span>
<span class="lineNum">     529 </span>            :     convert_noninflect_cubic_to_quads(choppedPts + 0,
<span class="lineNum">     530 </span>            :                                       toleranceSqd,
<span class="lineNum">     531 </span>            :                                       constrainWithinTangents,
<span class="lineNum">     532 </span>            :                                       dir,
<span class="lineNum">     533 </span>            :                                       quads,
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                                       sublevel + 1);</span>
<span class="lineNum">     535 </span>            :     convert_noninflect_cubic_to_quads(choppedPts + 3,
<span class="lineNum">     536 </span>            :                                       toleranceSqd,
<span class="lineNum">     537 </span>            :                                       constrainWithinTangents,
<span class="lineNum">     538 </span>            :                                       dir,
<span class="lineNum">     539 </span>            :                                       quads,
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                                       sublevel + 1);</span>
<span class="lineNum">     541 </span>            : }
<a name="542"><span class="lineNum">     542 </span>            : }</a>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineNoCov">          0 : void GrPathUtils::convertCubicToQuads(const SkPoint p[4],</span>
<span class="lineNum">     545 </span>            :                                       SkScalar tolScale,
<span class="lineNum">     546 </span>            :                                       SkTArray&lt;SkPoint, true&gt;* quads) {
<span class="lineNum">     547 </span>            :     SkPoint chopped[10];
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     int count = SkChopCubicAtInflections(p, chopped);</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     const SkScalar tolSqd = SkScalarSquare(tolScale);</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         SkPoint* cubic = chopped + 3*i;</span>
<span class="lineNum">     554 </span>            :         // The direction param is ignored if the third param is false.
<span class="lineNum">     555 </span>            :         convert_noninflect_cubic_to_quads(cubic, tolSqd, false,
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                                           SkPathPriv::kCCW_FirstDirection, quads);</span>
<span class="lineNum">     557 </span>            :     }
<a name="558"><span class="lineNum">     558 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineNoCov">          0 : void GrPathUtils::convertCubicToQuadsConstrainToTangents(const SkPoint p[4],</span>
<span class="lineNum">     561 </span>            :                                                          SkScalar tolScale,
<span class="lineNum">     562 </span>            :                                                          SkPathPriv::FirstDirection dir,
<span class="lineNum">     563 </span>            :                                                          SkTArray&lt;SkPoint, true&gt;* quads) {
<span class="lineNum">     564 </span>            :     SkPoint chopped[10];
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     int count = SkChopCubicAtInflections(p, chopped);</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     const SkScalar tolSqd = SkScalarSquare(tolScale);</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         SkPoint* cubic = chopped + 3*i;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         convert_noninflect_cubic_to_quads(cubic, tolSqd, true, dir, quads);</span>
<span class="lineNum">     572 </span>            :     }
<span class="lineNum">     573 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : // Solves linear system to extract klm
<span class="lineNum">     578 </span>            : // P.K = k (similarly for l, m)
<span class="lineNum">     579 </span>            : // Where P is matrix of control points
<span class="lineNum">     580 </span>            : // K is coefficients for the line K
<a name="581"><span class="lineNum">     581 </span>            : // k is vector of values of K evaluated at the control points</a>
<span class="lineNum">     582 </span>            : // Solving for K, thus K = P^(-1) . k
<span class="lineNum">     583 </span><span class="lineNoCov">          0 : static void calc_cubic_klm(const SkPoint p[4], const SkScalar controlK[4],</span>
<span class="lineNum">     584 </span>            :                            const SkScalar controlL[4], const SkScalar controlM[4],
<span class="lineNum">     585 </span>            :                            SkScalar k[3], SkScalar l[3], SkScalar m[3]) {
<span class="lineNum">     586 </span>            :     SkMatrix matrix;
<span class="lineNum">     587 </span>            :     matrix.setAll(p[0].fX, p[0].fY, 1.f,
<span class="lineNum">     588 </span>            :                   p[1].fX, p[1].fY, 1.f,
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                   p[2].fX, p[2].fY, 1.f);</span>
<span class="lineNum">     590 </span>            :     SkMatrix inverse;
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     if (matrix.invert(&amp;inverse)) {</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :        inverse.mapHomogeneousPoints(k, controlK, 1);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :        inverse.mapHomogeneousPoints(l, controlL, 1);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :        inverse.mapHomogeneousPoints(m, controlM, 1);</span>
<span class="lineNum">     595 </span>            :     }
<span class="lineNum">     596 </span>            : 
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : static void set_serp_klm(const SkScalar d[3], SkScalar k[4], SkScalar l[4], SkScalar m[4]) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     SkScalar tempSqrt = SkScalarSqrt(9.f * d[1] * d[1] - 12.f * d[0] * d[2]);</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     SkScalar ls = 3.f * d[1] - tempSqrt;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     SkScalar lt = 6.f * d[0];</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     SkScalar ms = 3.f * d[1] + tempSqrt;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     SkScalar mt = 6.f * d[0];</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     k[0] = ls * ms;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     k[1] = (3.f * ls * ms - ls * mt - lt * ms) / 3.f;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     k[2] = (lt * (mt - 2.f * ms) + ls * (3.f * ms - 2.f * mt)) / 3.f;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     k[3] = (lt - ls) * (mt - ms);</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     l[0] = ls * ls * ls;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     const SkScalar lt_ls = lt - ls;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     l[1] = ls * ls * lt_ls * -1.f;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     l[2] = lt_ls * lt_ls * ls;</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     l[3] = -1.f * lt_ls * lt_ls * lt_ls;</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     m[0] = ms * ms * ms;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     const SkScalar mt_ms = mt - ms;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     m[1] = ms * ms * mt_ms * -1.f;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     m[2] = mt_ms * mt_ms * ms;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     m[3] = -1.f * mt_ms * mt_ms * mt_ms;</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :     // If d0 &lt; 0 we need to flip the orientation of our curve
<span class="lineNum">     624 </span>            :     // This is done by negating the k and l values
<span class="lineNum">     625 </span>            :     // We want negative distance values to be on the inside
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     if ( d[0] &gt; 0) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 4; ++i) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :             k[i] = -k[i];</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :             l[i] = -l[i];</span>
<span class="lineNum">     630 </span>            :         }
<span class="lineNum">     631 </span>            :     }
<a name="632"><span class="lineNum">     632 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 : static void set_loop_klm(const SkScalar d[3], SkScalar k[4], SkScalar l[4], SkScalar m[4]) {</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     SkScalar tempSqrt = SkScalarSqrt(4.f * d[0] * d[2] - 3.f * d[1] * d[1]);</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     SkScalar ls = d[1] - tempSqrt;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     SkScalar lt = 2.f * d[0];</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     SkScalar ms = d[1] + tempSqrt;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     SkScalar mt = 2.f * d[0];</span>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     k[0] = ls * ms;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     k[1] = (3.f * ls*ms - ls * mt - lt * ms) / 3.f;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     k[2] = (lt * (mt - 2.f * ms) + ls * (3.f * ms - 2.f * mt)) / 3.f;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     k[3] = (lt - ls) * (mt - ms);</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     l[0] = ls * ls * ms;</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     l[1] = (ls * (ls * (mt - 3.f * ms) + 2.f * lt * ms))/-3.f;</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     l[2] = ((lt - ls) * (ls * (2.f * mt - 3.f * ms) + lt * ms))/3.f;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     l[3] = -1.f * (lt - ls) * (lt - ls) * (mt - ms);</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     m[0] = ls * ms * ms;</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     m[1] = (ms * (ls * (2.f * mt - 3.f * ms) + lt * ms))/-3.f;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     m[2] = ((mt - ms) * (ls * (mt - 3.f * ms) + 2.f * lt * ms))/3.f;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     m[3] = -1.f * (lt - ls) * (mt - ms) * (mt - ms);</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :     // If (d0 &lt; 0 &amp;&amp; sign(k1) &gt; 0) || (d0 &gt; 0 &amp;&amp; sign(k1) &lt; 0),
<span class="lineNum">     658 </span>            :     // we need to flip the orientation of our curve.
<span class="lineNum">     659 </span>            :     // This is done by negating the k and l values
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     if ( (d[0] &lt; 0 &amp;&amp; k[1] &gt; 0) || (d[0] &gt; 0 &amp;&amp; k[1] &lt; 0)) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 4; ++i) {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :             k[i] = -k[i];</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :             l[i] = -l[i];</span>
<span class="lineNum">     664 </span>            :         }
<span class="lineNum">     665 </span>            :     }
<a name="666"><span class="lineNum">     666 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 : static void set_cusp_klm(const SkScalar d[3], SkScalar k[4], SkScalar l[4], SkScalar m[4]) {</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     const SkScalar ls = d[2];</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     const SkScalar lt = 3.f * d[1];</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     k[0] = ls;</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     k[1] = ls - lt / 3.f;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     k[2] = ls - 2.f * lt / 3.f;</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     k[3] = ls - lt;</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     l[0] = ls * ls * ls;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     const SkScalar ls_lt = ls - lt;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     l[1] = ls * ls * ls_lt;</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     l[2] = ls_lt * ls_lt * ls;</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     l[3] = ls_lt * ls_lt * ls_lt;</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     m[0] = 1.f;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     m[1] = 1.f;</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     m[2] = 1.f;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     m[3] = 1.f;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            : // For the case when a cubic is actually a quadratic
<span class="lineNum">     690 </span>            : // M =
<span class="lineNum">     691 </span>            : // 0     0     0
<span class="lineNum">     692 </span>            : // 1/3   0     1/3
<a name="693"><span class="lineNum">     693 </span>            : // 2/3   1/3   2/3</a>
<span class="lineNum">     694 </span>            : // 1     1     1
<span class="lineNum">     695 </span><span class="lineNoCov">          0 : static void set_quadratic_klm(const SkScalar d[3], SkScalar k[4], SkScalar l[4], SkScalar m[4]) {</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     k[0] = 0.f;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     k[1] = 1.f/3.f;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     k[2] = 2.f/3.f;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     k[3] = 1.f;</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     l[0] = 0.f;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     l[1] = 0.f;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     l[2] = 1.f/3.f;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     l[3] = 1.f;</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     m[0] = 0.f;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     m[1] = 1.f/3.f;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     m[2] = 2.f/3.f;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     m[3] = 1.f;</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :     // If d2 &lt; 0 we need to flip the orientation of our curve
<span class="lineNum">     712 </span>            :     // This is done by negating the k and l values
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     if ( d[2] &gt; 0) {</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 4; ++i) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :             k[i] = -k[i];</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :             l[i] = -l[i];</span>
<span class="lineNum">     717 </span>            :         }
<span class="lineNum">     718 </span>            :     }
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineNoCov">          0 : int GrPathUtils::chopCubicAtLoopIntersection(const SkPoint src[4], SkPoint dst[10], SkScalar klm[9],</span>
<span class="lineNum">     722 </span>            :                                              SkScalar klm_rev[3]) {
<span class="lineNum">     723 </span>            :     // Variable to store the two parametric values at the loop double point
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     SkScalar smallS = 0.f;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     SkScalar largeS = 0.f;</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     SkScalar d[3];
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     SkCubicType cType = SkClassifyCubic(src, d);</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     int chop_count = 0;</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     if (kLoop_SkCubicType == cType) {</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         SkScalar tempSqrt = SkScalarSqrt(4.f * d[0] * d[2] - 3.f * d[1] * d[1]);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         SkScalar ls = d[1] - tempSqrt;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         SkScalar lt = 2.f * d[0];</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :         SkScalar ms = d[1] + tempSqrt;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :         SkScalar mt = 2.f * d[0];</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         ls = ls / lt;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         ms = ms / mt;</span>
<span class="lineNum">     739 </span>            :         // need to have t values sorted since this is what is expected by SkChopCubicAt
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         if (ls &lt;= ms) {</span>
<span class="lineNum">     741 </span>            :             smallS = ls;
<span class="lineNum">     742 </span>            :             largeS = ms;
<span class="lineNum">     743 </span>            :         } else {
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :             smallS = ms;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :             largeS = ls;</span>
<span class="lineNum">     746 </span>            :         }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            :         SkScalar chop_ts[2];
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         if (smallS &gt; 0.f &amp;&amp; smallS &lt; 1.f) {</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :             chop_ts[chop_count++] = smallS;</span>
<span class="lineNum">     751 </span>            :         }
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         if (largeS &gt; 0.f &amp;&amp; largeS &lt; 1.f) {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :             chop_ts[chop_count++] = largeS;</span>
<span class="lineNum">     754 </span>            :         }
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         if(dst) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :             SkChopCubicAt(src, dst, chop_ts, chop_count);</span>
<span class="lineNum">     757 </span>            :         }
<span class="lineNum">     758 </span>            :     } else {
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         if (dst) {</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :             memcpy(dst, src, sizeof(SkPoint) * 4);</span>
<span class="lineNum">     761 </span>            :         }
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     if (klm &amp;&amp; klm_rev) {</span>
<span class="lineNum">     765 </span>            :         // Set klm_rev to to match the sub_section of cubic that needs to have its orientation
<span class="lineNum">     766 </span>            :         // flipped. This will always be the section that is the &quot;loop&quot;
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         if (2 == chop_count) {</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :             klm_rev[0] = 1.f;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :             klm_rev[1] = -1.f;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :             klm_rev[2] = 1.f;</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         } else if (1 == chop_count) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :             if (smallS &lt; 0.f) {</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 klm_rev[0] = -1.f;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :                 klm_rev[1] = 1.f;</span>
<span class="lineNum">     775 </span>            :             } else {
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :                 klm_rev[0] = 1.f;</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                 klm_rev[1] = -1.f;</span>
<span class="lineNum">     778 </span>            :             }
<span class="lineNum">     779 </span>            :         } else {
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :             if (smallS &lt; 0.f &amp;&amp; largeS &gt; 1.f) {</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :                 klm_rev[0] = -1.f;</span>
<span class="lineNum">     782 </span>            :             } else {
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :                 klm_rev[0] = 1.f;</span>
<span class="lineNum">     784 </span>            :             }
<span class="lineNum">     785 </span>            :         }
<span class="lineNum">     786 </span>            :         SkScalar controlK[4];
<span class="lineNum">     787 </span>            :         SkScalar controlL[4];
<span class="lineNum">     788 </span>            :         SkScalar controlM[4];
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         if (kSerpentine_SkCubicType == cType || (kCusp_SkCubicType == cType &amp;&amp; 0.f != d[0])) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :             set_serp_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         } else if (kLoop_SkCubicType == cType) {</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :             set_loop_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         } else if (kCusp_SkCubicType == cType) {</span>
<span class="lineNum">     795 </span>            :             SkASSERT(0.f == d[0]);
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :             set_cusp_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         } else if (kQuadratic_SkCubicType == cType) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             set_quadratic_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     799 </span>            :         }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         calc_cubic_klm(src, controlK, controlL, controlM, klm, &amp;klm[3], &amp;klm[6]);</span>
<span class="lineNum">     802 </span>            :     }
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     return chop_count + 1;</span>
<a name="804"><span class="lineNum">     804 </span>            : }</a>
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineNoCov">          0 : void GrPathUtils::getCubicKLM(const SkPoint p[4], SkScalar klm[9]) {</span>
<span class="lineNum">     807 </span>            :     SkScalar d[3];
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     SkCubicType cType = SkClassifyCubic(p, d);</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :     SkScalar controlK[4];
<span class="lineNum">     811 </span>            :     SkScalar controlL[4];
<span class="lineNum">     812 </span>            :     SkScalar controlM[4];
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     if (kSerpentine_SkCubicType == cType || (kCusp_SkCubicType == cType &amp;&amp; 0.f != d[0])) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         set_serp_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     } else if (kLoop_SkCubicType == cType) {</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         set_loop_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     } else if (kCusp_SkCubicType == cType) {</span>
<span class="lineNum">     819 </span>            :         SkASSERT(0.f == d[0]);
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         set_cusp_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     } else if (kQuadratic_SkCubicType == cType) {</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         set_quadratic_klm(d, controlK, controlL, controlM);</span>
<span class="lineNum">     823 </span>            :     }
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     calc_cubic_klm(p, controlK, controlL, controlM, klm, &amp;klm[3], &amp;klm[6]);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
