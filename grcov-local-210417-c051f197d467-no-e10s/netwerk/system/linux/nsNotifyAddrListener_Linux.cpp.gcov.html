<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - netwerk/system/linux/nsNotifyAddrListener_Linux.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">netwerk/system/linux</a> - nsNotifyAddrListener_Linux.cpp<span style="font-size: 80%;"> (source / <a href="nsNotifyAddrListener_Linux.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">109</td>
            <td class="headerCovTableEntry">227</td>
            <td class="headerCovTableEntryLo">48.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntryLo">47.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim:set et sw=4 ts=4: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">       8 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">       9 </span>            : #include &lt;poll.h&gt;
<span class="lineNum">      10 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      11 </span>            : #ifndef MOZ_WIDGET_GONK
<span class="lineNum">      12 </span>            : #include &lt;ifaddrs.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;net/if.h&gt;
<span class="lineNum">      14 </span>            : #endif
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;nsThreadUtils.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsIObserverService.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsServiceManagerUtils.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsNotifyAddrListener_Linux.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/Logging.h&quot;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &quot;mozilla/Base64.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mozilla/FileUtils.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/Services.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;mozilla/SHA1.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;mozilla/Sprintf.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #ifdef MOZ_WIDGET_GONK
<span class="lineNum">      32 </span>            : #include &lt;cutils/properties.h&gt;
<span class="lineNum">      33 </span>            : #endif
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /* a shorter name that better explains what it does */
<span class="lineNum">      36 </span>            : #define EINTR_RETRY(x) MOZ_TEMP_FAILURE_RETRY(x)
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : // period during which to absorb subsequent network change events, in
<span class="lineNum">      39 </span>            : // milliseconds
<span class="lineNum">      40 </span>            : static const unsigned int kNetworkChangeCoalescingPeriod  = 1000;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : using namespace mozilla;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : static LazyLogModule gNotifyAddrLog(&quot;nsNotifyAddr&quot;);
<span class="lineNum">      45 </span>            : #define LOG(args) MOZ_LOG(gNotifyAddrLog, mozilla::LogLevel::Debug, args)
<span class="lineNum">      46 </span>            : 
<a name="47"><span class="lineNum">      47 </span>            : #define NETWORK_NOTIFY_CHANGED_PREF &quot;network.notify.changed&quot;</a>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span><span class="lineCov">          1 : NS_IMPL_ISUPPORTS(nsNotifyAddrListener,</span>
<span class="lineNum">      50 </span>            :                   nsINetworkLinkService,
<span class="lineNum">      51 </span>            :                   nsIRunnable,
<a name="52"><span class="lineNum">      52 </span>            :                   nsIObserver)</a>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span><span class="lineCov">          1 : nsNotifyAddrListener::nsNotifyAddrListener()</span>
<span class="lineNum">      55 </span>            :     : mLinkUp(true)  // assume true by default
<span class="lineNum">      56 </span>            :     , mStatusKnown(false)
<span class="lineNum">      57 </span>            :     , mAllowChangedEvent(true)
<span class="lineNum">      58 </span><span class="lineCov">          1 :     , mCoalescingActive(false)</span>
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span><span class="lineCov">          1 :     mShutdownPipe[0] = -1;</span>
<span class="lineNum">      61 </span><span class="lineCov">          1 :     mShutdownPipe[1] = -1;</span>
<a name="62"><span class="lineNum">      62 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::~nsNotifyAddrListener()</span>
<span class="lineNum">      65 </span>            : {
<span class="lineNum">      66 </span>            :     MOZ_ASSERT(!mThread, &quot;nsNotifyAddrListener thread shutdown failed&quot;);
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     if (mShutdownPipe[0] != -1) {</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :         EINTR_RETRY(close(mShutdownPipe[0]));</span>
<span class="lineNum">      70 </span>            :     }
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     if (mShutdownPipe[1] != -1) {</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :         EINTR_RETRY(close(mShutdownPipe[1]));</span>
<span class="lineNum">      73 </span>            :     }
<span class="lineNum">      74 </span><span class="lineNoCov">          0 : }</span>
<a name="75"><span class="lineNum">      75 </span>            : </a>
<span class="lineNum">      76 </span>            : NS_IMETHODIMP
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::GetIsLinkUp(bool *aIsUp)</span>
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span>            :     // XXX This function has not yet been implemented for this platform
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     *aIsUp = mLinkUp;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">      82 </span>            : }
<a name="83"><span class="lineNum">      83 </span>            : </a>
<span class="lineNum">      84 </span>            : NS_IMETHODIMP
<span class="lineNum">      85 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::GetLinkStatusKnown(bool *aIsUp)</span>
<span class="lineNum">      86 </span>            : {
<span class="lineNum">      87 </span>            :     // XXX This function has not yet been implemented for this platform
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     *aIsUp = mStatusKnown;</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">      90 </span>            : }
<a name="91"><span class="lineNum">      91 </span>            : </a>
<span class="lineNum">      92 </span>            : NS_IMETHODIMP
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::GetLinkType(uint32_t *aLinkType)</span>
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG_POINTER(aLinkType);</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   // XXX This function has not yet been implemented for this platform
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   *aLinkType = nsINetworkLinkService::LINK_TYPE_UNKNOWN;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     100 </span>            : }
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : //
<span class="lineNum">     103 </span>            : // Figure out the current &quot;network identification&quot; string.
<span class="lineNum">     104 </span>            : //
<span class="lineNum">     105 </span>            : // It detects the IP of the default gateway in the routing table, then the MAC
<span class="lineNum">     106 </span>            : // address of that IP in the ARP table before it hashes that string (to avoid
<a name="107"><span class="lineNum">     107 </span>            : // information leakage).</a>
<span class="lineNum">     108 </span>            : //
<span class="lineNum">     109 </span><span class="lineCov">          1 : void nsNotifyAddrListener::calculateNetworkId(void)</span>
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span><span class="lineCov">          1 :     const char *kProcRoute = &quot;/proc/net/route&quot;; /* IPv4 routes */</span>
<span class="lineNum">     112 </span><span class="lineCov">          1 :     const char *kProcArp = &quot;/proc/net/arp&quot;;</span>
<span class="lineNum">     113 </span><span class="lineCov">          1 :     bool found = false;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineCov">          1 :     FILE *froute = fopen(kProcRoute, &quot;r&quot;);</span>
<span class="lineNum">     116 </span><span class="lineCov">          1 :     if (froute) {</span>
<span class="lineNum">     117 </span>            :         char buffer[512];
<span class="lineNum">     118 </span><span class="lineCov">          1 :         uint32_t gw = 0;</span>
<span class="lineNum">     119 </span><span class="lineCov">          1 :         char *l = fgets(buffer, sizeof(buffer), froute);</span>
<span class="lineNum">     120 </span><span class="lineCov">          1 :         if (l) {</span>
<span class="lineNum">     121 </span>            :             /* skip the title line  */
<span class="lineNum">     122 </span><span class="lineCov">          1 :             while (l) {</span>
<span class="lineNum">     123 </span>            :                 char interf[32];
<span class="lineNum">     124 </span>            :                 uint32_t dest;
<span class="lineNum">     125 </span>            :                 uint32_t gateway;
<span class="lineNum">     126 </span><span class="lineCov">          1 :                 l = fgets(buffer, sizeof(buffer), froute);</span>
<span class="lineNum">     127 </span><span class="lineCov">          1 :                 if (l) {</span>
<span class="lineNum">     128 </span><span class="lineCov">          1 :                     buffer[511]=0; /* as a precaution */</span>
<span class="lineNum">     129 </span>            :                     int val = sscanf(buffer, &quot;%31s %x %x&quot;,
<span class="lineNum">     130 </span><span class="lineCov">          1 :                                      interf, &amp;dest, &amp;gateway);</span>
<span class="lineNum">     131 </span><span class="lineCov">          1 :                     if ((3 == val) &amp;&amp; !dest) {</span>
<span class="lineNum">     132 </span><span class="lineCov">          1 :                         gw = gateway;</span>
<span class="lineNum">     133 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">     134 </span>            :                     }
<span class="lineNum">     135 </span>            :                 }
<span class="lineNum">     136 </span>            :             }
<span class="lineNum">     137 </span>            :         }
<span class="lineNum">     138 </span><span class="lineCov">          1 :         fclose(froute);</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">          1 :         if (gw) {</span>
<span class="lineNum">     141 </span>            :             /* create a string to search for in the arp table */
<span class="lineNum">     142 </span>            :             char searchfor[16];
<span class="lineNum">     143 </span>            :             SprintfLiteral(searchfor, &quot;%d.%d.%d.%d&quot;,
<span class="lineNum">     144 </span>            :                            gw &amp; 0xff,
<span class="lineNum">     145 </span><span class="lineCov">          1 :                            (gw &gt;&gt; 8) &amp; 0xff,</span>
<span class="lineNum">     146 </span><span class="lineCov">          1 :                            (gw &gt;&gt; 16) &amp; 0xff,</span>
<span class="lineNum">     147 </span><span class="lineCov">          1 :                            gw &gt;&gt; 24);</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineCov">          1 :             FILE *farp = fopen(kProcArp, &quot;r&quot;);</span>
<span class="lineNum">     150 </span><span class="lineCov">          1 :             if (farp) {</span>
<span class="lineNum">     151 </span><span class="lineCov">          1 :                 l = fgets(buffer, sizeof(buffer), farp);</span>
<span class="lineNum">     152 </span><span class="lineCov">          1 :                 while (l) {</span>
<span class="lineNum">     153 </span>            :                     /* skip the title line  */
<span class="lineNum">     154 </span><span class="lineCov">          1 :                     l = fgets(buffer, sizeof(buffer), farp);</span>
<span class="lineNum">     155 </span><span class="lineCov">          1 :                     if (l) {</span>
<span class="lineNum">     156 </span><span class="lineCov">          1 :                         buffer[511]=0; /* as a precaution */</span>
<span class="lineNum">     157 </span>            :                         int p[4];
<span class="lineNum">     158 </span>            :                         char type[16];
<span class="lineNum">     159 </span>            :                         char flags[16];
<span class="lineNum">     160 </span>            :                         char hw[32];
<span class="lineNum">     161 </span><span class="lineCov">          1 :                         if (7 == sscanf(buffer, &quot;%u.%u.%u.%u %15s %15s %31s&quot;,</span>
<span class="lineNum">     162 </span>            :                                         &amp;p[0], &amp;p[1], &amp;p[2], &amp;p[3],
<span class="lineNum">     163 </span><span class="lineCov">          1 :                                         type, flags, hw)) {</span>
<span class="lineNum">     164 </span><span class="lineCov">          1 :                             uint32_t searchip = p[0] | (p[1] &lt;&lt; 8) |</span>
<span class="lineNum">     165 </span><span class="lineCov">          1 :                                 (p[2] &lt;&lt; 16) | (p[3] &lt;&lt; 24);</span>
<span class="lineNum">     166 </span><span class="lineCov">          1 :                             if (gw == searchip) {</span>
<span class="lineNum">     167 </span><span class="lineCov">          1 :                                 LOG((&quot;networkid: MAC %s\n&quot;, hw));</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :                                 nsAutoCString mac(hw);</span>
<span class="lineNum">     169 </span>            :                                 // This 'addition' could potentially be a
<span class="lineNum">     170 </span>            :                                 // fixed number from the profile or something.
<span class="lineNum">     171 </span><span class="lineCov">          1 :                                 nsAutoCString addition(&quot;local-rubbish&quot;);</span>
<span class="lineNum">     172 </span><span class="lineCov">          1 :                                 nsAutoCString output;</span>
<span class="lineNum">     173 </span><span class="lineCov">          1 :                                 SHA1Sum sha1;</span>
<span class="lineNum">     174 </span><span class="lineCov">          1 :                                 nsCString combined(mac + addition);</span>
<span class="lineNum">     175 </span><span class="lineCov">          1 :                                 sha1.update(combined.get(), combined.Length());</span>
<span class="lineNum">     176 </span>            :                                 uint8_t digest[SHA1Sum::kHashSize];
<span class="lineNum">     177 </span><span class="lineCov">          1 :                                 sha1.finish(digest);</span>
<span class="lineNum">     178 </span>            :                                 nsCString newString(reinterpret_cast&lt;char*&gt;(digest),
<span class="lineNum">     179 </span><span class="lineCov">          1 :                                                     SHA1Sum::kHashSize);</span>
<span class="lineNum">     180 </span><span class="lineCov">          1 :                                 nsresult rv = Base64Encode(newString, output);</span>
<span class="lineNum">     181 </span><span class="lineCov">          1 :                                 MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">     182 </span><span class="lineCov">          1 :                                 LOG((&quot;networkid: id %s\n&quot;, output.get()));</span>
<span class="lineNum">     183 </span><span class="lineCov">          1 :                                 if (mNetworkId != output) {</span>
<span class="lineNum">     184 </span>            :                                     // new id
<span class="lineNum">     185 </span><span class="lineCov">          1 :                                     Telemetry::Accumulate(Telemetry::NETWORK_ID, 1);</span>
<span class="lineNum">     186 </span><span class="lineCov">          1 :                                     mNetworkId = output;</span>
<span class="lineNum">     187 </span>            :                                 }
<span class="lineNum">     188 </span>            :                                 else {
<span class="lineNum">     189 </span>            :                                     // same id
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :                                     Telemetry::Accumulate(Telemetry::NETWORK_ID, 2);</span>
<span class="lineNum">     191 </span>            :                                 }
<span class="lineNum">     192 </span><span class="lineCov">          1 :                                 found = true;</span>
<span class="lineNum">     193 </span>            :                                 break;
<span class="lineNum">     194 </span>            :                             }
<span class="lineNum">     195 </span>            :                         }
<span class="lineNum">     196 </span>            :                     }
<span class="lineNum">     197 </span>            :                 }
<span class="lineNum">     198 </span><span class="lineCov">          1 :                 fclose(farp);</span>
<span class="lineNum">     199 </span>            :             } /* if (farp) */
<span class="lineNum">     200 </span>            :         } /* if (gw) */
<span class="lineNum">     201 </span>            :     } /* if (froute) */
<span class="lineNum">     202 </span><span class="lineCov">          1 :     if (!found) {</span>
<span class="lineNum">     203 </span>            :         // no id
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::NETWORK_ID, 0);</span>
<span class="lineNum">     205 </span>            :     }
<span class="lineNum">     206 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : //
<a name="209"><span class="lineNum">     209 </span>            : // Check if there's a network interface available to do networking on.</a>
<span class="lineNum">     210 </span>            : //
<span class="lineNum">     211 </span><span class="lineNoCov">          0 : void nsNotifyAddrListener::checkLink(void)</span>
<span class="lineNum">     212 </span>            : {
<span class="lineNum">     213 </span>            : #ifdef MOZ_WIDGET_GONK
<span class="lineNum">     214 </span>            :     // b2g instead has NetworkManager.js which handles UP/DOWN
<span class="lineNum">     215 </span>            : #else
<span class="lineNum">     216 </span>            :     struct ifaddrs *list;
<span class="lineNum">     217 </span>            :     struct ifaddrs *ifa;
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     bool link = false;</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     bool prevLinkUp = mLinkUp;</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (getifaddrs(&amp;list))</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :     // Walk through the linked list, maintaining head pointer so we can free
<span class="lineNum">     225 </span>            :     // list later
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     for (ifa = list; ifa != NULL; ifa = ifa-&gt;ifa_next) {</span>
<span class="lineNum">     228 </span>            :         int family;
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         if (ifa-&gt;ifa_addr == NULL)</span>
<span class="lineNum">     230 </span>            :             continue;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         family = ifa-&gt;ifa_addr-&gt;sa_family;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         if ((family == AF_INET || family == AF_INET6) &amp;&amp;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :             (ifa-&gt;ifa_flags &amp; IFF_RUNNING) &amp;&amp;</span>
<span class="lineNum">     236 </span>            :             !(ifa-&gt;ifa_flags &amp; IFF_LOOPBACK)) {
<span class="lineNum">     237 </span>            :             // An interface that is UP and not loopback
<span class="lineNum">     238 </span>            :             link = true;
<span class="lineNum">     239 </span>            :             break;
<span class="lineNum">     240 </span>            :         }
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     mLinkUp = link;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     freeifaddrs(list);</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (prevLinkUp != mLinkUp) {</span>
<span class="lineNum">     246 </span>            :         // UP/DOWN status changed, send appropriate UP/DOWN event
<span class="lineNum">     247 </span>            :         SendEvent(mLinkUp ?
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                   NS_NETWORK_LINK_DATA_UP : NS_NETWORK_LINK_DATA_DOWN);</span>
<span class="lineNum">     249 </span>            :     }
<span class="lineNum">     250 </span>            : #endif
<a name="251"><span class="lineNum">     251 </span>            : }</a>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 : void nsNotifyAddrListener::OnNetlinkMessage(int aNetlinkSocket)</span>
<span class="lineNum">     254 </span>            : {
<span class="lineNum">     255 </span>            :     struct  nlmsghdr *nlh;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :     // The buffer size below, (4095) was chosen partly based on testing and
<span class="lineNum">     258 </span>            :     // partly on existing sample source code using this size. It needs to be
<span class="lineNum">     259 </span>            :     // large enough to hold the netlink messages from the kernel.
<span class="lineNum">     260 </span>            :     char buffer[4095];
<span class="lineNum">     261 </span>            :     struct rtattr *attr;
<span class="lineNum">     262 </span>            :     int attr_len;
<span class="lineNum">     263 </span>            :     const struct ifaddrmsg* newifam;
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     ssize_t rc = EINTR_RETRY(recv(aNetlinkSocket, buffer, sizeof(buffer), 0));</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     if (rc &lt; 0) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     269 </span>            :     }
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     size_t netlink_bytes = rc;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     nlh = reinterpret_cast&lt;struct nlmsghdr *&gt;(buffer);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     bool networkChange = false;</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     for (; NLMSG_OK(nlh, netlink_bytes);</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :          nlh = NLMSG_NEXT(nlh, netlink_bytes)) {</span>
<span class="lineNum">     278 </span>            :         char prefixaddr[INET6_ADDRSTRLEN];
<span class="lineNum">     279 </span>            :         char localaddr[INET6_ADDRSTRLEN];
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         char* addr = nullptr;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         prefixaddr[0] = localaddr[0] = '\0';</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         if (NLMSG_DONE == nlh-&gt;nlmsg_type) {</span>
<span class="lineNum">     284 </span>            :             break;
<span class="lineNum">     285 </span>            :         }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         LOG((&quot;nsNotifyAddrListener::OnNetlinkMessage: new/deleted address\n&quot;));</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         newifam = reinterpret_cast&lt;struct ifaddrmsg*&gt;(NLMSG_DATA(nlh));</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         if ((newifam-&gt;ifa_family != AF_INET) &amp;&amp;</span>
<span class="lineNum">     291 </span>            :             (newifam-&gt;ifa_family != AF_INET6)) {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     293 </span>            :         }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         attr = IFA_RTA (newifam);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         attr_len = IFA_PAYLOAD (nlh);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         for (;attr_len &amp;&amp; RTA_OK (attr, attr_len);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :              attr = RTA_NEXT (attr, attr_len)) {</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :             if (attr-&gt;rta_type == IFA_ADDRESS) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                 if (newifam-&gt;ifa_family == AF_INET) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :                     struct in_addr* in = (struct in_addr*)RTA_DATA(attr);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :                     inet_ntop(AF_INET, in, prefixaddr, INET_ADDRSTRLEN);</span>
<span class="lineNum">     303 </span>            :                 } else {
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :                     struct in6_addr* in = (struct in6_addr*)RTA_DATA(attr);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                     inet_ntop(AF_INET6, in, prefixaddr, INET6_ADDRSTRLEN);</span>
<span class="lineNum">     306 </span>            :                 }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :             } else if (attr-&gt;rta_type == IFA_LOCAL) {</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                 if (newifam-&gt;ifa_family == AF_INET) {</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                     struct in_addr* in = (struct in_addr*)RTA_DATA(attr);</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :                     inet_ntop(AF_INET, in, localaddr, INET_ADDRSTRLEN);</span>
<span class="lineNum">     311 </span>            :                 } else {
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                     struct in6_addr* in = (struct in6_addr*)RTA_DATA(attr);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                     inet_ntop(AF_INET6, in, localaddr, INET6_ADDRSTRLEN);</span>
<span class="lineNum">     314 </span>            :                 }
<span class="lineNum">     315 </span>            :             }
<span class="lineNum">     316 </span>            :         }
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         if (localaddr[0]) {</span>
<span class="lineNum">     318 </span>            :             addr = localaddr;
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         } else if (prefixaddr[0]) {</span>
<span class="lineNum">     320 </span>            :             addr = prefixaddr;
<span class="lineNum">     321 </span>            :         } else {
<span class="lineNum">     322 </span>            :             continue;
<span class="lineNum">     323 </span>            :         }
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         if (nlh-&gt;nlmsg_type == RTM_NEWADDR) {</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :             LOG((&quot;nsNotifyAddrListener::OnNetlinkMessage: a new address &quot;</span>
<span class="lineNum">     326 </span>            :                  &quot;- %s.&quot;, addr));
<span class="lineNum">     327 </span>            :             struct ifaddrmsg* ifam;
<span class="lineNum">     328 </span>            :             nsCString addrStr;
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :             addrStr.Assign(addr);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             if (mAddressInfo.Get(addrStr, &amp;ifam)) {</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                 LOG((&quot;nsNotifyAddrListener::OnNetlinkMessage: the address &quot;</span>
<span class="lineNum">     332 </span>            :                      &quot;already known.&quot;));
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                 if (memcmp(ifam, newifam, sizeof(struct ifaddrmsg))) {</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                     LOG((&quot;nsNotifyAddrListener::OnNetlinkMessage: but &quot;</span>
<span class="lineNum">     335 </span>            :                          &quot;the address info has been changed.&quot;));
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                     networkChange = true;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :                     memcpy(ifam, newifam, sizeof(struct ifaddrmsg));</span>
<span class="lineNum">     338 </span>            :                 }
<span class="lineNum">     339 </span>            :             } else {
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                 networkChange = true;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                 ifam = (struct ifaddrmsg*)malloc(sizeof(struct ifaddrmsg));</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                 memcpy(ifam, newifam, sizeof(struct ifaddrmsg));</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                 mAddressInfo.Put(addrStr,ifam);</span>
<span class="lineNum">     344 </span>            :             }
<span class="lineNum">     345 </span>            :         } else {
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             LOG((&quot;nsNotifyAddrListener::OnNetlinkMessage: an address &quot;</span>
<span class="lineNum">     347 </span>            :                  &quot;has been deleted - %s.&quot;, addr));
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :             networkChange = true;</span>
<span class="lineNum">     349 </span>            :             nsCString addrStr;
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :             addrStr.Assign(addr);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :             mAddressInfo.Remove(addrStr);</span>
<span class="lineNum">     352 </span>            :         }
<span class="lineNum">     353 </span>            :     }
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     if (networkChange &amp;&amp; mAllowChangedEvent) {</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         NetworkChanged();</span>
<span class="lineNum">     357 </span>            :     }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if (networkChange) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         checkLink();</span>
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span>            : }
<a name="363"><span class="lineNum">     363 </span>            : </a>
<span class="lineNum">     364 </span>            : NS_IMETHODIMP
<span class="lineNum">     365 </span><span class="lineCov">          1 : nsNotifyAddrListener::Run()</span>
<span class="lineNum">     366 </span>            : {
<span class="lineNum">     367 </span><span class="lineCov">          1 :     int netlinkSocket = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);</span>
<span class="lineNum">     368 </span><span class="lineCov">          1 :     if (netlinkSocket &lt; 0) {</span>
<span class="lineNum">     369 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">     370 </span>            :     }
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     struct sockaddr_nl addr;
<span class="lineNum">     373 </span><span class="lineCov">          1 :     memset(&amp;addr, 0, sizeof(addr));   // clear addr</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineCov">          1 :     addr.nl_family = AF_NETLINK;</span>
<span class="lineNum">     376 </span><span class="lineCov">          1 :     addr.nl_groups = RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR;</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineCov">          1 :     if (bind(netlinkSocket, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {</span>
<span class="lineNum">     379 </span>            :         // failure!
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         EINTR_RETRY(close(netlinkSocket));</span>
<span class="lineNum">     381 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">     382 </span>            :     }
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :     // switch the socket into non-blocking
<span class="lineNum">     385 </span><span class="lineCov">          1 :     int flags = fcntl(netlinkSocket, F_GETFL, 0);</span>
<span class="lineNum">     386 </span><span class="lineCov">          1 :     (void)fcntl(netlinkSocket, F_SETFL, flags | O_NONBLOCK);</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :     struct pollfd fds[2];
<span class="lineNum">     389 </span><span class="lineCov">          1 :     fds[0].fd = mShutdownPipe[0];</span>
<span class="lineNum">     390 </span><span class="lineCov">          1 :     fds[0].events = POLLIN;</span>
<span class="lineNum">     391 </span><span class="lineCov">          1 :     fds[0].revents = 0;</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineCov">          1 :     fds[1].fd = netlinkSocket;</span>
<span class="lineNum">     394 </span><span class="lineCov">          1 :     fds[1].events = POLLIN;</span>
<span class="lineNum">     395 </span><span class="lineCov">          1 :     fds[1].revents = 0;</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineCov">          1 :     calculateNetworkId();</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineCov">          1 :     nsresult rv = NS_OK;</span>
<span class="lineNum">     400 </span><span class="lineCov">          1 :     bool shutdown = false;</span>
<span class="lineNum">     401 </span><span class="lineCov">          1 :     int pollWait = -1;</span>
<span class="lineNum">     402 </span><span class="lineCov">          1 :     while (!shutdown) {</span>
<span class="lineNum">     403 </span><span class="lineCov">          1 :         int rc = EINTR_RETRY(poll(fds, 2, pollWait));</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span><span class="lineCov">          1 :         if (rc &gt; 0) {</span>
<span class="lineNum">     406 </span><span class="lineCov">          1 :             if (fds[0].revents &amp; POLLIN) {</span>
<span class="lineNum">     407 </span>            :                 // shutdown, abort the loop!
<span class="lineNum">     408 </span><span class="lineCov">          1 :                 LOG((&quot;thread shutdown received, dying...\n&quot;));</span>
<span class="lineNum">     409 </span>            :                 shutdown = true;
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :             } else if (fds[1].revents &amp; POLLIN) {</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                 LOG((&quot;netlink message received, handling it...\n&quot;));</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :                 OnNetlinkMessage(netlinkSocket);</span>
<span class="lineNum">     413 </span>            :             }
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         } else if (rc &lt; 0) {</span>
<span class="lineNum">     415 </span>            :             rv = NS_ERROR_FAILURE;
<span class="lineNum">     416 </span>            :             break;
<span class="lineNum">     417 </span>            :         }
<span class="lineNum">     418 </span><span class="lineCov">          1 :         if (mCoalescingActive) {</span>
<span class="lineNum">     419 </span>            :             // check if coalescing period should continue
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :             double period = (TimeStamp::Now() - mChangeTime).ToMilliseconds();</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             if (period &gt;= kNetworkChangeCoalescingPeriod) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                 SendEvent(NS_NETWORK_LINK_DATA_CHANGED);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                 calculateNetworkId();</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                 mCoalescingActive = false;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :                 pollWait = -1; // restore to default</span>
<span class="lineNum">     426 </span>            :             } else {
<span class="lineNum">     427 </span>            :                 // wait no longer than to the end of the period
<span class="lineNum">     428 </span>            :                 pollWait = static_cast&lt;int&gt;
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                     (kNetworkChangeCoalescingPeriod - period);</span>
<span class="lineNum">     430 </span>            :             }
<span class="lineNum">     431 </span>            :         }
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">          1 :     EINTR_RETRY(close(netlinkSocket));</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">          1 :     return rv;</span>
<span class="lineNum">     437 </span>            : }
<a name="438"><span class="lineNum">     438 </span>            : </a>
<span class="lineNum">     439 </span>            : NS_IMETHODIMP
<span class="lineNum">     440 </span><span class="lineCov">          1 : nsNotifyAddrListener::Observe(nsISupports *subject,</span>
<span class="lineNum">     441 </span>            :                               const char *topic,
<span class="lineNum">     442 </span>            :                               const char16_t *data)
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span><span class="lineCov">          1 :     if (!strcmp(&quot;xpcom-shutdown-threads&quot;, topic)) {</span>
<span class="lineNum">     445 </span><span class="lineCov">          1 :         Shutdown();</span>
<span class="lineNum">     446 </span>            :     }
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">     449 </span>            : }
<a name="450"><span class="lineNum">     450 </span>            : </a>
<span class="lineNum">     451 </span>            : nsresult
<span class="lineNum">     452 </span><span class="lineCov">          1 : nsNotifyAddrListener::Init(void)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span>            :     nsCOMPtr&lt;nsIObserverService&gt; observerService =
<span class="lineNum">     455 </span><span class="lineCov">          1 :         mozilla::services::GetObserverService();</span>
<span class="lineNum">     456 </span><span class="lineCov">          1 :     if (!observerService)</span>
<span class="lineNum">     457 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     nsresult rv = observerService-&gt;AddObserver(this, &quot;xpcom-shutdown-threads&quot;,
<span class="lineNum">     460 </span><span class="lineCov">          1 :                                                false);</span>
<span class="lineNum">     461 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :     Preferences::AddBoolVarCache(&amp;mAllowChangedEvent,
<span class="lineNum">     464 </span><span class="lineCov">          1 :                                  NETWORK_NOTIFY_CHANGED_PREF, true);</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineCov">          1 :     if (-1 == pipe(mShutdownPipe)) {</span>
<span class="lineNum">     467 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">     468 </span>            :     }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">          1 :     rv = NS_NewNamedThread(&quot;Link Monitor&quot;, getter_AddRefs(mThread), this);</span>
<span class="lineNum">     471 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :     return NS_OK;
<span class="lineNum">     474 </span>            : }
<a name="475"><span class="lineNum">     475 </span>            : </a>
<span class="lineNum">     476 </span>            : nsresult
<span class="lineNum">     477 </span><span class="lineCov">          1 : nsNotifyAddrListener::Shutdown(void)</span>
<span class="lineNum">     478 </span>            : {
<span class="lineNum">     479 </span>            :     // remove xpcom shutdown observer
<span class="lineNum">     480 </span>            :     nsCOMPtr&lt;nsIObserverService&gt; observerService =
<span class="lineNum">     481 </span><span class="lineCov">          1 :         mozilla::services::GetObserverService();</span>
<span class="lineNum">     482 </span><span class="lineCov">          1 :     if (observerService)</span>
<span class="lineNum">     483 </span><span class="lineCov">          1 :         observerService-&gt;RemoveObserver(this, &quot;xpcom-shutdown-threads&quot;);</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span><span class="lineCov">          1 :     LOG((&quot;write() to signal thread shutdown\n&quot;));</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :     // awake the thread to make it terminate
<span class="lineNum">     488 </span><span class="lineCov">          1 :     ssize_t rc = EINTR_RETRY(write(mShutdownPipe[1], &quot;1&quot;, 1));</span>
<span class="lineNum">     489 </span><span class="lineCov">          1 :     LOG((&quot;write() returned %d, errno == %d\n&quot;, (int)rc, errno));</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">          1 :     nsresult rv = mThread-&gt;Shutdown();</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :     // Have to break the cycle here, otherwise nsNotifyAddrListener holds
<span class="lineNum">     494 </span>            :     // onto the thread and the thread holds onto the nsNotifyAddrListener
<span class="lineNum">     495 </span>            :     // via its mRunnable
<span class="lineNum">     496 </span><span class="lineCov">          1 :     mThread = nullptr;</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineCov">          1 :     return rv;</span>
<span class="lineNum">     499 </span>            : }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : /*
<span class="lineNum">     503 </span>            :  * A network event has been registered. Delay the actual sending of the event
<span class="lineNum">     504 </span>            :  * for a while and absorb subsequent events in the mean time in an effort to
<span class="lineNum">     505 </span>            :  * squash potentially many triggers into a single event.
<span class="lineNum">     506 </span>            :  * Only ever called from the same thread.
<a name="507"><span class="lineNum">     507 </span>            :  */</a>
<span class="lineNum">     508 </span>            : nsresult
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::NetworkChanged()</span>
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     if (mCoalescingActive) {</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         LOG((&quot;NetworkChanged: absorbed an event (coalescing active)\n&quot;));</span>
<span class="lineNum">     513 </span>            :     } else {
<span class="lineNum">     514 </span>            :         // A fresh trigger!
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         mChangeTime = TimeStamp::Now();</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         mCoalescingActive = true;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         LOG((&quot;NetworkChanged: coalescing period started\n&quot;));</span>
<span class="lineNum">     518 </span>            :     }
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     520 </span>            : }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : /* Sends the given event.  Assumes aEventID never goes out of scope (static
<span class="lineNum">     523 </span>            :  * strings are ideal).
<a name="524"><span class="lineNum">     524 </span>            :  */</a>
<span class="lineNum">     525 </span>            : nsresult
<span class="lineNum">     526 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::SendEvent(const char *aEventID)</span>
<span class="lineNum">     527 </span>            : {
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     if (!aEventID)</span>
<span class="lineNum">     529 </span>            :         return NS_ERROR_NULL_POINTER;
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     LOG((&quot;SendEvent: %s\n&quot;, aEventID));</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     nsresult rv = NS_OK;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIRunnable&gt; event = new ChangeEvent(this, aEventID);</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv = NS_DispatchToMainThread(event)))</span>
<span class="lineNum">     535 </span>            :         NS_WARNING(&quot;Failed to dispatch ChangeEvent&quot;);
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     537 </span>            : }
<a name="538"><span class="lineNum">     538 </span>            : </a>
<span class="lineNum">     539 </span>            : NS_IMETHODIMP
<span class="lineNum">     540 </span><span class="lineNoCov">          0 : nsNotifyAddrListener::ChangeEvent::Run()</span>
<span class="lineNum">     541 </span>            : {
<span class="lineNum">     542 </span>            :     nsCOMPtr&lt;nsIObserverService&gt; observerService =
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         mozilla::services::GetObserverService();</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     if (observerService)</span>
<span class="lineNum">     545 </span>            :         observerService-&gt;NotifyObservers(
<span class="lineNum">     546 </span>            :                 mService, NS_NETWORK_LINK_TOPIC,
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 NS_ConvertASCIItoUTF16(mEventID).get());</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     549 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
