<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/vm/Shape.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/vm</a> - Shape.h<span style="font-size: 80%;"> (source / <a href="Shape.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">257</td>
            <td class="headerCovTableEntry">257</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntry">61</td>
            <td class="headerCovTableEntryHi">93.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef vm_Shape_h
<span class="lineNum">       8 </span>            : #define vm_Shape_h
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/GuardObjects.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/MathAlgorithms.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/TemplateLib.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;jsapi.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;jsatom.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;jsfriendapi.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;jspropertytree.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;jstypes.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;NamespaceImports.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;gc/Barrier.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;gc/Heap.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;gc/Marking.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;gc/Rooting.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;js/HashTable.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;js/MemoryMetrics.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;js/RootingAPI.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;js/UbiNode.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;vm/ObjectGroup.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;vm/String.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;vm/Symbol.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #ifdef _MSC_VER
<span class="lineNum">      37 </span>            : #pragma warning(push)
<span class="lineNum">      38 </span>            : #pragma warning(disable:4800)
<span class="lineNum">      39 </span>            : #pragma warning(push)
<span class="lineNum">      40 </span>            : #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
<span class="lineNum">      41 </span>            : #endif
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /*
<span class="lineNum">      44 </span>            :  * In isolation, a Shape represents a property that exists in one or more
<span class="lineNum">      45 </span>            :  * objects; it has an id, flags, etc. (But it doesn't represent the property's
<span class="lineNum">      46 </span>            :  * value.)  However, Shapes are always stored in linked linear sequence of
<span class="lineNum">      47 </span>            :  * Shapes, called &quot;shape lineages&quot;. Each shape lineage represents the layout of
<span class="lineNum">      48 </span>            :  * an entire object.
<span class="lineNum">      49 </span>            :  *
<span class="lineNum">      50 </span>            :  * Every JSObject has a pointer, |shape_|, accessible via lastProperty(), to
<span class="lineNum">      51 </span>            :  * the last Shape in a shape lineage, which identifies the property most
<span class="lineNum">      52 </span>            :  * recently added to the object.  This pointer permits fast object layout
<span class="lineNum">      53 </span>            :  * tests. The shape lineage order also dictates the enumeration order for the
<span class="lineNum">      54 </span>            :  * object; ECMA requires no particular order but this implementation has
<span class="lineNum">      55 </span>            :  * promised and delivered property definition order.
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  * Shape lineages occur in two kinds of data structure.
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  * 1. N-ary property trees. Each path from a non-root node to the root node in
<span class="lineNum">      60 </span>            :  *    a property tree is a shape lineage. Property trees permit full (or
<span class="lineNum">      61 </span>            :  *    partial) sharing of Shapes between objects that have fully (or partly)
<span class="lineNum">      62 </span>            :  *    identical layouts. The root is an EmptyShape whose identity is determined
<span class="lineNum">      63 </span>            :  *    by the object's class, compartment and prototype. These Shapes are shared
<span class="lineNum">      64 </span>            :  *    and immutable.
<span class="lineNum">      65 </span>            :  *
<span class="lineNum">      66 </span>            :  * 2. Dictionary mode lists. Shapes in such lists are said to be &quot;in
<span class="lineNum">      67 </span>            :  *    dictionary mode&quot;, as are objects that point to such Shapes. These Shapes
<span class="lineNum">      68 </span>            :  *    are unshared, private to a single object, and immutable except for their
<span class="lineNum">      69 </span>            :  *    links in the dictionary list.
<span class="lineNum">      70 </span>            :  *
<span class="lineNum">      71 </span>            :  * All shape lineages are bi-directionally linked, via the |parent| and
<span class="lineNum">      72 </span>            :  * |kids|/|listp| members.
<span class="lineNum">      73 </span>            :  *
<span class="lineNum">      74 </span>            :  * Shape lineages start out life in the property tree. They can be converted
<span class="lineNum">      75 </span>            :  * (by copying) to dictionary mode lists in the following circumstances.
<span class="lineNum">      76 </span>            :  *
<span class="lineNum">      77 </span>            :  * 1. The shape lineage's size reaches MAX_HEIGHT. This reasonable limit avoids
<span class="lineNum">      78 </span>            :  *    potential worst cases involving shape lineage mutations.
<span class="lineNum">      79 </span>            :  *
<span class="lineNum">      80 </span>            :  * 2. A property represented by a non-last Shape in a shape lineage is removed
<span class="lineNum">      81 </span>            :  *    from an object. (In the last Shape case, obj-&gt;shape_ can be easily
<span class="lineNum">      82 </span>            :  *    adjusted to point to obj-&gt;shape_-&gt;parent.)  We originally tried lazy
<span class="lineNum">      83 </span>            :  *    forking of the property tree, but this blows up for delete/add
<span class="lineNum">      84 </span>            :  *    repetitions.
<span class="lineNum">      85 </span>            :  *
<span class="lineNum">      86 </span>            :  * 3. A property represented by a non-last Shape in a shape lineage has its
<span class="lineNum">      87 </span>            :  *    attributes modified.
<span class="lineNum">      88 </span>            :  *
<span class="lineNum">      89 </span>            :  * To find the Shape for a particular property of an object initially requires
<span class="lineNum">      90 </span>            :  * a linear search. But if the number of searches starting at any particular
<span class="lineNum">      91 </span>            :  * Shape in the property tree exceeds LINEAR_SEARCHES_MAX and the Shape's
<span class="lineNum">      92 </span>            :  * lineage has (excluding the EmptyShape) at least MIN_ENTRIES, we create an
<span class="lineNum">      93 </span>            :  * auxiliary hash table -- the ShapeTable -- that allows faster lookup.
<span class="lineNum">      94 </span>            :  * Furthermore, a ShapeTable is always created for dictionary mode lists,
<span class="lineNum">      95 </span>            :  * and it is attached to the last Shape in the lineage. Shape tables for
<span class="lineNum">      96 </span>            :  * property tree Shapes never change, but shape tables for dictionary mode
<span class="lineNum">      97 </span>            :  * Shapes can grow and shrink.
<span class="lineNum">      98 </span>            :  *
<span class="lineNum">      99 </span>            :  * To save memory, shape tables can be discarded on GC and recreated when
<span class="lineNum">     100 </span>            :  * needed. AutoKeepShapeTables can be used to avoid discarding shape tables
<span class="lineNum">     101 </span>            :  * for a particular zone. Methods operating on ShapeTables take either an
<span class="lineNum">     102 </span>            :  * AutoCheckCannotGC or AutoKeepShapeTables argument, to help ensure tables
<span class="lineNum">     103 </span>            :  * are not purged while we're using them.
<span class="lineNum">     104 </span>            :  *
<span class="lineNum">     105 </span>            :  * There used to be a long, math-heavy comment here explaining why property
<span class="lineNum">     106 </span>            :  * trees are more space-efficient than alternatives.  This was removed in bug
<span class="lineNum">     107 </span>            :  * 631138; see that bug for the full details.
<span class="lineNum">     108 </span>            :  *
<span class="lineNum">     109 </span>            :  * For getters/setters, an AccessorShape is allocated. This is a slightly fatter
<span class="lineNum">     110 </span>            :  * type with extra fields for the getter/setter data.
<span class="lineNum">     111 </span>            :  *
<span class="lineNum">     112 </span>            :  * Because many Shapes have similar data, there is actually a secondary type
<span class="lineNum">     113 </span>            :  * called a BaseShape that holds some of a Shape's data.  Many shapes can share
<span class="lineNum">     114 </span>            :  * a single BaseShape.
<span class="lineNum">     115 </span>            :  */
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : #define JSSLOT_FREE(clasp)  JSCLASS_RESERVED_SLOTS(clasp)
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : namespace js {
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : class TenuringTracer;
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : typedef JSGetterOp GetterOp;
<span class="lineNum">     124 </span>            : typedef JSSetterOp SetterOp;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : /* Limit on the number of slotful properties in an object. */
<span class="lineNum">     127 </span>            : static const uint32_t SHAPE_INVALID_SLOT = JS_BIT(24) - 1;
<span class="lineNum">     128 </span>            : static const uint32_t SHAPE_MAXIMUM_SLOT = JS_BIT(24) - 2;
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : enum class MaybeAdding { Adding = true, NotAdding = false };
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : class AutoKeepShapeTables;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : /*
<span class="lineNum">     135 </span>            :  * Shapes use multiplicative hashing, but specialized to
<span class="lineNum">     136 </span>            :  * minimize footprint.
<span class="lineNum">     137 </span>            :  */
<span class="lineNum">     138 </span>            : class ShapeTable {
<span class="lineNum">     139 </span>            :   public:
<span class="lineNum">     140 </span>            :     friend class NativeObject;
<span class="lineNum">     141 </span>            :     friend class BaseShape;
<span class="lineNum">     142 </span>            :     static const uint32_t MIN_ENTRIES   = 11;
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :     class Entry {
<span class="lineNum">     145 </span>            :         // js::Shape pointer tag bit indicating a collision.
<span class="lineNum">     146 </span>            :         static const uintptr_t SHAPE_COLLISION = 1;
<span class="lineNum">     147 </span>            :         static Shape* const SHAPE_REMOVED; // = SHAPE_COLLISION
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :         Shape* shape_;
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :         Entry() = delete;
<span class="lineNum">     152 </span>            :         Entry(const Entry&amp;) = delete;
<span class="lineNum">     153 </span>            :         Entry&amp; operator=(const Entry&amp;) = delete;
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            :       public:</a>
<span class="lineNum">     156 </span><span class="lineCov">          1 :         bool isFree() const { return shape_ == nullptr; }</span>
<a name="157"><span class="lineNum">     157 </span><span class="lineCov">          1 :         bool isRemoved() const { return shape_ == SHAPE_REMOVED; }</span></a>
<span class="lineNum">     158 </span>            :         bool isLive() const { return !isFree() &amp;&amp; !isRemoved(); }
<span class="lineNum">     159 </span><span class="lineCov">          1 :         bool hadCollision() const { return uintptr_t(shape_) &amp; SHAPE_COLLISION; }</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">          1 :         void setFree() { shape_ = nullptr; }</span>
<a name="162"><span class="lineNum">     162 </span><span class="lineCov">          1 :         void setRemoved() { shape_ = SHAPE_REMOVED; }</span></a>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">          1 :         Shape* shape() const {</span>
<span class="lineNum">     165 </span><span class="lineCov">          1 :             return reinterpret_cast&lt;Shape*&gt;(uintptr_t(shape_) &amp; ~SHAPE_COLLISION);</span>
<span class="lineNum">     166 </span>            :         }
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :         void setShape(Shape* shape) {
<span class="lineNum">     169 </span>            :             MOZ_ASSERT(isFree());
<span class="lineNum">     170 </span>            :             MOZ_ASSERT(shape);
<span class="lineNum">     171 </span>            :             MOZ_ASSERT(shape != SHAPE_REMOVED);
<span class="lineNum">     172 </span><span class="lineCov">          1 :             shape_ = shape;</span>
<span class="lineNum">     173 </span>            :             MOZ_ASSERT(!hadCollision());
<a name="174"><span class="lineNum">     174 </span>            :         }</a>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">          1 :         void flagCollision() {</span>
<span class="lineNum">     177 </span><span class="lineCov">          1 :             shape_ = reinterpret_cast&lt;Shape*&gt;(uintptr_t(shape_) | SHAPE_COLLISION);</span>
<span class="lineNum">     178 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">     179 </span>            :         void setPreservingCollision(Shape* shape) {
<span class="lineNum">     180 </span><span class="lineCov">          1 :             shape_ = reinterpret_cast&lt;Shape*&gt;(uintptr_t(shape) | uintptr_t(hadCollision()));</span>
<span class="lineNum">     181 </span>            :         }
<span class="lineNum">     182 </span>            :     };
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   private:
<span class="lineNum">     185 </span>            :     static const uint32_t HASH_BITS     = mozilla::tl::BitSize&lt;HashNumber&gt;::value;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :     // This value is low because it's common for a ShapeTable to be created
<span class="lineNum">     188 </span>            :     // with an entryCount of zero.
<span class="lineNum">     189 </span>            :     static const uint32_t MIN_SIZE_LOG2 = 2;
<span class="lineNum">     190 </span>            :     static const uint32_t MIN_SIZE      = JS_BIT(MIN_SIZE_LOG2);
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :     uint32_t        hashShift_;         /* multiplicative hash shift */
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :     uint32_t        entryCount_;        /* number of entries in table */
<span class="lineNum">     195 </span>            :     uint32_t        removedCount_;      /* removed entry sentinels in table */
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :     uint32_t        freeList_;          /* SHAPE_INVALID_SLOT or head of slot
<span class="lineNum">     198 </span>            :                                            freelist in owning dictionary-mode
<span class="lineNum">     199 </span>            :                                            object */
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :     Entry*          entries_;          /* table of ptrs to shared tree nodes */
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :     template&lt;MaybeAdding Adding&gt;
<span class="lineNum">     204 </span>            :     MOZ_ALWAYS_INLINE Entry&amp; searchUnchecked(jsid id);
<a name="205"><span class="lineNum">     205 </span>            : </a>
<span class="lineNum">     206 </span>            :   public:
<span class="lineNum">     207 </span><span class="lineCov">          1 :     explicit ShapeTable(uint32_t nentries)</span>
<span class="lineNum">     208 </span>            :       : hashShift_(HASH_BITS - MIN_SIZE_LOG2),
<span class="lineNum">     209 </span>            :         entryCount_(nentries),
<span class="lineNum">     210 </span>            :         removedCount_(0),
<span class="lineNum">     211 </span>            :         freeList_(SHAPE_INVALID_SLOT),
<span class="lineNum">     212 </span><span class="lineCov">          1 :         entries_(nullptr)</span>
<span class="lineNum">     213 </span>            :     {
<span class="lineNum">     214 </span>            :         /* NB: entries is set by init, which must be called. */
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">          1 :     }</span></a>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineCov">          1 :     ~ShapeTable() {</span>
<span class="lineNum">     218 </span><span class="lineCov">          1 :         js_free(entries_);</span>
<span class="lineNum">     219 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :     uint32_t entryCount() const { return entryCount_; }
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :     uint32_t freeList() const { return freeList_; }
<span class="lineNum">     224 </span><span class="lineCov">          1 :     void setFreeList(uint32_t slot) { freeList_ = slot; }</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     /*
<span class="lineNum">     227 </span>            :      * This counts the ShapeTable object itself (which must be
<span class="lineNum">     228 </span>            :      * heap-allocated) and its |entries| array.
<span class="lineNum">     229 </span>            :      */
<span class="lineNum">     230 </span>            :     size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
<span class="lineNum">     231 </span><span class="lineCov">          1 :         return mallocSizeOf(this) + mallocSizeOf(entries_);</span>
<span class="lineNum">     232 </span>            :     }
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :     // init() is fallible and reports OOM to the context.
<span class="lineNum">     235 </span>            :     bool init(JSContext* cx, Shape* lastProp);
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :     // change() is fallible but does not report OOM.
<span class="lineNum">     238 </span>            :     bool change(JSContext* cx, int log2Delta);
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :     template&lt;MaybeAdding Adding&gt;
<span class="lineNum">     241 </span>            :     MOZ_ALWAYS_INLINE Entry&amp; search(jsid id, const AutoKeepShapeTables&amp;);
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     template&lt;MaybeAdding Adding&gt;
<span class="lineNum">     244 </span>            :     MOZ_ALWAYS_INLINE Entry&amp; search(jsid id, const JS::AutoCheckCannotGC&amp;);
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :     void trace(JSTracer* trc);
<span class="lineNum">     247 </span>            : #ifdef JSGC_HASH_TABLE_CHECKS
<span class="lineNum">     248 </span>            :     void checkAfterMovingGC();
<span class="lineNum">     249 </span>            : #endif
<a name="250"><span class="lineNum">     250 </span>            : </a>
<span class="lineNum">     251 </span>            :   private:
<span class="lineNum">     252 </span><span class="lineCov">          1 :     Entry&amp; getEntry(uint32_t i) const {</span>
<span class="lineNum">     253 </span>            :         MOZ_ASSERT(i &lt; capacity());
<span class="lineNum">     254 </span><span class="lineCov">          1 :         return entries_[i];</span>
<span class="lineNum">     255 </span>            :     }
<span class="lineNum">     256 </span>            :     void decEntryCount() {
<span class="lineNum">     257 </span>            :         MOZ_ASSERT(entryCount_ &gt; 0);
<span class="lineNum">     258 </span><span class="lineCov">          1 :         entryCount_--;</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            :     void incEntryCount() {
<span class="lineNum">     261 </span><span class="lineCov">          1 :         entryCount_++;</span>
<span class="lineNum">     262 </span>            :         MOZ_ASSERT(entryCount_ + removedCount_ &lt;= capacity());
<span class="lineNum">     263 </span>            :     }
<span class="lineNum">     264 </span>            :     void incRemovedCount() {
<span class="lineNum">     265 </span><span class="lineCov">          1 :         removedCount_++;</span>
<span class="lineNum">     266 </span>            :         MOZ_ASSERT(entryCount_ + removedCount_ &lt;= capacity());
<span class="lineNum">     267 </span>            :     }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :     /* By definition, hashShift = HASH_BITS - log2(capacity). */
<span class="lineNum">     270 </span><span class="lineCov">          1 :     uint32_t capacity() const { return JS_BIT(HASH_BITS - hashShift_); }</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :     /* Whether we need to grow.  We want to do this if the load factor is &gt;= 0.75 */
<span class="lineNum">     273 </span>            :     bool needsToGrow() const {
<span class="lineNum">     274 </span><span class="lineCov">          1 :         uint32_t size = capacity();</span>
<span class="lineNum">     275 </span><span class="lineCov">          1 :         return entryCount_ + removedCount_ &gt;= size - (size &gt;&gt; 2);</span>
<span class="lineNum">     276 </span>            :     }
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     /*
<span class="lineNum">     279 </span>            :      * Try to grow the table.  On failure, reports out of memory on cx
<span class="lineNum">     280 </span>            :      * and returns false.  This will make any extant pointers into the
<span class="lineNum">     281 </span>            :      * table invalid.  Don't call this unless needsToGrow() is true.
<span class="lineNum">     282 </span>            :      */
<span class="lineNum">     283 </span>            :     bool grow(JSContext* cx);
<span class="lineNum">     284 </span>            : };
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : // Ensures no shape tables are purged in the current zone.
<span class="lineNum">     287 </span>            : class MOZ_RAII AutoKeepShapeTables
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :     JSContext* cx_;
<span class="lineNum">     290 </span>            :     bool prev_;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     AutoKeepShapeTables(const AutoKeepShapeTables&amp;) = delete;
<span class="lineNum">     293 </span>            :     void operator=(const AutoKeepShapeTables&amp;) = delete;
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :   public:
<span class="lineNum">     296 </span>            :     explicit inline AutoKeepShapeTables(JSContext* cx);
<span class="lineNum">     297 </span>            :     inline ~AutoKeepShapeTables();
<span class="lineNum">     298 </span>            : };
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /*
<span class="lineNum">     301 </span>            :  * Use the reserved attribute bit to mean shadowability.
<span class="lineNum">     302 </span>            :  */
<span class="lineNum">     303 </span>            : #define JSPROP_SHADOWABLE       JSPROP_INTERNAL_USE_BIT
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : /*
<span class="lineNum">     306 </span>            :  * Shapes encode information about both a property lineage *and* a particular
<span class="lineNum">     307 </span>            :  * property. This information is split across the Shape and the BaseShape
<span class="lineNum">     308 </span>            :  * at shape-&gt;base(). Both Shape and BaseShape can be either owned or unowned
<span class="lineNum">     309 </span>            :  * by, respectively, the Object or Shape referring to them.
<span class="lineNum">     310 </span>            :  *
<span class="lineNum">     311 </span>            :  * Owned Shapes are used in dictionary objects, and form a doubly linked list
<span class="lineNum">     312 </span>            :  * whose entries are all owned by that dictionary. Unowned Shapes are all in
<span class="lineNum">     313 </span>            :  * the property tree.
<span class="lineNum">     314 </span>            :  *
<span class="lineNum">     315 </span>            :  * Owned BaseShapes are used for shapes which have shape tables, including the
<span class="lineNum">     316 </span>            :  * last properties in all dictionaries. Unowned BaseShapes compactly store
<span class="lineNum">     317 </span>            :  * information common to many shapes. In a given zone there is a single
<span class="lineNum">     318 </span>            :  * BaseShape for each combination of BaseShape information. This information is
<span class="lineNum">     319 </span>            :  * cloned in owned BaseShapes so that information can be quickly looked up for a
<span class="lineNum">     320 </span>            :  * given object or shape without regard to whether the base shape is owned or
<span class="lineNum">     321 </span>            :  * not.
<span class="lineNum">     322 </span>            :  *
<span class="lineNum">     323 </span>            :  * All combinations of owned/unowned Shapes/BaseShapes are possible:
<span class="lineNum">     324 </span>            :  *
<span class="lineNum">     325 </span>            :  * Owned Shape, Owned BaseShape:
<span class="lineNum">     326 </span>            :  *
<span class="lineNum">     327 </span>            :  *     Last property in a dictionary object. The BaseShape is transferred from
<span class="lineNum">     328 </span>            :  *     property to property as the object's last property changes.
<span class="lineNum">     329 </span>            :  *
<span class="lineNum">     330 </span>            :  * Owned Shape, Unowned BaseShape:
<span class="lineNum">     331 </span>            :  *
<span class="lineNum">     332 </span>            :  *     Property in a dictionary object other than the last one.
<span class="lineNum">     333 </span>            :  *
<span class="lineNum">     334 </span>            :  * Unowned Shape, Owned BaseShape:
<span class="lineNum">     335 </span>            :  *
<span class="lineNum">     336 </span>            :  *     Property in the property tree which has a shape table.
<span class="lineNum">     337 </span>            :  *
<span class="lineNum">     338 </span>            :  * Unowned Shape, Unowned BaseShape:
<span class="lineNum">     339 </span>            :  *
<span class="lineNum">     340 </span>            :  *     Property in the property tree which does not have a shape table.
<span class="lineNum">     341 </span>            :  *
<span class="lineNum">     342 </span>            :  * BaseShapes additionally encode some information about the referring object
<span class="lineNum">     343 </span>            :  * itself. This includes the object's class and various flags that may be set
<span class="lineNum">     344 </span>            :  * for the object. Except for the class, this information is mutable and may
<span class="lineNum">     345 </span>            :  * change when the object has an established property lineage. On such changes
<span class="lineNum">     346 </span>            :  * the entire property lineage is not updated, but rather only the last property
<span class="lineNum">     347 </span>            :  * (and its base shape). This works because only the object's last property is
<span class="lineNum">     348 </span>            :  * used to query information about the object. Care must be taken to call
<span class="lineNum">     349 </span>            :  * JSObject::canRemoveLastProperty when unwinding an object to an earlier
<span class="lineNum">     350 </span>            :  * property, however.
<span class="lineNum">     351 </span>            :  */
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : class AccessorShape;
<span class="lineNum">     354 </span>            : class Shape;
<span class="lineNum">     355 </span>            : class UnownedBaseShape;
<span class="lineNum">     356 </span>            : struct StackBaseShape;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : class BaseShape : public gc::TenuredCell
<span class="lineNum">     359 </span>            : {
<span class="lineNum">     360 </span>            :   public:
<span class="lineNum">     361 </span>            :     friend class Shape;
<span class="lineNum">     362 </span>            :     friend struct StackBaseShape;
<span class="lineNum">     363 </span>            :     friend struct StackShape;
<span class="lineNum">     364 </span>            :     friend void gc::MergeCompartments(JSCompartment* source, JSCompartment* target);
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     enum Flag {
<span class="lineNum">     367 </span>            :         /* Owned by the referring shape. */
<span class="lineNum">     368 </span>            :         OWNED_SHAPE        = 0x1,
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :         /* (0x2 and 0x4 are unused) */
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :         /*
<span class="lineNum">     373 </span>            :          * Flags set which describe the referring object. Once set these cannot
<span class="lineNum">     374 </span>            :          * be unset (except during object densification of sparse indexes), and
<span class="lineNum">     375 </span>            :          * are transferred from shape to shape as the object's last property
<span class="lineNum">     376 </span>            :          * changes.
<span class="lineNum">     377 </span>            :          *
<span class="lineNum">     378 </span>            :          * If you add a new flag here, please add appropriate code to
<span class="lineNum">     379 </span>            :          * JSObject::dump to dump it as part of object representation.
<span class="lineNum">     380 </span>            :          */
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :         DELEGATE            =    0x8,
<span class="lineNum">     383 </span>            :         NOT_EXTENSIBLE      =   0x10,
<span class="lineNum">     384 </span>            :         INDEXED             =   0x20,
<span class="lineNum">     385 </span>            :         /* (0x40 is unused) */
<span class="lineNum">     386 </span>            :         HAD_ELEMENTS_ACCESS =   0x80,
<span class="lineNum">     387 </span>            :         WATCHED             =  0x100,
<span class="lineNum">     388 </span>            :         ITERATED_SINGLETON  =  0x200,
<span class="lineNum">     389 </span>            :         NEW_GROUP_UNKNOWN   =  0x400,
<span class="lineNum">     390 </span>            :         UNCACHEABLE_PROTO   =  0x800,
<span class="lineNum">     391 </span>            :         IMMUTABLE_PROTOTYPE = 0x1000,
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :         // See JSObject::isQualifiedVarObj().
<span class="lineNum">     394 </span>            :         QUALIFIED_VAROBJ    = 0x2000,
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :         // 0x4000 is unused.
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :         // For a function used as an interpreted constructor, whether a 'new'
<span class="lineNum">     399 </span>            :         // type had constructor information cleared.
<span class="lineNum">     400 </span>            :         NEW_SCRIPT_CLEARED  = 0x8000,
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :         OBJECT_FLAG_MASK    = 0xfff8
<span class="lineNum">     403 </span>            :     };
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   private:
<span class="lineNum">     406 </span>            :     const Class*        clasp_;        /* Class of referring object. */
<span class="lineNum">     407 </span>            :     uint32_t            flags;          /* Vector of above flags. */
<span class="lineNum">     408 </span>            :     uint32_t            slotSpan_;      /* Object slot span for BaseShapes at
<span class="lineNum">     409 </span>            :                                          * dictionary last properties. */
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :     /* For owned BaseShapes, the canonical unowned BaseShape. */
<span class="lineNum">     412 </span>            :     GCPtrUnownedBaseShape unowned_;
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :     /* For owned BaseShapes, the shape's shape table. */
<span class="lineNum">     415 </span>            :     ShapeTable*      table_;
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : #if JS_BITS_PER_WORD == 32
<span class="lineNum">     418 </span>            :     // Ensure sizeof(BaseShape) is a multiple of gc::CellSize.
<span class="lineNum">     419 </span>            :     uint32_t padding_;
<span class="lineNum">     420 </span>            : #endif
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :     BaseShape(const BaseShape&amp; base) = delete;
<span class="lineNum">     423 </span>            :     BaseShape&amp; operator=(const BaseShape&amp; other) = delete;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   public:
<span class="lineNum">     426 </span>            :     void finalize(FreeOp* fop);
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :     explicit inline BaseShape(const StackBaseShape&amp; base);
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     /* Not defined: BaseShapes must not be stack allocated. */
<span class="lineNum">     431 </span>            :     ~BaseShape();
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :     const Class* clasp() const { return clasp_; }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">          1 :     bool isOwned() const { return !!(flags &amp; OWNED_SHAPE); }</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :     static void copyFromUnowned(BaseShape&amp; dest, UnownedBaseShape&amp; src);
<span class="lineNum">     438 </span>            :     inline void adoptUnowned(UnownedBaseShape* other);
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :     void setOwned(UnownedBaseShape* unowned) {
<span class="lineNum">     441 </span><span class="lineCov">          1 :         flags |= OWNED_SHAPE;</span>
<span class="lineNum">     442 </span><span class="lineCov">          1 :         unowned_ = unowned;</span>
<span class="lineNum">     443 </span>            :     }
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineCov">          1 :     uint32_t getObjectFlags() const { return flags &amp; OBJECT_FLAG_MASK; }</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">          1 :     bool hasTable() const { MOZ_ASSERT_IF(table_, isOwned()); return table_ != nullptr; }</span>
<span class="lineNum">     448 </span><span class="lineCov">          1 :     void setTable(ShapeTable* table) { MOZ_ASSERT(isOwned()); table_ = table; }</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :     ShapeTable* maybeTable(const AutoKeepShapeTables&amp;) const {
<span class="lineNum">     451 </span>            :         MOZ_ASSERT_IF(table_, isOwned());
<span class="lineNum">     452 </span>            :         return table_;
<span class="lineNum">     453 </span>            :     }
<span class="lineNum">     454 </span>            :     ShapeTable* maybeTable(const JS::AutoCheckCannotGC&amp;) const {
<span class="lineNum">     455 </span>            :         MOZ_ASSERT_IF(table_, isOwned());
<a name="456"><span class="lineNum">     456 </span>            :         return table_;</a>
<span class="lineNum">     457 </span>            :     }
<span class="lineNum">     458 </span><span class="lineCov">          1 :     void maybePurgeTable() {</span>
<span class="lineNum">     459 </span><span class="lineCov">          1 :         if (table_ &amp;&amp; table_-&gt;freeList() == SHAPE_INVALID_SLOT) {</span>
<span class="lineNum">     460 </span><span class="lineCov">          1 :             js_delete(table_);</span>
<span class="lineNum">     461 </span><span class="lineCov">          1 :             table_ = nullptr;</span>
<span class="lineNum">     462 </span>            :         }
<span class="lineNum">     463 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :     uint32_t slotSpan() const { MOZ_ASSERT(isOwned()); return slotSpan_; }
<span class="lineNum">     466 </span><span class="lineCov">          1 :     void setSlotSpan(uint32_t slotSpan) { MOZ_ASSERT(isOwned()); slotSpan_ = slotSpan; }</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :     /*
<span class="lineNum">     469 </span>            :      * Lookup base shapes from the zone's baseShapes table, adding if not
<span class="lineNum">     470 </span>            :      * already found.
<span class="lineNum">     471 </span>            :      */
<span class="lineNum">     472 </span>            :     static UnownedBaseShape* getUnowned(JSContext* cx, StackBaseShape&amp; base);
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :     /* Get the canonical base shape. */
<span class="lineNum">     475 </span>            :     inline UnownedBaseShape* unowned();
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :     /* Get the canonical base shape for an owned one. */
<span class="lineNum">     478 </span>            :     inline UnownedBaseShape* baseUnowned();
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :     /* Get the canonical base shape for an unowned one (i.e. identity). */
<span class="lineNum">     481 </span>            :     inline UnownedBaseShape* toUnowned();
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :     /* Check that an owned base shape is consistent with its unowned base. */
<span class="lineNum">     484 </span>            :     void assertConsistency();
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :     /* For JIT usage */
<span class="lineNum">     487 </span>            :     static inline size_t offsetOfFlags() { return offsetof(BaseShape, flags); }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :     static const JS::TraceKind TraceKind = JS::TraceKind::BaseShape;
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :     void traceChildren(JSTracer* trc);
<span class="lineNum">     492 </span>            :     void traceChildrenSkipShapeTable(JSTracer* trc);
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : #ifdef DEBUG
<span class="lineNum">     495 </span>            :     bool canSkipMarkingShapeTable(Shape* lastShape);
<span class="lineNum">     496 </span>            : #endif
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :   private:
<span class="lineNum">     499 </span>            :     static void staticAsserts() {
<span class="lineNum">     500 </span>            :         JS_STATIC_ASSERT(offsetof(BaseShape, clasp_) == offsetof(js::shadow::BaseShape, clasp_));
<span class="lineNum">     501 </span>            :         static_assert(sizeof(BaseShape) % gc::CellSize == 0,
<span class="lineNum">     502 </span>            :                       &quot;Things inheriting from gc::Cell must have a size that's &quot;
<span class="lineNum">     503 </span>            :                       &quot;a multiple of gc::CellSize&quot;);
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     void traceShapeTable(JSTracer* trc);
<span class="lineNum">     507 </span>            : };
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : class UnownedBaseShape : public BaseShape {};
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : UnownedBaseShape*
<span class="lineNum">     512 </span>            : BaseShape::unowned()
<span class="lineNum">     513 </span>            : {
<span class="lineNum">     514 </span><span class="lineCov">          1 :     return isOwned() ? baseUnowned() : toUnowned();</span>
<span class="lineNum">     515 </span>            : }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : UnownedBaseShape*
<span class="lineNum">     518 </span>            : BaseShape::toUnowned()
<span class="lineNum">     519 </span>            : {
<span class="lineNum">     520 </span>            :     MOZ_ASSERT(!isOwned() &amp;&amp; !unowned_);
<span class="lineNum">     521 </span>            :     return static_cast&lt;UnownedBaseShape*&gt;(this);
<span class="lineNum">     522 </span>            : }
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : UnownedBaseShape*
<span class="lineNum">     525 </span>            : BaseShape::baseUnowned()
<span class="lineNum">     526 </span>            : {
<span class="lineNum">     527 </span>            :     MOZ_ASSERT(isOwned() &amp;&amp; unowned_);
<span class="lineNum">     528 </span><span class="lineCov">          1 :     return unowned_;</span>
<span class="lineNum">     529 </span>            : }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : /* Entries for the per-zone baseShapes set of unowned base shapes. */
<span class="lineNum">     532 </span>            : struct StackBaseShape : public DefaultHasher&lt;ReadBarriered&lt;UnownedBaseShape*&gt;&gt;
<span class="lineNum">     533 </span>            : {
<span class="lineNum">     534 </span>            :     uint32_t flags;
<span class="lineNum">     535 </span>            :     const Class* clasp;
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :     explicit StackBaseShape(BaseShape* base)
<span class="lineNum">     538 </span><span class="lineCov">          1 :       : flags(base-&gt;flags &amp; BaseShape::OBJECT_FLAG_MASK),</span>
<span class="lineNum">     539 </span><span class="lineCov">          1 :         clasp(base-&gt;clasp_)</span>
<span class="lineNum">     540 </span>            :     {}
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            :     inline StackBaseShape(JSContext* cx, const Class* clasp, uint32_t objectFlags);
<span class="lineNum">     543 </span>            :     explicit inline StackBaseShape(Shape* shape);
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :     struct Lookup
<span class="lineNum">     546 </span>            :     {
<span class="lineNum">     547 </span>            :         uint32_t flags;
<span class="lineNum">     548 </span>            :         const Class* clasp;
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :         MOZ_IMPLICIT Lookup(const StackBaseShape&amp; base)
<span class="lineNum">     551 </span><span class="lineCov">          1 :           : flags(base.flags), clasp(base.clasp)</span>
<span class="lineNum">     552 </span>            :         {}
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :         MOZ_IMPLICIT Lookup(UnownedBaseShape* base)
<span class="lineNum">     555 </span>            :           : flags(base-&gt;getObjectFlags()), clasp(base-&gt;clasp())
<span class="lineNum">     556 </span>            :         {
<span class="lineNum">     557 </span>            :             MOZ_ASSERT(!base-&gt;isOwned());
<span class="lineNum">     558 </span>            :         }
<span class="lineNum">     559 </span>            :     };
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :     static inline HashNumber hash(const Lookup&amp; lookup);
<span class="lineNum">     562 </span>            :     static inline bool match(ReadBarriered&lt;UnownedBaseShape*&gt; key, const Lookup&amp; lookup);
<span class="lineNum">     563 </span>            : };
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : static MOZ_ALWAYS_INLINE js::HashNumber
<span class="lineNum">     566 </span>            : HashId(jsid id)
<span class="lineNum">     567 </span>            : {
<span class="lineNum">     568 </span>            :     // HashGeneric alone would work, but bits of atom and symbol addresses
<span class="lineNum">     569 </span>            :     // could then be recovered from the hash code. See bug 1330769.
<span class="lineNum">     570 </span><span class="lineCov">          1 :     if (MOZ_LIKELY(JSID_IS_ATOM(id)))</span>
<span class="lineNum">     571 </span><span class="lineCov">          1 :         return JSID_TO_ATOM(id)-&gt;hash();</span>
<span class="lineNum">     572 </span><span class="lineCov">          1 :     if (JSID_IS_SYMBOL(id))</span>
<span class="lineNum">     573 </span><span class="lineCov">          1 :         return JSID_TO_SYMBOL(id)-&gt;hash();</span>
<span class="lineNum">     574 </span><span class="lineCov">          1 :     return mozilla::HashGeneric(JSID_BITS(id));</span>
<span class="lineNum">     575 </span>            : }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : template &lt;&gt;
<span class="lineNum">     578 </span>            : struct DefaultHasher&lt;jsid&gt;
<a name="579"><span class="lineNum">     579 </span>            : {</a>
<span class="lineNum">     580 </span>            :     typedef jsid Lookup;
<span class="lineNum">     581 </span><span class="lineCov">          1 :     static HashNumber hash(jsid id) {</span>
<a name="582"><span class="lineNum">     582 </span><span class="lineCov">          1 :         return HashId(id);</span></a>
<span class="lineNum">     583 </span>            :     }
<span class="lineNum">     584 </span><span class="lineCov">          1 :     static bool match(jsid id1, jsid id2) {</span>
<span class="lineNum">     585 </span><span class="lineCov">          1 :         return id1 == id2;</span>
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span>            : };
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            : using BaseShapeSet = JS::GCHashSet&lt;ReadBarriered&lt;UnownedBaseShape*&gt;,
<span class="lineNum">     590 </span>            :                                    StackBaseShape,
<span class="lineNum">     591 </span>            :                                    SystemAllocPolicy&gt;;
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            : class Shape : public gc::TenuredCell
<span class="lineNum">     594 </span>            : {
<span class="lineNum">     595 </span>            :     friend class ::JSObject;
<span class="lineNum">     596 </span>            :     friend class ::JSFunction;
<span class="lineNum">     597 </span>            :     friend class NativeObject;
<span class="lineNum">     598 </span>            :     friend class PropertyTree;
<span class="lineNum">     599 </span>            :     friend class TenuringTracer;
<span class="lineNum">     600 </span>            :     friend struct StackBaseShape;
<span class="lineNum">     601 </span>            :     friend struct StackShape;
<span class="lineNum">     602 </span>            :     friend class JS::ubi::Concrete&lt;Shape&gt;;
<span class="lineNum">     603 </span>            :     friend class js::gc::RelocationOverlay;
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   protected:
<span class="lineNum">     606 </span>            :     GCPtrBaseShape base_;
<span class="lineNum">     607 </span>            :     PreBarrieredId propid_;
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :     enum SlotInfo : uint32_t
<span class="lineNum">     610 </span>            :     {
<span class="lineNum">     611 </span>            :         /* Number of fixed slots in objects with this shape. */
<span class="lineNum">     612 </span>            :         // FIXED_SLOTS_MAX is the biggest count of fixed slots a Shape can store
<span class="lineNum">     613 </span>            :         FIXED_SLOTS_MAX        = 0x1f,
<span class="lineNum">     614 </span>            :         FIXED_SLOTS_SHIFT      = 27,
<span class="lineNum">     615 </span>            :         FIXED_SLOTS_MASK       = uint32_t(FIXED_SLOTS_MAX &lt;&lt; FIXED_SLOTS_SHIFT),
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :         /*
<span class="lineNum">     618 </span>            :          * numLinearSearches starts at zero and is incremented initially on
<span class="lineNum">     619 </span>            :          * search() calls. Once numLinearSearches reaches LINEAR_SEARCHES_MAX,
<span class="lineNum">     620 </span>            :          * the table is created on the next search() call. The table can also
<span class="lineNum">     621 </span>            :          * be created when hashifying for dictionary mode.
<span class="lineNum">     622 </span>            :          */
<span class="lineNum">     623 </span>            :         LINEAR_SEARCHES_MAX    = 0x7,
<span class="lineNum">     624 </span>            :         LINEAR_SEARCHES_SHIFT  = 24,
<span class="lineNum">     625 </span>            :         LINEAR_SEARCHES_MASK   = LINEAR_SEARCHES_MAX &lt;&lt; LINEAR_SEARCHES_SHIFT,
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :         /*
<span class="lineNum">     628 </span>            :          * Mask to get the index in object slots for shapes which hasSlot().
<span class="lineNum">     629 </span>            :          * For !hasSlot() shapes in the property tree with a parent, stores the
<span class="lineNum">     630 </span>            :          * parent's slot index (which may be invalid), and invalid for all
<span class="lineNum">     631 </span>            :          * other shapes.
<span class="lineNum">     632 </span>            :          */
<span class="lineNum">     633 </span>            :         SLOT_MASK              = JS_BIT(24) - 1
<span class="lineNum">     634 </span>            :     };
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :     uint32_t            slotInfo;       /* mask of above info */
<span class="lineNum">     637 </span>            :     uint8_t             attrs;          /* attributes, see jsapi.h JSPROP_* */
<span class="lineNum">     638 </span>            :     uint8_t             flags;          /* flags, see below for defines */
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :     GCPtrShape   parent;          /* parent node, reverse for..in order */
<span class="lineNum">     641 </span>            :     /* kids is valid when !inDictionary(), listp is valid when inDictionary(). */
<span class="lineNum">     642 </span>            :     union {
<span class="lineNum">     643 </span>            :         KidsPointer kids;         /* null, single child, or a tagged ptr
<span class="lineNum">     644 </span>            :                                      to many-kids data structure */
<span class="lineNum">     645 </span>            :         GCPtrShape* listp;        /* dictionary list starting at shape_
<span class="lineNum">     646 </span>            :                                      has a double-indirect back pointer,
<span class="lineNum">     647 </span>            :                                      either to the next shape's parent if not
<span class="lineNum">     648 </span>            :                                      last, else to obj-&gt;shape_ */
<span class="lineNum">     649 </span>            :     };
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :     template&lt;MaybeAdding Adding = MaybeAdding::NotAdding&gt;
<span class="lineNum">     652 </span>            :     static MOZ_ALWAYS_INLINE Shape* search(JSContext* cx, Shape* start, jsid id);
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :     template&lt;MaybeAdding Adding = MaybeAdding::NotAdding&gt;
<span class="lineNum">     655 </span>            :     static inline MOZ_MUST_USE bool search(JSContext* cx, Shape* start, jsid id,
<span class="lineNum">     656 </span>            :                                            const AutoKeepShapeTables&amp;,
<span class="lineNum">     657 </span>            :                                            Shape** pshape, ShapeTable::Entry** pentry);
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :     static inline Shape* searchNoHashify(Shape* start, jsid id);
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :     void removeFromDictionary(NativeObject* obj);
<span class="lineNum">     662 </span>            :     void insertIntoDictionary(GCPtrShape* dictp);
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     inline void initDictionaryShape(const StackShape&amp; child, uint32_t nfixed,
<span class="lineNum">     665 </span>            :                                     GCPtrShape* dictp);
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :     /* Replace the base shape of the last shape in a non-dictionary lineage with base. */
<span class="lineNum">     668 </span>            :     static Shape* replaceLastProperty(JSContext* cx, StackBaseShape&amp; base,
<span class="lineNum">     669 </span>            :                                       TaggedProto proto, HandleShape shape);
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :     /*
<span class="lineNum">     672 </span>            :      * This function is thread safe if every shape in the lineage of |shape|
<span class="lineNum">     673 </span>            :      * is thread local, which is the case when we clone the entire shape
<span class="lineNum">     674 </span>            :      * lineage in preparation for converting an object to dictionary mode.
<span class="lineNum">     675 </span>            :      */
<span class="lineNum">     676 </span>            :     static bool hashify(JSContext* cx, Shape* shape);
<span class="lineNum">     677 </span>            :     void handoffTableTo(Shape* newShape);
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :     void setParent(Shape* p) {
<span class="lineNum">     680 </span>            :         MOZ_ASSERT_IF(p &amp;&amp; !p-&gt;hasMissingSlot() &amp;&amp; !inDictionary(),
<span class="lineNum">     681 </span>            :                       p-&gt;maybeSlot() &lt;= maybeSlot());
<span class="lineNum">     682 </span>            :         MOZ_ASSERT_IF(p &amp;&amp; !inDictionary(),
<span class="lineNum">     683 </span>            :                       hasSlot() == (p-&gt;maybeSlot() != maybeSlot()));
<span class="lineNum">     684 </span><span class="lineCov">          1 :         parent = p;</span>
<span class="lineNum">     685 </span>            :     }
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :     bool ensureOwnBaseShape(JSContext* cx) {
<span class="lineNum">     688 </span><span class="lineCov">          1 :         if (base()-&gt;isOwned())</span>
<span class="lineNum">     689 </span>            :             return true;
<span class="lineNum">     690 </span><span class="lineCov">          1 :         return makeOwnBaseShape(cx);</span>
<span class="lineNum">     691 </span>            :     }
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :     bool makeOwnBaseShape(JSContext* cx);
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :     MOZ_ALWAYS_INLINE MOZ_MUST_USE bool maybeCreateTableForLookup(JSContext* cx);
<a name="696"><span class="lineNum">     696 </span>            : </a>
<span class="lineNum">     697 </span>            :   public:
<span class="lineNum">     698 </span><span class="lineCov">          1 :     bool hasTable() const { return base()-&gt;hasTable(); }</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :     ShapeTable* maybeTable(const AutoKeepShapeTables&amp; keep) const {
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">          1 :         return base()-&gt;maybeTable(keep);</span></a>
<span class="lineNum">     702 </span>            :     }
<span class="lineNum">     703 </span><span class="lineCov">          1 :     ShapeTable* maybeTable(const JS::AutoCheckCannotGC&amp; check) const {</span>
<span class="lineNum">     704 </span><span class="lineCov">          1 :         return base()-&gt;maybeTable(check);</span>
<span class="lineNum">     705 </span>            :     }
<a name="706"><span class="lineNum">     706 </span>            : </a>
<span class="lineNum">     707 </span>            :     template &lt;typename T&gt;
<span class="lineNum">     708 </span><span class="lineCov">          1 :     MOZ_MUST_USE ShapeTable* ensureTableForDictionary(JSContext* cx, const T&amp; nogc) {</span>
<span class="lineNum">     709 </span>            :         MOZ_ASSERT(inDictionary());
<span class="lineNum">     710 </span><span class="lineCov">          1 :         if (ShapeTable* table = maybeTable(nogc))</span>
<span class="lineNum">     711 </span>            :             return table;
<span class="lineNum">     712 </span><span class="lineCov">          1 :         if (!hashify(cx, this))</span>
<span class="lineNum">     713 </span>            :             return nullptr;
<span class="lineNum">     714 </span><span class="lineCov">          1 :         ShapeTable* table = maybeTable(nogc);</span>
<span class="lineNum">     715 </span>            :         MOZ_ASSERT(table);
<span class="lineNum">     716 </span><span class="lineCov">          1 :         return table;</span>
<a name="717"><span class="lineNum">     717 </span>            :     }</a>
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span><span class="lineCov">          1 :     void addSizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf,</span>
<span class="lineNum">     720 </span>            :                                 JS::ShapeInfo* info) const
<span class="lineNum">     721 </span>            :     {
<span class="lineNum">     722 </span>            :         JS::AutoCheckCannotGC nogc;
<span class="lineNum">     723 </span><span class="lineCov">          1 :         if (ShapeTable* table = maybeTable(nogc)) {</span>
<span class="lineNum">     724 </span><span class="lineCov">          1 :             if (inDictionary())</span>
<span class="lineNum">     725 </span><span class="lineCov">          1 :                 info-&gt;shapesMallocHeapDictTables += table-&gt;sizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">     726 </span>            :             else
<span class="lineNum">     727 </span><span class="lineCov">          1 :                 info-&gt;shapesMallocHeapTreeTables += table-&gt;sizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">     728 </span>            :         }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineCov">          1 :         if (!inDictionary() &amp;&amp; kids.isHash())</span>
<span class="lineNum">     731 </span><span class="lineCov">          1 :             info-&gt;shapesMallocHeapTreeKids += kids.toHash()-&gt;sizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">     732 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :     bool isAccessorShape() const {
<span class="lineNum">     735 </span>            :         MOZ_ASSERT_IF(flags &amp; ACCESSOR_SHAPE, getAllocKind() == gc::AllocKind::ACCESSOR_SHAPE);
<span class="lineNum">     736 </span><span class="lineCov">          1 :         return flags &amp; ACCESSOR_SHAPE;</span>
<span class="lineNum">     737 </span>            :     }
<span class="lineNum">     738 </span>            :     AccessorShape&amp; asAccessorShape() const {
<span class="lineNum">     739 </span>            :         MOZ_ASSERT(isAccessorShape());
<span class="lineNum">     740 </span>            :         return *(AccessorShape*)this;
<span class="lineNum">     741 </span>            :     }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineCov">          1 :     const GCPtrShape&amp; previous() const { return parent; }</span>
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :     template &lt;AllowGC allowGC&gt;
<span class="lineNum">     746 </span>            :     class Range {
<span class="lineNum">     747 </span>            :       protected:
<span class="lineNum">     748 </span>            :         friend class Shape;
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            :         typename MaybeRooted&lt;Shape*, allowGC&gt;::RootType cursor;
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :       public:
<span class="lineNum">     753 </span>            :         Range(JSContext* cx, Shape* shape) : cursor(cx, shape) {
<span class="lineNum">     754 </span>            :             JS_STATIC_ASSERT(allowGC == CanGC);
<span class="lineNum">     755 </span>            :         }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineCov">          1 :         explicit Range(Shape* shape) : cursor((JSContext*) nullptr, shape) {</span>
<span class="lineNum">     758 </span>            :             JS_STATIC_ASSERT(allowGC == NoGC);
<span class="lineNum">     759 </span>            :         }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :         bool empty() const {
<span class="lineNum">     762 </span><span class="lineCov">          1 :             return !cursor || cursor-&gt;isEmptyShape();</span>
<span class="lineNum">     763 </span>            :         }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :         Shape&amp; front() const {
<span class="lineNum">     766 </span>            :             MOZ_ASSERT(!empty());
<span class="lineNum">     767 </span><span class="lineCov">          1 :             return *cursor;</span>
<span class="lineNum">     768 </span>            :         }
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :         void popFront() {
<span class="lineNum">     771 </span>            :             MOZ_ASSERT(!empty());
<span class="lineNum">     772 </span><span class="lineCov">          1 :             cursor = cursor-&gt;parent;</span>
<span class="lineNum">     773 </span>            :         }
<span class="lineNum">     774 </span>            :     };
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :     const Class* getObjectClass() const {
<span class="lineNum">     777 </span><span class="lineCov">          1 :         return base()-&gt;clasp_;</span>
<span class="lineNum">     778 </span>            :     }
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :     static Shape* setObjectFlags(JSContext* cx,
<span class="lineNum">     781 </span>            :                                  BaseShape::Flag flag, TaggedProto proto, Shape* last);
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :     uint32_t getObjectFlags() const { return base()-&gt;getObjectFlags(); }
<span class="lineNum">     784 </span>            :     bool hasAllObjectFlags(BaseShape::Flag flags) const {
<span class="lineNum">     785 </span>            :         MOZ_ASSERT(flags);
<span class="lineNum">     786 </span>            :         MOZ_ASSERT(!(flags &amp; ~BaseShape::OBJECT_FLAG_MASK));
<span class="lineNum">     787 </span><span class="lineCov">          1 :         return (base()-&gt;flags &amp; flags) == flags;</span>
<span class="lineNum">     788 </span>            :     }
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :   protected:
<span class="lineNum">     791 </span>            :     /*
<span class="lineNum">     792 </span>            :      * Implementation-private bits stored in shape-&gt;flags. See public: enum {}
<span class="lineNum">     793 </span>            :      * flags further below, which were allocated FCFS over time, so interleave
<span class="lineNum">     794 </span>            :      * with these bits.
<span class="lineNum">     795 </span>            :      */
<span class="lineNum">     796 </span>            :     enum {
<span class="lineNum">     797 </span>            :         /* Property stored in per-object dictionary, not shared property tree. */
<span class="lineNum">     798 </span>            :         IN_DICTIONARY   = 0x01,
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :         /*
<span class="lineNum">     801 </span>            :          * Slotful property was stored to more than once. This is used as a
<span class="lineNum">     802 </span>            :          * hint for type inference.
<span class="lineNum">     803 </span>            :          */
<span class="lineNum">     804 </span>            :         OVERWRITTEN     = 0x02,
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :         /*
<span class="lineNum">     807 </span>            :          * This shape is an AccessorShape, a fat Shape that can store
<span class="lineNum">     808 </span>            :          * getter/setter information.
<span class="lineNum">     809 </span>            :          */
<span class="lineNum">     810 </span>            :         ACCESSOR_SHAPE  = 0x04,
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :         /* Flags used to speed up isBigEnoughForAShapeTable(). */
<span class="lineNum">     813 </span>            :         HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE = 0x08,
<span class="lineNum">     814 </span>            :         CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE = 0x10,
<span class="lineNum">     815 </span>            :     };
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :     /* Get a shape identical to this one, without parent/kids information. */
<span class="lineNum">     818 </span>            :     inline Shape(const StackShape&amp; other, uint32_t nfixed);
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     /* Used by EmptyShape (see jsscopeinlines.h). */
<span class="lineNum">     821 </span>            :     inline Shape(UnownedBaseShape* base, uint32_t nfixed);
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     /* Copy constructor disabled, to avoid misuse of the above form. */
<span class="lineNum">     824 </span>            :     Shape(const Shape&amp; other) = delete;
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            :     /* Allocate a new shape based on the given StackShape. */
<span class="lineNum">     827 </span>            :     static inline Shape* new_(JSContext* cx, Handle&lt;StackShape&gt; other, uint32_t nfixed);
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :     /*
<span class="lineNum">     830 </span>            :      * Whether this shape has a valid slot value. This may be true even if
<span class="lineNum">     831 </span>            :      * !hasSlot() (see SlotInfo comment above), and may be false even if
<span class="lineNum">     832 </span>            :      * hasSlot() if the shape is being constructed and has not had a slot
<span class="lineNum">     833 </span>            :      * assigned yet. After construction, hasSlot() implies !hasMissingSlot().
<span class="lineNum">     834 </span>            :      */
<span class="lineNum">     835 </span><span class="lineCov">          1 :     bool hasMissingSlot() const { return maybeSlot() == SHAPE_INVALID_SLOT; }</span>
<a name="836"><span class="lineNum">     836 </span>            : </a>
<span class="lineNum">     837 </span>            :   public:
<span class="lineNum">     838 </span><span class="lineCov">          1 :     bool inDictionary() const {</span>
<span class="lineNum">     839 </span><span class="lineCov">          1 :         return (flags &amp; IN_DICTIONARY) != 0;</span>
<span class="lineNum">     840 </span>            :     }
<a name="841"><span class="lineNum">     841 </span>            : </a>
<span class="lineNum">     842 </span>            :     inline GetterOp getter() const;
<span class="lineNum">     843 </span><span class="lineCov">          1 :     bool hasDefaultGetter() const { return !getter(); }</span>
<span class="lineNum">     844 </span>            :     GetterOp getterOp() const { MOZ_ASSERT(!hasGetterValue()); return getter(); }
<span class="lineNum">     845 </span>            :     inline JSObject* getterObject() const;
<span class="lineNum">     846 </span><span class="lineCov">          1 :     bool hasGetterObject() const { return hasGetterValue() &amp;&amp; getterObject(); }</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     // Per ES5, decode null getterObj as the undefined value, which encodes as null.
<span class="lineNum">     849 </span>            :     Value getterValue() const {
<span class="lineNum">     850 </span>            :         MOZ_ASSERT(hasGetterValue());
<span class="lineNum">     851 </span><span class="lineCov">          1 :         if (JSObject* getterObj = getterObject())</span>
<span class="lineNum">     852 </span>            :             return ObjectValue(*getterObj);
<span class="lineNum">     853 </span>            :         return UndefinedValue();
<span class="lineNum">     854 </span>            :     }
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :     Value getterOrUndefined() const {
<span class="lineNum">     857 </span><span class="lineCov">          1 :         return hasGetterValue() ? getterValue() : UndefinedValue();</span>
<span class="lineNum">     858 </span>            :     }
<a name="859"><span class="lineNum">     859 </span>            : </a>
<span class="lineNum">     860 </span>            :     inline SetterOp setter() const;
<span class="lineNum">     861 </span><span class="lineCov">          1 :     bool hasDefaultSetter() const { return !setter(); }</span>
<span class="lineNum">     862 </span>            :     SetterOp setterOp() const { MOZ_ASSERT(!hasSetterValue()); return setter(); }
<span class="lineNum">     863 </span>            :     inline JSObject* setterObject() const;
<span class="lineNum">     864 </span><span class="lineCov">          1 :     bool hasSetterObject() const { return hasSetterValue() &amp;&amp; setterObject(); }</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :     // Per ES5, decode null setterObj as the undefined value, which encodes as null.
<span class="lineNum">     867 </span>            :     Value setterValue() const {
<span class="lineNum">     868 </span>            :         MOZ_ASSERT(hasSetterValue());
<span class="lineNum">     869 </span><span class="lineCov">          1 :         if (JSObject* setterObj = setterObject())</span>
<span class="lineNum">     870 </span>            :             return ObjectValue(*setterObj);
<span class="lineNum">     871 </span>            :         return UndefinedValue();
<span class="lineNum">     872 </span>            :     }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :     Value setterOrUndefined() const {
<span class="lineNum">     875 </span><span class="lineCov">          1 :         return hasSetterValue() ? setterValue() : UndefinedValue();</span>
<span class="lineNum">     876 </span>            :     }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :     void setOverwritten() {
<span class="lineNum">     879 </span><span class="lineCov">          1 :         flags |= OVERWRITTEN;</span>
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span>            :     bool hadOverwrite() const {
<span class="lineNum">     882 </span><span class="lineCov">          1 :         return flags &amp; OVERWRITTEN;</span>
<span class="lineNum">     883 </span>            :     }
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :     void update(GetterOp getter, SetterOp setter, uint8_t attrs);
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            :     bool matches(const Shape* other) const {
<span class="lineNum">     888 </span>            :         return propid_.get() == other-&gt;propid_.get() &amp;&amp;
<span class="lineNum">     889 </span>            :                matchesParamsAfterId(other-&gt;base(), other-&gt;maybeSlot(), other-&gt;attrs, other-&gt;flags,
<span class="lineNum">     890 </span>            :                                     other-&gt;getter(), other-&gt;setter());
<span class="lineNum">     891 </span>            :     }
<span class="lineNum">     892 </span>            : 
<a name="893"><span class="lineNum">     893 </span>            :     inline bool matches(const StackShape&amp; other) const;</a>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">          1 :     bool matchesParamsAfterId(BaseShape* base, uint32_t aslot, unsigned aattrs, unsigned aflags,</span>
<span class="lineNum">     896 </span>            :                               GetterOp rawGetter, SetterOp rawSetter) const
<span class="lineNum">     897 </span>            :     {
<span class="lineNum">     898 </span><span class="lineCov">          1 :         return base-&gt;unowned() == this-&gt;base()-&gt;unowned() &amp;&amp;</span>
<span class="lineNum">     899 </span><span class="lineCov">          1 :                maybeSlot() == aslot &amp;&amp;</span>
<span class="lineNum">     900 </span><span class="lineCov">          1 :                attrs == aattrs &amp;&amp;</span>
<span class="lineNum">     901 </span><span class="lineCov">          1 :                getter() == rawGetter &amp;&amp;</span>
<span class="lineNum">     902 </span><span class="lineCov">          1 :                setter() == rawSetter;</span>
<span class="lineNum">     903 </span>            :     }
<span class="lineNum">     904 </span>            : 
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">          1 :     BaseShape* base() const { return base_.get(); }</span></a>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">          1 :     bool hasSlot() const {</span>
<a name="908"><span class="lineNum">     908 </span><span class="lineCov">          1 :         return (attrs &amp; JSPROP_SHARED) == 0;</span></a>
<span class="lineNum">     909 </span>            :     }
<span class="lineNum">     910 </span><span class="lineCov">          1 :     uint32_t slot() const { MOZ_ASSERT(hasSlot() &amp;&amp; !hasMissingSlot()); return maybeSlot(); }</span>
<span class="lineNum">     911 </span>            :     uint32_t maybeSlot() const {
<span class="lineNum">     912 </span><span class="lineCov">          1 :         return slotInfo &amp; SLOT_MASK;</span>
<a name="913"><span class="lineNum">     913 </span>            :     }</a>
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineCov">          1 :     bool isEmptyShape() const {</span>
<span class="lineNum">     916 </span>            :         MOZ_ASSERT_IF(JSID_IS_EMPTY(propid_), hasMissingSlot());
<span class="lineNum">     917 </span><span class="lineCov">          1 :         return JSID_IS_EMPTY(propid_);</span>
<span class="lineNum">     918 </span>            :     }
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :     uint32_t slotSpan(const Class* clasp) const {
<span class="lineNum">     921 </span>            :         MOZ_ASSERT(!inDictionary());
<span class="lineNum">     922 </span><span class="lineCov">          1 :         uint32_t free = JSSLOT_FREE(clasp);</span>
<span class="lineNum">     923 </span><span class="lineCov">          1 :         return hasMissingSlot() ? free : Max(free, maybeSlot() + 1);</span>
<a name="924"><span class="lineNum">     924 </span>            :     }</a>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineCov">          1 :     uint32_t slotSpan() const {</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :         return slotSpan(getObjectClass());</span>
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     void setSlot(uint32_t slot) {
<span class="lineNum">     931 </span>            :         MOZ_ASSERT(slot &lt;= SHAPE_INVALID_SLOT);
<span class="lineNum">     932 </span><span class="lineCov">          1 :         slotInfo = slotInfo &amp; ~Shape::SLOT_MASK;</span>
<span class="lineNum">     933 </span><span class="lineCov">          1 :         slotInfo = slotInfo | slot;</span>
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :     uint32_t numFixedSlots() const {
<span class="lineNum">     937 </span><span class="lineCov">          1 :         return slotInfo &gt;&gt; FIXED_SLOTS_SHIFT;</span>
<span class="lineNum">     938 </span>            :     }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :     void setNumFixedSlots(uint32_t nfixed) {
<span class="lineNum">     941 </span>            :         MOZ_ASSERT(nfixed &lt; FIXED_SLOTS_MAX);
<span class="lineNum">     942 </span><span class="lineCov">          1 :         slotInfo = slotInfo &amp; ~FIXED_SLOTS_MASK;</span>
<span class="lineNum">     943 </span><span class="lineCov">          1 :         slotInfo = slotInfo | (nfixed &lt;&lt; FIXED_SLOTS_SHIFT);</span>
<a name="944"><span class="lineNum">     944 </span>            :     }</a>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">          1 :     uint32_t numLinearSearches() const {</span>
<span class="lineNum">     947 </span><span class="lineCov">          1 :         return (slotInfo &amp; LINEAR_SEARCHES_MASK) &gt;&gt; LINEAR_SEARCHES_SHIFT;</span>
<a name="948"><span class="lineNum">     948 </span>            :     }</a>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span><span class="lineCov">          1 :     void incrementNumLinearSearches() {</span>
<span class="lineNum">     951 </span><span class="lineCov">          1 :         uint32_t count = numLinearSearches();</span>
<span class="lineNum">     952 </span>            :         MOZ_ASSERT(count &lt; LINEAR_SEARCHES_MAX);
<span class="lineNum">     953 </span><span class="lineCov">          1 :         slotInfo = slotInfo &amp; ~LINEAR_SEARCHES_MASK;</span>
<span class="lineNum">     954 </span><span class="lineCov">          1 :         slotInfo = slotInfo | ((count + 1) &lt;&lt; LINEAR_SEARCHES_SHIFT);</span>
<span class="lineNum">     955 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     const PreBarrieredId&amp; propid() const {
<span class="lineNum">     958 </span>            :         MOZ_ASSERT(!isEmptyShape());
<span class="lineNum">     959 </span>            :         MOZ_ASSERT(!JSID_IS_VOID(propid_));
<a name="960"><span class="lineNum">     960 </span><span class="lineCov">          1 :         return propid_;</span></a>
<a name="961"><span class="lineNum">     961 </span>            :     }</a>
<span class="lineNum">     962 </span><span class="lineCov">          1 :     PreBarrieredId&amp; propidRef() { MOZ_ASSERT(!JSID_IS_VOID(propid_)); return propid_; }</span>
<span class="lineNum">     963 </span><span class="lineCov">          1 :     jsid propidRaw() const {</span>
<span class="lineNum">     964 </span>            :         // Return the actual jsid, not an internal reference.
<span class="lineNum">     965 </span><span class="lineCov">          1 :         return propid();</span>
<span class="lineNum">     966 </span>            :     }
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :     uint8_t attributes() const { return attrs; }
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">          1 :     bool configurable() const { return (attrs &amp; JSPROP_PERMANENT) == 0; }</span></a>
<span class="lineNum">     970 </span><span class="lineCov">          1 :     bool enumerable() const { return (attrs &amp; JSPROP_ENUMERATE) != 0; }</span>
<span class="lineNum">     971 </span><span class="lineCov">          1 :     bool writable() const {</span>
<span class="lineNum">     972 </span><span class="lineCov">          1 :         return (attrs &amp; JSPROP_READONLY) == 0;</span>
<span class="lineNum">     973 </span>            :     }
<span class="lineNum">     974 </span><span class="lineCov">          1 :     bool hasGetterValue() const { return attrs &amp; JSPROP_GETTER; }</span>
<span class="lineNum">     975 </span><span class="lineCov">          1 :     bool hasSetterValue() const { return attrs &amp; JSPROP_SETTER; }</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :     bool isDataDescriptor() const {
<span class="lineNum">     978 </span><span class="lineCov">          1 :         return (attrs &amp; (JSPROP_SETTER | JSPROP_GETTER)) == 0;</span>
<span class="lineNum">     979 </span>            :     }
<span class="lineNum">     980 </span>            :     bool isAccessorDescriptor() const {
<span class="lineNum">     981 </span>            :         return (attrs &amp; (JSPROP_SETTER | JSPROP_GETTER)) != 0;
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineCov">          1 :     bool hasShadowable() const { return attrs &amp; JSPROP_SHADOWABLE; }</span>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :     uint32_t entryCount() {
<span class="lineNum">     987 </span>            :         JS::AutoCheckCannotGC nogc;
<span class="lineNum">     988 </span><span class="lineCov">          1 :         if (ShapeTable* table = maybeTable(nogc))</span>
<span class="lineNum">     989 </span>            :             return table-&gt;entryCount();
<span class="lineNum">     990 </span>            :         uint32_t count = 0;
<span class="lineNum">     991 </span><span class="lineCov">          1 :         for (Shape::Range&lt;NoGC&gt; r(this); !r.empty(); r.popFront())</span>
<span class="lineNum">     992 </span><span class="lineCov">          1 :             ++count;</span>
<span class="lineNum">     993 </span><span class="lineCov">          1 :         return count;</span>
<span class="lineNum">     994 </span>            :     }
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :   private:
<span class="lineNum">     997 </span>            :     bool isBigEnoughForAShapeTableSlow() {
<span class="lineNum">     998 </span>            :         uint32_t count = 0;
<span class="lineNum">     999 </span><span class="lineCov">          1 :         for (Shape::Range&lt;NoGC&gt; r(this); !r.empty(); r.popFront()) {</span>
<span class="lineNum">    1000 </span><span class="lineCov">          1 :             ++count;</span>
<span class="lineNum">    1001 </span><span class="lineCov">          1 :             if (count &gt;= ShapeTable::MIN_ENTRIES)</span>
<span class="lineNum">    1002 </span>            :                 return true;
<span class="lineNum">    1003 </span>            :         }
<span class="lineNum">    1004 </span>            :         return false;
<span class="lineNum">    1005 </span>            :     }
<span class="lineNum">    1006 </span>            :     void clearCachedBigEnoughForShapeTable() {
<span class="lineNum">    1007 </span><span class="lineCov">          1 :         flags &amp;= ~(HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE | CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE);</span>
<span class="lineNum">    1008 </span>            :     }
<a name="1009"><span class="lineNum">    1009 </span>            : </a>
<span class="lineNum">    1010 </span>            :   public:
<span class="lineNum">    1011 </span><span class="lineCov">          1 :     bool isBigEnoughForAShapeTable() {</span>
<span class="lineNum">    1012 </span>            :         MOZ_ASSERT(!hasTable());
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :         // isBigEnoughForAShapeTableSlow is pretty inefficient so we only call
<span class="lineNum">    1015 </span>            :         // it once and cache the result.
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineCov">          1 :         if (flags &amp; HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE) {</span>
<span class="lineNum">    1018 </span><span class="lineCov">          1 :             bool res = flags &amp; CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE;</span>
<span class="lineNum">    1019 </span>            :             MOZ_ASSERT(res == isBigEnoughForAShapeTableSlow());
<span class="lineNum">    1020 </span><span class="lineCov">          1 :             return res;</span>
<span class="lineNum">    1021 </span>            :         }
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :         MOZ_ASSERT(!(flags &amp; CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE));
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span><span class="lineCov">          1 :         bool res = isBigEnoughForAShapeTableSlow();</span>
<span class="lineNum">    1026 </span><span class="lineCov">          1 :         if (res)</span>
<span class="lineNum">    1027 </span><span class="lineCov">          1 :             flags |= CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE;</span>
<span class="lineNum">    1028 </span><span class="lineCov">          1 :         flags |= HAS_CACHED_BIG_ENOUGH_FOR_SHAPE_TABLE;</span>
<span class="lineNum">    1029 </span><span class="lineCov">          1 :         return res;</span>
<span class="lineNum">    1030 </span>            :     }
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            : #ifdef DEBUG
<span class="lineNum">    1033 </span>            :     void dump(FILE* fp) const;
<span class="lineNum">    1034 </span>            :     void dumpSubtree(int level, FILE* fp) const;
<span class="lineNum">    1035 </span>            : #endif
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            :     void sweep();
<span class="lineNum">    1038 </span>            :     void finalize(FreeOp* fop);
<span class="lineNum">    1039 </span>            :     void removeChild(Shape* child);
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :     static const JS::TraceKind TraceKind = JS::TraceKind::Shape;
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            :     void traceChildren(JSTracer* trc);
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :     MOZ_ALWAYS_INLINE Shape* search(JSContext* cx, jsid id);
<span class="lineNum">    1046 </span>            :     MOZ_ALWAYS_INLINE Shape* searchLinear(jsid id);
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :     void fixupAfterMovingGC();
<span class="lineNum">    1049 </span>            :     void fixupGetterSetterForBarrier(JSTracer* trc);
<span class="lineNum">    1050 </span>            :     void updateBaseShapeAfterMovingGC();
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :     /* For JIT usage */
<span class="lineNum">    1053 </span>            :     static inline size_t offsetOfBase() { return offsetof(Shape, base_); }
<span class="lineNum">    1054 </span>            :     static inline size_t offsetOfSlotInfo() { return offsetof(Shape, slotInfo); }
<span class="lineNum">    1055 </span>            :     static inline uint32_t fixedSlotsMask() { return FIXED_SLOTS_MASK; }
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            :   private:
<span class="lineNum">    1058 </span>            :     void fixupDictionaryShapeAfterMovingGC();
<span class="lineNum">    1059 </span>            :     void fixupShapeTreeAfterMovingGC();
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :     static void staticAsserts() {
<span class="lineNum">    1062 </span>            :         JS_STATIC_ASSERT(offsetof(Shape, base_) == offsetof(js::shadow::Shape, base));
<span class="lineNum">    1063 </span>            :         JS_STATIC_ASSERT(offsetof(Shape, slotInfo) == offsetof(js::shadow::Shape, slotInfo));
<span class="lineNum">    1064 </span>            :         JS_STATIC_ASSERT(FIXED_SLOTS_SHIFT == js::shadow::Shape::FIXED_SLOTS_SHIFT);
<span class="lineNum">    1065 </span>            :     }
<span class="lineNum">    1066 </span>            : };
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            : /* Fat Shape used for accessor properties. */
<span class="lineNum">    1069 </span>            : class AccessorShape : public Shape
<span class="lineNum">    1070 </span>            : {
<span class="lineNum">    1071 </span>            :     friend class Shape;
<span class="lineNum">    1072 </span>            :     friend class NativeObject;
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :     union {
<span class="lineNum">    1075 </span>            :         GetterOp rawGetter;     /* getter hook for shape */
<span class="lineNum">    1076 </span>            :         JSObject* getterObj;    /* user-defined callable &quot;get&quot; object or
<span class="lineNum">    1077 </span>            :                                    null if shape-&gt;hasGetterValue() */
<span class="lineNum">    1078 </span>            :     };
<span class="lineNum">    1079 </span>            :     union {
<span class="lineNum">    1080 </span>            :         SetterOp rawSetter;     /* setter hook for shape */
<span class="lineNum">    1081 </span>            :         JSObject* setterObj;    /* user-defined callable &quot;set&quot; object or
<span class="lineNum">    1082 </span>            :                                    null if shape-&gt;hasSetterValue() */
<span class="lineNum">    1083 </span>            :     };
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :   public:
<span class="lineNum">    1086 </span>            :     /* Get a shape identical to this one, without parent/kids information. */
<span class="lineNum">    1087 </span>            :     inline AccessorShape(const StackShape&amp; other, uint32_t nfixed);
<span class="lineNum">    1088 </span>            : };
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            : inline
<span class="lineNum">    1091 </span>            : StackBaseShape::StackBaseShape(Shape* shape)
<span class="lineNum">    1092 </span>            :   : flags(shape-&gt;getObjectFlags()),
<span class="lineNum">    1093 </span><span class="lineCov">          1 :     clasp(shape-&gt;getObjectClass())</span>
<span class="lineNum">    1094 </span>            : {}
<span class="lineNum">    1095 </span>            : 
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">          1 : class MOZ_RAII AutoRooterGetterSetter</span></a>
<span class="lineNum">    1097 </span>            : {
<span class="lineNum">    1098 </span><span class="lineCov">          1 :     class Inner final : private JS::CustomAutoRooter</span>
<span class="lineNum">    1099 </span>            :     {
<span class="lineNum">    1100 </span>            :       public:
<span class="lineNum">    1101 </span>            :         inline Inner(JSContext* cx, uint8_t attrs, GetterOp* pgetter_, SetterOp* psetter_);
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span>            :       private:
<span class="lineNum">    1104 </span>            :         virtual void trace(JSTracer* trc);
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            :         uint8_t attrs;
<span class="lineNum">    1107 </span>            :         GetterOp* pgetter;
<span class="lineNum">    1108 </span>            :         SetterOp* psetter;
<span class="lineNum">    1109 </span>            :     };
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :   public:
<span class="lineNum">    1112 </span>            :     inline AutoRooterGetterSetter(JSContext* cx, uint8_t attrs,
<span class="lineNum">    1113 </span>            :                                   GetterOp* pgetter, SetterOp* psetter
<span class="lineNum">    1114 </span>            :                                   MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
<span class="lineNum">    1115 </span>            :     inline AutoRooterGetterSetter(JSContext* cx, uint8_t attrs,
<span class="lineNum">    1116 </span>            :                                   JSNative* pgetter, JSNative* psetter
<span class="lineNum">    1117 </span>            :                                   MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            :   private:
<span class="lineNum">    1120 </span>            :     mozilla::Maybe&lt;Inner&gt; inner;
<span class="lineNum">    1121 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    1122 </span>            : };
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            : struct EmptyShape : public js::Shape
<span class="lineNum">    1125 </span>            : {
<span class="lineNum">    1126 </span>            :     EmptyShape(UnownedBaseShape* base, uint32_t nfixed)
<span class="lineNum">    1127 </span><span class="lineCov">          1 :       : js::Shape(base, nfixed)</span>
<span class="lineNum">    1128 </span>            :     { }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :     static Shape* new_(JSContext* cx, Handle&lt;UnownedBaseShape*&gt; base, uint32_t nfixed);
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :     /*
<span class="lineNum">    1133 </span>            :      * Lookup an initial shape matching the given parameters, creating an empty
<span class="lineNum">    1134 </span>            :      * shape if none was found.
<span class="lineNum">    1135 </span>            :      */
<span class="lineNum">    1136 </span>            :     static Shape* getInitialShape(JSContext* cx, const Class* clasp,
<span class="lineNum">    1137 </span>            :                                   TaggedProto proto, size_t nfixed, uint32_t objectFlags = 0);
<span class="lineNum">    1138 </span>            :     static Shape* getInitialShape(JSContext* cx, const Class* clasp,
<span class="lineNum">    1139 </span>            :                                   TaggedProto proto, gc::AllocKind kind, uint32_t objectFlags = 0);
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            :     /*
<span class="lineNum">    1142 </span>            :      * Reinsert an alternate initial shape, to be returned by future
<span class="lineNum">    1143 </span>            :      * getInitialShape calls, until the new shape becomes unreachable in a GC
<span class="lineNum">    1144 </span>            :      * and the table entry is purged.
<span class="lineNum">    1145 </span>            :      */
<span class="lineNum">    1146 </span>            :     static void insertInitialShape(JSContext* cx, HandleShape shape, HandleObject proto);
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span>            :     /*
<span class="lineNum">    1149 </span>            :      * Some object subclasses are allocated with a built-in set of properties.
<span class="lineNum">    1150 </span>            :      * The first time such an object is created, these built-in properties must
<span class="lineNum">    1151 </span>            :      * be set manually, to compute an initial shape.  Afterward, that initial
<span class="lineNum">    1152 </span>            :      * shape can be reused for newly-created objects that use the subclass's
<span class="lineNum">    1153 </span>            :      * standard prototype.  This method should be used in a post-allocation
<span class="lineNum">    1154 </span>            :      * init method, to ensure that objects of such subclasses compute and cache
<span class="lineNum">    1155 </span>            :      * the initial shape, if it hasn't already been computed.
<span class="lineNum">    1156 </span>            :      */
<span class="lineNum">    1157 </span>            :     template&lt;class ObjectSubclass&gt;
<span class="lineNum">    1158 </span>            :     static inline bool
<span class="lineNum">    1159 </span>            :     ensureInitialCustomShape(JSContext* cx, Handle&lt;ObjectSubclass*&gt; obj);
<span class="lineNum">    1160 </span>            : };
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            : // InitialShapeProto stores either:
<span class="lineNum">    1163 </span>            : //
<span class="lineNum">    1164 </span>            : // * A TaggedProto (or ReadBarriered&lt;TaggedProto&gt;).
<span class="lineNum">    1165 </span>            : //
<span class="lineNum">    1166 </span>            : // * A JSProtoKey. This is used instead of the TaggedProto if the proto is one
<span class="lineNum">    1167 </span>            : //   of the global's builtin prototypes. For instance, if the proto is the
<span class="lineNum">    1168 </span>            : //   initial Object.prototype, we use key_ = JSProto_Object, proto_ = nullptr.
<span class="lineNum">    1169 </span>            : //
<span class="lineNum">    1170 </span>            : // Using the JSProtoKey here is an optimization that lets us share more shapes
<a name="1171"><span class="lineNum">    1171 </span>            : // across compartments within a zone.</a>
<span class="lineNum">    1172 </span>            : template &lt;typename PtrType&gt;
<span class="lineNum">    1173 </span><span class="lineCov">          1 : class InitialShapeProto</span>
<span class="lineNum">    1174 </span>            : {
<span class="lineNum">    1175 </span>            :     template &lt;typename T&gt; friend class InitialShapeProto;
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            :     JSProtoKey key_;
<span class="lineNum">    1178 </span>            :     PtrType proto_;
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :   public:
<span class="lineNum">    1181 </span>            :     InitialShapeProto()
<span class="lineNum">    1182 </span>            :       : key_(JSProto_LIMIT), proto_()
<span class="lineNum">    1183 </span>            :     {}
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            :     InitialShapeProto(JSProtoKey key, TaggedProto proto)
<span class="lineNum">    1186 </span>            :       : key_(key), proto_(proto)
<span class="lineNum">    1187 </span>            :     {}
<a name="1188"><span class="lineNum">    1188 </span>            : </a>
<span class="lineNum">    1189 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    1190 </span><span class="lineCov">          1 :     explicit InitialShapeProto(const InitialShapeProto&lt;T&gt;&amp; other)</span>
<span class="lineNum">    1191 </span><span class="lineCov">          1 :       : key_(other.key()), proto_(other.proto_)</span>
<span class="lineNum">    1192 </span><span class="lineCov">          1 :     {}</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            :     explicit InitialShapeProto(TaggedProto proto)
<span class="lineNum">    1195 </span><span class="lineCov">          1 :       : key_(JSProto_LIMIT), proto_(proto)</span>
<span class="lineNum">    1196 </span>            :     {}
<span class="lineNum">    1197 </span>            :     explicit InitialShapeProto(JSProtoKey key)
<span class="lineNum">    1198 </span><span class="lineCov">          1 :       : key_(key), proto_(nullptr)</span>
<span class="lineNum">    1199 </span>            :     {
<span class="lineNum">    1200 </span>            :         MOZ_ASSERT(key &lt; JSProto_LIMIT);
<span class="lineNum">    1201 </span>            :     }
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :     HashNumber hashCode() const {
<span class="lineNum">    1204 </span><span class="lineCov">          1 :         return proto_.hashCode() ^ HashNumber(key_);</span>
<a name="1205"><span class="lineNum">    1205 </span>            :     }</a>
<span class="lineNum">    1206 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    1207 </span><span class="lineCov">          1 :     bool match(const InitialShapeProto&lt;T&gt;&amp; other) const {</span>
<span class="lineNum">    1208 </span>            :         return key_ == other.key_ &amp;&amp;
<span class="lineNum">    1209 </span><span class="lineCov">          1 :                proto_.uniqueId() == other.proto_.unbarrieredGet().uniqueId();</span>
<span class="lineNum">    1210 </span>            :     }
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :     JSProtoKey key() const {
<span class="lineNum">    1213 </span>            :         return key_;
<span class="lineNum">    1214 </span>            :     }
<span class="lineNum">    1215 </span>            :     const PtrType&amp; proto() const {
<a name="1216"><span class="lineNum">    1216 </span><span class="lineCov">          1 :         return proto_;</span></a>
<span class="lineNum">    1217 </span>            :     }
<span class="lineNum">    1218 </span><span class="lineCov">          1 :     void setProto(TaggedProto proto) {</span>
<span class="lineNum">    1219 </span><span class="lineCov">          1 :         proto_ = proto;</span>
<span class="lineNum">    1220 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    1221 </span>            : };
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            : /*
<span class="lineNum">    1224 </span>            :  * Entries for the per-zone initialShapes set indexing initial shapes for
<a name="1225"><span class="lineNum">    1225 </span>            :  * objects in the zone and the associated types.</a>
<span class="lineNum">    1226 </span>            :  */
<span class="lineNum">    1227 </span><span class="lineCov">          1 : struct InitialShapeEntry</span>
<span class="lineNum">    1228 </span>            : {
<span class="lineNum">    1229 </span>            :     /*
<span class="lineNum">    1230 </span>            :      * Initial shape to give to the object. This is an empty shape, except for
<span class="lineNum">    1231 </span>            :      * certain classes (e.g. String, RegExp) which may add certain baked-in
<span class="lineNum">    1232 </span>            :      * properties.
<span class="lineNum">    1233 </span>            :      */
<span class="lineNum">    1234 </span>            :     ReadBarriered&lt;Shape*&gt; shape;
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span>            :     /*
<span class="lineNum">    1237 </span>            :      * Matching prototype for the entry. The shape of an object determines its
<span class="lineNum">    1238 </span>            :      * prototype, but the prototype cannot be determined from the shape itself.
<span class="lineNum">    1239 </span>            :      */
<span class="lineNum">    1240 </span>            :     using ShapeProto = InitialShapeProto&lt;ReadBarriered&lt;TaggedProto&gt;&gt;;
<span class="lineNum">    1241 </span>            :     ShapeProto proto;
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            :     /* State used to determine a match on an initial shape. */
<span class="lineNum">    1244 </span>            :     struct Lookup {
<span class="lineNum">    1245 </span>            :         using ShapeProto = InitialShapeProto&lt;TaggedProto&gt;;
<span class="lineNum">    1246 </span>            :         const Class* clasp;
<span class="lineNum">    1247 </span>            :         ShapeProto proto;
<span class="lineNum">    1248 </span>            :         uint32_t nfixed;
<span class="lineNum">    1249 </span>            :         uint32_t baseFlags;
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            :         Lookup(const Class* clasp, ShapeProto proto, uint32_t nfixed, uint32_t baseFlags)
<span class="lineNum">    1252 </span><span class="lineCov">          1 :           : clasp(clasp), proto(proto), nfixed(nfixed), baseFlags(baseFlags)</span>
<span class="lineNum">    1253 </span>            :         {}
<span class="lineNum">    1254 </span>            :     };
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :     inline InitialShapeEntry();
<span class="lineNum">    1257 </span>            :     inline InitialShapeEntry(Shape* shape, const Lookup::ShapeProto&amp; proto);
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            :     static inline HashNumber hash(const Lookup&amp; lookup);
<span class="lineNum">    1260 </span>            :     static inline bool match(const InitialShapeEntry&amp; key, const Lookup&amp; lookup);
<a name="1261"><span class="lineNum">    1261 </span>            :     static void rekey(InitialShapeEntry&amp; k, const InitialShapeEntry&amp; newKey) { k = newKey; }</a>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span><span class="lineCov">          1 :     bool needsSweep() {</span>
<span class="lineNum">    1264 </span><span class="lineCov">          1 :         Shape* ushape = shape.unbarrieredGet();</span>
<span class="lineNum">    1265 </span><span class="lineCov">          1 :         TaggedProto uproto = proto.proto().unbarrieredGet();</span>
<span class="lineNum">    1266 </span><span class="lineCov">          1 :         JSObject* protoObj = uproto.raw();</span>
<span class="lineNum">    1267 </span><span class="lineCov">          1 :         return (gc::IsAboutToBeFinalizedUnbarriered(&amp;ushape) ||</span>
<span class="lineNum">    1268 </span><span class="lineCov">          1 :                 (uproto.isObject() &amp;&amp; gc::IsAboutToBeFinalizedUnbarriered(&amp;protoObj)));</span>
<span class="lineNum">    1269 </span>            :     }
<span class="lineNum">    1270 </span>            : };
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : using InitialShapeSet = JS::GCHashSet&lt;InitialShapeEntry, InitialShapeEntry, SystemAllocPolicy&gt;;
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            : struct StackShape
<span class="lineNum">    1275 </span>            : {
<span class="lineNum">    1276 </span>            :     /* For performance, StackShape only roots when absolutely necessary. */
<span class="lineNum">    1277 </span>            :     UnownedBaseShape* base;
<span class="lineNum">    1278 </span>            :     jsid propid;
<span class="lineNum">    1279 </span>            :     GetterOp rawGetter;
<span class="lineNum">    1280 </span>            :     SetterOp rawSetter;
<span class="lineNum">    1281 </span>            :     uint32_t slot_;
<span class="lineNum">    1282 </span>            :     uint8_t attrs;
<span class="lineNum">    1283 </span>            :     uint8_t flags;
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            :     explicit StackShape(UnownedBaseShape* base, jsid propid, uint32_t slot,
<span class="lineNum">    1286 </span>            :                         unsigned attrs, unsigned flags)
<span class="lineNum">    1287 </span>            :       : base(base),
<span class="lineNum">    1288 </span>            :         propid(propid),
<span class="lineNum">    1289 </span>            :         rawGetter(nullptr),
<span class="lineNum">    1290 </span>            :         rawSetter(nullptr),
<span class="lineNum">    1291 </span>            :         slot_(slot),
<span class="lineNum">    1292 </span>            :         attrs(uint8_t(attrs)),
<span class="lineNum">    1293 </span><span class="lineCov">          1 :         flags(uint8_t(flags))</span>
<span class="lineNum">    1294 </span>            :     {
<span class="lineNum">    1295 </span>            :         MOZ_ASSERT(base);
<span class="lineNum">    1296 </span>            :         MOZ_ASSERT(!JSID_IS_VOID(propid));
<span class="lineNum">    1297 </span>            :         MOZ_ASSERT(slot &lt;= SHAPE_INVALID_SLOT);
<span class="lineNum">    1298 </span>            :         MOZ_ASSERT_IF(attrs &amp; (JSPROP_GETTER | JSPROP_SETTER), attrs &amp; JSPROP_SHARED);
<a name="1299"><span class="lineNum">    1299 </span>            :     }</a>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineCov">          1 :     explicit StackShape(Shape* shape)</span>
<span class="lineNum">    1302 </span><span class="lineCov">          1 :       : base(shape-&gt;base()-&gt;unowned()),</span>
<span class="lineNum">    1303 </span>            :         propid(shape-&gt;propidRef()),
<span class="lineNum">    1304 </span>            :         rawGetter(shape-&gt;getter()),
<span class="lineNum">    1305 </span>            :         rawSetter(shape-&gt;setter()),
<span class="lineNum">    1306 </span><span class="lineCov">          1 :         slot_(shape-&gt;maybeSlot()),</span>
<span class="lineNum">    1307 </span>            :         attrs(shape-&gt;attrs),
<span class="lineNum">    1308 </span><span class="lineCov">          1 :         flags(shape-&gt;flags)</span>
<span class="lineNum">    1309 </span><span class="lineCov">          1 :     {}</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            :     void updateGetterSetter(GetterOp rawGetter, SetterOp rawSetter) {
<span class="lineNum">    1312 </span><span class="lineCov">          1 :         if (rawGetter || rawSetter || (attrs &amp; (JSPROP_GETTER|JSPROP_SETTER)))</span>
<span class="lineNum">    1313 </span><span class="lineCov">          1 :             flags |= Shape::ACCESSOR_SHAPE;</span>
<span class="lineNum">    1314 </span>            :         else
<span class="lineNum">    1315 </span><span class="lineCov">          1 :             flags &amp;= ~Shape::ACCESSOR_SHAPE;</span>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span><span class="lineCov">          1 :         this-&gt;rawGetter = rawGetter;</span>
<span class="lineNum">    1318 </span><span class="lineCov">          1 :         this-&gt;rawSetter = rawSetter;</span>
<span class="lineNum">    1319 </span>            :     }
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span><span class="lineCov">          1 :     bool hasSlot() const { return (attrs &amp; JSPROP_SHARED) == 0; }</span>
<span class="lineNum">    1322 </span><span class="lineCov">          1 :     bool hasMissingSlot() const { return maybeSlot() == SHAPE_INVALID_SLOT; }</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            :     uint32_t slot() const { MOZ_ASSERT(hasSlot() &amp;&amp; !hasMissingSlot()); return slot_; }
<span class="lineNum">    1325 </span>            :     uint32_t maybeSlot() const { return slot_; }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            :     uint32_t slotSpan() const {
<span class="lineNum">    1328 </span>            :         uint32_t free = JSSLOT_FREE(base-&gt;clasp_);
<span class="lineNum">    1329 </span>            :         return hasMissingSlot() ? free : (maybeSlot() + 1);
<span class="lineNum">    1330 </span>            :     }
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            :     void setSlot(uint32_t slot) {
<span class="lineNum">    1333 </span>            :         MOZ_ASSERT(slot &lt;= SHAPE_INVALID_SLOT);
<span class="lineNum">    1334 </span><span class="lineCov">          1 :         slot_ = slot;</span>
<span class="lineNum">    1335 </span>            :     }
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            :     bool isAccessorShape() const {
<span class="lineNum">    1338 </span><span class="lineCov">          1 :         return flags &amp; Shape::ACCESSOR_SHAPE;</span>
<a name="1339"><span class="lineNum">    1339 </span>            :     }</a>
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineCov">          1 :     HashNumber hash() const {</span>
<span class="lineNum">    1342 </span><span class="lineCov">          1 :         HashNumber hash = uintptr_t(base);</span>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            :         /* Accumulate from least to most random so the low bits are most random. */
<span class="lineNum">    1345 </span><span class="lineCov">          1 :         hash = mozilla::RotateLeft(hash, 4) ^ attrs;</span>
<span class="lineNum">    1346 </span><span class="lineCov">          1 :         hash = mozilla::RotateLeft(hash, 4) ^ slot_;</span>
<span class="lineNum">    1347 </span><span class="lineCov">          1 :         hash = mozilla::RotateLeft(hash, 4) ^ HashId(propid);</span>
<span class="lineNum">    1348 </span><span class="lineCov">          1 :         hash = mozilla::RotateLeft(hash, 4) ^ uintptr_t(rawGetter);</span>
<span class="lineNum">    1349 </span><span class="lineCov">          1 :         hash = mozilla::RotateLeft(hash, 4) ^ uintptr_t(rawSetter);</span>
<span class="lineNum">    1350 </span><span class="lineCov">          1 :         return hash;</span>
<span class="lineNum">    1351 </span>            :     }
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :     // Traceable implementation.
<span class="lineNum">    1354 </span>            :     static void trace(StackShape* stackShape, JSTracer* trc) { stackShape-&gt;trace(trc); }
<span class="lineNum">    1355 </span>            :     void trace(JSTracer* trc);
<span class="lineNum">    1356 </span>            : };
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : template &lt;typename Wrapper&gt;
<span class="lineNum">    1359 </span>            : class WrappedPtrOperations&lt;StackShape, Wrapper&gt;
<span class="lineNum">    1360 </span>            : {
<span class="lineNum">    1361 </span>            :     const StackShape&amp; ss() const { return static_cast&lt;const Wrapper*&gt;(this)-&gt;get(); }
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            :   public:
<span class="lineNum">    1364 </span>            :     bool hasSlot() const { return ss().hasSlot(); }
<span class="lineNum">    1365 </span><span class="lineCov">          1 :     bool hasMissingSlot() const { return ss().hasMissingSlot(); }</span>
<span class="lineNum">    1366 </span>            :     uint32_t slot() const { return ss().slot(); }
<span class="lineNum">    1367 </span>            :     uint32_t maybeSlot() const { return ss().maybeSlot(); }
<span class="lineNum">    1368 </span>            :     uint32_t slotSpan() const { return ss().slotSpan(); }
<span class="lineNum">    1369 </span>            :     bool isAccessorShape() const { return ss().isAccessorShape(); }
<span class="lineNum">    1370 </span><span class="lineCov">          1 :     uint8_t attrs() const { return ss().attrs; }</span>
<span class="lineNum">    1371 </span>            : };
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            : template &lt;typename Wrapper&gt;
<span class="lineNum">    1374 </span>            : class MutableWrappedPtrOperations&lt;StackShape, Wrapper&gt;
<span class="lineNum">    1375 </span>            :   : public WrappedPtrOperations&lt;StackShape, Wrapper&gt;
<span class="lineNum">    1376 </span>            : {
<span class="lineNum">    1377 </span>            :     StackShape&amp; ss() { return static_cast&lt;Wrapper*&gt;(this)-&gt;get(); }
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :   public:
<span class="lineNum">    1380 </span>            :     void updateGetterSetter(GetterOp rawGetter, SetterOp rawSetter) {
<span class="lineNum">    1381 </span><span class="lineCov">          1 :         ss().updateGetterSetter(rawGetter, rawSetter);</span>
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span><span class="lineCov">          1 :     void setSlot(uint32_t slot) { ss().setSlot(slot); }</span>
<span class="lineNum">    1384 </span><span class="lineCov">          1 :     void setBase(UnownedBaseShape* base) { ss().base = base; }</span>
<span class="lineNum">    1385 </span><span class="lineCov">          1 :     void setAttrs(uint8_t attrs) { ss().attrs = attrs; }</span>
<span class="lineNum">    1386 </span>            : };
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            : inline
<span class="lineNum">    1389 </span>            : Shape::Shape(const StackShape&amp; other, uint32_t nfixed)
<span class="lineNum">    1390 </span>            :   : base_(other.base),
<span class="lineNum">    1391 </span>            :     propid_(other.propid),
<span class="lineNum">    1392 </span><span class="lineCov">          1 :     slotInfo(other.maybeSlot() | (nfixed &lt;&lt; FIXED_SLOTS_SHIFT)),</span>
<span class="lineNum">    1393 </span>            :     attrs(other.attrs),
<span class="lineNum">    1394 </span>            :     flags(other.flags),
<span class="lineNum">    1395 </span><span class="lineCov">          1 :     parent(nullptr)</span>
<span class="lineNum">    1396 </span>            : {
<span class="lineNum">    1397 </span>            : #ifdef DEBUG
<span class="lineNum">    1398 </span>            :     gc::AllocKind allocKind = getAllocKind();
<span class="lineNum">    1399 </span>            :     MOZ_ASSERT_IF(other.isAccessorShape(), allocKind == gc::AllocKind::ACCESSOR_SHAPE);
<span class="lineNum">    1400 </span>            :     MOZ_ASSERT_IF(allocKind == gc::AllocKind::SHAPE, !other.isAccessorShape());
<span class="lineNum">    1401 </span>            : #endif
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            :     MOZ_ASSERT_IF(!isEmptyShape(), AtomIsMarked(zone(), propid()));
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span>            :     MOZ_ASSERT_IF(attrs &amp; (JSPROP_GETTER | JSPROP_SETTER), attrs &amp; JSPROP_SHARED);
<span class="lineNum">    1406 </span><span class="lineCov">          1 :     kids.setNull();</span>
<span class="lineNum">    1407 </span>            : }
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            : // This class is used to add a post barrier on the AccessorShape's getter/setter
<a name="1410"><span class="lineNum">    1410 </span>            : // objects. It updates the pointers and the shape's entry in the parent's</a>
<span class="lineNum">    1411 </span>            : // KidsHash table.
<span class="lineNum">    1412 </span><span class="lineCov">          1 : class ShapeGetterSetterRef : public gc::BufferableRef</span>
<span class="lineNum">    1413 </span>            : {
<span class="lineNum">    1414 </span>            :     AccessorShape* shape_;
<span class="lineNum">    1415 </span>            : 
<a name="1416"><span class="lineNum">    1416 </span>            :   public:</a>
<span class="lineNum">    1417 </span><span class="lineCov">          1 :     explicit ShapeGetterSetterRef(AccessorShape* shape) : shape_(shape) {}</span>
<span class="lineNum">    1418 </span><span class="lineCov">          1 :     void trace(JSTracer* trc) override { shape_-&gt;fixupGetterSetterForBarrier(trc); }</span>
<span class="lineNum">    1419 </span>            : };
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<span class="lineNum">    1421 </span>            : static inline void
<span class="lineNum">    1422 </span><span class="lineCov">          1 : GetterSetterWriteBarrierPost(AccessorShape* shape)</span>
<span class="lineNum">    1423 </span>            : {
<span class="lineNum">    1424 </span>            :     MOZ_ASSERT(shape);
<span class="lineNum">    1425 </span><span class="lineCov">          1 :     if (shape-&gt;hasGetterObject()) {</span>
<span class="lineNum">    1426 </span><span class="lineCov">          1 :         gc::StoreBuffer* sb = reinterpret_cast&lt;gc::Cell*&gt;(shape-&gt;getterObject())-&gt;storeBuffer();</span>
<span class="lineNum">    1427 </span><span class="lineCov">          1 :         if (sb) {</span>
<span class="lineNum">    1428 </span><span class="lineCov">          1 :             sb-&gt;putGeneric(ShapeGetterSetterRef(shape));</span>
<span class="lineNum">    1429 </span><span class="lineCov">          1 :             return;</span>
<span class="lineNum">    1430 </span>            :         }
<span class="lineNum">    1431 </span>            :     }
<span class="lineNum">    1432 </span><span class="lineCov">          1 :     if (shape-&gt;hasSetterObject()) {</span>
<span class="lineNum">    1433 </span><span class="lineCov">          1 :         gc::StoreBuffer* sb = reinterpret_cast&lt;gc::Cell*&gt;(shape-&gt;setterObject())-&gt;storeBuffer();</span>
<span class="lineNum">    1434 </span><span class="lineCov">          1 :         if (sb) {</span>
<span class="lineNum">    1435 </span><span class="lineCov">          1 :             sb-&gt;putGeneric(ShapeGetterSetterRef(shape));</span>
<span class="lineNum">    1436 </span><span class="lineCov">          1 :             return;</span>
<span class="lineNum">    1437 </span>            :         }
<span class="lineNum">    1438 </span>            :     }
<span class="lineNum">    1439 </span>            : }
<a name="1440"><span class="lineNum">    1440 </span>            : </a>
<span class="lineNum">    1441 </span>            : inline
<span class="lineNum">    1442 </span><span class="lineCov">          1 : AccessorShape::AccessorShape(const StackShape&amp; other, uint32_t nfixed)</span>
<span class="lineNum">    1443 </span>            :   : Shape(other, nfixed),
<span class="lineNum">    1444 </span>            :     rawGetter(other.rawGetter),
<span class="lineNum">    1445 </span><span class="lineCov">          1 :     rawSetter(other.rawSetter)</span>
<span class="lineNum">    1446 </span>            : {
<span class="lineNum">    1447 </span>            :     MOZ_ASSERT(getAllocKind() == gc::AllocKind::ACCESSOR_SHAPE);
<span class="lineNum">    1448 </span><span class="lineCov">          1 :     GetterSetterWriteBarrierPost(this);</span>
<span class="lineNum">    1449 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            : inline
<span class="lineNum">    1452 </span>            : Shape::Shape(UnownedBaseShape* base, uint32_t nfixed)
<span class="lineNum">    1453 </span>            :   : base_(base),
<span class="lineNum">    1454 </span>            :     propid_(JSID_EMPTY),
<span class="lineNum">    1455 </span><span class="lineCov">          1 :     slotInfo(SHAPE_INVALID_SLOT | (nfixed &lt;&lt; FIXED_SLOTS_SHIFT)),</span>
<span class="lineNum">    1456 </span>            :     attrs(JSPROP_SHARED),
<span class="lineNum">    1457 </span>            :     flags(0),
<span class="lineNum">    1458 </span><span class="lineCov">          1 :     parent(nullptr)</span>
<span class="lineNum">    1459 </span>            : {
<span class="lineNum">    1460 </span>            :     MOZ_ASSERT(base);
<span class="lineNum">    1461 </span><span class="lineCov">          1 :     kids.setNull();</span>
<span class="lineNum">    1462 </span>            : }
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span>            : inline GetterOp
<span class="lineNum">    1465 </span>            : Shape::getter() const
<span class="lineNum">    1466 </span>            : {
<span class="lineNum">    1467 </span><span class="lineCov">          1 :     return isAccessorShape() ? asAccessorShape().rawGetter : nullptr;</span>
<span class="lineNum">    1468 </span>            : }
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            : inline SetterOp
<span class="lineNum">    1471 </span>            : Shape::setter() const
<span class="lineNum">    1472 </span>            : {
<span class="lineNum">    1473 </span><span class="lineCov">          1 :     return isAccessorShape() ? asAccessorShape().rawSetter : nullptr;</span>
<span class="lineNum">    1474 </span>            : }
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            : inline JSObject*
<span class="lineNum">    1477 </span>            : Shape::getterObject() const
<span class="lineNum">    1478 </span>            : {
<span class="lineNum">    1479 </span>            :     MOZ_ASSERT(hasGetterValue());
<span class="lineNum">    1480 </span><span class="lineCov">          1 :     return asAccessorShape().getterObj;</span>
<span class="lineNum">    1481 </span>            : }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            : inline JSObject*
<span class="lineNum">    1484 </span>            : Shape::setterObject() const
<span class="lineNum">    1485 </span>            : {
<span class="lineNum">    1486 </span>            :     MOZ_ASSERT(hasSetterValue());
<span class="lineNum">    1487 </span><span class="lineCov">          1 :     return asAccessorShape().setterObj;</span>
<span class="lineNum">    1488 </span>            : }
<a name="1489"><span class="lineNum">    1489 </span>            : </a>
<span class="lineNum">    1490 </span>            : inline void
<span class="lineNum">    1491 </span><span class="lineCov">          1 : Shape::initDictionaryShape(const StackShape&amp; child, uint32_t nfixed, GCPtrShape* dictp)</span>
<span class="lineNum">    1492 </span>            : {
<span class="lineNum">    1493 </span><span class="lineCov">          1 :     if (child.isAccessorShape())</span>
<span class="lineNum">    1494 </span><span class="lineCov">          1 :         new (this) AccessorShape(child, nfixed);</span>
<span class="lineNum">    1495 </span>            :     else
<span class="lineNum">    1496 </span><span class="lineCov">          1 :         new (this) Shape(child, nfixed);</span>
<span class="lineNum">    1497 </span><span class="lineCov">          1 :     this-&gt;flags |= IN_DICTIONARY;</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineCov">          1 :     this-&gt;listp = nullptr;</span>
<span class="lineNum">    1500 </span><span class="lineCov">          1 :     if (dictp)</span>
<span class="lineNum">    1501 </span><span class="lineCov">          1 :         insertIntoDictionary(dictp);</span>
<span class="lineNum">    1502 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span>            : inline Shape*
<span class="lineNum">    1505 </span>            : Shape::searchLinear(jsid id)
<span class="lineNum">    1506 </span>            : {
<span class="lineNum">    1507 </span><span class="lineCov">          1 :     for (Shape* shape = this; shape; ) {</span>
<span class="lineNum">    1508 </span><span class="lineCov">          1 :         if (shape-&gt;propidRef() == id)</span>
<span class="lineNum">    1509 </span><span class="lineCov">          1 :             return shape;</span>
<span class="lineNum">    1510 </span><span class="lineCov">          1 :         shape = shape-&gt;parent;</span>
<span class="lineNum">    1511 </span>            :     }
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            :     return nullptr;
<span class="lineNum">    1514 </span>            : }
<a name="1515"><span class="lineNum">    1515 </span>            : </a>
<span class="lineNum">    1516 </span>            : inline bool
<span class="lineNum">    1517 </span><span class="lineCov">          1 : Shape::matches(const StackShape&amp; other) const</span>
<span class="lineNum">    1518 </span>            : {
<span class="lineNum">    1519 </span><span class="lineCov">          1 :     return propid_.get() == other.propid &amp;&amp;</span>
<span class="lineNum">    1520 </span>            :            matchesParamsAfterId(other.base, other.slot_, other.attrs, other.flags,
<span class="lineNum">    1521 </span><span class="lineCov">          1 :                                 other.rawGetter, other.rawSetter);</span>
<span class="lineNum">    1522 </span>            : }
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            : Shape*
<span class="lineNum">    1525 </span>            : ReshapeForAllocKind(JSContext* cx, Shape* shape, TaggedProto proto,
<span class="lineNum">    1526 </span>            :                     gc::AllocKind allocKind);
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            : } // namespace js
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            : #ifdef _MSC_VER
<span class="lineNum">    1531 </span>            : #pragma warning(pop)
<span class="lineNum">    1532 </span>            : #pragma warning(pop)
<span class="lineNum">    1533 </span>            : #endif
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            : // JS::ubi::Nodes can point to Shapes and BaseShapes; they're js::gc::Cell
<span class="lineNum">    1536 </span>            : // instances that occupy a compartment.
<span class="lineNum">    1537 </span>            : namespace JS {
<span class="lineNum">    1538 </span>            : namespace ubi {
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            : template&lt;&gt;
<span class="lineNum">    1541 </span>            : class Concrete&lt;js::Shape&gt; : TracerConcrete&lt;js::Shape&gt; {
<span class="lineNum">    1542 </span>            :   protected:
<span class="lineNum">    1543 </span><span class="lineCov">          1 :     explicit Concrete(js::Shape *ptr) : TracerConcrete&lt;js::Shape&gt;(ptr) { }</span>
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            :   public:
<span class="lineNum">    1546 </span><span class="lineCov">          1 :     static void construct(void *storage, js::Shape *ptr) { new (storage) Concrete(ptr); }</span>
<span class="lineNum">    1547 </span>            : 
<a name="1548"><span class="lineNum">    1548 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;</a>
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span><span class="lineCov">          1 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1551 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1552 </span>            : };
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            : template&lt;&gt;
<span class="lineNum">    1555 </span>            : class Concrete&lt;js::BaseShape&gt; : TracerConcrete&lt;js::BaseShape&gt; {
<span class="lineNum">    1556 </span>            :   protected:
<span class="lineNum">    1557 </span><span class="lineCov">          1 :     explicit Concrete(js::BaseShape *ptr) : TracerConcrete&lt;js::BaseShape&gt;(ptr) { }</span>
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            :   public:
<span class="lineNum">    1560 </span><span class="lineCov">          1 :     static void construct(void *storage, js::BaseShape *ptr) { new (storage) Concrete(ptr); }</span>
<span class="lineNum">    1561 </span>            : 
<a name="1562"><span class="lineNum">    1562 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;</a>
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineCov">          1 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1565 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1566 </span>            : };
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            : } // namespace ubi
<span class="lineNum">    1569 </span>            : } // namespace JS
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            : #endif /* vm_Shape_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
