<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/pdf/SkPDFDevice.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/pdf</a> - SkPDFDevice.cpp<span style="font-size: 80%;"> (source / <a href="SkPDFDevice.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1135</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">89</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2011 Google Inc.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;SkPDFDevice.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;SkAdvancedTypefaceMetrics.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;SkAnnotationKeys.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;SkBitmapDevice.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;SkBitmapKey.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;SkColor.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;SkColorFilter.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;SkDraw.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;SkDrawFilter.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;SkGlyphCache.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;SkImageFilterCache.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;SkMakeUnique.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;SkPath.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;SkPathEffect.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;SkPathOps.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;SkPDFBitmap.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;SkPDFCanon.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;SkPDFDocument.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;SkPDFFont.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;SkPDFFormXObject.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;SkPDFGraphicState.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;SkPDFResourceDict.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;SkPDFShader.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;SkPDFTypes.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;SkPDFUtils.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;SkPixelRef.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;SkRasterClip.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;SkRRect.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;SkScopeExit.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;SkString.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;SkSurface.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;SkTemplates.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;SkTextBlobRunIterator.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;SkTextFormatParams.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;SkUtils.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;SkXfermodeInterpretation.h&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #define DPI_FOR_RASTER_SCALE_ONE 72
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : // Utility functions
<span class="lineNum">      49 </span>            : 
<a name="50"><span class="lineNum">      50 </span>            : // If the paint will definitely draw opaquely, replace kSrc with</a>
<span class="lineNum">      51 </span>            : // kSrcOver.  http://crbug.com/473572
<span class="lineNum">      52 </span><span class="lineNoCov">          0 : static void replace_srcmode_on_opaque_paint(SkPaint* paint) {</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     if (kSrcOver_SkXfermodeInterpretation == SkInterpretXfermode(*paint, false)) {</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :         paint-&gt;setBlendMode(SkBlendMode::kSrcOver);</span>
<span class="lineNum">      55 </span>            :     }
<a name="56"><span class="lineNum">      56 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : static void emit_pdf_color(SkColor color, SkWStream* result) {</span>
<span class="lineNum">      59 </span>            :     SkASSERT(SkColorGetA(color) == 0xFF);  // We handle alpha elsewhere.
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendColorComponent(SkColorGetR(color), result);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     result-&gt;writeText(&quot; &quot;);</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendColorComponent(SkColorGetG(color), result);</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     result-&gt;writeText(&quot; &quot;);</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendColorComponent(SkColorGetB(color), result);</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     result-&gt;writeText(&quot; &quot;);</span>
<a name="66"><span class="lineNum">      66 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineNoCov">          0 : static SkPaint calculate_text_paint(const SkPaint&amp; paint) {</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     SkPaint result = paint;</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     if (result.isFakeBoldText()) {</span>
<span class="lineNum">      71 </span>            :         SkScalar fakeBoldScale = SkScalarInterpFunc(result.getTextSize(),
<span class="lineNum">      72 </span>            :                                                     kStdFakeBoldInterpKeys,
<span class="lineNum">      73 </span>            :                                                     kStdFakeBoldInterpValues,
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :                                                     kStdFakeBoldInterpLength);</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :         SkScalar width = SkScalarMul(result.getTextSize(), fakeBoldScale);</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :         if (result.getStyle() == SkPaint::kFill_Style) {</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :             result.setStyle(SkPaint::kStrokeAndFill_Style);</span>
<span class="lineNum">      78 </span>            :         } else {
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :             width += result.getStrokeWidth();</span>
<span class="lineNum">      80 </span>            :         }
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :         result.setStrokeWidth(width);</span>
<span class="lineNum">      82 </span>            :     }
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     return result;</span>
<a name="84"><span class="lineNum">      84 </span>            : }</a>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : static SkImageSubset make_image_subset(const SkBitmap&amp; bitmap) {</span>
<span class="lineNum">      87 </span>            :     SkASSERT(!bitmap.drawsNothing());
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     SkIRect subset = bitmap.getSubset();</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     SkAutoLockPixels autoLockPixels(bitmap);</span>
<span class="lineNum">      90 </span>            :     SkASSERT(bitmap.pixelRef());
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     SkBitmap tmp;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     tmp.setInfo(bitmap.pixelRef()-&gt;info(), bitmap.rowBytes());</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     tmp.setPixelRef(bitmap.pixelRef());</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     tmp.lockPixels();</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     auto img = SkImage::MakeFromBitmap(tmp);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     if (img) {</span>
<span class="lineNum">      97 </span>            :         SkASSERT(!bitmap.isImmutable() || img-&gt;uniqueID() == bitmap.getGenerationID());
<span class="lineNum">      98 </span>            :         SkASSERT(img-&gt;bounds().contains(subset));
<span class="lineNum">      99 </span>            :     }
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     SkImageSubset imageSubset(std::move(img), subset);</span>
<span class="lineNum">     101 </span>            :     // SkImage::MakeFromBitmap only preserves genID for immutable
<span class="lineNum">     102 </span>            :     // bitmaps.  Use the bitmap's original ID for de-duping.
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     imageSubset.setID(bitmap.getGenerationID());</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     return imageSubset;</span>
<a name="105"><span class="lineNum">     105 </span>            : }</a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : SkPDFDevice::GraphicStateEntry::GraphicStateEntry()</span>
<span class="lineNum">     108 </span>            :     : fColor(SK_ColorBLACK)
<span class="lineNum">     109 </span>            :     , fTextScaleX(SK_Scalar1)
<span class="lineNum">     110 </span>            :     , fTextFill(SkPaint::kFill_Style)
<span class="lineNum">     111 </span>            :     , fShaderIndex(-1)
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     , fGraphicStateIndex(-1) {</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     fMatrix.reset();</span>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineNoCov">          0 : bool SkPDFDevice::GraphicStateEntry::compareInitialState(</span>
<span class="lineNum">     117 </span>            :         const GraphicStateEntry&amp; cur) {
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     return fColor == cur.fColor &amp;&amp;</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :            fShaderIndex == cur.fShaderIndex &amp;&amp;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :            fGraphicStateIndex == cur.fGraphicStateIndex &amp;&amp;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :            fMatrix == cur.fMatrix &amp;&amp;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :            fClipStack == cur.fClipStack &amp;&amp;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :            (fTextScaleX == 0 ||</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                (fTextScaleX == cur.fTextScaleX &amp;&amp; fTextFill == cur.fTextFill));</span>
<a name="125"><span class="lineNum">     125 </span>            : }</a>
<span class="lineNum">     126 </span>            : 
<a name="127"><span class="lineNum">     127 </span><span class="lineNoCov">          0 : class GraphicStackState {</span></a>
<span class="lineNum">     128 </span>            : public:
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     GraphicStackState(const SkClipStack&amp; existingClipStack,</span>
<span class="lineNum">     130 </span>            :                       const SkRegion&amp; existingClipRegion,
<span class="lineNum">     131 </span>            :                       SkWStream* contentStream)
<span class="lineNum">     132 </span>            :             : fStackDepth(0),
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :               fContentStream(contentStream) {</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :         fEntries[0].fClipStack = existingClipStack;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         fEntries[0].fClipRegion = existingClipRegion;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     void updateClip(const SkClipStack&amp; clipStack, const SkRegion&amp; clipRegion,
<span class="lineNum">     139 </span>            :                     const SkPoint&amp; translation);
<span class="lineNum">     140 </span>            :     void updateMatrix(const SkMatrix&amp; matrix);
<span class="lineNum">     141 </span>            :     void updateDrawingState(const SkPDFDevice::GraphicStateEntry&amp; state);
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :     void drainStack();
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : private:
<span class="lineNum">     146 </span>            :     void push();
<span class="lineNum">     147 </span>            :     void pop();
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     SkPDFDevice::GraphicStateEntry* currentEntry() { return &amp;fEntries[fStackDepth]; }</span>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :     // Conservative limit on save depth, see impl. notes in PDF 1.4 spec.
<span class="lineNum">     151 </span>            :     static const int kMaxStackDepth = 12;
<span class="lineNum">     152 </span>            :     SkPDFDevice::GraphicStateEntry fEntries[kMaxStackDepth + 1];
<span class="lineNum">     153 </span>            :     int fStackDepth;
<span class="lineNum">     154 </span>            :     SkWStream* fContentStream;
<a name="155"><span class="lineNum">     155 </span>            : };</a>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 : void GraphicStackState::drainStack() {</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     while (fStackDepth) {</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         pop();</span>
<span class="lineNum">     160 </span>            :     }
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 : void GraphicStackState::push() {</span>
<span class="lineNum">     164 </span>            :     SkASSERT(fStackDepth &lt; kMaxStackDepth);
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     fContentStream-&gt;writeText(&quot;q\n&quot;);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     fStackDepth++;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     fEntries[fStackDepth] = fEntries[fStackDepth - 1];</span>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 : void GraphicStackState::pop() {</span>
<span class="lineNum">     171 </span>            :     SkASSERT(fStackDepth &gt; 0);
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     fContentStream-&gt;writeText(&quot;Q\n&quot;);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     fStackDepth--;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /* Calculate an inverted path's equivalent non-inverted path, given the
<span class="lineNum">     177 </span>            :  * canvas bounds.
<a name="178"><span class="lineNum">     178 </span>            :  * outPath may alias with invPath (since this is supported by PathOps).</a>
<span class="lineNum">     179 </span>            :  */
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : static bool calculate_inverse_path(const SkRect&amp; bounds, const SkPath&amp; invPath,</span>
<span class="lineNum">     181 </span>            :                                    SkPath* outPath) {
<span class="lineNum">     182 </span>            :     SkASSERT(invPath.isInverseFillType());
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     SkPath clipPath;</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     clipPath.addRect(bounds);</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     return Op(clipPath, invPath, kIntersect_SkPathOp, outPath);</span>
<span class="lineNum">     188 </span>            : }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : // Sanity check the numerical values of the SkRegion ops and PathOps ops
<span class="lineNum">     191 </span>            : // enums so region_op_to_pathops_op can do a straight passthrough cast.
<span class="lineNum">     192 </span>            : // If these are failing, it may be necessary to make region_op_to_pathops_op
<span class="lineNum">     193 </span>            : // do more.
<span class="lineNum">     194 </span>            : static_assert(SkRegion::kDifference_Op == (int)kDifference_SkPathOp, &quot;region_pathop_mismatch&quot;);
<span class="lineNum">     195 </span>            : static_assert(SkRegion::kIntersect_Op == (int)kIntersect_SkPathOp, &quot;region_pathop_mismatch&quot;);
<span class="lineNum">     196 </span>            : static_assert(SkRegion::kUnion_Op == (int)kUnion_SkPathOp, &quot;region_pathop_mismatch&quot;);
<span class="lineNum">     197 </span>            : static_assert(SkRegion::kXOR_Op == (int)kXOR_SkPathOp, &quot;region_pathop_mismatch&quot;);
<span class="lineNum">     198 </span>            : static_assert(SkRegion::kReverseDifference_Op == (int)kReverseDifference_SkPathOp,
<span class="lineNum">     199 </span>            :               &quot;region_pathop_mismatch&quot;);
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : static SkPathOp region_op_to_pathops_op(SkCanvas::ClipOp op) {
<span class="lineNum">     202 </span>            :     SkASSERT(op &gt;= 0);
<span class="lineNum">     203 </span>            :     SkASSERT(op &lt;= SkCanvas::kReverseDifference_Op);
<span class="lineNum">     204 </span>            :     return (SkPathOp)op;
<span class="lineNum">     205 </span>            : }
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : /* Uses Path Ops to calculate a vector SkPath clip from a clip stack.
<span class="lineNum">     208 </span>            :  * Returns true if successful, or false if not successful.
<span class="lineNum">     209 </span>            :  * If successful, the resulting clip is stored in outClipPath.
<span class="lineNum">     210 </span>            :  * If not successful, outClipPath is undefined, and a fallback method
<a name="211"><span class="lineNum">     211 </span>            :  * should be used.</a>
<span class="lineNum">     212 </span>            :  */
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : static bool get_clip_stack_path(const SkMatrix&amp; transform,</span>
<span class="lineNum">     214 </span>            :                                 const SkClipStack&amp; clipStack,
<span class="lineNum">     215 </span>            :                                 const SkRegion&amp; clipRegion,
<span class="lineNum">     216 </span>            :                                 SkPath* outClipPath) {
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     outClipPath-&gt;reset();</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     outClipPath-&gt;setFillType(SkPath::kInverseWinding_FillType);</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     const SkClipStack::Element* clipEntry;
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     SkClipStack::Iter iter;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     iter.reset(clipStack, SkClipStack::Iter::kBottom_IterStart);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     for (clipEntry = iter.next(); clipEntry; clipEntry = iter.next()) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         SkPath entryPath;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         if (SkClipStack::Element::kEmpty_Type == clipEntry-&gt;getType()) {</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             outClipPath-&gt;reset();</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :             outClipPath-&gt;setFillType(SkPath::kInverseWinding_FillType);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     229 </span>            :         } else {
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :             clipEntry-&gt;asPath(&amp;entryPath);</span>
<span class="lineNum">     231 </span>            :         }
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         entryPath.transform(transform);</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         if (SkCanvas::kReplace_Op == clipEntry-&gt;getOp()) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :             *outClipPath = entryPath;</span>
<span class="lineNum">     236 </span>            :         } else {
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :             SkPathOp op = region_op_to_pathops_op(clipEntry-&gt;getOp());</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :             if (!Op(*outClipPath, entryPath, op, outClipPath)) {</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     240 </span>            :             }
<span class="lineNum">     241 </span>            :         }
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     if (outClipPath-&gt;isInverseFillType()) {</span>
<span class="lineNum">     245 </span>            :         // The bounds are slightly outset to ensure this is correct in the
<span class="lineNum">     246 </span>            :         // face of floating-point accuracy and possible SkRegion bitmap
<span class="lineNum">     247 </span>            :         // approximations.
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         SkRect clipBounds = SkRect::Make(clipRegion.getBounds());</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         clipBounds.outset(SK_Scalar1, SK_Scalar1);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         if (!calculate_inverse_path(clipBounds, *outClipPath, outClipPath)) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     252 </span>            :         }
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span>            :     return true;
<span class="lineNum">     255 </span>            : }
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : // TODO(vandebo): Take advantage of SkClipStack::getSaveCount(), the PDF
<a name="258"><span class="lineNum">     258 </span>            : // graphic state stack, and the fact that we can know all the clips used</a>
<span class="lineNum">     259 </span>            : // on the page to optimize this.
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : void GraphicStackState::updateClip(const SkClipStack&amp; clipStack,</span>
<span class="lineNum">     261 </span>            :                                    const SkRegion&amp; clipRegion,
<span class="lineNum">     262 </span>            :                                    const SkPoint&amp; translation) {
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     if (clipStack == currentEntry()-&gt;fClipStack) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     265 </span>            :     }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     while (fStackDepth &gt; 0) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         pop();</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         if (clipStack == currentEntry()-&gt;fClipStack) {</span>
<span class="lineNum">     270 </span>            :             return;
<span class="lineNum">     271 </span>            :         }
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     push();</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     currentEntry()-&gt;fClipStack = clipStack;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     currentEntry()-&gt;fClipRegion = clipRegion;</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     SkMatrix transform;
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     transform.setTranslate(translation.fX, translation.fY);</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     SkPath clipPath;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     if (get_clip_stack_path(transform, clipStack, clipRegion, &amp;clipPath)) {</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         SkPDFUtils::EmitPath(clipPath, SkPaint::kFill_Style, fContentStream);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         SkPath::FillType clipFill = clipPath.getFillType();</span>
<span class="lineNum">     285 </span>            :         NOT_IMPLEMENTED(clipFill == SkPath::kInverseEvenOdd_FillType, false);
<span class="lineNum">     286 </span>            :         NOT_IMPLEMENTED(clipFill == SkPath::kInverseWinding_FillType, false);
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         if (clipFill == SkPath::kEvenOdd_FillType) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeText(&quot;W* n\n&quot;);</span>
<span class="lineNum">     289 </span>            :         } else {
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeText(&quot;W n\n&quot;);</span>
<span class="lineNum">     291 </span>            :         }
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     293 </span>            :     // If Op() fails (pathological case; e.g. input values are
<span class="lineNum">     294 </span>            :     // extremely large or NaN), emit no clip at all.
<a name="295"><span class="lineNum">     295 </span>            : }</a>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 : void GraphicStackState::updateMatrix(const SkMatrix&amp; matrix) {</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     if (matrix == currentEntry()-&gt;fMatrix) {</span>
<span class="lineNum">     299 </span>            :         return;
<span class="lineNum">     300 </span>            :     }
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     if (currentEntry()-&gt;fMatrix.getType() != SkMatrix::kIdentity_Mask) {</span>
<span class="lineNum">     303 </span>            :         SkASSERT(fStackDepth &gt; 0);
<span class="lineNum">     304 </span>            :         SkASSERT(fEntries[fStackDepth].fClipStack ==
<span class="lineNum">     305 </span>            :                  fEntries[fStackDepth -1].fClipStack);
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         pop();</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :         SkASSERT(currentEntry()-&gt;fMatrix.getType() == SkMatrix::kIdentity_Mask);
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     if (matrix.getType() == SkMatrix::kIdentity_Mask) {</span>
<span class="lineNum">     311 </span>            :         return;
<span class="lineNum">     312 </span>            :     }
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     push();</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendTransform(matrix, fContentStream);</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     currentEntry()-&gt;fMatrix = matrix;</span>
<a name="317"><span class="lineNum">     317 </span>            : }</a>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : void GraphicStackState::updateDrawingState(const SkPDFDevice::GraphicStateEntry&amp; state) {</span>
<span class="lineNum">     320 </span>            :     // PDF treats a shader as a color, so we only set one or the other.
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     if (state.fShaderIndex &gt;= 0) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         if (state.fShaderIndex != currentEntry()-&gt;fShaderIndex) {</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :             SkPDFUtils::ApplyPattern(state.fShaderIndex, fContentStream);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :             currentEntry()-&gt;fShaderIndex = state.fShaderIndex;</span>
<span class="lineNum">     325 </span>            :         }
<span class="lineNum">     326 </span>            :     } else {
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         if (state.fColor != currentEntry()-&gt;fColor ||</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 currentEntry()-&gt;fShaderIndex &gt;= 0) {</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :             emit_pdf_color(state.fColor, fContentStream);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeText(&quot;RG &quot;);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :             emit_pdf_color(state.fColor, fContentStream);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeText(&quot;rg\n&quot;);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :             currentEntry()-&gt;fColor = state.fColor;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :             currentEntry()-&gt;fShaderIndex = -1;</span>
<span class="lineNum">     335 </span>            :         }
<span class="lineNum">     336 </span>            :     }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     if (state.fGraphicStateIndex != currentEntry()-&gt;fGraphicStateIndex) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         SkPDFUtils::ApplyGraphicState(state.fGraphicStateIndex, fContentStream);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :         currentEntry()-&gt;fGraphicStateIndex = state.fGraphicStateIndex;</span>
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     if (state.fTextScaleX) {</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         if (state.fTextScaleX != currentEntry()-&gt;fTextScaleX) {</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :             SkScalar pdfScale = SkScalarMul(state.fTextScaleX,</span>
<span class="lineNum">     346 </span>            :                                             SkIntToScalar(100));
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :             SkPDFUtils::AppendScalar(pdfScale, fContentStream);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeText(&quot; Tz\n&quot;);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :             currentEntry()-&gt;fTextScaleX = state.fTextScaleX;</span>
<span class="lineNum">     350 </span>            :         }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         if (state.fTextFill != currentEntry()-&gt;fTextFill) {</span>
<span class="lineNum">     352 </span>            :             static_assert(SkPaint::kFill_Style == 0, &quot;enum_must_match_value&quot;);
<span class="lineNum">     353 </span>            :             static_assert(SkPaint::kStroke_Style == 1, &quot;enum_must_match_value&quot;);
<span class="lineNum">     354 </span>            :             static_assert(SkPaint::kStrokeAndFill_Style == 2, &quot;enum_must_match_value&quot;);
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeDecAsText(state.fTextFill);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             fContentStream-&gt;writeText(&quot; Tr\n&quot;);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :             currentEntry()-&gt;fTextFill = state.fTextFill;</span>
<span class="lineNum">     358 </span>            :         }
<span class="lineNum">     359 </span>            :     }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : static bool not_supported_for_layers(const SkPaint&amp; layerPaint) {
<span class="lineNum">     363 </span>            :     // PDF does not support image filters, so render them on CPU.
<span class="lineNum">     364 </span>            :     // Note that this rendering is done at &quot;screen&quot; resolution (100dpi), not
<span class="lineNum">     365 </span>            :     // printer resolution.
<span class="lineNum">     366 </span>            :     // TODO: It may be possible to express some filters natively using PDF
<span class="lineNum">     367 </span>            :     // to improve quality and file size (https://bug.skia.org/3043)
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :     // TODO: should we return true if there is a colorfilter?
<span class="lineNum">     370 </span>            :     return layerPaint.getImageFilter() != nullptr;
<a name="371"><span class="lineNum">     371 </span>            : }</a>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 : SkBaseDevice* SkPDFDevice::onCreateDevice(const CreateInfo&amp; cinfo, const SkPaint* layerPaint) {</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     if (layerPaint &amp;&amp; not_supported_for_layers(*layerPaint)) {</span>
<span class="lineNum">     375 </span>            :         // need to return a raster device, which we will detect in drawDevice()
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         return SkBitmapDevice::Create(cinfo.fInfo, SkSurfaceProps(0, kUnknown_SkPixelGeometry));</span>
<span class="lineNum">     377 </span>            :     }
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     SkISize size = SkISize::Make(cinfo.fInfo.width(), cinfo.fInfo.height());</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     return SkPDFDevice::Create(size, fRasterDpi, fDocument);</span>
<a name="380"><span class="lineNum">     380 </span>            : }</a>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineNoCov">          0 : SkPDFCanon* SkPDFDevice::getCanon() const { return fDocument-&gt;canon(); }</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : // A helper class to automatically finish a ContentEntry at the end of a
<span class="lineNum">     387 </span>            : // drawing method and maintain the state needed between set up and finish.
<a name="388"><span class="lineNum">     388 </span>            : class ScopedContentEntry {</a>
<span class="lineNum">     389 </span>            : public:
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     ScopedContentEntry(SkPDFDevice* device, const SkDraw&amp; draw,</span>
<span class="lineNum">     391 </span>            :                        const SkPaint&amp; paint, bool hasText = false)
<span class="lineNum">     392 </span>            :         : fDevice(device),
<span class="lineNum">     393 </span>            :           fContentEntry(nullptr),
<span class="lineNum">     394 </span>            :           fBlendMode(SkBlendMode::kSrcOver),
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :           fDstFormXObject(nullptr) {</span>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :         init(draw.fClipStack, draw.fRC-&gt;bwRgn(), *draw.fMatrix, paint, hasText);</span></a>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     ScopedContentEntry(SkPDFDevice* device, const SkClipStack* clipStack,</span>
<span class="lineNum">     399 </span>            :                        const SkRegion&amp; clipRegion, const SkMatrix&amp; matrix,
<span class="lineNum">     400 </span>            :                        const SkPaint&amp; paint, bool hasText = false)
<span class="lineNum">     401 </span>            :         : fDevice(device),
<span class="lineNum">     402 </span>            :           fContentEntry(nullptr),
<span class="lineNum">     403 </span>            :           fBlendMode(SkBlendMode::kSrcOver),
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :           fDstFormXObject(nullptr) {</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         init(clipStack, clipRegion, matrix, paint, hasText);</span>
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     ~ScopedContentEntry() {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         if (fContentEntry) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :             SkPath* shape = &amp;fShape;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :             if (shape-&gt;isEmpty()) {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :                 shape = nullptr;</span>
<span class="lineNum">     413 </span>            :             }
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :             fDevice-&gt;finishContentEntry(fBlendMode, std::move(fDstFormXObject), shape);</span>
<span class="lineNum">     415 </span>            :         }
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :     SkPDFDevice::ContentEntry* entry() { return fContentEntry; }
<a name="419"><span class="lineNum">     419 </span>            : </a>
<span class="lineNum">     420 </span>            :     /* Returns true when we explicitly need the shape of the drawing. */
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     bool needShape() {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         switch (fBlendMode) {</span>
<span class="lineNum">     423 </span>            :             case SkBlendMode::kClear:
<span class="lineNum">     424 </span>            :             case SkBlendMode::kSrc:
<span class="lineNum">     425 </span>            :             case SkBlendMode::kSrcIn:
<span class="lineNum">     426 </span>            :             case SkBlendMode::kSrcOut:
<span class="lineNum">     427 </span>            :             case SkBlendMode::kDstIn:
<span class="lineNum">     428 </span>            :             case SkBlendMode::kDstOut:
<span class="lineNum">     429 </span>            :             case SkBlendMode::kSrcATop:
<span class="lineNum">     430 </span>            :             case SkBlendMode::kDstATop:
<span class="lineNum">     431 </span>            :             case SkBlendMode::kModulate:
<span class="lineNum">     432 </span>            :                 return true;
<span class="lineNum">     433 </span>            :             default:
<span class="lineNum">     434 </span>            :                 return false;
<span class="lineNum">     435 </span>            :         }
<span class="lineNum">     436 </span>            :     }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     /* Returns true unless we only need the shape of the drawing. */
<span class="lineNum">     439 </span>            :     bool needSource() {
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         if (fBlendMode == SkBlendMode::kClear) {</span>
<span class="lineNum">     441 </span>            :             return false;
<span class="lineNum">     442 </span>            :         }
<span class="lineNum">     443 </span>            :         return true;
<span class="lineNum">     444 </span>            :     }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :     /* If the shape is different than the alpha component of the content, then
<span class="lineNum">     447 </span>            :      * setShape should be called with the shape.  In particular, images and
<span class="lineNum">     448 </span>            :      * devices have rectangular shape.
<span class="lineNum">     449 </span>            :      */
<span class="lineNum">     450 </span>            :     void setShape(const SkPath&amp; shape) {
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         fShape = shape;</span>
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : private:
<span class="lineNum">     455 </span>            :     SkPDFDevice* fDevice;
<span class="lineNum">     456 </span>            :     SkPDFDevice::ContentEntry* fContentEntry;
<span class="lineNum">     457 </span>            :     SkBlendMode fBlendMode;
<span class="lineNum">     458 </span>            :     sk_sp&lt;SkPDFObject&gt; fDstFormXObject;
<a name="459"><span class="lineNum">     459 </span>            :     SkPath fShape;</a>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     void init(const SkClipStack* clipStack, const SkRegion&amp; clipRegion,</span>
<span class="lineNum">     462 </span>            :               const SkMatrix&amp; matrix, const SkPaint&amp; paint, bool hasText) {
<span class="lineNum">     463 </span>            :         // Shape has to be flatten before we get here.
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         if (matrix.hasPerspective()) {</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             NOT_IMPLEMENTED(!matrix.hasPerspective(), false);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     467 </span>            :         }
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         fBlendMode = paint.getBlendMode();</span>
<span class="lineNum">     469 </span>            :         fContentEntry = fDevice-&gt;setUpContentEntry(clipStack, clipRegion,
<span class="lineNum">     470 </span>            :                                                    matrix, paint, hasText,
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                                                    &amp;fDstFormXObject);</span>
<span class="lineNum">     472 </span>            :     }
<span class="lineNum">     473 </span>            : };
<span class="lineNum">     474 </span>            : 
<a name="475"><span class="lineNum">     475 </span>            : ////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 : SkPDFDevice::SkPDFDevice(SkISize pageSize, SkScalar rasterDpi, SkPDFDocument* doc, bool flip)</span>
<span class="lineNum">     478 </span>            :     : INHERITED(SkImageInfo::MakeUnknown(pageSize.width(), pageSize.height()),
<span class="lineNum">     479 </span>            :                 SkSurfaceProps(0, kUnknown_SkPixelGeometry))
<span class="lineNum">     480 </span>            :     , fPageSize(pageSize)
<span class="lineNum">     481 </span>            :     , fExistingClipRegion(SkIRect::MakeSize(pageSize))
<span class="lineNum">     482 </span>            :     , fRasterDpi(rasterDpi)
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     , fDocument(doc) {</span>
<span class="lineNum">     484 </span>            :     SkASSERT(pageSize.width() &gt; 0);
<span class="lineNum">     485 </span>            :     SkASSERT(pageSize.height() &gt; 0);
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     if (flip) {</span>
<span class="lineNum">     488 </span>            :         // Skia generally uses the top left as the origin but PDF
<span class="lineNum">     489 </span>            :         // natively has the origin at the bottom left. This matrix
<span class="lineNum">     490 </span>            :         // corrects for that.  But that only needs to be done once, we
<span class="lineNum">     491 </span>            :         // don't do it when layering.
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         fInitialTransform.setTranslate(0, SkIntToScalar(pageSize.fHeight));</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         fInitialTransform.preScale(SK_Scalar1, -SK_Scalar1);</span>
<span class="lineNum">     494 </span>            :     } else {
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         fInitialTransform.setIdentity();</span>
<span class="lineNum">     496 </span>            :     }
<a name="497"><span class="lineNum">     497 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 : SkPDFDevice::~SkPDFDevice() {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     this-&gt;cleanUp();</span>
<a name="501"><span class="lineNum">     501 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 : void SkPDFDevice::init() {</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     fContentEntries.reset();</span>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 : void SkPDFDevice::cleanUp() {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     fGraphicStateResources.unrefAll();</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     fXObjectResources.unrefAll();</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     fFontResources.unrefAll();</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     fShaderResources.unrefAll();</span>
<a name="512"><span class="lineNum">     512 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawAnnotation(const SkDraw&amp; d, const SkRect&amp; rect, const char key[],</span>
<span class="lineNum">     515 </span>            :                                  SkData* value) {
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     if (0 == rect.width() &amp;&amp; 0 == rect.height()) {</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         handlePointAnnotation({ rect.x(), rect.y() }, *d.fMatrix, key, value);</span>
<span class="lineNum">     518 </span>            :     } else {
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         SkPath path;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         path.addRect(rect);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         handlePathAnnotation(path, d, key, value);</span>
<span class="lineNum">     522 </span>            :     }
<a name="523"><span class="lineNum">     523 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawPaint(const SkDraw&amp; d, const SkPaint&amp; paint) {</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     SkPaint newPaint = paint;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;newPaint);</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     newPaint.setStyle(SkPaint::kFill_Style);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, d, newPaint);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     internalDrawPaint(newPaint, content.entry());</span>
<a name="532"><span class="lineNum">     532 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 : void SkPDFDevice::internalDrawPaint(const SkPaint&amp; paint,</span>
<span class="lineNum">     535 </span>            :                                     SkPDFDevice::ContentEntry* contentEntry) {
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     if (!contentEntry) {</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     538 </span>            :     }
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     SkRect bbox = SkRect::MakeWH(SkIntToScalar(this-&gt;width()),</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                                  SkIntToScalar(this-&gt;height()));</span>
<span class="lineNum">     541 </span>            :     SkMatrix inverse;
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     if (!contentEntry-&gt;fState.fMatrix.invert(&amp;inverse)) {</span>
<span class="lineNum">     543 </span>            :         return;
<span class="lineNum">     544 </span>            :     }
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     inverse.mapRect(&amp;bbox);</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendRectangle(bbox, &amp;contentEntry-&gt;fContent);</span>
<span class="lineNum">     548 </span>            :     SkPDFUtils::PaintPath(paint.getStyle(), SkPath::kWinding_FillType,
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                           &amp;contentEntry-&gt;fContent);</span>
<a name="550"><span class="lineNum">     550 </span>            : }</a>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawPoints(const SkDraw&amp; d,</span>
<span class="lineNum">     553 </span>            :                              SkCanvas::PointMode mode,
<span class="lineNum">     554 </span>            :                              size_t count,
<span class="lineNum">     555 </span>            :                              const SkPoint* points,
<span class="lineNum">     556 </span>            :                              const SkPaint&amp; srcPaint) {
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     SkPaint passedPaint = srcPaint;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;passedPaint);</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     if (count == 0) {</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     562 </span>            :     }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :     // SkDraw::drawPoints converts to multiple calls to fDevice-&gt;drawPath.
<span class="lineNum">     565 </span>            :     // We only use this when there's a path effect because of the overhead
<span class="lineNum">     566 </span>            :     // of multiple calls to setUpContentEntry it causes.
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     if (passedPaint.getPathEffect()) {</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         if (d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">     569 </span>            :             return;
<span class="lineNum">     570 </span>            :         }
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         SkDraw pointDraw(d);</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         pointDraw.fDevice = this;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         pointDraw.drawPoints(mode, count, points, passedPaint, true);</span>
<span class="lineNum">     574 </span>            :         return;
<span class="lineNum">     575 </span>            :     }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     const SkPaint* paint = &amp;passedPaint;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     SkPaint modifiedPaint;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     if (mode == SkCanvas::kPoints_PointMode &amp;&amp;</span>
<span class="lineNum">     581 </span>            :             paint-&gt;getStrokeCap() != SkPaint::kRound_Cap) {
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         modifiedPaint = *paint;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         paint = &amp;modifiedPaint;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         if (paint-&gt;getStrokeWidth()) {</span>
<span class="lineNum">     585 </span>            :             // PDF won't draw a single point with square/butt caps because the
<span class="lineNum">     586 </span>            :             // orientation is ambiguous.  Draw a rectangle instead.
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :             modifiedPaint.setStyle(SkPaint::kFill_Style);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :             SkScalar strokeWidth = paint-&gt;getStrokeWidth();</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :             SkScalar halfStroke = SkScalarHalf(strokeWidth);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :             for (size_t i = 0; i &lt; count; i++) {</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 SkRect r = SkRect::MakeXYWH(points[i].fX, points[i].fY, 0, 0);</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 r.inset(-halfStroke, -halfStroke);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :                 drawRect(d, r, modifiedPaint);</span>
<span class="lineNum">     594 </span>            :             }
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     596 </span>            :         } else {
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :             modifiedPaint.setStrokeCap(SkPaint::kRound_Cap);</span>
<span class="lineNum">     598 </span>            :         }
<span class="lineNum">     599 </span>            :     }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, d, *paint);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     604 </span>            :     }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     switch (mode) {</span>
<span class="lineNum">     607 </span>            :         case SkCanvas::kPolygon_PointMode:
<span class="lineNum">     608 </span>            :             SkPDFUtils::MoveTo(points[0].fX, points[0].fY,
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                                &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :             for (size_t i = 1; i &lt; count; i++) {</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                 SkPDFUtils::AppendLine(points[i].fX, points[i].fY,</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :                                        &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     613 </span>            :             }
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :             SkPDFUtils::StrokePath(&amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     616 </span>            :         case SkCanvas::kLines_PointMode:
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :             for (size_t i = 0; i &lt; count/2; i++) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                 SkPDFUtils::MoveTo(points[i * 2].fX, points[i * 2].fY,</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                                    &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     620 </span>            :                 SkPDFUtils::AppendLine(points[i * 2 + 1].fX,
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                                        points[i * 2 + 1].fY,</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :                                        &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                 SkPDFUtils::StrokePath(&amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     624 </span>            :             }
<span class="lineNum">     625 </span>            :             break;
<span class="lineNum">     626 </span>            :         case SkCanvas::kPoints_PointMode:
<span class="lineNum">     627 </span>            :             SkASSERT(paint-&gt;getStrokeCap() == SkPaint::kRound_Cap);
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :             for (size_t i = 0; i &lt; count; i++) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :                 SkPDFUtils::MoveTo(points[i].fX, points[i].fY,</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                                    &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                 SkPDFUtils::ClosePath(&amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :                 SkPDFUtils::StrokePath(&amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     633 </span>            :             }
<span class="lineNum">     634 </span>            :             break;
<span class="lineNum">     635 </span>            :         default:
<span class="lineNum">     636 </span>            :             SkASSERT(false);
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     }</span>
<a name="638"><span class="lineNum">     638 </span>            : }</a>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineNoCov">          0 : static sk_sp&lt;SkPDFDict&gt; create_link_annotation(const SkRect&amp; translatedRect) {</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     auto annotation = sk_make_sp&lt;SkPDFDict&gt;(&quot;Annot&quot;);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     annotation-&gt;insertName(&quot;Subtype&quot;, &quot;Link&quot;);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     annotation-&gt;insertInt(&quot;F&quot;, 4);  // required by ISO 19005</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     auto border = sk_make_sp&lt;SkPDFArray&gt;();</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     border-&gt;reserve(3);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     border-&gt;appendInt(0);  // Horizontal corner radius.</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     border-&gt;appendInt(0);  // Vertical corner radius.</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     border-&gt;appendInt(0);  // Width, 0 = no border.</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     annotation-&gt;insertObject(&quot;Border&quot;, std::move(border));</span>
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     auto rect = sk_make_sp&lt;SkPDFArray&gt;();</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     rect-&gt;reserve(4);</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     rect-&gt;appendScalar(translatedRect.fLeft);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     rect-&gt;appendScalar(translatedRect.fTop);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     rect-&gt;appendScalar(translatedRect.fRight);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     rect-&gt;appendScalar(translatedRect.fBottom);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     annotation-&gt;insertObject(&quot;Rect&quot;, std::move(rect));</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     return annotation;</span>
<a name="661"><span class="lineNum">     661 </span>            : }</a>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineNoCov">          0 : static sk_sp&lt;SkPDFDict&gt; create_link_to_url(const SkData* urlData, const SkRect&amp; r) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFDict&gt; annotation = create_link_annotation(r);</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     SkString url(static_cast&lt;const char *&gt;(urlData-&gt;data()),</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                  urlData-&gt;size() - 1);</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     auto action = sk_make_sp&lt;SkPDFDict&gt;(&quot;Action&quot;);</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     action-&gt;insertName(&quot;S&quot;, &quot;URI&quot;);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     action-&gt;insertString(&quot;URI&quot;, url);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     annotation-&gt;insertObject(&quot;A&quot;, std::move(action));</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     return annotation;</span>
<a name="672"><span class="lineNum">     672 </span>            : }</a>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 : static sk_sp&lt;SkPDFDict&gt; create_link_named_dest(const SkData* nameData,</span>
<span class="lineNum">     675 </span>            :                                                const SkRect&amp; r) {
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFDict&gt; annotation = create_link_annotation(r);</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     SkString name(static_cast&lt;const char *&gt;(nameData-&gt;data()),</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                   nameData-&gt;size() - 1);</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     annotation-&gt;insertName(&quot;Dest&quot;, name);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     return annotation;</span>
<a name="681"><span class="lineNum">     681 </span>            : }</a>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawRect(const SkDraw&amp; d,</span>
<span class="lineNum">     684 </span>            :                            const SkRect&amp; rect,
<span class="lineNum">     685 </span>            :                            const SkPaint&amp; srcPaint) {
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     SkRect r = rect;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     r.sort();</span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     if (paint.getPathEffect()) {</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         if (d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">     693 </span>            :             return;
<span class="lineNum">     694 </span>            :         }
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         SkPath path;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         path.addRect(r);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         drawPath(d, path, paint, nullptr, true);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     699 </span>            :     }
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, d, paint);</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     704 </span>            :     }
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendRectangle(r, &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     706 </span>            :     SkPDFUtils::PaintPath(paint.getStyle(), SkPath::kWinding_FillType,
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                           &amp;content.entry()-&gt;fContent);</span>
<a name="708"><span class="lineNum">     708 </span>            : }</a>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawRRect(const SkDraw&amp; draw,</span>
<span class="lineNum">     711 </span>            :                             const SkRRect&amp; rrect,
<span class="lineNum">     712 </span>            :                             const SkPaint&amp; srcPaint) {
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     SkPath  path;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     path.addRRect(rrect);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     this-&gt;drawPath(draw, path, paint, nullptr, true);</span>
<a name="718"><span class="lineNum">     718 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawOval(const SkDraw&amp; draw,</span>
<span class="lineNum">     721 </span>            :                            const SkRect&amp; oval,
<span class="lineNum">     722 </span>            :                            const SkPaint&amp; srcPaint) {
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     SkPath  path;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     path.addOval(oval);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     this-&gt;drawPath(draw, path, paint, nullptr, true);</span>
<a name="728"><span class="lineNum">     728 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawPath(const SkDraw&amp; d,</span>
<span class="lineNum">     731 </span>            :                            const SkPath&amp; origPath,
<span class="lineNum">     732 </span>            :                            const SkPaint&amp; srcPaint,
<span class="lineNum">     733 </span>            :                            const SkMatrix* prePathMatrix,
<span class="lineNum">     734 </span>            :                            bool pathIsMutable) {
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     SkPath modifiedPath;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     SkPath* pathPtr = const_cast&lt;SkPath*&gt;(&amp;origPath);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     SkMatrix matrix = *d.fMatrix;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     if (prePathMatrix) {</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         if (paint.getPathEffect() || paint.getStyle() != SkPaint::kFill_Style) {</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :             if (!pathIsMutable) {</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                 pathPtr = &amp;modifiedPath;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                 pathIsMutable = true;</span>
<span class="lineNum">     746 </span>            :             }
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :             origPath.transform(*prePathMatrix, pathPtr);</span>
<span class="lineNum">     748 </span>            :         } else {
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :             matrix.preConcat(*prePathMatrix);</span>
<span class="lineNum">     750 </span>            :         }
<span class="lineNum">     751 </span>            :     }
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     if (paint.getPathEffect()) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         if (d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">     755 </span>            :             return;
<span class="lineNum">     756 </span>            :         }
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         if (!pathIsMutable) {</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :             pathPtr = &amp;modifiedPath;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :             pathIsMutable = true;</span>
<span class="lineNum">     760 </span>            :         }
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         bool fill = paint.getFillPath(origPath, pathPtr);</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         SkPaint noEffectPaint(paint);</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         noEffectPaint.setPathEffect(nullptr);</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         if (fill) {</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :             noEffectPaint.setStyle(SkPaint::kFill_Style);</span>
<span class="lineNum">     767 </span>            :         } else {
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :             noEffectPaint.setStyle(SkPaint::kStroke_Style);</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :             noEffectPaint.setStrokeWidth(0);</span>
<span class="lineNum">     770 </span>            :         }
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         drawPath(d, *pathPtr, noEffectPaint, nullptr, true);</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     773 </span>            :     }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :     if (handleInversePath(d, origPath, paint, pathIsMutable, prePathMatrix)) {</span>
<span class="lineNum">     776 </span>            :         return;
<span class="lineNum">     777 </span>            :     }
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, d.fClipStack, d.fRC-&gt;bwRgn(), matrix, paint);</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     782 </span>            :     }
<span class="lineNum">     783 </span>            :     bool consumeDegeratePathSegments =
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :            paint.getStyle() == SkPaint::kFill_Style ||</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :            (paint.getStrokeCap() != SkPaint::kRound_Cap &amp;&amp;</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :             paint.getStrokeCap() != SkPaint::kSquare_Cap);</span>
<span class="lineNum">     787 </span>            :     SkPDFUtils::EmitPath(*pathPtr, paint.getStyle(),
<span class="lineNum">     788 </span>            :                          consumeDegeratePathSegments,
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :                          &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     790 </span>            :     SkPDFUtils::PaintPath(paint.getStyle(), pathPtr-&gt;getFillType(),
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :                           &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">     792 </span>            : }
<a name="793"><span class="lineNum">     793 </span>            : </a>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawImageRect(const SkDraw&amp; d,</span>
<span class="lineNum">     796 </span>            :                                 const SkImage* image,
<span class="lineNum">     797 </span>            :                                 const SkRect* src,
<span class="lineNum">     798 </span>            :                                 const SkRect&amp; dst,
<span class="lineNum">     799 </span>            :                                 const SkPaint&amp; srcPaint,
<span class="lineNum">     800 </span>            :                                 SkCanvas::SrcRectConstraint) {
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     if (!image) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     SkIRect bounds = image-&gt;bounds();</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     if (image-&gt;isOpaque()) {</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     SkRect srcRect = src ? *src : SkRect::Make(bounds);</span>
<span class="lineNum">     810 </span>            :     SkMatrix transform;
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     transform.setRectToRect(srcRect, dst, SkMatrix::kFill_ScaleToFit);</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     if (src) {</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (!srcRect.intersect(SkRect::Make(bounds))) {</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     815 </span>            :         }
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :         srcRect.roundOut(&amp;bounds);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         transform.preTranslate(SkIntToScalar(bounds.x()),</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :                                SkIntToScalar(bounds.y()));</span>
<span class="lineNum">     819 </span>            :     }
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     SkImageSubset imageSubset(sk_ref_sp(const_cast&lt;SkImage*&gt;(image)), bounds);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     if (!imageSubset.isValid()) {</span>
<span class="lineNum">     822 </span>            :         return;
<span class="lineNum">     823 </span>            :     }
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     transform.postConcat(*d.fMatrix);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawImage(transform, d.fClipStack, d.fRC-&gt;bwRgn(),</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                             std::move(imageSubset), paint);</span>
<a name="827"><span class="lineNum">     827 </span>            : }</a>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawBitmapRect(const SkDraw&amp; d,</span>
<span class="lineNum">     830 </span>            :                                  const SkBitmap&amp; bitmap,
<span class="lineNum">     831 </span>            :                                  const SkRect* src,
<span class="lineNum">     832 </span>            :                                  const SkRect&amp; dst,
<span class="lineNum">     833 </span>            :                                 const SkPaint&amp; srcPaint,
<span class="lineNum">     834 </span>            :                                 SkCanvas::SrcRectConstraint) {
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     if (bitmap.drawsNothing()) {</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     837 </span>            :     }
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     SkIRect bounds = bitmap.bounds();</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     if (bitmap.isOpaque()) {</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :         replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     842 </span>            :     }
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     SkRect srcRect = src ? *src : SkRect::Make(bounds);</span>
<span class="lineNum">     844 </span>            :     SkMatrix transform;
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     transform.setRectToRect(srcRect, dst, SkMatrix::kFill_ScaleToFit);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     if (src) {</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         if (!srcRect.intersect(SkRect::Make(bounds))) {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     849 </span>            :         }
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         srcRect.roundOut(&amp;bounds);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         transform.preTranslate(SkIntToScalar(bounds.x()),</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :                                SkIntToScalar(bounds.y()));</span>
<span class="lineNum">     853 </span>            :     }
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :     SkBitmap bitmapSubset;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     if (!bitmap.extractSubset(&amp;bitmapSubset, bounds)) {</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     857 </span>            :     }
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     SkImageSubset imageSubset = make_image_subset(bitmapSubset);</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     if (!imageSubset.isValid()) {</span>
<span class="lineNum">     860 </span>            :         return;
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     transform.postConcat(*d.fMatrix);</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawImage(transform, d.fClipStack, d.fRC-&gt;bwRgn(),</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                             std::move(imageSubset), paint);</span>
<a name="865"><span class="lineNum">     865 </span>            : }</a>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawBitmap(const SkDraw&amp; d,</span>
<span class="lineNum">     868 </span>            :                              const SkBitmap&amp; bitmap,
<span class="lineNum">     869 </span>            :                              const SkMatrix&amp; matrix,
<span class="lineNum">     870 </span>            :                              const SkPaint&amp; srcPaint) {
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     if (bitmap.drawsNothing() || d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     873 </span>            :     }
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     if (bitmap.isOpaque()) {</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     877 </span>            :     }
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     SkImageSubset imageSubset = make_image_subset(bitmap);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     if (!imageSubset.isValid()) {</span>
<span class="lineNum">     880 </span>            :         return;
<span class="lineNum">     881 </span>            :     }
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     SkMatrix transform = matrix;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     transform.postConcat(*d.fMatrix);</span>
<span class="lineNum">     884 </span>            :     this-&gt;internalDrawImage(
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             transform, d.fClipStack, d.fRC-&gt;bwRgn(), std::move(imageSubset), paint);</span>
<a name="886"><span class="lineNum">     886 </span>            : }</a>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawSprite(const SkDraw&amp; d,</span>
<span class="lineNum">     889 </span>            :                              const SkBitmap&amp; bitmap,
<span class="lineNum">     890 </span>            :                              int x,
<span class="lineNum">     891 </span>            :                              int y,
<span class="lineNum">     892 </span>            :                              const SkPaint&amp; srcPaint) {
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     if (bitmap.drawsNothing() || d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     895 </span>            :     }
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     if (bitmap.isOpaque()) {</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     899 </span>            :     }
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     SkImageSubset imageSubset = make_image_subset(bitmap);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if (!imageSubset.isValid()) {</span>
<span class="lineNum">     902 </span>            :         return;
<span class="lineNum">     903 </span>            :     }
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     SkMatrix transform = SkMatrix::MakeTrans(SkIntToScalar(x), SkIntToScalar(y));</span>
<span class="lineNum">     905 </span>            :     this-&gt;internalDrawImage(
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :             transform, d.fClipStack, d.fRC-&gt;bwRgn(), std::move(imageSubset), paint);</span>
<a name="907"><span class="lineNum">     907 </span>            : }</a>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawImage(const SkDraw&amp; draw,</span>
<span class="lineNum">     910 </span>            :                             const SkImage* image,
<span class="lineNum">     911 </span>            :                             SkScalar x,
<span class="lineNum">     912 </span>            :                             SkScalar y,
<span class="lineNum">     913 </span>            :                             const SkPaint&amp; srcPaint) {
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     SkPaint paint = srcPaint;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     if (!image) {</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     917 </span>            :     }
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     if (image-&gt;isOpaque()) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :         replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">     920 </span>            :     }
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     if (draw.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">     922 </span>            :         return;
<span class="lineNum">     923 </span>            :     }
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     SkImageSubset imageSubset(sk_ref_sp(const_cast&lt;SkImage*&gt;(image)));</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     if (!imageSubset.isValid()) {</span>
<span class="lineNum">     926 </span>            :         return;
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span>            :     SkMatrix transform = SkMatrix::MakeTrans(x, y);
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     transform.postConcat(*draw.fMatrix);</span>
<span class="lineNum">     930 </span>            :     this-&gt;internalDrawImage(
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :             transform, draw.fClipStack, draw.fRC-&gt;bwRgn(), std::move(imageSubset), paint);</span>
<span class="lineNum">     932 </span>            : }
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : namespace {
<span class="lineNum">     935 </span>            : class GlyphPositioner {
<span class="lineNum">     936 </span>            : public:
<span class="lineNum">     937 </span>            :     GlyphPositioner(SkDynamicMemoryWStream* content,
<span class="lineNum">     938 </span>            :                     SkScalar textSkewX,
<span class="lineNum">     939 </span>            :                     bool wideChars,
<span class="lineNum">     940 </span>            :                     bool defaultPositioning,
<span class="lineNum">     941 </span>            :                     SkPoint origin)
<span class="lineNum">     942 </span>            :         : fContent(content)
<span class="lineNum">     943 </span>            :         , fCurrentMatrixOrigin(origin)
<span class="lineNum">     944 </span>            :         , fTextSkewX(textSkewX)
<span class="lineNum">     945 </span>            :         , fWideChars(wideChars)
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         , fDefaultPositioning(defaultPositioning) {</span>
<a name="947"><span class="lineNum">     947 </span>            :     }</a>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     ~GlyphPositioner() { this-&gt;flush(); }</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     void flush() {</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         if (fInText) {</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :             fContent-&gt;writeText(&quot;&gt; Tj\n&quot;);</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :             fInText = false;</span>
<a name="953"><span class="lineNum">     953 </span>            :         }</a>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     void writeGlyph(SkPoint xy,</span>
<span class="lineNum">     956 </span>            :                     SkScalar advanceWidth,
<span class="lineNum">     957 </span>            :                     uint16_t glyph) {
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         if (!fInitialized) {</span>
<span class="lineNum">     959 </span>            :             // Flip the text about the x-axis to account for origin swap and include
<span class="lineNum">     960 </span>            :             // the passed parameters.
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :             fContent-&gt;writeText(&quot;1 0 &quot;);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :             SkPDFUtils::AppendScalar(-fTextSkewX, fContent);</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :             fContent-&gt;writeText(&quot; -1 &quot;);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :             SkPDFUtils::AppendScalar(fCurrentMatrixOrigin.x(), fContent);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :             fContent-&gt;writeText(&quot; &quot;);</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :             SkPDFUtils::AppendScalar(fCurrentMatrixOrigin.y(), fContent);</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :             fContent-&gt;writeText(&quot; Tm\n&quot;);</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :             fCurrentMatrixOrigin.set(0.0f, 0.0f);</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :             fInitialized = true;</span>
<span class="lineNum">     970 </span>            :         }
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         if (!fDefaultPositioning) {</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :             SkPoint position = xy - fCurrentMatrixOrigin;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             if (position != SkPoint{fXAdvance, 0}) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :                 this-&gt;flush();</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :                 SkPDFUtils::AppendScalar(position.x(), fContent);</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :                 fContent-&gt;writeText(&quot; &quot;);</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :                 SkPDFUtils::AppendScalar(-position.y(), fContent);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 fContent-&gt;writeText(&quot; Td &quot;);</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :                 fCurrentMatrixOrigin = xy;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :                 fXAdvance = 0;</span>
<span class="lineNum">     981 </span>            :             }
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :             fXAdvance += advanceWidth;</span>
<span class="lineNum">     983 </span>            :         }
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         if (!fInText) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :             fContent-&gt;writeText(&quot;&lt;&quot;);</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :             fInText = true;</span>
<span class="lineNum">     987 </span>            :         }
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :         if (fWideChars) {</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :             SkPDFUtils::WriteUInt16BE(fContent, glyph);</span>
<span class="lineNum">     990 </span>            :         } else {
<span class="lineNum">     991 </span>            :             SkASSERT(0 == glyph &gt;&gt; 8);
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :             SkPDFUtils::WriteUInt8(fContent, static_cast&lt;uint8_t&gt;(glyph));</span>
<span class="lineNum">     993 </span>            :         }
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            : private:
<span class="lineNum">     997 </span>            :     SkDynamicMemoryWStream* fContent;
<span class="lineNum">     998 </span>            :     SkPoint fCurrentMatrixOrigin;
<span class="lineNum">     999 </span>            :     SkScalar fXAdvance = 0.0f;
<span class="lineNum">    1000 </span>            :     SkScalar fTextSkewX;
<span class="lineNum">    1001 </span>            :     bool fWideChars;
<span class="lineNum">    1002 </span>            :     bool fInText = false;
<span class="lineNum">    1003 </span>            :     bool fInitialized = false;
<span class="lineNum">    1004 </span>            :     const bool fDefaultPositioning;
<span class="lineNum">    1005 </span>            : };
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : /** Given the m-to-n glyph-to-character mapping data (as returned by
<span class="lineNum">    1008 </span>            :     harfbuzz), iterate over the clusters. */
<a name="1009"><span class="lineNum">    1009 </span>            : class Clusterator {</a>
<a name="1010"><span class="lineNum">    1010 </span>            : public:</a>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     Clusterator() : fClusters(nullptr), fUtf8Text(nullptr), fGlyphCount(0), fTextByteLength(0) {}</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     explicit Clusterator(uint32_t glyphCount)</span>
<span class="lineNum">    1013 </span>            :         : fClusters(nullptr)
<span class="lineNum">    1014 </span>            :         , fUtf8Text(nullptr)
<span class="lineNum">    1015 </span>            :         , fGlyphCount(glyphCount)
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :         , fTextByteLength(0) {}</span>
<a name="1017"><span class="lineNum">    1017 </span>            :     // The clusters[] array is an array of offsets into utf8Text[],</a>
<span class="lineNum">    1018 </span>            :     // one offset for each glyph.  See SkTextBlobBuilder for more info.
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     Clusterator(const uint32_t* clusters,</span>
<span class="lineNum">    1020 </span>            :                 const char* utf8Text,
<span class="lineNum">    1021 </span>            :                 uint32_t glyphCount,
<span class="lineNum">    1022 </span>            :                 uint32_t textByteLength)
<span class="lineNum">    1023 </span>            :         : fClusters(clusters)
<span class="lineNum">    1024 </span>            :         , fUtf8Text(utf8Text)
<span class="lineNum">    1025 </span>            :         , fGlyphCount(glyphCount)
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :         , fTextByteLength(textByteLength) {</span>
<span class="lineNum">    1027 </span>            :         // This is a cheap heuristic for /ReversedChars which seems to
<span class="lineNum">    1028 </span>            :         // work for clusters produced by HarfBuzz, which either
<span class="lineNum">    1029 </span>            :         // increase from zero (LTR) or decrease to zero (RTL).
<span class="lineNum">    1030 </span>            :         // &quot;ReversedChars&quot; is how PDF deals with RTL text.
<span class="lineNum">    1031 </span>            :         fReversedChars =
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :             fUtf8Text &amp;&amp; fClusters &amp;&amp; fGlyphCount &amp;&amp; fClusters[0] != 0;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1034 </span>            :     struct Cluster {
<span class="lineNum">    1035 </span>            :         const char* fUtf8Text;
<span class="lineNum">    1036 </span>            :         uint32_t fTextByteLength;
<span class="lineNum">    1037 </span>            :         uint32_t fGlyphIndex;
<span class="lineNum">    1038 </span>            :         uint32_t fGlyphCount;
<span class="lineNum">    1039 </span>            :         explicit operator bool() const { return fGlyphCount != 0; }
<span class="lineNum">    1040 </span>            :     };
<a name="1041"><span class="lineNum">    1041 </span>            :     // True if this looks like right-to-left text.</a>
<span class="lineNum">    1042 </span>            :     bool reversedChars() const { return fReversedChars; }
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     Cluster next() {</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :         if ((!fUtf8Text || !fClusters) &amp;&amp; fGlyphCount) {</span>
<span class="lineNum">    1045 </span>            :             // These glyphs have no text.  Treat as one &quot;cluster&quot;.
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :             uint32_t glyphCount = fGlyphCount;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :             fGlyphCount = 0;</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :             return Cluster{nullptr, 0, 0, glyphCount};</span>
<span class="lineNum">    1049 </span>            :         }
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         if (fGlyphCount == 0 || fTextByteLength == 0) {</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :             return Cluster{nullptr, 0, 0, 0};  // empty</span>
<span class="lineNum">    1052 </span>            :         }
<span class="lineNum">    1053 </span>            :         SkASSERT(fUtf8Text);
<span class="lineNum">    1054 </span>            :         SkASSERT(fClusters);
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         uint32_t cluster = fClusters[0];</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         if (cluster &gt;= fTextByteLength) {</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :             return Cluster{nullptr, 0, 0, 0};  // bad input.</span>
<span class="lineNum">    1058 </span>            :         }
<span class="lineNum">    1059 </span>            :         uint32_t glyphsInCluster = 1;
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         while (glyphsInCluster &lt; fGlyphCount &amp;&amp;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                fClusters[glyphsInCluster] == cluster) {</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :             ++glyphsInCluster;</span>
<span class="lineNum">    1063 </span>            :         }
<span class="lineNum">    1064 </span>            :         SkASSERT(glyphsInCluster &lt;= fGlyphCount);
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         uint32_t textLength = 0;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         if (glyphsInCluster == fGlyphCount) {</span>
<span class="lineNum">    1067 </span>            :             // consumes rest of glyphs and rest of text
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :             if (kInvalidCluster == fPreviousCluster) { // LTR text or single cluster</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                 textLength = fTextByteLength - cluster;</span>
<span class="lineNum">    1070 </span>            :             } else { // RTL text; last cluster.
<span class="lineNum">    1071 </span>            :                 SkASSERT(fPreviousCluster &lt; fTextByteLength);
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                 if (fPreviousCluster &lt;= cluster) {  // bad input.</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                     return Cluster{nullptr, 0, 0, 0};</span>
<span class="lineNum">    1074 </span>            :                 }
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                 textLength = fPreviousCluster - cluster;</span>
<span class="lineNum">    1076 </span>            :             }
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :             fGlyphCount = 0;</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :             return Cluster{fUtf8Text + cluster,</span>
<span class="lineNum">    1079 </span>            :                            textLength,
<span class="lineNum">    1080 </span>            :                            fGlyphIndex,
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :                            glyphsInCluster};</span>
<span class="lineNum">    1082 </span>            :         }
<span class="lineNum">    1083 </span>            :         SkASSERT(glyphsInCluster &lt; fGlyphCount);
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         uint32_t nextCluster = fClusters[glyphsInCluster];</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         if (nextCluster &gt;= fTextByteLength) {</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :             return Cluster{nullptr, 0, 0, 0};  // bad input.</span>
<span class="lineNum">    1087 </span>            :         }
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         if (nextCluster &gt; cluster) { // LTR text</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :             if (kInvalidCluster != fPreviousCluster) {</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :                 return Cluster{nullptr, 0, 0, 0};  // bad input.</span>
<span class="lineNum">    1091 </span>            :             }
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :             textLength = nextCluster - cluster;</span>
<span class="lineNum">    1093 </span>            :         } else { // RTL text
<span class="lineNum">    1094 </span>            :             SkASSERT(nextCluster &lt; cluster);
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :             if (kInvalidCluster == fPreviousCluster) { // first cluster</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :                 textLength = fTextByteLength - cluster;</span>
<span class="lineNum">    1097 </span>            :             } else { // later cluster
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                 if (fPreviousCluster &lt;= cluster) {</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                     return Cluster{nullptr, 0, 0, 0}; // bad input.</span>
<span class="lineNum">    1100 </span>            :                 }
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                 textLength = fPreviousCluster - cluster;</span>
<span class="lineNum">    1102 </span>            :             }
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :             fPreviousCluster = cluster;</span>
<span class="lineNum">    1104 </span>            :         }
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :         uint32_t glyphIndex = fGlyphIndex;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         fGlyphCount -= glyphsInCluster;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         fGlyphIndex += glyphsInCluster;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         fClusters   += glyphsInCluster;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         return Cluster{fUtf8Text + cluster,</span>
<span class="lineNum">    1110 </span>            :                        textLength,
<span class="lineNum">    1111 </span>            :                        glyphIndex,
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                        glyphsInCluster};</span>
<span class="lineNum">    1113 </span>            :     }
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            : private:
<span class="lineNum">    1116 </span>            :     static constexpr uint32_t kInvalidCluster = 0xFFFFFFFF;
<span class="lineNum">    1117 </span>            :     const uint32_t* fClusters;
<span class="lineNum">    1118 </span>            :     const char* fUtf8Text;
<span class="lineNum">    1119 </span>            :     uint32_t fGlyphCount;
<span class="lineNum">    1120 </span>            :     uint32_t fTextByteLength;
<span class="lineNum">    1121 </span>            :     uint32_t fGlyphIndex = 0;
<span class="lineNum">    1122 </span>            :     uint32_t fPreviousCluster = kInvalidCluster;
<span class="lineNum">    1123 </span>            :     bool fReversedChars = false;
<a name="1124"><span class="lineNum">    1124 </span>            : };</a>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 : struct TextStorage {</span>
<span class="lineNum">    1127 </span>            :     SkAutoTMalloc&lt;char&gt; fUtf8textStorage;
<span class="lineNum">    1128 </span>            :     SkAutoTMalloc&lt;uint32_t&gt; fClusterStorage;
<span class="lineNum">    1129 </span>            :     SkAutoTMalloc&lt;SkGlyphID&gt; fGlyphStorage;
<span class="lineNum">    1130 </span>            : };
<span class="lineNum">    1131 </span>            : }  // namespace
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span>            : /** Given some unicode text (as passed to drawText(), convert to
<a name="1134"><span class="lineNum">    1134 </span>            :     glyphs (via primitive shaping), while preserving</a>
<span class="lineNum">    1135 </span>            :     glyph-to-character mapping information. */
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 : static Clusterator make_clusterator(</span>
<span class="lineNum">    1137 </span>            :         const void* sourceText,
<span class="lineNum">    1138 </span>            :         size_t sourceByteCount,
<span class="lineNum">    1139 </span>            :         const SkPaint&amp; paint,
<span class="lineNum">    1140 </span>            :         TextStorage* storage,
<span class="lineNum">    1141 </span>            :         int glyphCount) {
<span class="lineNum">    1142 </span>            :     SkASSERT(SkPaint::kGlyphID_TextEncoding != paint.getTextEncoding());
<span class="lineNum">    1143 </span>            :     SkASSERT(glyphCount == paint.textToGlyphs(sourceText, sourceByteCount, nullptr));
<span class="lineNum">    1144 </span>            :     SkASSERT(glyphCount &gt; 0);
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     storage-&gt;fGlyphStorage.reset(SkToSizeT(glyphCount));</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     (void)paint.textToGlyphs(sourceText, sourceByteCount, storage-&gt;fGlyphStorage.get());</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     storage-&gt;fClusterStorage.reset(SkToSizeT(glyphCount));</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     uint32_t* clusters = storage-&gt;fClusterStorage.get();</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :     uint32_t utf8ByteCount = 0;</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     const char* utf8Text = nullptr;</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     switch (paint.getTextEncoding()) {</span>
<span class="lineNum">    1152 </span>            :         case SkPaint::kUTF8_TextEncoding: {
<span class="lineNum">    1153 </span>            :             const char* txtPtr = (const char*)sourceText;
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :             for (int i = 0; i &lt; glyphCount; ++i) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                 clusters[i] = SkToU32(txtPtr - (const char*)sourceText);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                 txtPtr += SkUTF8_LeadByteToCount(*(const unsigned char*)txtPtr);</span>
<span class="lineNum">    1157 </span>            :                 SkASSERT(txtPtr &lt;= (const char*)sourceText + sourceByteCount);
<span class="lineNum">    1158 </span>            :             }
<span class="lineNum">    1159 </span>            :             SkASSERT(txtPtr == (const char*)sourceText + sourceByteCount);
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :             utf8ByteCount = SkToU32(sourceByteCount);</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             utf8Text = (const char*)sourceText;</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1163 </span>            :         }
<span class="lineNum">    1164 </span>            :         case SkPaint::kUTF16_TextEncoding: {
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             const uint16_t* utf16ptr = (const uint16_t*)sourceText;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :             int utf16count = SkToInt(sourceByteCount / sizeof(uint16_t));</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             utf8ByteCount = SkToU32(SkUTF16_ToUTF8(utf16ptr, utf16count));</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :             storage-&gt;fUtf8textStorage.reset(utf8ByteCount);</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :             char* txtPtr = storage-&gt;fUtf8textStorage.get();</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :             utf8Text = txtPtr;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :             int clusterIndex = 0;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :             while (utf16ptr &lt; (const uint16_t*)sourceText + utf16count) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                 clusters[clusterIndex++] = SkToU32(txtPtr - utf8Text);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 SkUnichar uni = SkUTF16_NextUnichar(&amp;utf16ptr);</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                 txtPtr += SkUTF8_FromUnichar(uni, txtPtr);</span>
<span class="lineNum">    1176 </span>            :             }
<span class="lineNum">    1177 </span>            :             SkASSERT(clusterIndex == glyphCount);
<span class="lineNum">    1178 </span>            :             SkASSERT(txtPtr == storage-&gt;fUtf8textStorage.get() + utf8ByteCount);
<span class="lineNum">    1179 </span>            :             SkASSERT(utf16ptr == (const uint16_t*)sourceText + utf16count);
<span class="lineNum">    1180 </span>            :             break;
<span class="lineNum">    1181 </span>            :         }
<span class="lineNum">    1182 </span>            :         case SkPaint::kUTF32_TextEncoding: {
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :             const SkUnichar* utf32 = (const SkUnichar*)sourceText;</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :             int utf32count = SkToInt(sourceByteCount / sizeof(SkUnichar));</span>
<span class="lineNum">    1185 </span>            :             SkASSERT(glyphCount == utf32count);
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :             for (int i = 0; i &lt; utf32count; ++i) {</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                 utf8ByteCount += SkToU32(SkUTF8_FromUnichar(utf32[i]));</span>
<span class="lineNum">    1188 </span>            :             }
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :             storage-&gt;fUtf8textStorage.reset(SkToSizeT(utf8ByteCount));</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :             char* txtPtr = storage-&gt;fUtf8textStorage.get();</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :             utf8Text = txtPtr;</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :             for (int i = 0; i &lt; utf32count; ++i) {</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                 clusters[i] = SkToU32(txtPtr - utf8Text);</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                 txtPtr += SkUTF8_FromUnichar(utf32[i], txtPtr);</span>
<span class="lineNum">    1195 </span>            :             }
<span class="lineNum">    1196 </span>            :             break;
<span class="lineNum">    1197 </span>            :         }
<span class="lineNum">    1198 </span>            :         default:
<span class="lineNum">    1199 </span>            :             SkDEBUGFAIL(&quot;&quot;);
<span class="lineNum">    1200 </span>            :             break;
<span class="lineNum">    1201 </span>            :     }
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     return Clusterator(clusters, utf8Text, SkToU32(glyphCount), utf8ByteCount);</span>
<a name="1203"><span class="lineNum">    1203 </span>            : }</a>
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 : static SkUnichar map_glyph(const SkTDArray&lt;SkUnichar&gt;&amp; glyphToUnicode, SkGlyphID glyph) {</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     return SkToInt(glyph) &lt; glyphToUnicode.count() ? glyphToUnicode[SkToInt(glyph)] : -1;</span>
<a name="1207"><span class="lineNum">    1207 </span>            : }</a>
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 : static void update_font(SkWStream* wStream, int fontIndex, SkScalar textSize) {</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :     wStream-&gt;writeText(&quot;/&quot;);</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     char prefix = SkPDFResourceDict::GetResourceTypePrefix(SkPDFResourceDict::kFont_ResourceType);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     wStream-&gt;write(&amp;prefix, 1);</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     wStream-&gt;writeDecAsText(fontIndex);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     wStream-&gt;writeText(&quot; &quot;);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     SkPDFUtils::AppendScalar(textSize, wStream);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     wStream-&gt;writeText(&quot; Tf\n&quot;);</span>
<a name="1217"><span class="lineNum">    1217 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 : void SkPDFDevice::internalDrawText(</span>
<span class="lineNum">    1220 </span>            :         const SkDraw&amp; d, const void* sourceText, size_t sourceByteCount,
<span class="lineNum">    1221 </span>            :         const SkScalar pos[], SkTextBlob::GlyphPositioning positioning,
<span class="lineNum">    1222 </span>            :         SkPoint offset, const SkPaint&amp; srcPaint, const uint32_t* clusters,
<span class="lineNum">    1223 </span>            :         uint32_t textByteLength, const char* utf8Text) {
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     NOT_IMPLEMENTED(srcPaint.getMaskFilter() != nullptr, false);</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     if (srcPaint.getMaskFilter() != nullptr) {</span>
<span class="lineNum">    1226 </span>            :         // Don't pretend we support drawing MaskFilters, it makes for artifacts
<span class="lineNum">    1227 </span>            :         // making text unreadable (e.g. same text twice when using CSS shadows).
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1229 </span>            :     }
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     NOT_IMPLEMENTED(srcPaint.isVerticalText(), false);</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     if (srcPaint.isVerticalText()) {</span>
<span class="lineNum">    1232 </span>            :         // Don't pretend we support drawing vertical text.  It is not
<span class="lineNum">    1233 </span>            :         // clear to me how to switch to &quot;vertical writing&quot; mode in PDF.
<span class="lineNum">    1234 </span>            :         // Currently neither Chromium or Android set this flag.
<span class="lineNum">    1235 </span>            :         // https://bug.skia.org/5665
<span class="lineNum">    1236 </span>            :         return;
<span class="lineNum">    1237 </span>            :     }
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     if (0 == sourceByteCount || !sourceText) {</span>
<span class="lineNum">    1239 </span>            :         return;
<span class="lineNum">    1240 </span>            :     }
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     SkPaint paint = calculate_text_paint(srcPaint);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     replace_srcmode_on_opaque_paint(&amp;paint);</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     if (!paint.getTypeface()) {</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :         paint.setTypeface(SkTypeface::MakeDefault());</span>
<span class="lineNum">    1245 </span>            :     }
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     SkTypeface* typeface = paint.getTypeface();</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     if (!typeface) {</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;SkPDF: SkTypeface::MakeDefault() returned nullptr.\n&quot;);</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1250 </span>            :     }
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            :     const SkAdvancedTypefaceMetrics* metrics =
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :         SkPDFFont::GetMetrics(typeface, fDocument-&gt;canon());</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :     if (!metrics) {</span>
<span class="lineNum">    1255 </span>            :         return;
<span class="lineNum">    1256 </span>            :     }
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     int glyphCount = paint.textToGlyphs(sourceText, sourceByteCount, nullptr);</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     if (glyphCount &lt;= 0) {</span>
<span class="lineNum">    1259 </span>            :         return;
<span class="lineNum">    1260 </span>            :     }
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :     // These three heap buffers are only used in the case where no glyphs
<span class="lineNum">    1263 </span>            :     // are passed to drawText() (most clients pass glyphs or a textblob).
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     TextStorage storage;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     const SkGlyphID* glyphs = nullptr;</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :     Clusterator clusterator;</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     if (textByteLength &gt; 0) {</span>
<span class="lineNum">    1268 </span>            :         SkASSERT(glyphCount == SkToInt(sourceByteCount / sizeof(SkGlyphID)));
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :         glyphs = (const SkGlyphID*)sourceText;</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :         clusterator = Clusterator(clusters, utf8Text, SkToU32(glyphCount), textByteLength);</span>
<span class="lineNum">    1271 </span>            :         SkASSERT(clusters);
<span class="lineNum">    1272 </span>            :         SkASSERT(utf8Text);
<span class="lineNum">    1273 </span>            :         SkASSERT(srcPaint.getTextEncoding() == SkPaint::kGlyphID_TextEncoding);
<span class="lineNum">    1274 </span>            :         SkASSERT(glyphCount == paint.textToGlyphs(sourceText, sourceByteCount, nullptr));
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     } else if (SkPaint::kGlyphID_TextEncoding == srcPaint.getTextEncoding()) {</span>
<span class="lineNum">    1276 </span>            :         SkASSERT(glyphCount == SkToInt(sourceByteCount / sizeof(SkGlyphID)));
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         glyphs = (const SkGlyphID*)sourceText;</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         clusterator = Clusterator(SkToU32(glyphCount));</span>
<span class="lineNum">    1279 </span>            :         SkASSERT(glyphCount == paint.textToGlyphs(sourceText, sourceByteCount, nullptr));
<span class="lineNum">    1280 </span>            :         SkASSERT(nullptr == clusters);
<span class="lineNum">    1281 </span>            :         SkASSERT(nullptr == utf8Text);
<span class="lineNum">    1282 </span>            :     } else {
<span class="lineNum">    1283 </span>            :         SkASSERT(nullptr == clusters);
<span class="lineNum">    1284 </span>            :         SkASSERT(nullptr == utf8Text);
<span class="lineNum">    1285 </span>            :         clusterator = make_clusterator(sourceText, sourceByteCount, srcPaint,
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :                                        &amp;storage, glyphCount);</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :         glyphs = storage.fGlyphStorage;</span>
<span class="lineNum">    1288 </span>            :     }
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :     bool defaultPositioning = (positioning == SkTextBlob::kDefault_Positioning);</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :     paint.setHinting(SkPaint::kNo_Hinting);</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     SkAutoGlyphCache glyphCache(paint, nullptr, nullptr);</span>
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     SkPaint::Align alignment = paint.getTextAlign();</span>
<span class="lineNum">    1294 </span>            :     float alignmentFactor = SkPaint::kLeft_Align   == alignment ?  0.0f :
<span class="lineNum">    1295 </span>            :                             SkPaint::kCenter_Align == alignment ? -0.5f :
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :                             /* SkPaint::kRight_Align */           -1.0f;</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     if (defaultPositioning &amp;&amp; alignment != SkPaint::kLeft_Align) {</span>
<span class="lineNum">    1298 </span>            :         SkScalar advance = 0;
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; glyphCount; ++i) {</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :             advance += glyphCache-&gt;getGlyphIDAdvance(glyphs[i]).fAdvanceX;</span>
<span class="lineNum">    1301 </span>            :         }
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :         offset.offset(alignmentFactor * advance, 0);</span>
<span class="lineNum">    1303 </span>            :     }
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, d, paint, true);</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1307 </span>            :     }
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     SkDynamicMemoryWStream* out = &amp;content.entry()-&gt;fContent;</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     SkScalar textSize = paint.getTextSize();</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :     const SkTDArray&lt;SkUnichar&gt;&amp; glyphToUnicode = metrics-&gt;fGlyphToUnicode;</span>
<a name="1311"><span class="lineNum">    1311 </span>            : </a>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     out-&gt;writeText(&quot;BT\n&quot;);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     SK_AT_SCOPE_EXIT(out-&gt;writeText(&quot;ET\n&quot;));</span>
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     const SkGlyphID maxGlyphID = metrics-&gt;fLastGlyphID;</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     bool multiByteGlyphs = SkPDFFont::IsMultiByte(SkPDFFont::FontType(*metrics));</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :     if (clusterator.reversedChars()) {</span>
<a name="1318"><span class="lineNum">    1318 </span><span class="lineNoCov">          0 :         out-&gt;writeText(&quot;/ReversedChars BMC\n&quot;);</span></a>
<span class="lineNum">    1319 </span>            :     }
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :     SK_AT_SCOPE_EXIT(if (clusterator.reversedChars()) { out-&gt;writeText(&quot;EMC\n&quot;); } );</span>
<span class="lineNum">    1321 </span>            :     GlyphPositioner glyphPositioner(out,
<span class="lineNum">    1322 </span>            :                                     paint.getTextSkewX(),
<span class="lineNum">    1323 </span>            :                                     multiByteGlyphs,
<span class="lineNum">    1324 </span>            :                                     defaultPositioning,
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                                     offset);</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     SkPDFFont* font = nullptr;</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     while (Clusterator::Cluster c = clusterator.next()) {</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :         int index = c.fGlyphIndex;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :         int glyphLimit = index + c.fGlyphCount;</span>
<a name="1331"><span class="lineNum">    1331 </span>            : </a>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         bool actualText = false;</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :         SK_AT_SCOPE_EXIT(if (actualText) { glyphPositioner.flush(); out-&gt;writeText(&quot;EMC\n&quot;); } );</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :         if (c.fUtf8Text) {  // real cluster</span>
<span class="lineNum">    1335 </span>            :             // Check if `/ActualText` needed.
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :             const char* textPtr = c.fUtf8Text;</span>
<span class="lineNum">    1337 </span>            :             // TODO(halcanary): validate utf8 input.
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :             SkUnichar unichar = SkUTF8_NextUnichar(&amp;textPtr);</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :             const char* textEnd = c.fUtf8Text + c.fTextByteLength;</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :             if (textPtr &lt; textEnd ||                                  // more characters left</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :                 glyphLimit &gt; index + 1 ||                             // toUnicode wouldn't work</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :                 unichar != map_glyph(glyphToUnicode, glyphs[index]))  // test single Unichar map</span>
<span class="lineNum">    1343 </span>            :             {
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :                 glyphPositioner.flush();</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :                 out-&gt;writeText(&quot;/Span&lt;&lt;/ActualText &lt;&quot;);</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :                 SkPDFUtils::WriteUTF16beHex(out, 0xFEFF);  // U+FEFF = BYTE ORDER MARK</span>
<span class="lineNum">    1347 </span>            :                 // the BOM marks this text as UTF-16BE, not PDFDocEncoding.
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                 SkPDFUtils::WriteUTF16beHex(out, unichar);  // first char</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                 while (textPtr &lt; textEnd) {</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                     unichar = SkUTF8_NextUnichar(&amp;textPtr);</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :                     SkPDFUtils::WriteUTF16beHex(out, unichar);</span>
<span class="lineNum">    1352 </span>            :                 }
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :                 out-&gt;writeText(&quot;&gt; &gt;&gt; BDC\n&quot;);  // begin marked-content sequence</span>
<span class="lineNum">    1354 </span>            :                                                // with an associated property list.
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :                 actualText = true;</span>
<span class="lineNum">    1356 </span>            :             }
<span class="lineNum">    1357 </span>            :         }
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :         for (; index &lt; glyphLimit; ++index) {</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :             SkGlyphID gid = glyphs[index];</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :             if (gid &gt; maxGlyphID) {</span>
<span class="lineNum">    1361 </span>            :                 continue;
<span class="lineNum">    1362 </span>            :             }
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :             if (!font || !font-&gt;hasGlyph(gid)) {</span>
<span class="lineNum">    1364 </span>            :                 // Not yet specified font or need to switch font.
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :                 int fontIndex = this-&gt;getFontResourceIndex(typeface, gid);</span>
<span class="lineNum">    1366 </span>            :                 // All preconditions for SkPDFFont::GetFontResource are met.
<span class="lineNum">    1367 </span>            :                 SkASSERT(fontIndex &gt;= 0);
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :                 if (fontIndex &lt; 0) {</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    1370 </span>            :                 }
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :                 glyphPositioner.flush();</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :                 update_font(out, fontIndex, textSize);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :                 font = fFontResources[fontIndex];</span>
<span class="lineNum">    1374 </span>            :                 SkASSERT(font);  // All preconditions for SkPDFFont::GetFontResource are met.
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :                 if (!font) {</span>
<span class="lineNum">    1376 </span>            :                     return;
<span class="lineNum">    1377 </span>            :                 }
<span class="lineNum">    1378 </span>            :                 SkASSERT(font-&gt;multiByteGlyphs() == multiByteGlyphs);
<span class="lineNum">    1379 </span>            :             }
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :             SkPoint xy{0, 0};</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :             SkScalar advance{0};</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :             if (!defaultPositioning) {</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :                 advance = glyphCache-&gt;getGlyphIDAdvance(gid).fAdvanceX;</span>
<span class="lineNum">    1384 </span>            :                 xy = SkTextBlob::kFull_Positioning == positioning
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                    ? SkPoint{pos[2 * index], pos[2 * index + 1]}</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :                    : SkPoint{pos[index], 0};</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                 if (alignment != SkPaint::kLeft_Align) {</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                     xy.offset(alignmentFactor * advance, 0);</span>
<span class="lineNum">    1389 </span>            :                 }
<span class="lineNum">    1390 </span>            :             }
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :             font-&gt;noteGlyphUsage(gid);</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :             SkGlyphID encodedGlyph = multiByteGlyphs ? gid : font-&gt;glyphToPDFFontEncoding(gid);</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :             glyphPositioner.writeGlyph(xy, advance, encodedGlyph);</span>
<span class="lineNum">    1394 </span>            :         }
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :     }</span>
<a name="1396"><span class="lineNum">    1396 </span>            : }</a>
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawText(const SkDraw&amp; d, const void* text, size_t len,</span>
<span class="lineNum">    1399 </span>            :                            SkScalar x, SkScalar y, const SkPaint&amp; paint) {
<span class="lineNum">    1400 </span>            :     this-&gt;internalDrawText(d, text, len, nullptr, SkTextBlob::kDefault_Positioning,
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :                            SkPoint{x, y}, paint, nullptr, 0, nullptr);</span>
<a name="1402"><span class="lineNum">    1402 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawPosText(const SkDraw&amp; d, const void* text, size_t len,</span>
<span class="lineNum">    1405 </span>            :                               const SkScalar pos[], int scalarsPerPos,
<span class="lineNum">    1406 </span>            :                               const SkPoint&amp; offset, const SkPaint&amp; paint) {
<span class="lineNum">    1407 </span>            :     this-&gt;internalDrawText(d, text, len, pos, (SkTextBlob::GlyphPositioning)scalarsPerPos,
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :                            offset, paint, nullptr, 0, nullptr);</span>
<a name="1409"><span class="lineNum">    1409 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawTextBlob(const SkDraw&amp; draw, const SkTextBlob* blob, SkScalar x, SkScalar y,</span>
<span class="lineNum">    1412 </span>            :                                const SkPaint &amp;paint, SkDrawFilter* drawFilter) {
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     for (SkTextBlobRunIterator it(blob); !it.done(); it.next()) {</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         SkPaint runPaint(paint);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :         it.applyFontToPaint(&amp;runPaint);</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :         if (drawFilter &amp;&amp; !drawFilter-&gt;filter(&amp;runPaint, SkDrawFilter::kText_Type)) {</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1418 </span>            :         }
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :         runPaint.setFlags(this-&gt;filterTextFlags(runPaint));</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :         SkPoint offset = it.offset() + SkPoint{x, y};</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :         this-&gt;internalDrawText(draw, it.glyphs(), sizeof(SkGlyphID) * it.glyphCount(),</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                                it.pos(), it.positioning(), offset, runPaint,</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :                                it.clusters(), it.textSize(), it.text());</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :     }</span>
<a name="1425"><span class="lineNum">    1425 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawVertices(const SkDraw&amp; d, SkCanvas::VertexMode,</span>
<span class="lineNum">    1428 </span>            :                                int vertexCount, const SkPoint verts[],
<span class="lineNum">    1429 </span>            :                                const SkPoint texs[], const SkColor colors[],
<span class="lineNum">    1430 </span>            :                                SkXfermode* xmode, const uint16_t indices[],
<span class="lineNum">    1431 </span>            :                                int indexCount, const SkPaint&amp; paint) {
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     if (d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1434 </span>            :     }
<span class="lineNum">    1435 </span>            :     // TODO: implement drawVertices
<a name="1436"><span class="lineNum">    1436 </span>            : }</a>
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawDevice(const SkDraw&amp; d, SkBaseDevice* device,</span>
<span class="lineNum">    1439 </span>            :                              int x, int y, const SkPaint&amp; paint) {
<span class="lineNum">    1440 </span>            :     SkASSERT(!paint.getImageFilter());
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :     // Check if the source device is really a bitmapdevice (because that's what we returned
<span class="lineNum">    1443 </span>            :     // from createDevice (likely due to an imagefilter)
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     SkPixmap pmap;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     if (device-&gt;peekPixels(&amp;pmap)) {</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :         SkBitmap bitmap;</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :         bitmap.installPixels(pmap);</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :         this-&gt;drawSprite(d, bitmap, x, y, paint);</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1450 </span>            :     }
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :     // our onCreateCompatibleDevice() always creates SkPDFDevice subclasses.
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     SkPDFDevice* pdfDevice = static_cast&lt;SkPDFDevice*&gt;(device);</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     SkScalar scalarX = SkIntToScalar(x);</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     SkScalar scalarY = SkIntToScalar(y);</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     for (const RectWithData&amp; l : pdfDevice-&gt;fLinkToURLs) {</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :         SkRect r = l.rect.makeOffset(scalarX, scalarY);</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :         fLinkToURLs.emplace_back(r, l.data.get());</span>
<span class="lineNum">    1460 </span>            :     }
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     for (const RectWithData&amp; l : pdfDevice-&gt;fLinkToDestinations) {</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :         SkRect r = l.rect.makeOffset(scalarX, scalarY);</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :         fLinkToDestinations.emplace_back(r, l.data.get());</span>
<span class="lineNum">    1464 </span>            :     }
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     for (const NamedDestination&amp; d : pdfDevice-&gt;fNamedDestinations) {</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         SkPoint p = d.point + SkPoint::Make(scalarX, scalarY);</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :         fNamedDestinations.emplace_back(d.nameData.get(), p);</span>
<span class="lineNum">    1468 </span>            :     }
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     if (pdfDevice-&gt;isContentEmpty()) {</span>
<span class="lineNum">    1471 </span>            :         return;
<span class="lineNum">    1472 </span>            :     }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            :     SkMatrix matrix;
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     matrix.setTranslate(SkIntToScalar(x), SkIntToScalar(y));</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, d.fClipStack, d.fRC-&gt;bwRgn(), matrix, paint);</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1479 </span>            :     }
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :     if (content.needShape()) {</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :         SkPath shape;</span>
<span class="lineNum">    1482 </span>            :         shape.addRect(SkRect::MakeXYWH(SkIntToScalar(x), SkIntToScalar(y),
<span class="lineNum">    1483 </span>            :                                        SkIntToScalar(device-&gt;width()),
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                                        SkIntToScalar(device-&gt;height())));</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :         content.setShape(shape);</span>
<span class="lineNum">    1486 </span>            :     }
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :     if (!content.needSource()) {</span>
<span class="lineNum">    1488 </span>            :         return;
<span class="lineNum">    1489 </span>            :     }
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFObject&gt; xObject = pdfDevice-&gt;makeFormXObjectFromDevice();</span>
<span class="lineNum">    1492 </span>            :     SkPDFUtils::DrawFormXObject(this-&gt;addXObjectResource(xObject.get()),
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :                                 &amp;content.entry()-&gt;fContent);</span>
<a name="1494"><span class="lineNum">    1494 </span>            : }</a>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 : sk_sp&lt;SkSurface&gt; SkPDFDevice::makeSurface(const SkImageInfo&amp; info, const SkSurfaceProps&amp; props) {</span>
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     return SkSurface::MakeRaster(info, &amp;props);</span>
<span class="lineNum">    1498 </span>            : }
<a name="1499"><span class="lineNum">    1499 </span>            : </a>
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 : sk_sp&lt;SkPDFDict&gt; SkPDFDevice::makeResourceDict() const {</span>
<span class="lineNum">    1502 </span>            :     SkTDArray&lt;SkPDFObject*&gt; fonts;
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :     fonts.setReserve(fFontResources.count());</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     for (SkPDFFont* font : fFontResources) {</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :         fonts.push(font);</span>
<span class="lineNum">    1506 </span>            :     }
<span class="lineNum">    1507 </span>            :     return SkPDFResourceDict::Make(
<span class="lineNum">    1508 </span>            :             &amp;fGraphicStateResources,
<span class="lineNum">    1509 </span>            :             &amp;fShaderResources,
<span class="lineNum">    1510 </span>            :             &amp;fXObjectResources,
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :             &amp;fonts);</span>
<a name="1512"><span class="lineNum">    1512 </span>            : }</a>
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 : sk_sp&lt;SkPDFArray&gt; SkPDFDevice::copyMediaBox() const {</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     auto mediaBox = sk_make_sp&lt;SkPDFArray&gt;();</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     mediaBox-&gt;reserve(4);</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     mediaBox-&gt;appendInt(0);</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     mediaBox-&gt;appendInt(0);</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     mediaBox-&gt;appendInt(fPageSize.width());</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     mediaBox-&gt;appendInt(fPageSize.height());</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     return mediaBox;</span>
<a name="1522"><span class="lineNum">    1522 </span>            : }</a>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 : std::unique_ptr&lt;SkStreamAsset&gt; SkPDFDevice::content() const {</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     SkDynamicMemoryWStream buffer;</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     if (fInitialTransform.getType() != SkMatrix::kIdentity_Mask) {</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :         SkPDFUtils::AppendTransform(fInitialTransform, &amp;buffer);</span>
<span class="lineNum">    1528 </span>            :     }
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :     GraphicStackState gsState(fExistingClipStack, fExistingClipRegion, &amp;buffer);</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     for (const auto&amp; entry : fContentEntries) {</span>
<span class="lineNum">    1532 </span>            :         SkPoint translation;
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :         translation.iset(this-&gt;getOrigin());</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :         translation.negate();</span>
<span class="lineNum">    1535 </span>            :         gsState.updateClip(entry.fState.fClipStack, entry.fState.fClipRegion,
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :                            translation);</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :         gsState.updateMatrix(entry.fState.fMatrix);</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :         gsState.updateDrawingState(entry.fState);</span>
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :         entry.fContent.writeToStream(&amp;buffer);</span>
<span class="lineNum">    1541 </span>            :     }
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :     gsState.drainStack();</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     if (buffer.bytesWritten() &gt; 0) {</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :         return std::unique_ptr&lt;SkStreamAsset&gt;(buffer.detachAsStream());</span>
<span class="lineNum">    1545 </span>            :     } else {
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :         return skstd::make_unique&lt;SkMemoryStream&gt;();</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1548 </span>            : }
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            : /* Draws an inverse filled path by using Path Ops to compute the positive
<span class="lineNum">    1551 </span>            :  * inverse using the current clip as the inverse bounds.
<span class="lineNum">    1552 </span>            :  * Return true if this was an inverse path and was properly handled,
<span class="lineNum">    1553 </span>            :  * otherwise returns false and the normal drawing routine should continue,
<span class="lineNum">    1554 </span>            :  * either as a (incorrect) fallback or because the path was not inverse
<a name="1555"><span class="lineNum">    1555 </span>            :  * in the first place.</a>
<span class="lineNum">    1556 </span>            :  */
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 : bool SkPDFDevice::handleInversePath(const SkDraw&amp; d, const SkPath&amp; origPath,</span>
<span class="lineNum">    1558 </span>            :                                     const SkPaint&amp; paint, bool pathIsMutable,
<span class="lineNum">    1559 </span>            :                                     const SkMatrix* prePathMatrix) {
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :     if (!origPath.isInverseFillType()) {</span>
<span class="lineNum">    1561 </span>            :         return false;
<span class="lineNum">    1562 </span>            :     }
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     if (d.fRC-&gt;isEmpty()) {</span>
<span class="lineNum">    1565 </span>            :         return false;
<span class="lineNum">    1566 </span>            :     }
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :     SkPath modifiedPath;</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     SkPath* pathPtr = const_cast&lt;SkPath*&gt;(&amp;origPath);</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     SkPaint noInversePaint(paint);</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            :     // Merge stroking operations into final path.
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :     if (SkPaint::kStroke_Style == paint.getStyle() ||</span>
<span class="lineNum">    1574 </span>            :         SkPaint::kStrokeAndFill_Style == paint.getStyle()) {
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :         bool doFillPath = paint.getFillPath(origPath, &amp;modifiedPath);</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :         if (doFillPath) {</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :             noInversePaint.setStyle(SkPaint::kFill_Style);</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :             noInversePaint.setStrokeWidth(0);</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :             pathPtr = &amp;modifiedPath;</span>
<span class="lineNum">    1580 </span>            :         } else {
<span class="lineNum">    1581 </span>            :             // To be consistent with the raster output, hairline strokes
<span class="lineNum">    1582 </span>            :             // are rendered as non-inverted.
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :             modifiedPath.toggleInverseFillType();</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :             drawPath(d, modifiedPath, paint, nullptr, true);</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    1586 </span>            :         }
<span class="lineNum">    1587 </span>            :     }
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            :     // Get bounds of clip in current transform space
<span class="lineNum">    1590 </span>            :     // (clip bounds are given in device space).
<span class="lineNum">    1591 </span>            :     SkRect bounds;
<span class="lineNum">    1592 </span>            :     SkMatrix transformInverse;
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :     SkMatrix totalMatrix = *d.fMatrix;</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :     if (prePathMatrix) {</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :         totalMatrix.preConcat(*prePathMatrix);</span>
<span class="lineNum">    1596 </span>            :     }
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     if (!totalMatrix.invert(&amp;transformInverse)) {</span>
<span class="lineNum">    1598 </span>            :         return false;
<span class="lineNum">    1599 </span>            :     }
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :     bounds.set(d.fRC-&gt;getBounds());</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :     transformInverse.mapRect(&amp;bounds);</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :     // Extend the bounds by the line width (plus some padding)
<span class="lineNum">    1604 </span>            :     // so the edge doesn't cause a visible stroke.
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :     bounds.outset(paint.getStrokeWidth() + SK_Scalar1,</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :                   paint.getStrokeWidth() + SK_Scalar1);</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :     if (!calculate_inverse_path(bounds, *pathPtr, &amp;modifiedPath)) {</span>
<span class="lineNum">    1609 </span>            :         return false;
<span class="lineNum">    1610 </span>            :     }
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     drawPath(d, modifiedPath, noInversePaint, prePathMatrix, true);</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1614"><span class="lineNum">    1614 </span>            : }</a>
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 : void SkPDFDevice::handlePointAnnotation(const SkPoint&amp; point,</span>
<span class="lineNum">    1617 </span>            :                                         const SkMatrix&amp; matrix,
<span class="lineNum">    1618 </span>            :                                         const char key[], SkData* value) {
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :     if (!value) {</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1621 </span>            :     }
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :     if (!strcmp(SkAnnotationKeys::Define_Named_Dest_Key(), key)) {</span>
<span class="lineNum">    1624 </span>            :         SkPoint transformedPoint;
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :         matrix.mapXY(point.x(), point.y(), &amp;transformedPoint);</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :         fNamedDestinations.emplace_back(value, transformedPoint);</span>
<span class="lineNum">    1627 </span>            :     }
<a name="1628"><span class="lineNum">    1628 </span>            : }</a>
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 : void SkPDFDevice::handlePathAnnotation(const SkPath&amp; path,</span>
<span class="lineNum">    1631 </span>            :                                        const SkDraw&amp; d,
<span class="lineNum">    1632 </span>            :                                        const char key[], SkData* value) {
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :     if (!value) {</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1635 </span>            :     }
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     SkRasterClip clip = *d.fRC;</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     clip.op(path, *d.fMatrix, SkIRect::MakeWH(width(), height()),</span>
<span class="lineNum">    1639 </span>            :             SkRegion::kIntersect_Op,
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :             false);</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :     SkRect transformedRect = SkRect::Make(clip.getBounds());</span>
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :     if (!strcmp(SkAnnotationKeys::URL_Key(), key)) {</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :         if (!transformedRect.isEmpty()) {</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :             fLinkToURLs.emplace_back(transformedRect, value);</span>
<span class="lineNum">    1646 </span>            :         }
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :     } else if (!strcmp(SkAnnotationKeys::Link_Named_Dest_Key(), key)) {</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :         if (!transformedRect.isEmpty()) {</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :             fLinkToDestinations.emplace_back(transformedRect, value);</span>
<span class="lineNum">    1650 </span>            :         }
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :     }</span>
<a name="1652"><span class="lineNum">    1652 </span>            : }</a>
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 : void SkPDFDevice::appendAnnotations(SkPDFArray* array) const {</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :     array-&gt;reserve(fLinkToURLs.count() + fLinkToDestinations.count());</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :     for (const RectWithData&amp; rectWithURL : fLinkToURLs) {</span>
<span class="lineNum">    1657 </span>            :         SkRect r;
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :         fInitialTransform.mapRect(&amp;r, rectWithURL.rect);</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :         array-&gt;appendObject(create_link_to_url(rectWithURL.data.get(), r));</span>
<span class="lineNum">    1660 </span>            :     }
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :     for (const RectWithData&amp; linkToDestination : fLinkToDestinations) {</span>
<span class="lineNum">    1662 </span>            :         SkRect r;
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :         fInitialTransform.mapRect(&amp;r, linkToDestination.rect);</span>
<span class="lineNum">    1664 </span>            :         array-&gt;appendObject(
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                 create_link_named_dest(linkToDestination.data.get(), r));</span>
<span class="lineNum">    1666 </span>            :     }
<a name="1667"><span class="lineNum">    1667 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 : void SkPDFDevice::appendDestinations(SkPDFDict* dict, SkPDFObject* page) const {</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :     for (const NamedDestination&amp; dest : fNamedDestinations) {</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :         auto pdfDest = sk_make_sp&lt;SkPDFArray&gt;();</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :         pdfDest-&gt;reserve(5);</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :         pdfDest-&gt;appendObjRef(sk_ref_sp(page));</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :         pdfDest-&gt;appendName(&quot;XYZ&quot;);</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :         SkPoint p = fInitialTransform.mapXY(dest.point.x(), dest.point.y());</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :         pdfDest-&gt;appendScalar(p.x());</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :         pdfDest-&gt;appendScalar(p.y());</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :         pdfDest-&gt;appendInt(0);  // Leave zoom unchanged</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :         SkString name(static_cast&lt;const char*&gt;(dest.nameData-&gt;data()));</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :         dict-&gt;insertObject(name, std::move(pdfDest));</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     }</span>
<a name="1682"><span class="lineNum">    1682 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 : sk_sp&lt;SkPDFObject&gt; SkPDFDevice::makeFormXObjectFromDevice() {</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :     SkMatrix inverseTransform = SkMatrix::I();</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :     if (!fInitialTransform.isIdentity()) {</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :         if (!fInitialTransform.invert(&amp;inverseTransform)) {</span>
<span class="lineNum">    1688 </span>            :             SkDEBUGFAIL(&quot;Layer initial transform should be invertible.&quot;);
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :             inverseTransform.reset();</span>
<span class="lineNum">    1690 </span>            :         }
<span class="lineNum">    1691 </span>            :     }
<span class="lineNum">    1692 </span>            :     sk_sp&lt;SkPDFObject&gt; xobject =
<span class="lineNum">    1693 </span>            :         SkPDFMakeFormXObject(this-&gt;content(), this-&gt;copyMediaBox(),
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :                              this-&gt;makeResourceDict(), inverseTransform, nullptr);</span>
<span class="lineNum">    1695 </span>            :     // We always draw the form xobjects that we create back into the device, so
<span class="lineNum">    1696 </span>            :     // we simply preserve the font usage instead of pulling it out and merging
<span class="lineNum">    1697 </span>            :     // it back in later.
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :     this-&gt;cleanUp();  // Reset this device to have no content.</span>
<span class="lineNum">    1699 </span>            :     this-&gt;init();
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     return xobject;</span>
<a name="1701"><span class="lineNum">    1701 </span>            : }</a>
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawFormXObjectWithMask(int xObjectIndex,</span>
<span class="lineNum">    1704 </span>            :                                           sk_sp&lt;SkPDFObject&gt; mask,
<span class="lineNum">    1705 </span>            :                                           const SkClipStack* clipStack,
<span class="lineNum">    1706 </span>            :                                           const SkRegion&amp; clipRegion,
<span class="lineNum">    1707 </span>            :                                           SkBlendMode mode,
<span class="lineNum">    1708 </span>            :                                           bool invertClip) {
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :     if (clipRegion.isEmpty() &amp;&amp; !invertClip) {</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1711 </span>            :     }
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            :     sk_sp&lt;SkPDFDict&gt; sMaskGS = SkPDFGraphicState::GetSMaskGraphicState(
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :             std::move(mask), invertClip,</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :             SkPDFGraphicState::kAlpha_SMaskMode, fDocument-&gt;canon());</span>
<span class="lineNum">    1716 </span>            : 
<span class="lineNum">    1717 </span>            :     SkMatrix identity;
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :     identity.reset();</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :     SkPaint paint;</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     paint.setBlendMode(mode);</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, clipStack, clipRegion, identity, paint);</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1724 </span>            :     }
<span class="lineNum">    1725 </span>            :     SkPDFUtils::ApplyGraphicState(addGraphicStateResource(sMaskGS.get()),
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :                                   &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     SkPDFUtils::DrawFormXObject(xObjectIndex, &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :     // Call makeNoSmaskGraphicState() instead of
<span class="lineNum">    1730 </span>            :     // SkPDFGraphicState::MakeNoSmaskGraphicState so that the canon
<span class="lineNum">    1731 </span>            :     // can deduplicate.
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :     sMaskGS = fDocument-&gt;canon()-&gt;makeNoSmaskGraphicState();</span>
<span class="lineNum">    1733 </span>            :     SkPDFUtils::ApplyGraphicState(addGraphicStateResource(sMaskGS.get()),
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :                                   &amp;content.entry()-&gt;fContent);</span>
<a name="1735"><span class="lineNum">    1735 </span>            : }</a>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 : SkPDFDevice::ContentEntry* SkPDFDevice::setUpContentEntry(const SkClipStack* clipStack,</span>
<span class="lineNum">    1738 </span>            :                                              const SkRegion&amp; clipRegion,
<span class="lineNum">    1739 </span>            :                                              const SkMatrix&amp; matrix,
<span class="lineNum">    1740 </span>            :                                              const SkPaint&amp; paint,
<span class="lineNum">    1741 </span>            :                                              bool hasText,
<span class="lineNum">    1742 </span>            :                                              sk_sp&lt;SkPDFObject&gt;* dst) {
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     *dst = nullptr;</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     if (clipRegion.isEmpty()) {</span>
<span class="lineNum">    1745 </span>            :         return nullptr;
<span class="lineNum">    1746 </span>            :     }
<span class="lineNum">    1747 </span>            : 
<span class="lineNum">    1748 </span>            :     // The clip stack can come from an SkDraw where it is technically optional.
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :     SkClipStack synthesizedClipStack;</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :     if (clipStack == nullptr) {</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :         if (clipRegion == fExistingClipRegion) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :             clipStack = &amp;fExistingClipStack;</span>
<span class="lineNum">    1753 </span>            :         } else {
<span class="lineNum">    1754 </span>            :             // GraphicStackState::updateClip expects the clip stack to have
<span class="lineNum">    1755 </span>            :             // fExistingClip as a prefix, so start there, then set the clip
<span class="lineNum">    1756 </span>            :             // to the passed region.
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :             synthesizedClipStack = fExistingClipStack;</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :             SkPath clipPath;</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :             clipRegion.getBoundaryPath(&amp;clipPath);</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :             synthesizedClipStack.clipPath(clipPath, SkMatrix::I(), SkCanvas::kReplace_Op, false);</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :             clipStack = &amp;synthesizedClipStack;</span>
<span class="lineNum">    1762 </span>            :         }
<span class="lineNum">    1763 </span>            :     }
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :     SkBlendMode blendMode = paint.getBlendMode();</span>
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            :     // For the following modes, we want to handle source and destination
<span class="lineNum">    1768 </span>            :     // separately, so make an object of what's already there.
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :     if (blendMode == SkBlendMode::kClear       ||</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kSrc     ||</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kSrcIn   ||</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kDstIn   ||</span>
<span class="lineNum">    1773 </span>            :             blendMode == SkBlendMode::kSrcOut  ||
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kDstOut  ||</span>
<span class="lineNum">    1775 </span>            :             blendMode == SkBlendMode::kSrcATop ||
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kDstATop ||</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kModulate) {</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :         if (!isContentEmpty()) {</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :             *dst = this-&gt;makeFormXObjectFromDevice();</span>
<span class="lineNum">    1780 </span>            :             SkASSERT(isContentEmpty());
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :         } else if (blendMode != SkBlendMode::kSrc &amp;&amp;</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :                    blendMode != SkBlendMode::kSrcOut) {</span>
<span class="lineNum">    1783 </span>            :             // Except for Src and SrcOut, if there isn't anything already there,
<span class="lineNum">    1784 </span>            :             // then we're done.
<span class="lineNum">    1785 </span>            :             return nullptr;
<span class="lineNum">    1786 </span>            :         }
<span class="lineNum">    1787 </span>            :     }
<span class="lineNum">    1788 </span>            :     // TODO(vandebo): Figure out how/if we can handle the following modes:
<span class="lineNum">    1789 </span>            :     // Xor, Plus.
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :     // Dst xfer mode doesn't draw source at all.
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :     if (blendMode == SkBlendMode::kDst) {</span>
<span class="lineNum">    1793 </span>            :         return nullptr;
<span class="lineNum">    1794 </span>            :     }
<span class="lineNum">    1795 </span>            : 
<span class="lineNum">    1796 </span>            :     SkPDFDevice::ContentEntry* entry;
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :     if (fContentEntries.back() &amp;&amp; fContentEntries.back()-&gt;fContent.getOffset() == 0) {</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :         entry = fContentEntries.back();</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     } else if (blendMode != SkBlendMode::kDstOver) {</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :         entry = fContentEntries.emplace_back();</span>
<span class="lineNum">    1801 </span>            :     } else {
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :         entry = fContentEntries.emplace_front();</span>
<span class="lineNum">    1803 </span>            :     }
<span class="lineNum">    1804 </span>            :     populateGraphicStateEntryFromPaint(matrix, *clipStack, clipRegion, paint,
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :                                        hasText, &amp;entry-&gt;fState);</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :     return entry;</span>
<a name="1807"><span class="lineNum">    1807 </span>            : }</a>
<span class="lineNum">    1808 </span>            : 
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 : void SkPDFDevice::finishContentEntry(SkBlendMode blendMode,</span>
<span class="lineNum">    1810 </span>            :                                      sk_sp&lt;SkPDFObject&gt; dst,
<span class="lineNum">    1811 </span>            :                                      SkPath* shape) {
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :     if (blendMode != SkBlendMode::kClear       &amp;&amp;</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :             blendMode != SkBlendMode::kSrc     &amp;&amp;</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :             blendMode != SkBlendMode::kDstOver &amp;&amp;</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :             blendMode != SkBlendMode::kSrcIn   &amp;&amp;</span>
<span class="lineNum">    1816 </span>            :             blendMode != SkBlendMode::kDstIn   &amp;&amp;
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :             blendMode != SkBlendMode::kSrcOut  &amp;&amp;</span>
<span class="lineNum">    1818 </span>            :             blendMode != SkBlendMode::kDstOut  &amp;&amp;
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :             blendMode != SkBlendMode::kSrcATop &amp;&amp;</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :             blendMode != SkBlendMode::kDstATop &amp;&amp;</span>
<span class="lineNum">    1821 </span>            :             blendMode != SkBlendMode::kModulate) {
<span class="lineNum">    1822 </span>            :         SkASSERT(!dst);
<span class="lineNum">    1823 </span>            :         return;
<span class="lineNum">    1824 </span>            :     }
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :     if (blendMode == SkBlendMode::kDstOver) {</span>
<span class="lineNum">    1826 </span>            :         SkASSERT(!dst);
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :         if (fContentEntries.front()-&gt;fContent.getOffset() == 0) {</span>
<span class="lineNum">    1828 </span>            :             // For DstOver, an empty content entry was inserted before the rest
<span class="lineNum">    1829 </span>            :             // of the content entries. If nothing was drawn, it needs to be
<span class="lineNum">    1830 </span>            :             // removed.
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :             fContentEntries.pop_front();</span>
<span class="lineNum">    1832 </span>            :         }
<span class="lineNum">    1833 </span>            :         return;
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :     if (!dst) {</span>
<span class="lineNum">    1836 </span>            :         SkASSERT(blendMode == SkBlendMode::kSrc ||
<span class="lineNum">    1837 </span>            :                  blendMode == SkBlendMode::kSrcOut);
<span class="lineNum">    1838 </span>            :         return;
<span class="lineNum">    1839 </span>            :     }
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            :     SkASSERT(dst);
<span class="lineNum">    1842 </span>            :     SkASSERT(fContentEntries.count() == 1);
<span class="lineNum">    1843 </span>            :     // Changing the current content into a form-xobject will destroy the clip
<span class="lineNum">    1844 </span>            :     // objects which is fine since the xobject will already be clipped. However
<span class="lineNum">    1845 </span>            :     // if source has shape, we need to clip it too, so a copy of the clip is
<span class="lineNum">    1846 </span>            :     // saved.
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     SkClipStack clipStack = fContentEntries.front()-&gt;fState.fClipStack;</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :     SkRegion clipRegion = fContentEntries.front()-&gt;fState.fClipRegion;</span>
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span>            :     SkMatrix identity;
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     identity.reset();</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :     SkPaint stockPaint;</span>
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFObject&gt; srcFormXObject;</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :     if (isContentEmpty()) {</span>
<span class="lineNum">    1857 </span>            :         // If nothing was drawn and there's no shape, then the draw was a
<span class="lineNum">    1858 </span>            :         // no-op, but dst needs to be restored for that to be true.
<span class="lineNum">    1859 </span>            :         // If there is shape, then an empty source with Src, SrcIn, SrcOut,
<span class="lineNum">    1860 </span>            :         // DstIn, DstAtop or Modulate reduces to Clear and DstOut or SrcAtop
<span class="lineNum">    1861 </span>            :         // reduces to Dst.
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :         if (shape == nullptr || blendMode == SkBlendMode::kDstOut ||</span>
<span class="lineNum">    1863 </span>            :                 blendMode == SkBlendMode::kSrcATop) {
<span class="lineNum">    1864 </span>            :             ScopedContentEntry content(this, &amp;fExistingClipStack,
<span class="lineNum">    1865 </span>            :                                        fExistingClipRegion, identity,
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :                                        stockPaint);</span>
<span class="lineNum">    1867 </span>            :             // TODO: addXObjectResource take sk_sp
<span class="lineNum">    1868 </span>            :             SkPDFUtils::DrawFormXObject(this-&gt;addXObjectResource(dst.get()),
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :                                         &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1871 </span>            :         } else {
<span class="lineNum">    1872 </span>            :             blendMode = SkBlendMode::kClear;
<span class="lineNum">    1873 </span>            :         }
<span class="lineNum">    1874 </span>            :     } else {
<span class="lineNum">    1875 </span>            :         SkASSERT(fContentEntries.count() == 1);
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :         srcFormXObject = this-&gt;makeFormXObjectFromDevice();</span>
<span class="lineNum">    1877 </span>            :     }
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            :     // TODO(vandebo) srcFormXObject may contain alpha, but here we want it
<span class="lineNum">    1880 </span>            :     // without alpha.
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :     if (blendMode == SkBlendMode::kSrcATop) {</span>
<span class="lineNum">    1882 </span>            :         // TODO(vandebo): In order to properly support SrcATop we have to track
<span class="lineNum">    1883 </span>            :         // the shape of what's been drawn at all times. It's the intersection of
<span class="lineNum">    1884 </span>            :         // the non-transparent parts of the device and the outlines (shape) of
<span class="lineNum">    1885 </span>            :         // all images and devices drawn.
<span class="lineNum">    1886 </span>            :         drawFormXObjectWithMask(addXObjectResource(srcFormXObject.get()), dst,
<span class="lineNum">    1887 </span>            :                                 &amp;fExistingClipStack, fExistingClipRegion,
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :                                 SkBlendMode::kSrcOver, true);</span>
<span class="lineNum">    1889 </span>            :     } else {
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :         if (shape != nullptr) {</span>
<span class="lineNum">    1891 </span>            :             // Draw shape into a form-xobject.
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :             SkRasterClip rc(clipRegion);</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :             SkDraw d;</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :             d.fMatrix = &amp;identity;</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :             d.fRC = &amp;rc;</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :             d.fClipStack = &amp;clipStack;</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :             SkPaint filledPaint;</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :             filledPaint.setColor(SK_ColorBLACK);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :             filledPaint.setStyle(SkPaint::kFill_Style);</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :             this-&gt;drawPath(d, *shape, filledPaint, nullptr, true);</span>
<span class="lineNum">    1901 </span>            :             drawFormXObjectWithMask(addXObjectResource(dst.get()),
<span class="lineNum">    1902 </span>            :                                     this-&gt;makeFormXObjectFromDevice(),
<span class="lineNum">    1903 </span>            :                                     &amp;fExistingClipStack, fExistingClipRegion,
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                                     SkBlendMode::kSrcOver, true);</span>
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span>            :         } else {
<span class="lineNum">    1907 </span>            :             drawFormXObjectWithMask(addXObjectResource(dst.get()), srcFormXObject,
<span class="lineNum">    1908 </span>            :                                     &amp;fExistingClipStack, fExistingClipRegion,
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                                     SkBlendMode::kSrcOver, true);</span>
<span class="lineNum">    1910 </span>            :         }
<span class="lineNum">    1911 </span>            :     }
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :     if (blendMode == SkBlendMode::kClear) {</span>
<span class="lineNum">    1914 </span>            :         return;
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     } else if (blendMode == SkBlendMode::kSrc ||</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kDstATop) {</span>
<span class="lineNum">    1917 </span>            :         ScopedContentEntry content(this, &amp;fExistingClipStack,
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :                                    fExistingClipRegion, identity, stockPaint);</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :         if (content.entry()) {</span>
<span class="lineNum">    1920 </span>            :             SkPDFUtils::DrawFormXObject(
<span class="lineNum">    1921 </span>            :                     this-&gt;addXObjectResource(srcFormXObject.get()),
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :                     &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">    1923 </span>            :         }
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :         if (blendMode == SkBlendMode::kSrc) {</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :     } else if (blendMode == SkBlendMode::kSrcATop) {</span>
<span class="lineNum">    1928 </span>            :         ScopedContentEntry content(this, &amp;fExistingClipStack,
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :                                    fExistingClipRegion, identity, stockPaint);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :         if (content.entry()) {</span>
<span class="lineNum">    1931 </span>            :             SkPDFUtils::DrawFormXObject(this-&gt;addXObjectResource(dst.get()),
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :                                         &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1934 </span>            :     }
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            :     SkASSERT(blendMode == SkBlendMode::kSrcIn   ||
<span class="lineNum">    1937 </span>            :              blendMode == SkBlendMode::kDstIn   ||
<span class="lineNum">    1938 </span>            :              blendMode == SkBlendMode::kSrcOut  ||
<span class="lineNum">    1939 </span>            :              blendMode == SkBlendMode::kDstOut  ||
<span class="lineNum">    1940 </span>            :              blendMode == SkBlendMode::kSrcATop ||
<span class="lineNum">    1941 </span>            :              blendMode == SkBlendMode::kDstATop ||
<span class="lineNum">    1942 </span>            :              blendMode == SkBlendMode::kModulate);
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :     if (blendMode == SkBlendMode::kSrcIn ||</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :             blendMode == SkBlendMode::kSrcOut ||</span>
<span class="lineNum">    1946 </span>            :             blendMode == SkBlendMode::kSrcATop) {
<span class="lineNum">    1947 </span>            :         drawFormXObjectWithMask(addXObjectResource(srcFormXObject.get()),
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :                                 std::move(dst),</span>
<span class="lineNum">    1949 </span>            :                                 &amp;fExistingClipStack, fExistingClipRegion,
<span class="lineNum">    1950 </span>            :                                 SkBlendMode::kSrcOver,
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :                                 blendMode == SkBlendMode::kSrcOut);</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1953 </span>            :     } else {
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :         SkBlendMode mode = SkBlendMode::kSrcOver;</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :         int resourceID = addXObjectResource(dst.get());</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :         if (blendMode == SkBlendMode::kModulate) {</span>
<span class="lineNum">    1957 </span>            :             drawFormXObjectWithMask(addXObjectResource(srcFormXObject.get()),
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                                     std::move(dst), &amp;fExistingClipStack,</span>
<span class="lineNum">    1959 </span>            :                                     fExistingClipRegion,
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :                                     SkBlendMode::kSrcOver, false);</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :             mode = SkBlendMode::kMultiply;</span>
<span class="lineNum">    1962 </span>            :         }
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :         drawFormXObjectWithMask(resourceID, std::move(srcFormXObject),</span>
<span class="lineNum">    1964 </span>            :                                 &amp;fExistingClipStack, fExistingClipRegion, mode,
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :                                 blendMode == SkBlendMode::kDstOut);</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :     }</span>
<a name="1968"><span class="lineNum">    1968 </span>            : }</a>
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 : bool SkPDFDevice::isContentEmpty() {</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     if (!fContentEntries.front() || fContentEntries.front()-&gt;fContent.getOffset() == 0) {</span>
<span class="lineNum">    1972 </span>            :         SkASSERT(fContentEntries.count() &lt;= 1);
<span class="lineNum">    1973 </span>            :         return true;
<span class="lineNum">    1974 </span>            :     }
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="1976"><span class="lineNum">    1976 </span>            : }</a>
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 : void SkPDFDevice::populateGraphicStateEntryFromPaint(</span>
<span class="lineNum">    1979 </span>            :         const SkMatrix&amp; matrix,
<span class="lineNum">    1980 </span>            :         const SkClipStack&amp; clipStack,
<span class="lineNum">    1981 </span>            :         const SkRegion&amp; clipRegion,
<span class="lineNum">    1982 </span>            :         const SkPaint&amp; paint,
<span class="lineNum">    1983 </span>            :         bool hasText,
<span class="lineNum">    1984 </span>            :         SkPDFDevice::GraphicStateEntry* entry) {
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :     NOT_IMPLEMENTED(paint.getPathEffect() != nullptr, false);</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :     NOT_IMPLEMENTED(paint.getMaskFilter() != nullptr, false);</span>
<span class="lineNum">    1987 </span>            :     NOT_IMPLEMENTED(paint.getColorFilter() != nullptr, false);
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :     entry-&gt;fMatrix = matrix;</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :     entry-&gt;fClipStack = clipStack;</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :     entry-&gt;fClipRegion = clipRegion;</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :     entry-&gt;fColor = SkColorSetA(paint.getColor(), 0xFF);</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :     entry-&gt;fShaderIndex = -1;</span>
<span class="lineNum">    1994 </span>            : 
<span class="lineNum">    1995 </span>            :     // PDF treats a shader as a color, so we only set one or the other.
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFObject&gt; pdfShader;</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :     SkShader* shader = paint.getShader();</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :     SkColor color = paint.getColor();</span>
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :     if (shader) {</span>
<span class="lineNum">    2000 </span>            :         // PDF positions patterns relative to the initial transform, so
<span class="lineNum">    2001 </span>            :         // we need to apply the current transform to the shader parameters.
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :         SkMatrix transform = matrix;</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :         transform.postConcat(fInitialTransform);</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span>            :         // PDF doesn't support kClamp_TileMode, so we simulate it by making
<span class="lineNum">    2006 </span>            :         // a pattern the size of the current clip.
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :         SkIRect bounds = clipRegion.getBounds();</span>
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span>            :         // We need to apply the initial transform to bounds in order to get
<span class="lineNum">    2010 </span>            :         // bounds in a consistent coordinate system.
<span class="lineNum">    2011 </span>            :         SkRect boundsTemp;
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :         boundsTemp.set(bounds);</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :         fInitialTransform.mapRect(&amp;boundsTemp);</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :         boundsTemp.roundOut(&amp;bounds);</span>
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span>            :         SkScalar rasterScale =
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :                 SkIntToScalar(fRasterDpi) / DPI_FOR_RASTER_SCALE_ONE;</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :         pdfShader = SkPDFShader::GetPDFShader(</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :                 fDocument, fRasterDpi, shader, transform, bounds, rasterScale);</span>
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :         if (pdfShader.get()) {</span>
<span class="lineNum">    2022 </span>            :             // pdfShader has been canonicalized so we can directly compare
<span class="lineNum">    2023 </span>            :             // pointers.
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :             int resourceIndex = fShaderResources.find(pdfShader.get());</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :             if (resourceIndex &lt; 0) {</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :                 resourceIndex = fShaderResources.count();</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :                 fShaderResources.push(pdfShader.get());</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :                 pdfShader.get()-&gt;ref();</span>
<span class="lineNum">    2029 </span>            :             }
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :             entry-&gt;fShaderIndex = resourceIndex;</span>
<span class="lineNum">    2031 </span>            :         } else {
<span class="lineNum">    2032 </span>            :             // A color shader is treated as an invalid shader so we don't have
<span class="lineNum">    2033 </span>            :             // to set a shader just for a color.
<span class="lineNum">    2034 </span>            :             SkShader::GradientInfo gradientInfo;
<span class="lineNum">    2035 </span>            :             SkColor gradientColor;
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :             gradientInfo.fColors = &amp;gradientColor;</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :             gradientInfo.fColorOffsets = nullptr;</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :             gradientInfo.fColorCount = 1;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :             if (shader-&gt;asAGradient(&amp;gradientInfo) ==</span>
<span class="lineNum">    2040 </span>            :                     SkShader::kColor_GradientType) {
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :                 entry-&gt;fColor = SkColorSetA(gradientColor, 0xFF);</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :                 color = gradientColor;</span>
<span class="lineNum">    2043 </span>            :             }
<span class="lineNum">    2044 </span>            :         }
<span class="lineNum">    2045 </span>            :     }
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFGraphicState&gt; newGraphicState;</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :     if (color == paint.getColor()) {</span>
<span class="lineNum">    2049 </span>            :         newGraphicState.reset(
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :                 SkPDFGraphicState::GetGraphicStateForPaint(fDocument-&gt;canon(), paint));</span>
<span class="lineNum">    2051 </span>            :     } else {
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :         SkPaint newPaint = paint;</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :         newPaint.setColor(color);</span>
<span class="lineNum">    2054 </span>            :         newGraphicState.reset(
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :                 SkPDFGraphicState::GetGraphicStateForPaint(fDocument-&gt;canon(), newPaint));</span>
<span class="lineNum">    2056 </span>            :     }
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :     int resourceIndex = addGraphicStateResource(newGraphicState.get());</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :     entry-&gt;fGraphicStateIndex = resourceIndex;</span>
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :     if (hasText) {</span>
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :         entry-&gt;fTextScaleX = paint.getTextScaleX();</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :         entry-&gt;fTextFill = paint.getStyle();</span>
<span class="lineNum">    2063 </span>            :     } else {
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :         entry-&gt;fTextScaleX = 0;</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :     }</span>
<a name="2066"><span class="lineNum">    2066 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 : int SkPDFDevice::addGraphicStateResource(SkPDFObject* gs) {</span>
<span class="lineNum">    2069 </span>            :     // Assumes that gs has been canonicalized (so we can directly compare
<span class="lineNum">    2070 </span>            :     // pointers).
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :     int result = fGraphicStateResources.find(gs);</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     if (result &lt; 0) {</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         result = fGraphicStateResources.count();</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         fGraphicStateResources.push(gs);</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         gs-&gt;ref();</span>
<span class="lineNum">    2076 </span>            :     }
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :     return result;</span>
<a name="2078"><span class="lineNum">    2078 </span>            : }</a>
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 : int SkPDFDevice::addXObjectResource(SkPDFObject* xObject) {</span>
<span class="lineNum">    2081 </span>            :     // TODO(halcanary): make this take a sk_sp&lt;SkPDFObject&gt;
<span class="lineNum">    2082 </span>            :     // Assumes that xobject has been canonicalized (so we can directly compare
<span class="lineNum">    2083 </span>            :     // pointers).
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :     int result = fXObjectResources.find(xObject);</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     if (result &lt; 0) {</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         result = fXObjectResources.count();</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :         fXObjectResources.push(SkRef(xObject));</span>
<span class="lineNum">    2088 </span>            :     }
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     return result;</span>
<a name="2090"><span class="lineNum">    2090 </span>            : }</a>
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 : int SkPDFDevice::getFontResourceIndex(SkTypeface* typeface, uint16_t glyphID) {</span>
<span class="lineNum">    2093 </span>            :     sk_sp&lt;SkPDFFont&gt; newFont(
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :             SkPDFFont::GetFontResource(fDocument-&gt;canon(), typeface, glyphID));</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :     if (!newFont) {</span>
<span class="lineNum">    2096 </span>            :         return -1;
<span class="lineNum">    2097 </span>            :     }
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :     int resourceIndex = fFontResources.find(newFont.get());</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :     if (resourceIndex &lt; 0) {</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :         fDocument-&gt;registerFont(newFont.get());</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :         resourceIndex = fFontResources.count();</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         fFontResources.push(newFont.release());</span>
<span class="lineNum">    2103 </span>            :     }
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :     return resourceIndex;</span>
<a name="2105"><span class="lineNum">    2105 </span>            : }</a>
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 : static SkSize rect_to_size(const SkRect&amp; r) {</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :     return SkSize::Make(r.width(), r.height());</span>
<a name="2109"><span class="lineNum">    2109 </span>            : }</a>
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 : static sk_sp&lt;SkImage&gt; color_filter(const SkImageSubset&amp; imageSubset,</span>
<span class="lineNum">    2112 </span>            :                                    SkColorFilter* colorFilter) {
<span class="lineNum">    2113 </span>            :     auto surface =
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :         SkSurface::MakeRaster(SkImageInfo::MakeN32Premul(imageSubset.dimensions()));</span>
<span class="lineNum">    2115 </span>            :     SkASSERT(surface);
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     SkCanvas* canvas = surface-&gt;getCanvas();</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     canvas-&gt;clear(SK_ColorTRANSPARENT);</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :     SkPaint paint;</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :     paint.setColorFilter(sk_ref_sp(colorFilter));</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :     imageSubset.draw(canvas, &amp;paint);</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :     canvas-&gt;flush();</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :     return surface-&gt;makeImageSnapshot();</span>
<span class="lineNum">    2123 </span>            : }
<a name="2124"><span class="lineNum">    2124 </span>            : </a>
<span class="lineNum">    2125 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 : void SkPDFDevice::internalDrawImage(const SkMatrix&amp; origMatrix,</span>
<span class="lineNum">    2127 </span>            :                                     const SkClipStack* clipStack,
<span class="lineNum">    2128 </span>            :                                     const SkRegion&amp; origClipRegion,
<span class="lineNum">    2129 </span>            :                                     SkImageSubset imageSubset,
<span class="lineNum">    2130 </span>            :                                     const SkPaint&amp; paint) {
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :     if (imageSubset.dimensions().isZero()) {</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2133 </span>            :     }
<span class="lineNum">    2134 </span>            :     #ifdef SK_PDF_IMAGE_STATS
<span class="lineNum">    2135 </span>            :     gDrawImageCalls.fetch_add(1);
<span class="lineNum">    2136 </span>            :     #endif
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :     SkMatrix matrix = origMatrix;</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :     SkRegion perspectiveBounds;</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :     const SkRegion* clipRegion = &amp;origClipRegion;</span>
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            :     // Rasterize the bitmap using perspective in a new bitmap.
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :     if (origMatrix.hasPerspective()) {</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :         if (fRasterDpi == 0) {</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2145 </span>            :         }
<span class="lineNum">    2146 </span>            :         // Transform the bitmap in the new space, without taking into
<span class="lineNum">    2147 </span>            :         // account the initial transform.
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :         SkPath perspectiveOutline;</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         SkRect imageBounds = SkRect::Make(imageSubset.bounds());</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :         perspectiveOutline.addRect(imageBounds);</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :         perspectiveOutline.transform(origMatrix);</span>
<span class="lineNum">    2152 </span>            : 
<span class="lineNum">    2153 </span>            :         // TODO(edisonn): perf - use current clip too.
<span class="lineNum">    2154 </span>            :         // Retrieve the bounds of the new shape.
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :         SkRect bounds = perspectiveOutline.getBounds();</span>
<span class="lineNum">    2156 </span>            : 
<span class="lineNum">    2157 </span>            :         // Transform the bitmap in the new space, taking into
<span class="lineNum">    2158 </span>            :         // account the initial transform.
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :         SkMatrix total = origMatrix;</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :         total.postConcat(fInitialTransform);</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :         SkScalar dpiScale = SkIntToScalar(fRasterDpi) /</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :                             SkIntToScalar(DPI_FOR_RASTER_SCALE_ONE);</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :         total.postScale(dpiScale, dpiScale);</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :         SkPath physicalPerspectiveOutline;</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :         physicalPerspectiveOutline.addRect(imageBounds);</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :         physicalPerspectiveOutline.transform(total);</span>
<span class="lineNum">    2168 </span>            : 
<span class="lineNum">    2169 </span>            :         SkRect physicalPerspectiveBounds =
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :                 physicalPerspectiveOutline.getBounds();</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         SkScalar scaleX = physicalPerspectiveBounds.width() / bounds.width();</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         SkScalar scaleY = physicalPerspectiveBounds.height() / bounds.height();</span>
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span>            :         // TODO(edisonn): A better approach would be to use a bitmap shader
<span class="lineNum">    2175 </span>            :         // (in clamp mode) and draw a rect over the entire bounding box. Then
<span class="lineNum">    2176 </span>            :         // intersect perspectiveOutline to the clip. That will avoid introducing
<span class="lineNum">    2177 </span>            :         // alpha to the image while still giving good behavior at the edge of
<span class="lineNum">    2178 </span>            :         // the image.  Avoiding alpha will reduce the pdf size and generation
<span class="lineNum">    2179 </span>            :         // CPU time some.
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :         SkISize wh = rect_to_size(physicalPerspectiveBounds).toCeil();</span>
<span class="lineNum">    2182 </span>            : 
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :         auto surface = SkSurface::MakeRaster(SkImageInfo::MakeN32Premul(wh));</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :         if (!surface) {</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2186 </span>            :         }
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :         SkCanvas* canvas = surface-&gt;getCanvas();</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :         canvas-&gt;clear(SK_ColorTRANSPARENT);</span>
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :         SkScalar deltaX = bounds.left();</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :         SkScalar deltaY = bounds.top();</span>
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :         SkMatrix offsetMatrix = origMatrix;</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :         offsetMatrix.postTranslate(-deltaX, -deltaY);</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :         offsetMatrix.postScale(scaleX, scaleY);</span>
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            :         // Translate the draw in the new canvas, so we perfectly fit the
<span class="lineNum">    2198 </span>            :         // shape in the bitmap.
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :         canvas-&gt;setMatrix(offsetMatrix);</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :         imageSubset.draw(canvas, nullptr);</span>
<span class="lineNum">    2201 </span>            :         // Make sure the final bits are in the bitmap.
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :         canvas-&gt;flush();</span>
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span>            :         // In the new space, we use the identity matrix translated
<span class="lineNum">    2205 </span>            :         // and scaled to reflect DPI.
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :         matrix.setScale(1 / scaleX, 1 / scaleY);</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :         matrix.postTranslate(deltaX, deltaY);</span>
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :         perspectiveBounds.setRect(bounds.roundOut());</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :         clipRegion = &amp;perspectiveBounds;</span>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :         imageSubset = SkImageSubset(surface-&gt;makeImageSnapshot());</span>
<span class="lineNum">    2213 </span>            :     }
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            :     SkMatrix scaled;
<span class="lineNum">    2216 </span>            :     // Adjust for origin flip.
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :     scaled.setScale(SK_Scalar1, -SK_Scalar1);</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :     scaled.postTranslate(0, SK_Scalar1);</span>
<span class="lineNum">    2219 </span>            :     // Scale the image up from 1x1 to WxH.
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :     SkIRect subset = imageSubset.bounds();</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :     scaled.postScale(SkIntToScalar(imageSubset.dimensions().width()),</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :                      SkIntToScalar(imageSubset.dimensions().height()));</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :     scaled.postConcat(matrix);</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     ScopedContentEntry content(this, clipStack, *clipRegion, scaled, paint);</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :     if (!content.entry()) {</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2227 </span>            :     }
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :     if (content.needShape()) {</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :         SkPath shape;</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :         shape.addRect(SkRect::Make(subset));</span>
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :         shape.transform(matrix);</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :         content.setShape(shape);</span>
<span class="lineNum">    2233 </span>            :     }
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :     if (!content.needSource()) {</span>
<span class="lineNum">    2235 </span>            :         return;
<span class="lineNum">    2236 </span>            :     }
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :     if (SkColorFilter* colorFilter = paint.getColorFilter()) {</span>
<span class="lineNum">    2239 </span>            :         // TODO(https://bug.skia.org/4378): implement colorfilter on other
<span class="lineNum">    2240 </span>            :         // draw calls.  This code here works for all
<span class="lineNum">    2241 </span>            :         // drawBitmap*()/drawImage*() calls amd ImageFilters (which
<span class="lineNum">    2242 </span>            :         // rasterize a layer on this backend).  Fortuanely, this seems
<span class="lineNum">    2243 </span>            :         // to be how Chromium impements most color-filters.
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :         sk_sp&lt;SkImage&gt; img = color_filter(imageSubset, colorFilter);</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :         imageSubset = SkImageSubset(std::move(img));</span>
<span class="lineNum">    2246 </span>            :         // TODO(halcanary): de-dupe this by caching filtered images.
<span class="lineNum">    2247 </span>            :         // (maybe in the resource cache?)
<span class="lineNum">    2248 </span>            :     }
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span>            :     SkBitmapKey key = imageSubset.getKey();
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :     sk_sp&lt;SkPDFObject&gt; pdfimage = fDocument-&gt;canon()-&gt;findPDFBitmap(key);</span>
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :     if (!pdfimage) {</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :         sk_sp&lt;SkImage&gt; img = imageSubset.makeImage();</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :         if (!img) {</span>
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2256 </span>            :         }
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :         pdfimage = SkPDFCreateBitmapObject(</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                 std::move(img), fDocument-&gt;canon()-&gt;getPixelSerializer());</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :         if (!pdfimage) {</span>
<span class="lineNum">    2260 </span>            :             return;
<span class="lineNum">    2261 </span>            :         }
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :         fDocument-&gt;serialize(pdfimage);  // serialize images early.</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :         fDocument-&gt;canon()-&gt;addPDFBitmap(key, pdfimage);</span>
<span class="lineNum">    2264 </span>            :     }
<span class="lineNum">    2265 </span>            :     // TODO(halcanary): addXObjectResource() should take a sk_sp&lt;SkPDFObject&gt;
<span class="lineNum">    2266 </span>            :     SkPDFUtils::DrawFormXObject(this-&gt;addXObjectResource(pdfimage.get()),
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                                 &amp;content.entry()-&gt;fContent);</span>
<span class="lineNum">    2268 </span>            : }
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            : ///////////////////////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            : #include &quot;SkSpecialImage.h&quot;
<a name="2273"><span class="lineNum">    2273 </span>            : #include &quot;SkImageFilter.h&quot;</a>
<span class="lineNum">    2274 </span>            : 
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 : void SkPDFDevice::drawSpecial(const SkDraw&amp; draw, SkSpecialImage* srcImg, int x, int y,</span>
<span class="lineNum">    2276 </span>            :                                  const SkPaint&amp; paint) {
<span class="lineNum">    2277 </span>            :     SkASSERT(!srcImg-&gt;isTextureBacked());
<span class="lineNum">    2278 </span>            : 
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :     SkBitmap resultBM;</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :     SkImageFilter* filter = paint.getImageFilter();</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :     if (filter) {</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :         SkIPoint offset = SkIPoint::Make(0, 0);</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :         SkMatrix matrix = *draw.fMatrix;</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :         matrix.postTranslate(SkIntToScalar(-x), SkIntToScalar(-y));</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :         const SkIRect clipBounds = draw.fRC-&gt;getBounds().makeOffset(-x, -y);</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :         SkAutoTUnref&lt;SkImageFilterCache&gt; cache(this-&gt;getImageFilterCache());</span>
<span class="lineNum">    2288 </span>            :         // TODO: Should PDF be operating in a specified color space? For now, run the filter
<span class="lineNum">    2289 </span>            :         // in the same color space as the source (this is different from all other backends).
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         SkImageFilter::OutputProperties outputProperties(srcImg-&gt;getColorSpace());</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :         SkImageFilter::Context ctx(matrix, clipBounds, cache.get(), outputProperties);</span>
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         sk_sp&lt;SkSpecialImage&gt; resultImg(filter-&gt;filterImage(srcImg, ctx, &amp;offset));</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :         if (resultImg) {</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :             SkPaint tmpUnfiltered(paint);</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :             tmpUnfiltered.setImageFilter(nullptr);</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :             if (resultImg-&gt;getROPixels(&amp;resultBM)) {</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :                 this-&gt;drawSprite(draw, resultBM, x + offset.x(), y + offset.y(), tmpUnfiltered);</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2300 </span>            :         }
<span class="lineNum">    2301 </span>            :     } else {
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :         if (srcImg-&gt;getROPixels(&amp;resultBM)) {</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :             this-&gt;drawSprite(draw, resultBM, x, y, paint);</span>
<span class="lineNum">    2304 </span>            :         }
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :     }</span>
<a name="2306"><span class="lineNum">    2306 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 : sk_sp&lt;SkSpecialImage&gt; SkPDFDevice::makeSpecial(const SkBitmap&amp; bitmap) {</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :     return SkSpecialImage::MakeFromRaster(bitmap.bounds(), bitmap);</span>
<a name="2310"><span class="lineNum">    2310 </span>            : }</a>
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 : sk_sp&lt;SkSpecialImage&gt; SkPDFDevice::makeSpecial(const SkImage* image) {</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :     return SkSpecialImage::MakeFromImage(SkIRect::MakeWH(image-&gt;width(), image-&gt;height()),</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :                                          image-&gt;makeNonTextureImage());</span>
<a name="2315"><span class="lineNum">    2315 </span>            : }</a>
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 : sk_sp&lt;SkSpecialImage&gt; SkPDFDevice::snapSpecial() {</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<a name="2319"><span class="lineNum">    2319 </span>            : }</a>
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 : SkImageFilterCache* SkPDFDevice::getImageFilterCache() {</span>
<span class="lineNum">    2322 </span>            :     // We always return a transient cache, so it is freed after each
<span class="lineNum">    2323 </span>            :     // filter traversal.
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :     return SkImageFilterCache::Create(SkImageFilterCache::kDefaultTransientSize);</span>
<span class="lineNum">    2325 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
