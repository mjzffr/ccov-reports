<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/common/uresdata.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/common</a> - uresdata.cpp<span style="font-size: 80%;"> (source / <a href="uresdata.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">272</td>
            <td class="headerCovTableEntry">610</td>
            <td class="headerCovTableEntryLo">44.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntryLo">70.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (C) 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : *******************************************************************************
<span class="lineNum">       5 </span>            : * Copyright (C) 1999-2016, International Business Machines Corporation
<span class="lineNum">       6 </span>            : *               and others. All Rights Reserved.
<span class="lineNum">       7 </span>            : *******************************************************************************
<span class="lineNum">       8 </span>            : *   file name:  uresdata.cpp
<span class="lineNum">       9 </span>            : *   encoding:   US-ASCII
<span class="lineNum">      10 </span>            : *   tab size:   8 (not used)
<span class="lineNum">      11 </span>            : *   indentation:4
<span class="lineNum">      12 </span>            : *
<span class="lineNum">      13 </span>            : *   created on: 1999dec08
<span class="lineNum">      14 </span>            : *   created by: Markus W. Scherer
<span class="lineNum">      15 </span>            : * Modification History:
<span class="lineNum">      16 </span>            : *
<span class="lineNum">      17 </span>            : *   Date        Name        Description
<span class="lineNum">      18 </span>            : *   06/20/2000  helena      OS/400 port changes; mostly typecast.
<span class="lineNum">      19 </span>            : *   06/24/02    weiv        Added support for resource sharing
<span class="lineNum">      20 </span>            : */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;unicode/udata.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;unicode/ustring.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;unicode/utf16.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;cstring.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;resource.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;uarrsort.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;ucol_swp.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;udataswp.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;uinvchar.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;uresdata.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;uresimp.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : /*
<span class="lineNum">      38 </span>            :  * Resource access helpers
<span class="lineNum">      39 </span>            :  */
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : /* get a const char* pointer to the key with the keyOffset byte offset from pRoot */
<span class="lineNum">      42 </span>            : #define RES_GET_KEY16(pResData, keyOffset) \
<span class="lineNum">      43 </span>            :     ((keyOffset)&lt;(pResData)-&gt;localKeyLimit ? \
<span class="lineNum">      44 </span>            :         (const char *)(pResData)-&gt;pRoot+(keyOffset) : \
<span class="lineNum">      45 </span>            :         (pResData)-&gt;poolBundleKeys+(keyOffset)-(pResData)-&gt;localKeyLimit)
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #define RES_GET_KEY32(pResData, keyOffset) \
<span class="lineNum">      48 </span>            :     ((keyOffset)&gt;=0 ? \
<span class="lineNum">      49 </span>            :         (const char *)(pResData)-&gt;pRoot+(keyOffset) : \
<span class="lineNum">      50 </span>            :         (pResData)-&gt;poolBundleKeys+((keyOffset)&amp;0x7fffffff))
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #define URESDATA_ITEM_NOT_FOUND -1
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /* empty resources, returned when the resource offset is 0 */
<span class="lineNum">      55 </span>            : static const uint16_t gEmpty16=0;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : static const struct {
<span class="lineNum">      58 </span>            :     int32_t length;
<span class="lineNum">      59 </span>            :     int32_t res;
<span class="lineNum">      60 </span>            : } gEmpty32={ 0, 0 };
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : static const struct {
<span class="lineNum">      63 </span>            :     int32_t length;
<span class="lineNum">      64 </span>            :     UChar nul;
<span class="lineNum">      65 </span>            :     UChar pad;
<span class="lineNum">      66 </span>            : } gEmptyString={ 0, 0, 0 };
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : /*
<span class="lineNum">      69 </span>            :  * All the type-access functions assume that
<span class="lineNum">      70 </span>            :  * the resource is of the expected type.
<span class="lineNum">      71 </span>            :  */
<a name="72"><span class="lineNum">      72 </span>            : </a>
<span class="lineNum">      73 </span>            : static int32_t
<span class="lineNum">      74 </span><span class="lineCov">          1 : _res_findTableItem(const ResourceData *pResData, const uint16_t *keyOffsets, int32_t length,</span>
<span class="lineNum">      75 </span>            :                    const char *key, const char **realKey) {
<span class="lineNum">      76 </span>            :     const char *tableKey;
<span class="lineNum">      77 </span>            :     int32_t mid, start, limit;
<span class="lineNum">      78 </span>            :     int result;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :     /* do a binary search for the key */
<span class="lineNum">      81 </span><span class="lineCov">          1 :     start=0;</span>
<span class="lineNum">      82 </span><span class="lineCov">          1 :     limit=length;</span>
<span class="lineNum">      83 </span><span class="lineCov">          1 :     while(start&lt;limit) {</span>
<span class="lineNum">      84 </span><span class="lineCov">          1 :         mid = (start + limit) / 2;</span>
<span class="lineNum">      85 </span><span class="lineCov">          1 :         tableKey = RES_GET_KEY16(pResData, keyOffsets[mid]);</span>
<span class="lineNum">      86 </span><span class="lineCov">          1 :         if (pResData-&gt;useNativeStrcmp) {</span>
<span class="lineNum">      87 </span><span class="lineCov">          1 :             result = uprv_strcmp(key, tableKey);</span>
<span class="lineNum">      88 </span>            :         } else {
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :             result = uprv_compareInvCharsAsAscii(key, tableKey);</span>
<span class="lineNum">      90 </span>            :         }
<span class="lineNum">      91 </span><span class="lineCov">          1 :         if (result &lt; 0) {</span>
<span class="lineNum">      92 </span>            :             limit = mid;
<span class="lineNum">      93 </span><span class="lineCov">          1 :         } else if (result &gt; 0) {</span>
<span class="lineNum">      94 </span><span class="lineCov">          1 :             start = mid + 1;</span>
<span class="lineNum">      95 </span>            :         } else {
<span class="lineNum">      96 </span>            :             /* We found it! */
<span class="lineNum">      97 </span><span class="lineCov">          1 :             *realKey=tableKey;</span>
<span class="lineNum">      98 </span><span class="lineCov">          1 :             return mid;</span>
<span class="lineNum">      99 </span>            :         }
<span class="lineNum">     100 </span>            :     }
<span class="lineNum">     101 </span>            :     return URESDATA_ITEM_NOT_FOUND;  /* not found or table is empty. */
<span class="lineNum">     102 </span>            : }
<a name="103"><span class="lineNum">     103 </span>            : </a>
<span class="lineNum">     104 </span>            : static int32_t
<span class="lineNum">     105 </span><span class="lineNoCov">          0 : _res_findTable32Item(const ResourceData *pResData, const int32_t *keyOffsets, int32_t length,</span>
<span class="lineNum">     106 </span>            :                      const char *key, const char **realKey) {
<span class="lineNum">     107 </span>            :     const char *tableKey;
<span class="lineNum">     108 </span>            :     int32_t mid, start, limit;
<span class="lineNum">     109 </span>            :     int result;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :     /* do a binary search for the key */
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     start=0;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     limit=length;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     while(start&lt;limit) {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         mid = (start + limit) / 2;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         tableKey = RES_GET_KEY32(pResData, keyOffsets[mid]);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :         if (pResData-&gt;useNativeStrcmp) {</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :             result = uprv_strcmp(key, tableKey);</span>
<span class="lineNum">     119 </span>            :         } else {
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :             result = uprv_compareInvCharsAsAscii(key, tableKey);</span>
<span class="lineNum">     121 </span>            :         }
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :         if (result &lt; 0) {</span>
<span class="lineNum">     123 </span>            :             limit = mid;
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         } else if (result &gt; 0) {</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :             start = mid + 1;</span>
<span class="lineNum">     126 </span>            :         } else {
<span class="lineNum">     127 </span>            :             /* We found it! */
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :             *realKey=tableKey;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :             return mid;</span>
<span class="lineNum">     130 </span>            :         }
<span class="lineNum">     131 </span>            :     }
<span class="lineNum">     132 </span>            :     return URESDATA_ITEM_NOT_FOUND;  /* not found or table is empty. */
<span class="lineNum">     133 </span>            : }
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /* helper for res_load() ---------------------------------------------------- */
<a name="136"><span class="lineNum">     136 </span>            : </a>
<span class="lineNum">     137 </span>            : static UBool U_CALLCONV
<span class="lineNum">     138 </span><span class="lineCov">          1 : isAcceptable(void *context,</span>
<span class="lineNum">     139 </span>            :              const char * /*type*/, const char * /*name*/,
<span class="lineNum">     140 </span>            :              const UDataInfo *pInfo) {
<span class="lineNum">     141 </span><span class="lineCov">          1 :     uprv_memcpy(context, pInfo-&gt;formatVersion, 4);</span>
<span class="lineNum">     142 </span>            :     return (UBool)(
<span class="lineNum">     143 </span><span class="lineCov">          1 :         pInfo-&gt;size&gt;=20 &amp;&amp;</span>
<span class="lineNum">     144 </span><span class="lineCov">          1 :         pInfo-&gt;isBigEndian==U_IS_BIG_ENDIAN &amp;&amp;</span>
<span class="lineNum">     145 </span><span class="lineCov">          1 :         pInfo-&gt;charsetFamily==U_CHARSET_FAMILY &amp;&amp;</span>
<span class="lineNum">     146 </span><span class="lineCov">          1 :         pInfo-&gt;sizeofUChar==U_SIZEOF_UCHAR &amp;&amp;</span>
<span class="lineNum">     147 </span><span class="lineCov">          1 :         pInfo-&gt;dataFormat[0]==0x52 &amp;&amp;   /* dataFormat=&quot;ResB&quot; */</span>
<span class="lineNum">     148 </span>            :         pInfo-&gt;dataFormat[1]==0x65 &amp;&amp;
<span class="lineNum">     149 </span><span class="lineCov">          1 :         pInfo-&gt;dataFormat[2]==0x73 &amp;&amp;</span>
<span class="lineNum">     150 </span><span class="lineCov">          1 :         pInfo-&gt;dataFormat[3]==0x42 &amp;&amp;</span>
<span class="lineNum">     151 </span><span class="lineCov">          1 :         (1&lt;=pInfo-&gt;formatVersion[0] &amp;&amp; pInfo-&gt;formatVersion[0]&lt;=3));</span>
<span class="lineNum">     152 </span>            : }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /* semi-public functions ---------------------------------------------------- */
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : static void
<span class="lineNum">     157 </span><span class="lineCov">          1 : res_init(ResourceData *pResData,</span>
<span class="lineNum">     158 </span>            :          UVersionInfo formatVersion, const void *inBytes, int32_t length,
<span class="lineNum">     159 </span>            :          UErrorCode *errorCode) {
<span class="lineNum">     160 </span>            :     UResType rootType;
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :     /* get the root resource */
<span class="lineNum">     163 </span><span class="lineCov">          1 :     pResData-&gt;pRoot=(const int32_t *)inBytes;</span>
<span class="lineNum">     164 </span><span class="lineCov">          1 :     pResData-&gt;rootRes=(Resource)*pResData-&gt;pRoot;</span>
<span class="lineNum">     165 </span><span class="lineCov">          1 :     pResData-&gt;p16BitUnits=&amp;gEmpty16;</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     /* formatVersion 1.1 must have a root item and at least 5 indexes */
<span class="lineNum">     168 </span><span class="lineCov">          1 :     if(length&gt;=0 &amp;&amp; (length/4)&lt;((formatVersion[0]==1 &amp;&amp; formatVersion[1]==0) ? 1 : 1+5)) {</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         *errorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         res_unload(pResData);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     172 </span>            :     }
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :     /* currently, we accept only resources that have a Table as their roots */
<span class="lineNum">     175 </span><span class="lineCov">          1 :     rootType=(UResType)RES_GET_TYPE(pResData-&gt;rootRes);</span>
<span class="lineNum">     176 </span><span class="lineCov">          1 :     if(!URES_IS_TABLE(rootType)) {</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         *errorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         res_unload(pResData);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     180 </span>            :     }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineCov">          1 :     if(formatVersion[0]==1 &amp;&amp; formatVersion[1]==0) {</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         pResData-&gt;localKeyLimit=0x10000;  /* greater than any 16-bit key string offset */</span>
<span class="lineNum">     184 </span>            :     } else {
<span class="lineNum">     185 </span>            :         /* bundles with formatVersion 1.1 and later contain an indexes[] array */
<span class="lineNum">     186 </span><span class="lineCov">          1 :         const int32_t *indexes=pResData-&gt;pRoot+1;</span>
<span class="lineNum">     187 </span><span class="lineCov">          1 :         int32_t indexLength=indexes[URES_INDEX_LENGTH]&amp;0xff;</span>
<span class="lineNum">     188 </span><span class="lineCov">          1 :         if(indexLength&lt;=URES_INDEX_MAX_TABLE_LENGTH) {</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :             *errorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :             res_unload(pResData);</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     192 </span>            :         }
<span class="lineNum">     193 </span><span class="lineCov">          1 :         if( length&gt;=0 &amp;&amp;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :             (length&lt;((1+indexLength)&lt;&lt;2) ||</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :              length&lt;(indexes[URES_INDEX_BUNDLE_TOP]&lt;&lt;2))</span>
<span class="lineNum">     196 </span>            :         ) {
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :             *errorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :             res_unload(pResData);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     200 </span>            :         }
<span class="lineNum">     201 </span><span class="lineCov">          1 :         if(indexes[URES_INDEX_KEYS_TOP]&gt;(1+indexLength)) {</span>
<span class="lineNum">     202 </span><span class="lineCov">          1 :             pResData-&gt;localKeyLimit=indexes[URES_INDEX_KEYS_TOP]&lt;&lt;2;</span>
<span class="lineNum">     203 </span>            :         }
<span class="lineNum">     204 </span><span class="lineCov">          1 :         if(formatVersion[0]&gt;=3) {</span>
<span class="lineNum">     205 </span>            :             // In formatVersion 1, the indexLength took up this whole int.
<span class="lineNum">     206 </span>            :             // In version 2, bits 31..8 were reserved and always 0.
<span class="lineNum">     207 </span>            :             // In version 3, they contain bits 23..0 of the poolStringIndexLimit.
<span class="lineNum">     208 </span>            :             // Bits 27..24 are in indexes[URES_INDEX_ATTRIBUTES] bits 15..12.
<span class="lineNum">     209 </span><span class="lineCov">          1 :             pResData-&gt;poolStringIndexLimit=(int32_t)((uint32_t)indexes[URES_INDEX_LENGTH]&gt;&gt;8);</span>
<span class="lineNum">     210 </span>            :         }
<span class="lineNum">     211 </span><span class="lineCov">          1 :         if(indexLength&gt;URES_INDEX_ATTRIBUTES) {</span>
<span class="lineNum">     212 </span><span class="lineCov">          1 :             int32_t att=indexes[URES_INDEX_ATTRIBUTES];</span>
<span class="lineNum">     213 </span><span class="lineCov">          1 :             pResData-&gt;noFallback=(UBool)(att&amp;URES_ATT_NO_FALLBACK);</span>
<span class="lineNum">     214 </span><span class="lineCov">          1 :             pResData-&gt;isPoolBundle=(UBool)((att&amp;URES_ATT_IS_POOL_BUNDLE)!=0);</span>
<span class="lineNum">     215 </span><span class="lineCov">          1 :             pResData-&gt;usesPoolBundle=(UBool)((att&amp;URES_ATT_USES_POOL_BUNDLE)!=0);</span>
<span class="lineNum">     216 </span><span class="lineCov">          1 :             pResData-&gt;poolStringIndexLimit|=(att&amp;0xf000)&lt;&lt;12;  // bits 15..12 -&gt; 27..24</span>
<span class="lineNum">     217 </span><span class="lineCov">          1 :             pResData-&gt;poolStringIndex16Limit=(int32_t)((uint32_t)att&gt;&gt;16);</span>
<span class="lineNum">     218 </span>            :         }
<span class="lineNum">     219 </span><span class="lineCov">          1 :         if((pResData-&gt;isPoolBundle || pResData-&gt;usesPoolBundle) &amp;&amp; indexLength&lt;=URES_INDEX_POOL_CHECKSUM) {</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :             *errorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :             res_unload(pResData);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     223 </span>            :         }
<span class="lineNum">     224 </span><span class="lineCov">          1 :         if( indexLength&gt;URES_INDEX_16BIT_TOP &amp;&amp;</span>
<span class="lineNum">     225 </span><span class="lineCov">          1 :             indexes[URES_INDEX_16BIT_TOP]&gt;indexes[URES_INDEX_KEYS_TOP]</span>
<span class="lineNum">     226 </span>            :         ) {
<span class="lineNum">     227 </span><span class="lineCov">          1 :             pResData-&gt;p16BitUnits=(const uint16_t *)(pResData-&gt;pRoot+indexes[URES_INDEX_KEYS_TOP]);</span>
<span class="lineNum">     228 </span>            :         }
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :     if(formatVersion[0]==1 || U_CHARSET_FAMILY==U_ASCII_FAMILY) {
<span class="lineNum">     232 </span>            :         /*
<span class="lineNum">     233 </span>            :          * formatVersion 1: compare key strings in native-charset order
<span class="lineNum">     234 </span>            :          * formatVersion 2 and up: compare key strings in ASCII order
<span class="lineNum">     235 </span>            :          */
<span class="lineNum">     236 </span><span class="lineCov">          1 :         pResData-&gt;useNativeStrcmp=TRUE;</span>
<span class="lineNum">     237 </span>            :     }
<span class="lineNum">     238 </span>            : }
<a name="239"><span class="lineNum">     239 </span>            : </a>
<span class="lineNum">     240 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     241 </span><span class="lineNoCov">          0 : res_read(ResourceData *pResData,</span>
<span class="lineNum">     242 </span>            :          const UDataInfo *pInfo, const void *inBytes, int32_t length,
<span class="lineNum">     243 </span>            :          UErrorCode *errorCode) {
<span class="lineNum">     244 </span>            :     UVersionInfo formatVersion;
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     uprv_memset(pResData, 0, sizeof(ResourceData));</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     if(U_FAILURE(*errorCode)) {</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     249 </span>            :     }
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     if(!isAcceptable(formatVersion, NULL, NULL, pInfo)) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         *errorCode=U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     res_init(pResData, formatVersion, inBytes, length, errorCode);</span>
<span class="lineNum">     255 </span>            : }
<a name="256"><span class="lineNum">     256 </span>            : </a>
<span class="lineNum">     257 </span>            : U_CFUNC void
<span class="lineNum">     258 </span><span class="lineCov">          1 : res_load(ResourceData *pResData,</span>
<span class="lineNum">     259 </span>            :          const char *path, const char *name, UErrorCode *errorCode) {
<span class="lineNum">     260 </span>            :     UVersionInfo formatVersion;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineCov">          1 :     uprv_memset(pResData, 0, sizeof(ResourceData));</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :     /* load the ResourceBundle file */
<span class="lineNum">     265 </span><span class="lineCov">          1 :     pResData-&gt;data=udata_openChoice(path, &quot;res&quot;, name, isAcceptable, formatVersion, errorCode);</span>
<span class="lineNum">     266 </span><span class="lineCov">          1 :     if(U_FAILURE(*errorCode)) {</span>
<span class="lineNum">     267 </span><span class="lineCov">          1 :         return;</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :     /* get its memory and initialize *pResData */
<span class="lineNum">     271 </span><span class="lineCov">          1 :     res_init(pResData, formatVersion, udata_getMemory(pResData-&gt;data), -1, errorCode);</span>
<span class="lineNum">     272 </span>            : }
<a name="273"><span class="lineNum">     273 </span>            : </a>
<span class="lineNum">     274 </span>            : U_CFUNC void
<span class="lineNum">     275 </span><span class="lineCov">          1 : res_unload(ResourceData *pResData) {</span>
<span class="lineNum">     276 </span><span class="lineCov">          1 :     if(pResData-&gt;data!=NULL) {</span>
<span class="lineNum">     277 </span><span class="lineCov">          1 :         udata_close(pResData-&gt;data);</span>
<span class="lineNum">     278 </span><span class="lineCov">          1 :         pResData-&gt;data=NULL;</span>
<span class="lineNum">     279 </span>            :     }
<span class="lineNum">     280 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : static const int8_t gPublicTypes[URES_LIMIT] = {
<span class="lineNum">     283 </span>            :     URES_STRING,
<span class="lineNum">     284 </span>            :     URES_BINARY,
<span class="lineNum">     285 </span>            :     URES_TABLE,
<span class="lineNum">     286 </span>            :     URES_ALIAS,
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     URES_TABLE,     /* URES_TABLE32 */
<span class="lineNum">     289 </span>            :     URES_TABLE,     /* URES_TABLE16 */
<span class="lineNum">     290 </span>            :     URES_STRING,    /* URES_STRING_V2 */
<span class="lineNum">     291 </span>            :     URES_INT,
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     URES_ARRAY,
<span class="lineNum">     294 </span>            :     URES_ARRAY,     /* URES_ARRAY16 */
<span class="lineNum">     295 </span>            :     URES_NONE,
<span class="lineNum">     296 </span>            :     URES_NONE,
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :     URES_NONE,
<span class="lineNum">     299 </span>            :     URES_NONE,
<span class="lineNum">     300 </span>            :     URES_INT_VECTOR,
<span class="lineNum">     301 </span>            :     URES_NONE
<span class="lineNum">     302 </span>            : };
<a name="303"><span class="lineNum">     303 </span>            : </a>
<span class="lineNum">     304 </span>            : U_CAPI UResType U_EXPORT2
<span class="lineNum">     305 </span><span class="lineCov">          1 : res_getPublicType(Resource res) {</span>
<span class="lineNum">     306 </span><span class="lineCov">          1 :     return (UResType)gPublicTypes[RES_GET_TYPE(res)];</span>
<span class="lineNum">     307 </span>            : }
<a name="308"><span class="lineNum">     308 </span>            : </a>
<span class="lineNum">     309 </span>            : U_CAPI const UChar * U_EXPORT2
<span class="lineNum">     310 </span><span class="lineCov">          1 : res_getString(const ResourceData *pResData, Resource res, int32_t *pLength) {</span>
<span class="lineNum">     311 </span>            :     const UChar *p;
<span class="lineNum">     312 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     313 </span>            :     int32_t length;
<span class="lineNum">     314 </span><span class="lineCov">          1 :     if(RES_GET_TYPE(res)==URES_STRING_V2) {</span>
<span class="lineNum">     315 </span>            :         int32_t first;
<span class="lineNum">     316 </span><span class="lineCov">          1 :         if((int32_t)offset&lt;pResData-&gt;poolStringIndexLimit) {</span>
<span class="lineNum">     317 </span><span class="lineCov">          1 :             p=(const UChar *)pResData-&gt;poolBundleStrings+offset;</span>
<span class="lineNum">     318 </span>            :         } else {
<span class="lineNum">     319 </span><span class="lineCov">          1 :             p=(const UChar *)pResData-&gt;p16BitUnits+(offset-pResData-&gt;poolStringIndexLimit);</span>
<span class="lineNum">     320 </span>            :         }
<span class="lineNum">     321 </span><span class="lineCov">          1 :         first=*p;</span>
<span class="lineNum">     322 </span><span class="lineCov">          1 :         if(!U16_IS_TRAIL(first)) {</span>
<span class="lineNum">     323 </span><span class="lineCov">          1 :             length=u_strlen(p);</span>
<span class="lineNum">     324 </span><span class="lineCov">          1 :         } else if(first&lt;0xdfef) {</span>
<span class="lineNum">     325 </span><span class="lineCov">          1 :             length=first&amp;0x3ff;</span>
<span class="lineNum">     326 </span><span class="lineCov">          1 :             ++p;</span>
<span class="lineNum">     327 </span><span class="lineCov">          1 :         } else if(first&lt;0xdfff) {</span>
<span class="lineNum">     328 </span><span class="lineCov">          1 :             length=((first-0xdfef)&lt;&lt;16)|p[1];</span>
<span class="lineNum">     329 </span><span class="lineCov">          1 :             p+=2;</span>
<span class="lineNum">     330 </span>            :         } else {
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :             length=((int32_t)p[1]&lt;&lt;16)|p[2];</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :             p+=3;</span>
<span class="lineNum">     333 </span>            :         }
<span class="lineNum">     334 </span><span class="lineCov">          1 :     } else if(res==offset) /* RES_GET_TYPE(res)==URES_STRING */ {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         const int32_t *p32= res==0 ? &amp;gEmptyString.length : pResData-&gt;pRoot+res;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         length=*p32++;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :         p=(const UChar *)p32;</span>
<span class="lineNum">     338 </span>            :     } else {
<span class="lineNum">     339 </span>            :         p=NULL;
<span class="lineNum">     340 </span>            :         length=0;
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span><span class="lineCov">          1 :     if(pLength) {</span>
<span class="lineNum">     343 </span><span class="lineCov">          1 :         *pLength=length;</span>
<span class="lineNum">     344 </span>            :     }
<span class="lineNum">     345 </span><span class="lineCov">          1 :     return p;</span>
<span class="lineNum">     346 </span>            : }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : namespace {
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : /**
<span class="lineNum">     351 </span>            :  * CLDR string value (three empty-set symbols)=={2205, 2205, 2205}
<span class="lineNum">     352 </span>            :  * prevents fallback to the parent bundle.
<span class="lineNum">     353 </span>            :  * TODO: combine with other code that handles this marker, use EMPTY_SET constant.
<a name="354"><span class="lineNum">     354 </span>            :  * TODO: maybe move to uresbund.cpp?</a>
<span class="lineNum">     355 </span>            :  */
<span class="lineNum">     356 </span><span class="lineCov">          1 : UBool isNoInheritanceMarker(const ResourceData *pResData, Resource res) {</span>
<span class="lineNum">     357 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     358 </span><span class="lineCov">          1 :     if (offset == 0) {</span>
<span class="lineNum">     359 </span>            :         // empty string
<span class="lineNum">     360 </span><span class="lineCov">          1 :     } else if (res == offset) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         const int32_t *p32=pResData-&gt;pRoot+res;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         int32_t length=*p32;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         const UChar *p=(const UChar *)p32;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         return length == 3 &amp;&amp; p[2] == 0x2205 &amp;&amp; p[3] == 0x2205 &amp;&amp; p[4] == 0x2205;</span>
<span class="lineNum">     365 </span><span class="lineCov">          1 :     } else if (RES_GET_TYPE(res) == URES_STRING_V2) {</span>
<span class="lineNum">     366 </span>            :         const UChar *p;
<span class="lineNum">     367 </span><span class="lineCov">          1 :         if((int32_t)offset&lt;pResData-&gt;poolStringIndexLimit) {</span>
<span class="lineNum">     368 </span><span class="lineCov">          1 :             p=(const UChar *)pResData-&gt;poolBundleStrings+offset;</span>
<span class="lineNum">     369 </span>            :         } else {
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :             p=(const UChar *)pResData-&gt;p16BitUnits+(offset-pResData-&gt;poolStringIndexLimit);</span>
<span class="lineNum">     371 </span>            :         }
<span class="lineNum">     372 </span><span class="lineCov">          1 :         int32_t first=*p;</span>
<span class="lineNum">     373 </span><span class="lineCov">          1 :         if (first == 0x2205) {  // implicit length</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :             return p[1] == 0x2205 &amp;&amp; p[2] == 0x2205 &amp;&amp; p[3] == 0;</span>
<span class="lineNum">     375 </span><span class="lineCov">          1 :         } else if (first == 0xdc03) {  // explicit length 3 (should not occur)</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :             return p[1] == 0x2205 &amp;&amp; p[2] == 0x2205 &amp;&amp; p[3] == 0x2205;</span>
<span class="lineNum">     377 </span>            :         } else {
<span class="lineNum">     378 </span>            :             // Assume that the string has not been stored with more length units than necessary.
<span class="lineNum">     379 </span>            :             return FALSE;
<span class="lineNum">     380 </span>            :         }
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span>            :     return FALSE;
<a name="383"><span class="lineNum">     383 </span>            : }</a>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineCov">          1 : int32_t getStringArray(const ResourceData *pResData, const icu::ResourceArray &amp;array,</span>
<span class="lineNum">     386 </span>            :                        icu::UnicodeString *dest, int32_t capacity,
<span class="lineNum">     387 </span>            :                        UErrorCode &amp;errorCode) {
<span class="lineNum">     388 </span><span class="lineCov">          1 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     389 </span>            :         return 0;
<span class="lineNum">     390 </span>            :     }
<span class="lineNum">     391 </span><span class="lineCov">          1 :     if(dest == NULL ? capacity != 0 : capacity &lt; 0) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         errorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     394 </span>            :     }
<span class="lineNum">     395 </span><span class="lineCov">          1 :     int32_t length = array.getSize();</span>
<span class="lineNum">     396 </span><span class="lineCov">          1 :     if(length == 0) {</span>
<span class="lineNum">     397 </span>            :         return 0;
<span class="lineNum">     398 </span>            :     }
<span class="lineNum">     399 </span><span class="lineCov">          1 :     if(length &gt; capacity) {</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         errorCode = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         return length;</span>
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span><span class="lineCov">          1 :     for(int32_t i = 0; i &lt; length; ++i) {</span>
<span class="lineNum">     404 </span>            :         int32_t sLength;
<span class="lineNum">     405 </span><span class="lineCov">          1 :         const UChar *s = res_getString(pResData, array.internalGetResource(pResData, i), &amp;sLength);</span>
<span class="lineNum">     406 </span><span class="lineCov">          1 :         if(s == NULL) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :             errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     409 </span>            :         }
<span class="lineNum">     410 </span><span class="lineCov">          1 :         dest[i].setTo(TRUE, s, sLength);</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span>            :     return length;
<span class="lineNum">     413 </span>            : }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : }  // namespace
<a name="416"><span class="lineNum">     416 </span>            : </a>
<span class="lineNum">     417 </span>            : U_CAPI const UChar * U_EXPORT2
<span class="lineNum">     418 </span><span class="lineCov">          1 : res_getAlias(const ResourceData *pResData, Resource res, int32_t *pLength) {</span>
<span class="lineNum">     419 </span>            :     const UChar *p;
<span class="lineNum">     420 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     421 </span>            :     int32_t length;
<span class="lineNum">     422 </span><span class="lineCov">          1 :     if(RES_GET_TYPE(res)==URES_ALIAS) {</span>
<span class="lineNum">     423 </span><span class="lineCov">          1 :         const int32_t *p32= offset==0 ? &amp;gEmptyString.length : pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     424 </span><span class="lineCov">          1 :         length=*p32++;</span>
<span class="lineNum">     425 </span><span class="lineCov">          1 :         p=(const UChar *)p32;</span>
<span class="lineNum">     426 </span>            :     } else {
<span class="lineNum">     427 </span>            :         p=NULL;
<span class="lineNum">     428 </span>            :         length=0;
<span class="lineNum">     429 </span>            :     }
<span class="lineNum">     430 </span><span class="lineCov">          1 :     if(pLength) {</span>
<span class="lineNum">     431 </span><span class="lineCov">          1 :         *pLength=length;</span>
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span><span class="lineCov">          1 :     return p;</span>
<span class="lineNum">     434 </span>            : }
<a name="435"><span class="lineNum">     435 </span>            : </a>
<span class="lineNum">     436 </span>            : U_CAPI const uint8_t * U_EXPORT2
<span class="lineNum">     437 </span><span class="lineCov">          1 : res_getBinary(const ResourceData *pResData, Resource res, int32_t *pLength) {</span>
<span class="lineNum">     438 </span>            :     const uint8_t *p;
<span class="lineNum">     439 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     440 </span>            :     int32_t length;
<span class="lineNum">     441 </span><span class="lineCov">          1 :     if(RES_GET_TYPE(res)==URES_BINARY) {</span>
<span class="lineNum">     442 </span><span class="lineCov">          1 :         const int32_t *p32= offset==0 ? (const int32_t*)&amp;gEmpty32 : pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     443 </span><span class="lineCov">          1 :         length=*p32++;</span>
<span class="lineNum">     444 </span><span class="lineCov">          1 :         p=(const uint8_t *)p32;</span>
<span class="lineNum">     445 </span>            :     } else {
<span class="lineNum">     446 </span>            :         p=NULL;
<span class="lineNum">     447 </span>            :         length=0;
<span class="lineNum">     448 </span>            :     }
<span class="lineNum">     449 </span><span class="lineCov">          1 :     if(pLength) {</span>
<span class="lineNum">     450 </span><span class="lineCov">          1 :         *pLength=length;</span>
<span class="lineNum">     451 </span>            :     }
<span class="lineNum">     452 </span><span class="lineCov">          1 :     return p;</span>
<span class="lineNum">     453 </span>            : }
<span class="lineNum">     454 </span>            : 
<a name="455"><span class="lineNum">     455 </span>            : </a>
<span class="lineNum">     456 </span>            : U_CAPI const int32_t * U_EXPORT2
<span class="lineNum">     457 </span><span class="lineCov">          1 : res_getIntVector(const ResourceData *pResData, Resource res, int32_t *pLength) {</span>
<span class="lineNum">     458 </span>            :     const int32_t *p;
<span class="lineNum">     459 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     460 </span>            :     int32_t length;
<span class="lineNum">     461 </span><span class="lineCov">          1 :     if(RES_GET_TYPE(res)==URES_INT_VECTOR) {</span>
<span class="lineNum">     462 </span><span class="lineCov">          1 :         p= offset==0 ? (const int32_t *)&amp;gEmpty32 : pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     463 </span><span class="lineCov">          1 :         length=*p++;</span>
<span class="lineNum">     464 </span>            :     } else {
<span class="lineNum">     465 </span>            :         p=NULL;
<span class="lineNum">     466 </span>            :         length=0;
<span class="lineNum">     467 </span>            :     }
<span class="lineNum">     468 </span><span class="lineCov">          1 :     if(pLength) {</span>
<span class="lineNum">     469 </span><span class="lineCov">          1 :         *pLength=length;</span>
<span class="lineNum">     470 </span>            :     }
<span class="lineNum">     471 </span><span class="lineCov">          1 :     return p;</span>
<span class="lineNum">     472 </span>            : }
<a name="473"><span class="lineNum">     473 </span>            : </a>
<span class="lineNum">     474 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     475 </span><span class="lineCov">          1 : res_countArrayItems(const ResourceData *pResData, Resource res) {</span>
<span class="lineNum">     476 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     477 </span><span class="lineCov">          1 :     switch(RES_GET_TYPE(res)) {</span>
<span class="lineNum">     478 </span>            :     case URES_STRING:
<span class="lineNum">     479 </span>            :     case URES_STRING_V2:
<span class="lineNum">     480 </span>            :     case URES_BINARY:
<span class="lineNum">     481 </span>            :     case URES_ALIAS:
<span class="lineNum">     482 </span>            :     case URES_INT:
<span class="lineNum">     483 </span>            :     case URES_INT_VECTOR:
<span class="lineNum">     484 </span>            :         return 1;
<span class="lineNum">     485 </span>            :     case URES_ARRAY:
<span class="lineNum">     486 </span>            :     case URES_TABLE32:
<span class="lineNum">     487 </span><span class="lineCov">          1 :         return offset==0 ? 0 : *(pResData-&gt;pRoot+offset);</span>
<span class="lineNum">     488 </span>            :     case URES_TABLE:
<span class="lineNum">     489 </span><span class="lineCov">          1 :         return offset==0 ? 0 : *((const uint16_t *)(pResData-&gt;pRoot+offset));</span>
<span class="lineNum">     490 </span>            :     case URES_ARRAY16:
<span class="lineNum">     491 </span>            :     case URES_TABLE16:
<span class="lineNum">     492 </span><span class="lineCov">          1 :         return pResData-&gt;p16BitUnits[offset];</span>
<span class="lineNum">     493 </span>            :     default:
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     495 </span>            :     }
<span class="lineNum">     496 </span>            : }
<span class="lineNum">     497 </span>            : 
<a name="498"><span class="lineNum">     498 </span>            : U_NAMESPACE_BEGIN</a>
<span class="lineNum">     499 </span>            : 
<a name="500"><span class="lineNum">     500 </span><span class="lineCov">          1 : ResourceDataValue::~ResourceDataValue() {}</span></a>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineCov">          1 : UResType ResourceDataValue::getType() const {</span>
<span class="lineNum">     503 </span><span class="lineCov">          1 :     return res_getPublicType(res);</span>
<a name="504"><span class="lineNum">     504 </span>            : }</a>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineCov">          1 : const UChar *ResourceDataValue::getString(int32_t &amp;length, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     507 </span><span class="lineCov">          1 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     508 </span>            :         return NULL;
<span class="lineNum">     509 </span>            :     }
<span class="lineNum">     510 </span><span class="lineCov">          1 :     const UChar *s = res_getString(pResData, res, &amp;length);</span>
<span class="lineNum">     511 </span><span class="lineCov">          1 :     if(s == NULL) {</span>
<span class="lineNum">     512 </span><span class="lineCov">          1 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     513 </span>            :     }
<span class="lineNum">     514 </span><span class="lineCov">          1 :     return s;</span>
<a name="515"><span class="lineNum">     515 </span>            : }</a>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">          1 : const UChar *ResourceDataValue::getAliasString(int32_t &amp;length, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     518 </span><span class="lineCov">          1 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     519 </span>            :         return NULL;
<span class="lineNum">     520 </span>            :     }
<span class="lineNum">     521 </span><span class="lineCov">          1 :     const UChar *s = res_getAlias(pResData, res, &amp;length);</span>
<span class="lineNum">     522 </span><span class="lineCov">          1 :     if(s == NULL) {</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span><span class="lineCov">          1 :     return s;</span>
<a name="526"><span class="lineNum">     526 </span>            : }</a>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineNoCov">          0 : int32_t ResourceDataValue::getInt(UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     530 </span>            :         return 0;
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     if(RES_GET_TYPE(res) != URES_INT) {</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     534 </span>            :     }
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     return RES_GET_INT(res);</span>
<a name="536"><span class="lineNum">     536 </span>            : }</a>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 : uint32_t ResourceDataValue::getUInt(UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     540 </span>            :         return 0;
<span class="lineNum">     541 </span>            :     }
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     if(RES_GET_TYPE(res) != URES_INT) {</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     544 </span>            :     }
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     return RES_GET_UINT(res);</span>
<a name="546"><span class="lineNum">     546 </span>            : }</a>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 : const int32_t *ResourceDataValue::getIntVector(int32_t &amp;length, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     550 </span>            :         return NULL;
<span class="lineNum">     551 </span>            :     }
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     const int32_t *iv = res_getIntVector(pResData, res, &amp;length);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     if(iv == NULL) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     return iv;</span>
<a name="557"><span class="lineNum">     557 </span>            : }</a>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineNoCov">          0 : const uint8_t *ResourceDataValue::getBinary(int32_t &amp;length, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     561 </span>            :         return NULL;
<span class="lineNum">     562 </span>            :     }
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     const uint8_t *b = res_getBinary(pResData, res, &amp;length);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     if(b == NULL) {</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     return b;</span>
<a name="568"><span class="lineNum">     568 </span>            : }</a>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">          1 : ResourceArray ResourceDataValue::getArray(UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     571 </span><span class="lineCov">          1 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     572 </span>            :         return ResourceArray();
<span class="lineNum">     573 </span>            :     }
<span class="lineNum">     574 </span><span class="lineCov">          1 :     const uint16_t *items16 = NULL;</span>
<span class="lineNum">     575 </span><span class="lineCov">          1 :     const Resource *items32 = NULL;</span>
<span class="lineNum">     576 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(res);</span>
<span class="lineNum">     577 </span><span class="lineCov">          1 :     int32_t length = 0;</span>
<span class="lineNum">     578 </span><span class="lineCov">          1 :     switch(RES_GET_TYPE(res)) {</span>
<span class="lineNum">     579 </span>            :     case URES_ARRAY:
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         if (offset!=0) {  // empty if offset==0</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :             items32 = (const Resource *)pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :             length = *items32++;</span>
<span class="lineNum">     583 </span>            :         }
<span class="lineNum">     584 </span>            :         break;
<span class="lineNum">     585 </span>            :     case URES_ARRAY16:
<span class="lineNum">     586 </span><span class="lineCov">          1 :         items16 = pResData-&gt;p16BitUnits+offset;</span>
<span class="lineNum">     587 </span><span class="lineCov">          1 :         length = *items16++;</span>
<span class="lineNum">     588 </span><span class="lineCov">          1 :         break;</span>
<span class="lineNum">     589 </span>            :     default:
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     591 </span>            :         return ResourceArray();
<span class="lineNum">     592 </span>            :     }
<span class="lineNum">     593 </span>            :     return ResourceArray(items16, items32, length);
<a name="594"><span class="lineNum">     594 </span>            : }</a>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineCov">          1 : ResourceTable ResourceDataValue::getTable(UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     597 </span><span class="lineCov">          1 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         return ResourceTable();</span>
<span class="lineNum">     599 </span>            :     }
<span class="lineNum">     600 </span><span class="lineCov">          1 :     const uint16_t *keys16 = NULL;</span>
<span class="lineNum">     601 </span><span class="lineCov">          1 :     const int32_t *keys32 = NULL;</span>
<span class="lineNum">     602 </span><span class="lineCov">          1 :     const uint16_t *items16 = NULL;</span>
<span class="lineNum">     603 </span><span class="lineCov">          1 :     const Resource *items32 = NULL;</span>
<span class="lineNum">     604 </span><span class="lineCov">          1 :     uint32_t offset = RES_GET_OFFSET(res);</span>
<span class="lineNum">     605 </span><span class="lineCov">          1 :     int32_t length = 0;</span>
<span class="lineNum">     606 </span><span class="lineCov">          1 :     switch(RES_GET_TYPE(res)) {</span>
<span class="lineNum">     607 </span>            :     case URES_TABLE:
<span class="lineNum">     608 </span><span class="lineCov">          1 :         if (offset != 0) {  // empty if offset==0</span>
<span class="lineNum">     609 </span><span class="lineCov">          1 :             keys16 = (const uint16_t *)(pResData-&gt;pRoot+offset);</span>
<span class="lineNum">     610 </span><span class="lineCov">          1 :             length = *keys16++;</span>
<span class="lineNum">     611 </span><span class="lineCov">          1 :             items32 = (const Resource *)(keys16+length+(~length&amp;1));</span>
<span class="lineNum">     612 </span>            :         }
<span class="lineNum">     613 </span>            :         break;
<span class="lineNum">     614 </span>            :     case URES_TABLE16:
<span class="lineNum">     615 </span><span class="lineCov">          1 :         keys16 = pResData-&gt;p16BitUnits+offset;</span>
<span class="lineNum">     616 </span><span class="lineCov">          1 :         length = *keys16++;</span>
<span class="lineNum">     617 </span><span class="lineCov">          1 :         items16 = keys16 + length;</span>
<span class="lineNum">     618 </span><span class="lineCov">          1 :         break;</span>
<span class="lineNum">     619 </span>            :     case URES_TABLE32:
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         if (offset != 0) {  // empty if offset==0</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :             keys32 = pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             length = *keys32++;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             items32 = (const Resource *)keys32 + length;</span>
<span class="lineNum">     624 </span>            :         }
<span class="lineNum">     625 </span>            :         break;
<span class="lineNum">     626 </span>            :     default:
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :         errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         return ResourceTable();</span>
<span class="lineNum">     629 </span>            :     }
<span class="lineNum">     630 </span>            :     return ResourceTable(keys16, keys32, items16, items32, length);
<a name="631"><span class="lineNum">     631 </span>            : }</a>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineCov">          1 : UBool ResourceDataValue::isNoInheritanceMarker() const {</span>
<span class="lineNum">     634 </span><span class="lineCov">          1 :     return ::isNoInheritanceMarker(pResData, res);</span>
<a name="635"><span class="lineNum">     635 </span>            : }</a>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineCov">          1 : int32_t ResourceDataValue::getStringArray(UnicodeString *dest, int32_t capacity,</span>
<span class="lineNum">     638 </span>            :                                           UErrorCode &amp;errorCode) const {
<span class="lineNum">     639 </span><span class="lineCov">          1 :     return ::getStringArray(pResData, getArray(errorCode), dest, capacity, errorCode);</span>
<a name="640"><span class="lineNum">     640 </span>            : }</a>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 : int32_t ResourceDataValue::getStringArrayOrStringAsArray(UnicodeString *dest, int32_t capacity,</span>
<span class="lineNum">     643 </span>            :                                                          UErrorCode &amp;errorCode) const {
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     if(URES_IS_ARRAY(res)) {</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         return ::getStringArray(pResData, getArray(errorCode), dest, capacity, errorCode);</span>
<span class="lineNum">     646 </span>            :     }
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     648 </span>            :         return 0;
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     if(dest == NULL ? capacity != 0 : capacity &lt; 0) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         errorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     653 </span>            :     }
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     if(capacity &lt; 1) {</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         errorCode = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     657 </span>            :     }
<span class="lineNum">     658 </span>            :     int32_t sLength;
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     const UChar *s = res_getString(pResData, res, &amp;sLength);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     if(s != NULL) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         dest[0].setTo(TRUE, s, sLength);</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     663 </span>            :     }
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     return 0;</span>
<a name="666"><span class="lineNum">     666 </span>            : }</a>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 : UnicodeString ResourceDataValue::getStringOrFirstOfArray(UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">     669 </span>            :     UnicodeString us;
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     671 </span>            :         return us;
<span class="lineNum">     672 </span>            :     }
<span class="lineNum">     673 </span>            :     int32_t sLength;
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     const UChar *s = res_getString(pResData, res, &amp;sLength);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     if(s != NULL) {</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         us.setTo(TRUE, s, sLength);</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         return us;</span>
<span class="lineNum">     678 </span>            :     }
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     ResourceArray array = getArray(errorCode);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     681 </span>            :         return us;
<span class="lineNum">     682 </span>            :     }
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     if(array.getSize() &gt; 0) {</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         s = res_getString(pResData, array.internalGetResource(pResData, 0), &amp;sLength);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         if(s != NULL) {</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :             us.setTo(TRUE, s, sLength);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :             return us;</span>
<span class="lineNum">     688 </span>            :         }
<span class="lineNum">     689 </span>            :     }
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     errorCode = U_RESOURCE_TYPE_MISMATCH;</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     return us;</span>
<span class="lineNum">     692 </span>            : }
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : U_NAMESPACE_END
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : static Resource
<span class="lineNum">     697 </span>            : makeResourceFrom16(const ResourceData *pResData, int32_t res16) {
<span class="lineNum">     698 </span><span class="lineCov">          1 :     if(res16&lt;pResData-&gt;poolStringIndex16Limit) {</span>
<span class="lineNum">     699 </span>            :         // Pool string, nothing to do.
<span class="lineNum">     700 </span>            :     } else {
<span class="lineNum">     701 </span>            :         // Local string, adjust the 16-bit offset to a regular one,
<span class="lineNum">     702 </span>            :         // with a larger pool string index limit.
<span class="lineNum">     703 </span><span class="lineCov">          1 :         res16=res16-pResData-&gt;poolStringIndex16Limit+pResData-&gt;poolStringIndexLimit;</span>
<span class="lineNum">     704 </span>            :     }
<span class="lineNum">     705 </span><span class="lineCov">          1 :     return URES_MAKE_RESOURCE(URES_STRING_V2, res16);</span>
<span class="lineNum">     706 </span>            : }
<a name="707"><span class="lineNum">     707 </span>            : </a>
<span class="lineNum">     708 </span>            : U_CAPI Resource U_EXPORT2
<span class="lineNum">     709 </span><span class="lineCov">          1 : res_getTableItemByKey(const ResourceData *pResData, Resource table,</span>
<span class="lineNum">     710 </span>            :                       int32_t *indexR, const char **key) {
<span class="lineNum">     711 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(table);</span>
<span class="lineNum">     712 </span>            :     int32_t length;
<span class="lineNum">     713 </span>            :     int32_t idx;
<span class="lineNum">     714 </span><span class="lineCov">          1 :     if(key == NULL || *key == NULL) {</span>
<span class="lineNum">     715 </span>            :         return RES_BOGUS;
<span class="lineNum">     716 </span>            :     }
<span class="lineNum">     717 </span><span class="lineCov">          1 :     switch(RES_GET_TYPE(table)) {</span>
<span class="lineNum">     718 </span>            :     case URES_TABLE: {
<span class="lineNum">     719 </span><span class="lineCov">          1 :         if (offset!=0) { /* empty if offset==0 */</span>
<span class="lineNum">     720 </span><span class="lineCov">          1 :             const uint16_t *p= (const uint16_t *)(pResData-&gt;pRoot+offset);</span>
<span class="lineNum">     721 </span><span class="lineCov">          1 :             length=*p++;</span>
<span class="lineNum">     722 </span><span class="lineCov">          1 :             *indexR=idx=_res_findTableItem(pResData, p, length, *key, key);</span>
<span class="lineNum">     723 </span><span class="lineCov">          1 :             if(idx&gt;=0) {</span>
<span class="lineNum">     724 </span><span class="lineCov">          1 :                 const Resource *p32=(const Resource *)(p+length+(~length&amp;1));</span>
<span class="lineNum">     725 </span><span class="lineCov">          1 :                 return p32[idx];</span>
<span class="lineNum">     726 </span>            :             }
<span class="lineNum">     727 </span>            :         }
<span class="lineNum">     728 </span>            :         break;
<span class="lineNum">     729 </span>            :     }
<span class="lineNum">     730 </span>            :     case URES_TABLE16: {
<span class="lineNum">     731 </span><span class="lineCov">          1 :         const uint16_t *p=pResData-&gt;p16BitUnits+offset;</span>
<span class="lineNum">     732 </span><span class="lineCov">          1 :         length=*p++;</span>
<span class="lineNum">     733 </span><span class="lineCov">          1 :         *indexR=idx=_res_findTableItem(pResData, p, length, *key, key);</span>
<span class="lineNum">     734 </span><span class="lineCov">          1 :         if(idx&gt;=0) {</span>
<span class="lineNum">     735 </span><span class="lineCov">          1 :             return makeResourceFrom16(pResData, p[length+idx]);</span>
<span class="lineNum">     736 </span>            :         }
<span class="lineNum">     737 </span>            :         break;
<span class="lineNum">     738 </span>            :     }
<span class="lineNum">     739 </span>            :     case URES_TABLE32: {
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         if (offset!=0) { /* empty if offset==0 */</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :             const int32_t *p= pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :             length=*p++;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :             *indexR=idx=_res_findTable32Item(pResData, p, length, *key, key);</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :             if(idx&gt;=0) {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                 return (Resource)p[length+idx];</span>
<span class="lineNum">     746 </span>            :             }
<span class="lineNum">     747 </span>            :         }
<span class="lineNum">     748 </span>            :         break;
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            :     default:
<span class="lineNum">     751 </span>            :         break;
<span class="lineNum">     752 </span>            :     }
<span class="lineNum">     753 </span>            :     return RES_BOGUS;
<span class="lineNum">     754 </span>            : }
<a name="755"><span class="lineNum">     755 </span>            : </a>
<span class="lineNum">     756 </span>            : U_CAPI Resource U_EXPORT2
<span class="lineNum">     757 </span><span class="lineCov">          1 : res_getTableItemByIndex(const ResourceData *pResData, Resource table,</span>
<span class="lineNum">     758 </span>            :                         int32_t indexR, const char **key) {
<span class="lineNum">     759 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(table);</span>
<span class="lineNum">     760 </span>            :     int32_t length;
<span class="lineNum">     761 </span>            :     U_ASSERT(indexR&gt;=0); /* to ensure the index is not negative */
<span class="lineNum">     762 </span><span class="lineCov">          1 :     switch(RES_GET_TYPE(table)) {</span>
<span class="lineNum">     763 </span>            :     case URES_TABLE: {
<span class="lineNum">     764 </span><span class="lineCov">          1 :         if (offset != 0) { /* empty if offset==0 */</span>
<span class="lineNum">     765 </span><span class="lineCov">          1 :             const uint16_t *p= (const uint16_t *)(pResData-&gt;pRoot+offset);</span>
<span class="lineNum">     766 </span><span class="lineCov">          1 :             length=*p++;</span>
<span class="lineNum">     767 </span><span class="lineCov">          1 :             if(indexR&lt;length) {</span>
<span class="lineNum">     768 </span><span class="lineCov">          1 :                 const Resource *p32=(const Resource *)(p+length+(~length&amp;1));</span>
<span class="lineNum">     769 </span><span class="lineCov">          1 :                 if(key!=NULL) {</span>
<span class="lineNum">     770 </span><span class="lineCov">          1 :                     *key=RES_GET_KEY16(pResData, p[indexR]);</span>
<span class="lineNum">     771 </span>            :                 }
<span class="lineNum">     772 </span><span class="lineCov">          1 :                 return p32[indexR];</span>
<span class="lineNum">     773 </span>            :             }
<span class="lineNum">     774 </span>            :         }
<span class="lineNum">     775 </span>            :         break;
<span class="lineNum">     776 </span>            :     }
<span class="lineNum">     777 </span>            :     case URES_TABLE16: {
<span class="lineNum">     778 </span><span class="lineCov">          1 :         const uint16_t *p=pResData-&gt;p16BitUnits+offset;</span>
<span class="lineNum">     779 </span><span class="lineCov">          1 :         length=*p++;</span>
<span class="lineNum">     780 </span><span class="lineCov">          1 :         if(indexR&lt;length) {</span>
<span class="lineNum">     781 </span><span class="lineCov">          1 :             if(key!=NULL) {</span>
<span class="lineNum">     782 </span><span class="lineCov">          1 :                 *key=RES_GET_KEY16(pResData, p[indexR]);</span>
<span class="lineNum">     783 </span>            :             }
<span class="lineNum">     784 </span><span class="lineCov">          1 :             return makeResourceFrom16(pResData, p[length+indexR]);</span>
<span class="lineNum">     785 </span>            :         }
<span class="lineNum">     786 </span>            :         break;
<span class="lineNum">     787 </span>            :     }
<span class="lineNum">     788 </span>            :     case URES_TABLE32: {
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         if (offset != 0) { /* empty if offset==0 */</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :             const int32_t *p= pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :             length=*p++;</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :             if(indexR&lt;length) {</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                 if(key!=NULL) {</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :                     *key=RES_GET_KEY32(pResData, p[indexR]);</span>
<span class="lineNum">     795 </span>            :                 }
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                 return (Resource)p[length+indexR];</span>
<span class="lineNum">     797 </span>            :             }
<span class="lineNum">     798 </span>            :         }
<span class="lineNum">     799 </span>            :         break;
<span class="lineNum">     800 </span>            :     }
<span class="lineNum">     801 </span>            :     default:
<span class="lineNum">     802 </span>            :         break;
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span>            :     return RES_BOGUS;
<span class="lineNum">     805 </span>            : }
<a name="806"><span class="lineNum">     806 </span>            : </a>
<span class="lineNum">     807 </span>            : U_CAPI Resource U_EXPORT2
<span class="lineNum">     808 </span><span class="lineCov">          1 : res_getResource(const ResourceData *pResData, const char *key) {</span>
<span class="lineNum">     809 </span><span class="lineCov">          1 :     const char *realKey=key;</span>
<span class="lineNum">     810 </span>            :     int32_t idx;
<span class="lineNum">     811 </span><span class="lineCov">          1 :     return res_getTableItemByKey(pResData, pResData-&gt;rootRes, &amp;idx, &amp;realKey);</span>
<span class="lineNum">     812 </span>            : }
<a name="813"><span class="lineNum">     813 </span>            : </a>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineCov">          1 : UBool icu::ResourceTable::getKeyAndValue(int32_t i,</span>
<span class="lineNum">     816 </span>            :                                          const char *&amp;key, icu::ResourceValue &amp;value) const {
<span class="lineNum">     817 </span><span class="lineCov">          1 :     if(0 &lt;= i &amp;&amp; i &lt; length) {</span>
<span class="lineNum">     818 </span><span class="lineCov">          1 :         icu::ResourceDataValue &amp;rdValue = static_cast&lt;icu::ResourceDataValue &amp;&gt;(value);</span>
<span class="lineNum">     819 </span><span class="lineCov">          1 :         if (keys16 != NULL) {</span>
<span class="lineNum">     820 </span><span class="lineCov">          1 :             key = RES_GET_KEY16(rdValue.pResData, keys16[i]);</span>
<span class="lineNum">     821 </span>            :         } else {
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :             key = RES_GET_KEY32(rdValue.pResData, keys32[i]);</span>
<span class="lineNum">     823 </span>            :         }
<span class="lineNum">     824 </span>            :         Resource res;
<span class="lineNum">     825 </span><span class="lineCov">          1 :         if (items16 != NULL) {</span>
<span class="lineNum">     826 </span><span class="lineCov">          1 :             res = makeResourceFrom16(rdValue.pResData, items16[i]);</span>
<span class="lineNum">     827 </span>            :         } else {
<span class="lineNum">     828 </span><span class="lineCov">          1 :             res = items32[i];</span>
<span class="lineNum">     829 </span>            :         }
<span class="lineNum">     830 </span><span class="lineCov">          1 :         rdValue.setResource(res);</span>
<span class="lineNum">     831 </span><span class="lineCov">          1 :         return TRUE;</span>
<span class="lineNum">     832 </span>            :     }
<span class="lineNum">     833 </span>            :     return FALSE;
<span class="lineNum">     834 </span>            : }
<a name="835"><span class="lineNum">     835 </span>            : </a>
<span class="lineNum">     836 </span>            : U_CAPI Resource U_EXPORT2
<span class="lineNum">     837 </span><span class="lineCov">          1 : res_getArrayItem(const ResourceData *pResData, Resource array, int32_t indexR) {</span>
<span class="lineNum">     838 </span><span class="lineCov">          1 :     uint32_t offset=RES_GET_OFFSET(array);</span>
<span class="lineNum">     839 </span>            :     U_ASSERT(indexR&gt;=0); /* to ensure the index is not negative */
<span class="lineNum">     840 </span><span class="lineCov">          1 :     switch(RES_GET_TYPE(array)) {</span>
<span class="lineNum">     841 </span>            :     case URES_ARRAY: {
<span class="lineNum">     842 </span><span class="lineCov">          1 :         if (offset!=0) { /* empty if offset==0 */</span>
<span class="lineNum">     843 </span><span class="lineCov">          1 :             const int32_t *p= pResData-&gt;pRoot+offset;</span>
<span class="lineNum">     844 </span><span class="lineCov">          1 :             if(indexR&lt;*p) {</span>
<span class="lineNum">     845 </span><span class="lineCov">          1 :                 return (Resource)p[1+indexR];</span>
<span class="lineNum">     846 </span>            :             }
<span class="lineNum">     847 </span>            :         }
<span class="lineNum">     848 </span>            :         break;
<span class="lineNum">     849 </span>            :     }
<span class="lineNum">     850 </span>            :     case URES_ARRAY16: {
<span class="lineNum">     851 </span><span class="lineCov">          1 :         const uint16_t *p=pResData-&gt;p16BitUnits+offset;</span>
<span class="lineNum">     852 </span><span class="lineCov">          1 :         if(indexR&lt;*p) {</span>
<span class="lineNum">     853 </span><span class="lineCov">          1 :             return makeResourceFrom16(pResData, p[1+indexR]);</span>
<span class="lineNum">     854 </span>            :         }
<span class="lineNum">     855 </span>            :         break;
<span class="lineNum">     856 </span>            :     }
<span class="lineNum">     857 </span>            :     default:
<span class="lineNum">     858 </span>            :         break;
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span>            :     return RES_BOGUS;
<a name="861"><span class="lineNum">     861 </span>            : }</a>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">          1 : uint32_t icu::ResourceArray::internalGetResource(const ResourceData *pResData, int32_t i) const {</span>
<span class="lineNum">     864 </span><span class="lineCov">          1 :     if (items16 != NULL) {</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :         return makeResourceFrom16(pResData, items16[i]);</span>
<span class="lineNum">     866 </span>            :     } else {
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         return items32[i];</span>
<span class="lineNum">     868 </span>            :     }
<a name="869"><span class="lineNum">     869 </span>            : }</a>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineCov">          1 : UBool icu::ResourceArray::getValue(int32_t i, icu::ResourceValue &amp;value) const {</span>
<span class="lineNum">     872 </span><span class="lineCov">          1 :     if(0 &lt;= i &amp;&amp; i &lt; length) {</span>
<span class="lineNum">     873 </span><span class="lineCov">          1 :         icu::ResourceDataValue &amp;rdValue = static_cast&lt;icu::ResourceDataValue &amp;&gt;(value);</span>
<span class="lineNum">     874 </span><span class="lineCov">          1 :         rdValue.setResource(internalGetResource(rdValue.pResData, i));</span>
<span class="lineNum">     875 </span><span class="lineCov">          1 :         return TRUE;</span>
<span class="lineNum">     876 </span>            :     }
<span class="lineNum">     877 </span>            :     return FALSE;
<span class="lineNum">     878 </span>            : }
<a name="879"><span class="lineNum">     879 </span>            : </a>
<span class="lineNum">     880 </span>            : U_CFUNC Resource
<span class="lineNum">     881 </span><span class="lineCov">          1 : res_findResource(const ResourceData *pResData, Resource r, char** path, const char** key) {</span>
<span class="lineNum">     882 </span><span class="lineCov">          1 :   char *pathP = *path, *nextSepP = *path;</span>
<span class="lineNum">     883 </span><span class="lineCov">          1 :   char *closeIndex = NULL;</span>
<span class="lineNum">     884 </span><span class="lineCov">          1 :   Resource t1 = r;</span>
<span class="lineNum">     885 </span>            :   Resource t2;
<span class="lineNum">     886 </span><span class="lineCov">          1 :   int32_t indexR = 0;</span>
<span class="lineNum">     887 </span><span class="lineCov">          1 :   UResType type = (UResType)RES_GET_TYPE(t1);</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   /* if you come in with an empty path, you'll be getting back the same resource */
<span class="lineNum">     890 </span><span class="lineCov">          1 :   if(!uprv_strlen(pathP)) {</span>
<span class="lineNum">     891 </span>            :       return r;
<span class="lineNum">     892 </span>            :   }
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :   /* one needs to have an aggregate resource in order to search in it */
<span class="lineNum">     895 </span><span class="lineCov">          1 :   if(!URES_IS_CONTAINER(type)) {</span>
<span class="lineNum">     896 </span>            :       return RES_BOGUS;
<span class="lineNum">     897 </span>            :   }
<span class="lineNum">     898 </span>            :   
<span class="lineNum">     899 </span><span class="lineCov">          1 :   while(nextSepP &amp;&amp; *pathP &amp;&amp; t1 != RES_BOGUS &amp;&amp; URES_IS_CONTAINER(type)) {</span>
<span class="lineNum">     900 </span>            :     /* Iteration stops if: the path has been consumed, we found a non-existing
<span class="lineNum">     901 </span>            :      * resource (t1 == RES_BOGUS) or we found a scalar resource (including alias)
<span class="lineNum">     902 </span>            :      */
<span class="lineNum">     903 </span><span class="lineCov">          1 :     nextSepP = uprv_strchr(pathP, RES_PATH_SEPARATOR);</span>
<span class="lineNum">     904 </span>            :     /* if there are more separators, terminate string 
<span class="lineNum">     905 </span>            :      * and set path to the remaining part of the string
<span class="lineNum">     906 </span>            :      */
<span class="lineNum">     907 </span><span class="lineCov">          1 :     if(nextSepP != NULL) {</span>
<span class="lineNum">     908 </span><span class="lineCov">          1 :       if(nextSepP == pathP) {</span>
<span class="lineNum">     909 </span>            :         // Empty key string.
<span class="lineNum">     910 </span>            :         return RES_BOGUS;
<span class="lineNum">     911 </span>            :       }
<span class="lineNum">     912 </span><span class="lineCov">          1 :       *nextSepP = 0; /* overwrite the separator with a NUL to terminate the key */</span>
<span class="lineNum">     913 </span><span class="lineCov">          1 :       *path = nextSepP+1;</span>
<span class="lineNum">     914 </span>            :     } else {
<span class="lineNum">     915 </span><span class="lineCov">          1 :       *path = uprv_strchr(pathP, 0);</span>
<span class="lineNum">     916 </span>            :     }
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            :     /* if the resource is a table */
<span class="lineNum">     919 </span>            :     /* try the key based access */
<span class="lineNum">     920 </span><span class="lineCov">          1 :     if(URES_IS_TABLE(type)) {</span>
<span class="lineNum">     921 </span><span class="lineCov">          1 :       *key = pathP;</span>
<span class="lineNum">     922 </span><span class="lineCov">          1 :       t2 = res_getTableItemByKey(pResData, t1, &amp;indexR, key);</span>
<span class="lineNum">     923 </span><span class="lineCov">          1 :       if(t2 == RES_BOGUS) { </span>
<span class="lineNum">     924 </span>            :         /* if we fail to get the resource by key, maybe we got an index */
<span class="lineNum">     925 </span><span class="lineCov">          1 :         indexR = uprv_strtol(pathP, &amp;closeIndex, 10);</span>
<span class="lineNum">     926 </span><span class="lineCov">          1 :         if(*closeIndex == 0) {</span>
<span class="lineNum">     927 </span>            :           /* if we indeed have an index, try to get the item by index */
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :           t2 = res_getTableItemByIndex(pResData, t1, indexR, key);</span>
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span>            :       }
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     } else if(URES_IS_ARRAY(type)) {</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       indexR = uprv_strtol(pathP, &amp;closeIndex, 10);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       if(*closeIndex == 0) {</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         t2 = res_getArrayItem(pResData, t1, indexR);</span>
<span class="lineNum">     935 </span>            :       } else {
<span class="lineNum">     936 </span>            :         t2 = RES_BOGUS; /* have an array, but don't have a valid index */
<span class="lineNum">     937 </span>            :       }
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       *key = NULL;</span>
<span class="lineNum">     939 </span>            :     } else { /* can't do much here, except setting t2 to bogus */
<span class="lineNum">     940 </span>            :       t2 = RES_BOGUS;
<span class="lineNum">     941 </span>            :     }
<span class="lineNum">     942 </span><span class="lineCov">          1 :     t1 = t2;</span>
<span class="lineNum">     943 </span><span class="lineCov">          1 :     type = (UResType)RES_GET_TYPE(t1);</span>
<span class="lineNum">     944 </span>            :     /* position pathP to next resource key/index */
<span class="lineNum">     945 </span><span class="lineCov">          1 :     pathP = *path;</span>
<span class="lineNum">     946 </span>            :   }
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineCov">          1 :   return t1;</span>
<span class="lineNum">     949 </span>            : }
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /* resource bundle swapping ------------------------------------------------- */
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            : /*
<span class="lineNum">     954 </span>            :  * Need to always enumerate the entire item tree,
<span class="lineNum">     955 </span>            :  * track the lowest address of any item to use as the limit for char keys[],
<span class="lineNum">     956 </span>            :  * track the highest address of any item to return the size of the data.
<span class="lineNum">     957 </span>            :  *
<span class="lineNum">     958 </span>            :  * We should have thought of storing those in the data...
<span class="lineNum">     959 </span>            :  * It is possible to extend the data structure by putting additional values
<span class="lineNum">     960 </span>            :  * in places that are inaccessible by ordinary enumeration of the item tree.
<span class="lineNum">     961 </span>            :  * For example, additional integers could be stored at the beginning or
<span class="lineNum">     962 </span>            :  * end of the key strings; this could be indicated by a minor version number,
<span class="lineNum">     963 </span>            :  * and the data swapping would have to know about these values.
<span class="lineNum">     964 </span>            :  *
<span class="lineNum">     965 </span>            :  * The data structure does not forbid keys to be shared, so we must swap
<span class="lineNum">     966 </span>            :  * all keys once instead of each key when it is referenced.
<span class="lineNum">     967 </span>            :  *
<span class="lineNum">     968 </span>            :  * These swapping functions assume that a resource bundle always has a length
<span class="lineNum">     969 </span>            :  * that is a multiple of 4 bytes.
<span class="lineNum">     970 </span>            :  * Currently, this is trivially true because genrb writes bundle tree leaves
<span class="lineNum">     971 </span>            :  * physically first, before their branches, so that the root table with its
<span class="lineNum">     972 </span>            :  * array of resource items (uint32_t values) is always last.
<span class="lineNum">     973 </span>            :  */
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /* definitions for table sorting ------------------------ */
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : /*
<span class="lineNum">     978 </span>            :  * row of a temporary array
<span class="lineNum">     979 </span>            :  *
<span class="lineNum">     980 </span>            :  * gets platform-endian key string indexes and sorting indexes;
<span class="lineNum">     981 </span>            :  * after sorting this array by keys, the actual key/value arrays are permutated
<span class="lineNum">     982 </span>            :  * according to the sorting indexes
<span class="lineNum">     983 </span>            :  */
<span class="lineNum">     984 </span>            : typedef struct Row {
<span class="lineNum">     985 </span>            :     int32_t keyIndex, sortIndex;
<span class="lineNum">     986 </span>            : } Row;
<a name="987"><span class="lineNum">     987 </span>            : </a>
<span class="lineNum">     988 </span>            : static int32_t U_CALLCONV
<span class="lineNum">     989 </span><span class="lineNoCov">          0 : ures_compareRows(const void *context, const void *left, const void *right) {</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     const char *keyChars=(const char *)context;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     return (int32_t)uprv_strcmp(keyChars+((const Row *)left)-&gt;keyIndex,</span>
<span class="lineNum">     992 </span>            :                                 keyChars+((const Row *)right)-&gt;keyIndex);
<span class="lineNum">     993 </span>            : }
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : typedef struct TempTable {
<span class="lineNum">     996 </span>            :     const char *keyChars;
<span class="lineNum">     997 </span>            :     Row *rows;
<span class="lineNum">     998 </span>            :     int32_t *resort;
<span class="lineNum">     999 </span>            :     uint32_t *resFlags;
<span class="lineNum">    1000 </span>            :     int32_t localKeyLimit;
<span class="lineNum">    1001 </span>            :     uint8_t majorFormatVersion;
<span class="lineNum">    1002 </span>            : } TempTable;
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            : enum {
<span class="lineNum">    1005 </span>            :     STACK_ROW_CAPACITY=200
<span class="lineNum">    1006 </span>            : };
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            : /* The table item key string is not locally available. */
<span class="lineNum">    1009 </span>            : static const char *const gUnknownKey=&quot;&quot;;
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : /* resource table key for collation binaries: &quot;%%CollationBin&quot; */
<span class="lineNum">    1012 </span>            : static const UChar gCollationBinKey[]={
<span class="lineNum">    1013 </span>            :     0x25, 0x25,
<span class="lineNum">    1014 </span>            :     0x43, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
<span class="lineNum">    1015 </span>            :     0x42, 0x69, 0x6e,
<span class="lineNum">    1016 </span>            :     0
<span class="lineNum">    1017 </span>            : };
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : /*
<span class="lineNum">    1020 </span>            :  * swap one resource item
<a name="1021"><span class="lineNum">    1021 </span>            :  */</a>
<span class="lineNum">    1022 </span>            : static void
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 : ures_swapResource(const UDataSwapper *ds,</span>
<span class="lineNum">    1024 </span>            :                   const Resource *inBundle, Resource *outBundle,
<span class="lineNum">    1025 </span>            :                   Resource res, /* caller swaps res itself */
<span class="lineNum">    1026 </span>            :                   const char *key,
<span class="lineNum">    1027 </span>            :                   TempTable *pTempTable,
<span class="lineNum">    1028 </span>            :                   UErrorCode *pErrorCode) {
<span class="lineNum">    1029 </span>            :     const Resource *p;
<span class="lineNum">    1030 </span>            :     Resource *q;
<span class="lineNum">    1031 </span>            :     int32_t offset, count;
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     switch(RES_GET_TYPE(res)) {</span>
<span class="lineNum">    1034 </span>            :     case URES_TABLE16:
<span class="lineNum">    1035 </span>            :     case URES_STRING_V2:
<span class="lineNum">    1036 </span>            :     case URES_INT:
<span class="lineNum">    1037 </span>            :     case URES_ARRAY16:
<span class="lineNum">    1038 </span>            :         /* integer, or points to 16-bit units, nothing to do here */
<span class="lineNum">    1039 </span>            :         return;
<span class="lineNum">    1040 </span>            :     default:
<span class="lineNum">    1041 </span>            :         break;
<span class="lineNum">    1042 </span>            :     }
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :     /* all other types use an offset to point to their data */
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     offset=(int32_t)RES_GET_OFFSET(res);</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     if(offset==0) {</span>
<span class="lineNum">    1047 </span>            :         /* special offset indicating an empty item */
<span class="lineNum">    1048 </span>            :         return;
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     if(pTempTable-&gt;resFlags[offset&gt;&gt;5]&amp;((uint32_t)1&lt;&lt;(offset&amp;0x1f))) {</span>
<span class="lineNum">    1051 </span>            :         /* we already swapped this resource item */
<span class="lineNum">    1052 </span>            :         return;
<span class="lineNum">    1053 </span>            :     } else {
<span class="lineNum">    1054 </span>            :         /* mark it as swapped now */
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         pTempTable-&gt;resFlags[offset&gt;&gt;5]|=((uint32_t)1&lt;&lt;(offset&amp;0x1f));</span>
<span class="lineNum">    1056 </span>            :     }
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     p=inBundle+offset;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     q=outBundle+offset;</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     switch(RES_GET_TYPE(res)) {</span>
<span class="lineNum">    1062 </span>            :     case URES_ALIAS:
<span class="lineNum">    1063 </span>            :         /* physically same value layout as string, fall through */
<span class="lineNum">    1064 </span>            :         U_FALLTHROUGH;
<span class="lineNum">    1065 </span>            :     case URES_STRING:
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         count=udata_readInt32(ds, (int32_t)*p);</span>
<span class="lineNum">    1067 </span>            :         /* swap length */
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         ds-&gt;swapArray32(ds, p, 4, q, pErrorCode);</span>
<span class="lineNum">    1069 </span>            :         /* swap each UChar (the terminating NUL would not change) */
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :         ds-&gt;swapArray16(ds, p+1, 2*count, q+1, pErrorCode);</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1072 </span>            :     case URES_BINARY:
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         count=udata_readInt32(ds, (int32_t)*p);</span>
<span class="lineNum">    1074 </span>            :         /* swap length */
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         ds-&gt;swapArray32(ds, p, 4, q, pErrorCode);</span>
<span class="lineNum">    1076 </span>            :         /* no need to swap or copy bytes - ures_swap() copied them all */
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            :         /* swap known formats */
<span class="lineNum">    1079 </span>            : #if !UCONFIG_NO_COLLATION
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         if( key!=NULL &amp;&amp;  /* the binary is in a table */</span>
<span class="lineNum">    1081 </span>            :             (key!=gUnknownKey ?
<span class="lineNum">    1082 </span>            :                 /* its table key string is &quot;%%CollationBin&quot; */
<span class="lineNum">    1083 </span>            :                 0==ds-&gt;compareInvChars(ds, key, -1,
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                                        gCollationBinKey, UPRV_LENGTHOF(gCollationBinKey)-1) :</span>
<span class="lineNum">    1085 </span>            :                 /* its table key string is unknown but it looks like a collation binary */
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                 ucol_looksLikeCollationBinary(ds, p+1, count))</span>
<span class="lineNum">    1087 </span>            :         ) {
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :             ucol_swap(ds, p+1, count, q+1, pErrorCode);</span>
<span class="lineNum">    1089 </span>            :         }
<span class="lineNum">    1090 </span>            : #endif
<span class="lineNum">    1091 </span>            :         break;
<span class="lineNum">    1092 </span>            :     case URES_TABLE:
<span class="lineNum">    1093 </span>            :     case URES_TABLE32:
<span class="lineNum">    1094 </span>            :         {
<span class="lineNum">    1095 </span>            :             const uint16_t *pKey16;
<span class="lineNum">    1096 </span>            :             uint16_t *qKey16;
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            :             const int32_t *pKey32;
<span class="lineNum">    1099 </span>            :             int32_t *qKey32;
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            :             Resource item;
<span class="lineNum">    1102 </span>            :             int32_t i, oldIndex;
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :             if(RES_GET_TYPE(res)==URES_TABLE) {</span>
<span class="lineNum">    1105 </span>            :                 /* get table item count */
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                 pKey16=(const uint16_t *)p;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                 qKey16=(uint16_t *)q;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                 count=ds-&gt;readUInt16(*pKey16);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                 pKey32=qKey32=NULL;</span>
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            :                 /* swap count */
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                 ds-&gt;swapArray16(ds, pKey16++, 2, qKey16++, pErrorCode);</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                 offset+=((1+count)+1)/2;</span>
<span class="lineNum">    1116 </span>            :             } else {
<span class="lineNum">    1117 </span>            :                 /* get table item count */
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :                 pKey32=(const int32_t *)p;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                 qKey32=(int32_t *)q;</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                 count=udata_readInt32(ds, *pKey32);</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :                 pKey16=qKey16=NULL;</span>
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            :                 /* swap count */
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                 ds-&gt;swapArray32(ds, pKey32++, 4, qKey32++, pErrorCode);</span>
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :                 offset+=1+count;</span>
<span class="lineNum">    1128 </span>            :             }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             if(count==0) {</span>
<span class="lineNum">    1131 </span>            :                 break;
<span class="lineNum">    1132 </span>            :             }
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :             p=inBundle+offset; /* pointer to table resources */</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :             q=outBundle+offset;</span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :             /* recurse */
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :                 const char *itemKey=gUnknownKey;</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                 if(pKey16!=NULL) {</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                     int32_t keyOffset=ds-&gt;readUInt16(pKey16[i]);</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                     if(keyOffset&lt;pTempTable-&gt;localKeyLimit) {</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                         itemKey=(const char *)outBundle+keyOffset;</span>
<span class="lineNum">    1144 </span>            :                     }
<span class="lineNum">    1145 </span>            :                 } else {
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                     int32_t keyOffset=udata_readInt32(ds, pKey32[i]);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                     if(keyOffset&gt;=0) {</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                         itemKey=(const char *)outBundle+keyOffset;</span>
<span class="lineNum">    1149 </span>            :                     }
<span class="lineNum">    1150 </span>            :                 }
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :                 item=ds-&gt;readUInt32(p[i]);</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :                 ures_swapResource(ds, inBundle, outBundle, item, itemKey, pTempTable, pErrorCode);</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                 if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1154 </span>            :                     udata_printError(ds, &quot;ures_swapResource(table res=%08x)[%d].recurse(%08x) failed\n&quot;,
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                                      res, i, item);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    1157 </span>            :                 }
<span class="lineNum">    1158 </span>            :             }
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :             if(pTempTable-&gt;majorFormatVersion&gt;1 || ds-&gt;inCharset==ds-&gt;outCharset) {</span>
<span class="lineNum">    1161 </span>            :                 /* no need to sort, just swap the offset/value arrays */
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :                 if(pKey16!=NULL) {</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                     ds-&gt;swapArray16(ds, pKey16, count*2, qKey16, pErrorCode);</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :                     ds-&gt;swapArray32(ds, p, count*4, q, pErrorCode);</span>
<span class="lineNum">    1165 </span>            :                 } else {
<span class="lineNum">    1166 </span>            :                     /* swap key offsets and items as one array */
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :                     ds-&gt;swapArray32(ds, pKey32, count*2*4, qKey32, pErrorCode);</span>
<span class="lineNum">    1168 </span>            :                 }
<span class="lineNum">    1169 </span>            :                 break;
<span class="lineNum">    1170 </span>            :             }
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            :             /*
<span class="lineNum">    1173 </span>            :              * We need to sort tables by outCharset key strings because they
<span class="lineNum">    1174 </span>            :              * sort differently for different charset families.
<span class="lineNum">    1175 </span>            :              * ures_swap() already set pTempTable-&gt;keyChars appropriately.
<span class="lineNum">    1176 </span>            :              * First we set up a temporary table with the key indexes and
<span class="lineNum">    1177 </span>            :              * sorting indexes and sort that.
<span class="lineNum">    1178 </span>            :              * Then we permutate and copy/swap the actual values.
<span class="lineNum">    1179 </span>            :              */
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :             if(pKey16!=NULL) {</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                 for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :                     pTempTable-&gt;rows[i].keyIndex=ds-&gt;readUInt16(pKey16[i]);</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                     pTempTable-&gt;rows[i].sortIndex=i;</span>
<span class="lineNum">    1184 </span>            :                 }
<span class="lineNum">    1185 </span>            :             } else {
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :                 for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                     pTempTable-&gt;rows[i].keyIndex=udata_readInt32(ds, pKey32[i]);</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                     pTempTable-&gt;rows[i].sortIndex=i;</span>
<span class="lineNum">    1189 </span>            :                 }
<span class="lineNum">    1190 </span>            :             }
<span class="lineNum">    1191 </span>            :             uprv_sortArray(pTempTable-&gt;rows, count, sizeof(Row),
<span class="lineNum">    1192 </span>            :                            ures_compareRows, pTempTable-&gt;keyChars,
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                            FALSE, pErrorCode);</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :             if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1195 </span>            :                 udata_printError(ds, &quot;ures_swapResource(table res=%08x).uprv_sortArray(%d items) failed\n&quot;,
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :                                  res, count);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1198 </span>            :             }
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :             /*
<span class="lineNum">    1201 </span>            :              * copy/swap/permutate items
<span class="lineNum">    1202 </span>            :              *
<span class="lineNum">    1203 </span>            :              * If we swap in-place, then the permutation must use another
<span class="lineNum">    1204 </span>            :              * temporary array (pTempTable-&gt;resort)
<span class="lineNum">    1205 </span>            :              * before the results are copied to the outBundle.
<span class="lineNum">    1206 </span>            :              */
<span class="lineNum">    1207 </span>            :             /* keys */
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :             if(pKey16!=NULL) {</span>
<span class="lineNum">    1209 </span>            :                 uint16_t *rKey16;
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :                 if(pKey16!=qKey16) {</span>
<span class="lineNum">    1212 </span>            :                     rKey16=qKey16;
<span class="lineNum">    1213 </span>            :                 } else {
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                     rKey16=(uint16_t *)pTempTable-&gt;resort;</span>
<span class="lineNum">    1215 </span>            :                 }
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                 for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                     oldIndex=pTempTable-&gt;rows[i].sortIndex;</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :                     ds-&gt;swapArray16(ds, pKey16+oldIndex, 2, rKey16+i, pErrorCode);</span>
<span class="lineNum">    1219 </span>            :                 }
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                 if(qKey16!=rKey16) {</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                     uprv_memcpy(qKey16, rKey16, 2*count);</span>
<span class="lineNum">    1222 </span>            :                 }
<span class="lineNum">    1223 </span>            :             } else {
<span class="lineNum">    1224 </span>            :                 int32_t *rKey32;
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :                 if(pKey32!=qKey32) {</span>
<span class="lineNum">    1227 </span>            :                     rKey32=qKey32;
<span class="lineNum">    1228 </span>            :                 } else {
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                     rKey32=pTempTable-&gt;resort;</span>
<span class="lineNum">    1230 </span>            :                 }
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                 for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                     oldIndex=pTempTable-&gt;rows[i].sortIndex;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :                     ds-&gt;swapArray32(ds, pKey32+oldIndex, 4, rKey32+i, pErrorCode);</span>
<span class="lineNum">    1234 </span>            :                 }
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                 if(qKey32!=rKey32) {</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :                     uprv_memcpy(qKey32, rKey32, 4*count);</span>
<span class="lineNum">    1237 </span>            :                 }
<span class="lineNum">    1238 </span>            :             }
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            :             /* resources */
<span class="lineNum">    1241 </span>            :             {
<span class="lineNum">    1242 </span>            :                 Resource *r;
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                 if(p!=q) {</span>
<span class="lineNum">    1246 </span>            :                     r=q;
<span class="lineNum">    1247 </span>            :                 } else {
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :                     r=(Resource *)pTempTable-&gt;resort;</span>
<span class="lineNum">    1249 </span>            :                 }
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :                 for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :                     oldIndex=pTempTable-&gt;rows[i].sortIndex;</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :                     ds-&gt;swapArray32(ds, p+oldIndex, 4, r+i, pErrorCode);</span>
<span class="lineNum">    1253 </span>            :                 }
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :                 if(q!=r) {</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :                     uprv_memcpy(q, r, 4*count);</span>
<span class="lineNum">    1256 </span>            :                 }
<span class="lineNum">    1257 </span>            :             }
<span class="lineNum">    1258 </span>            :         }
<span class="lineNum">    1259 </span>            :         break;
<span class="lineNum">    1260 </span>            :     case URES_ARRAY:
<span class="lineNum">    1261 </span>            :         {
<span class="lineNum">    1262 </span>            :             Resource item;
<span class="lineNum">    1263 </span>            :             int32_t i;
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :             count=udata_readInt32(ds, (int32_t)*p);</span>
<span class="lineNum">    1266 </span>            :             /* swap length */
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :             ds-&gt;swapArray32(ds, p++, 4, q++, pErrorCode);</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            :             /* recurse */
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;count; ++i) {</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :                 item=ds-&gt;readUInt32(p[i]);</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :                 ures_swapResource(ds, inBundle, outBundle, item, NULL, pTempTable, pErrorCode);</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :                 if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1274 </span>            :                     udata_printError(ds, &quot;ures_swapResource(array res=%08x)[%d].recurse(%08x) failed\n&quot;,
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                                      res, i, item);</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    1277 </span>            :                 }
<span class="lineNum">    1278 </span>            :             }
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            :             /* swap items */
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :             ds-&gt;swapArray32(ds, p, 4*count, q, pErrorCode);</span>
<span class="lineNum">    1282 </span>            :         }
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1284 </span>            :     case URES_INT_VECTOR:
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         count=udata_readInt32(ds, (int32_t)*p);</span>
<span class="lineNum">    1286 </span>            :         /* swap length and each integer */
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :         ds-&gt;swapArray32(ds, p, 4*(1+count), q, pErrorCode);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1289 </span>            :     default:
<span class="lineNum">    1290 </span>            :         /* also catches RES_BOGUS */
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :         *pErrorCode=U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1293 </span>            :     }
<span class="lineNum">    1294 </span>            : }
<a name="1295"><span class="lineNum">    1295 </span>            : </a>
<span class="lineNum">    1296 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 : ures_swap(const UDataSwapper *ds,</span>
<span class="lineNum">    1298 </span>            :           const void *inData, int32_t length, void *outData,
<span class="lineNum">    1299 </span>            :           UErrorCode *pErrorCode) {
<span class="lineNum">    1300 </span>            :     const UDataInfo *pInfo;
<span class="lineNum">    1301 </span>            :     const Resource *inBundle;
<span class="lineNum">    1302 </span>            :     Resource rootRes;
<span class="lineNum">    1303 </span>            :     int32_t headerSize, maxTableLength;
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            :     Row rows[STACK_ROW_CAPACITY];
<span class="lineNum">    1306 </span>            :     int32_t resort[STACK_ROW_CAPACITY];
<span class="lineNum">    1307 </span>            :     TempTable tempTable;
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :     const int32_t *inIndexes;
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            :     /* the following integers count Resource item offsets (4 bytes each), not bytes */
<span class="lineNum">    1312 </span>            :     int32_t bundleLength, indexLength, keysBottom, keysTop, resBottom, top;
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            :     /* udata_swapDataHeader checks the arguments */
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1317 </span>            :         return 0;
<span class="lineNum">    1318 </span>            :     }
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            :     /* check data format and format version */
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :     pInfo=(const UDataInfo *)((const char *)inData+4);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     if(!(</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :         pInfo-&gt;dataFormat[0]==0x52 &amp;&amp;   /* dataFormat=&quot;ResB&quot; */</span>
<span class="lineNum">    1324 </span>            :         pInfo-&gt;dataFormat[1]==0x65 &amp;&amp;
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :         pInfo-&gt;dataFormat[2]==0x73 &amp;&amp;</span>
<span class="lineNum">    1326 </span>            :         pInfo-&gt;dataFormat[3]==0x42 &amp;&amp;
<span class="lineNum">    1327 </span>            :         /* formatVersion 1.1+ or 2.x or 3.x */
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :         ((pInfo-&gt;formatVersion[0]==1 &amp;&amp; pInfo-&gt;formatVersion[1]&gt;=1) ||</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :             pInfo-&gt;formatVersion[0]==2 || pInfo-&gt;formatVersion[0]==3)</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     )) {</span>
<span class="lineNum">    1331 </span>            :         udata_printError(ds, &quot;ures_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not a resource bundle\n&quot;,
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                          pInfo-&gt;dataFormat[0], pInfo-&gt;dataFormat[1],</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                          pInfo-&gt;dataFormat[2], pInfo-&gt;dataFormat[3],</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                          pInfo-&gt;formatVersion[0], pInfo-&gt;formatVersion[1]);</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :         *pErrorCode=U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1337 </span>            :     }
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     tempTable.majorFormatVersion=pInfo-&gt;formatVersion[0];</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            :     /* a resource bundle must contain at least one resource item */
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :     if(length&lt;0) {</span>
<span class="lineNum">    1342 </span>            :         bundleLength=-1;
<span class="lineNum">    1343 </span>            :     } else {
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :         bundleLength=(length-headerSize)/4;</span>
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :         /* formatVersion 1.1 must have a root item and at least 5 indexes */
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :         if(bundleLength&lt;(1+5)) {</span>
<span class="lineNum">    1348 </span>            :             udata_printError(ds, &quot;ures_swap(): too few bytes (%d after header) for a resource bundle\n&quot;,
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                              length-headerSize);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :             *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1352 </span>            :         }
<span class="lineNum">    1353 </span>            :     }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     inBundle=(const Resource *)((const char *)inData+headerSize);</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     rootRes=ds-&gt;readUInt32(*inBundle);</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            :     /* formatVersion 1.1 adds the indexes[] array */
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     inIndexes=(const int32_t *)(inBundle+1);</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :     indexLength=udata_readInt32(ds, inIndexes[URES_INDEX_LENGTH])&amp;0xff;</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :     if(indexLength&lt;=URES_INDEX_MAX_TABLE_LENGTH) {</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :         udata_printError(ds, &quot;ures_swap(): too few indexes for a 1.1+ resource bundle\n&quot;);</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :         *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1366 </span>            :     }
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :     keysBottom=1+indexLength;</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     keysTop=udata_readInt32(ds, inIndexes[URES_INDEX_KEYS_TOP]);</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     if(indexLength&gt;URES_INDEX_16BIT_TOP) {</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :         resBottom=udata_readInt32(ds, inIndexes[URES_INDEX_16BIT_TOP]);</span>
<span class="lineNum">    1371 </span>            :     } else {
<span class="lineNum">    1372 </span>            :         resBottom=keysTop;
<span class="lineNum">    1373 </span>            :     }
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     top=udata_readInt32(ds, inIndexes[URES_INDEX_BUNDLE_TOP]);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     maxTableLength=udata_readInt32(ds, inIndexes[URES_INDEX_MAX_TABLE_LENGTH]);</span>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     if(0&lt;=bundleLength &amp;&amp; bundleLength&lt;top) {</span>
<span class="lineNum">    1378 </span>            :         udata_printError(ds, &quot;ures_swap(): resource top %d exceeds bundle length %d\n&quot;,
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :                          top, bundleLength);</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :         *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     if(keysTop&gt;(1+indexLength)) {</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :         tempTable.localKeyLimit=keysTop&lt;&lt;2;</span>
<span class="lineNum">    1385 </span>            :     } else {
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :         tempTable.localKeyLimit=0;</span>
<span class="lineNum">    1387 </span>            :     }
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     if(length&gt;=0) {</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :         Resource *outBundle=(Resource *)((char *)outData+headerSize);</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span>            :         /* track which resources we have already swapped */
<span class="lineNum">    1393 </span>            :         uint32_t stackResFlags[STACK_ROW_CAPACITY];
<span class="lineNum">    1394 </span>            :         int32_t resFlagsLength;
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            :         /*
<span class="lineNum">    1397 </span>            :          * We need one bit per 4 resource bundle bytes so that we can track
<span class="lineNum">    1398 </span>            :          * every possible Resource for whether we have swapped it already.
<span class="lineNum">    1399 </span>            :          * Multiple Resource words can refer to the same bundle offsets
<span class="lineNum">    1400 </span>            :          * for sharing identical values.
<span class="lineNum">    1401 </span>            :          * We could optimize this by allocating only for locations above
<span class="lineNum">    1402 </span>            :          * where Resource values are stored (above keys &amp; strings).
<span class="lineNum">    1403 </span>            :          */
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :         resFlagsLength=(length+31)&gt;&gt;5;          /* number of bytes needed */</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         resFlagsLength=(resFlagsLength+3)&amp;~3;   /* multiple of 4 bytes for uint32_t */</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :         if(resFlagsLength&lt;=(int32_t)sizeof(stackResFlags)) {</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :             tempTable.resFlags=stackResFlags;</span>
<span class="lineNum">    1408 </span>            :         } else {
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :             tempTable.resFlags=(uint32_t *)uprv_malloc(resFlagsLength);</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :             if(tempTable.resFlags==NULL) {</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                 udata_printError(ds, &quot;ures_swap(): unable to allocate memory for tracking resources\n&quot;);</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1414 </span>            :             }
<span class="lineNum">    1415 </span>            :         }
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :         uprv_memset(tempTable.resFlags, 0, resFlagsLength);</span>
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            :         /* copy the bundle for binary and inaccessible data */
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :         if(inData!=outData) {</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :             uprv_memcpy(outBundle, inBundle, 4*top);</span>
<span class="lineNum">    1421 </span>            :         }
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            :         /* swap the key strings, but not the padding bytes (0xaa) after the last string and its NUL */
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :         udata_swapInvStringBlock(ds, inBundle+keysBottom, 4*(keysTop-keysBottom),</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :                                     outBundle+keysBottom, pErrorCode);</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :         if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :             udata_printError(ds, &quot;ures_swap().udata_swapInvStringBlock(keys[%d]) failed\n&quot;, 4*(keysTop-keysBottom));</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1429 </span>            :         }
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :         /* swap the 16-bit units (strings, table16, array16) */
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :         if(keysTop&lt;resBottom) {</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :             ds-&gt;swapArray16(ds, inBundle+keysTop, (resBottom-keysTop)*4, outBundle+keysTop, pErrorCode);</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :             if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                 udata_printError(ds, &quot;ures_swap().swapArray16(16-bit units[%d]) failed\n&quot;, 2*(resBottom-keysTop));</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1437 </span>            :             }
<span class="lineNum">    1438 </span>            :         }
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            :         /* allocate the temporary table for sorting resource tables */
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :         tempTable.keyChars=(const char *)outBundle; /* sort by outCharset */</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :         if(tempTable.majorFormatVersion&gt;1 || maxTableLength&lt;=STACK_ROW_CAPACITY) {</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :             tempTable.rows=rows;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :             tempTable.resort=resort;</span>
<span class="lineNum">    1445 </span>            :         } else {
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :             tempTable.rows=(Row *)uprv_malloc(maxTableLength*sizeof(Row)+maxTableLength*4);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :             if(tempTable.rows==NULL) {</span>
<span class="lineNum">    1448 </span>            :                 udata_printError(ds, &quot;ures_swap(): unable to allocate memory for sorting tables (max length: %d)\n&quot;,
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                                  maxTableLength);</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :                 if(tempTable.resFlags!=stackResFlags) {</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                     uprv_free(tempTable.resFlags);</span>
<span class="lineNum">    1453 </span>            :                 }
<span class="lineNum">    1454 </span>            :                 return 0;
<span class="lineNum">    1455 </span>            :             }
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :             tempTable.resort=(int32_t *)(tempTable.rows+maxTableLength);</span>
<span class="lineNum">    1457 </span>            :         }
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            :         /* swap the resources */
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :         ures_swapResource(ds, inBundle, outBundle, rootRes, NULL, &amp;tempTable, pErrorCode);</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :         if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1462 </span>            :             udata_printError(ds, &quot;ures_swapResource(root res=%08x) failed\n&quot;,
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                              rootRes);</span>
<span class="lineNum">    1464 </span>            :         }
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         if(tempTable.rows!=rows) {</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :             uprv_free(tempTable.rows);</span>
<span class="lineNum">    1468 </span>            :         }
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :         if(tempTable.resFlags!=stackResFlags) {</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :             uprv_free(tempTable.resFlags);</span>
<span class="lineNum">    1471 </span>            :         }
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :         /* swap the root resource and indexes */
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         ds-&gt;swapArray32(ds, inBundle, keysBottom*4, outBundle, pErrorCode);</span>
<span class="lineNum">    1475 </span>            :     }
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :     return headerSize+4*top;</span>
<span class="lineNum">    1478 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
