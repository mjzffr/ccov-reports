<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/forms/nsTextControlFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/forms</a> - nsTextControlFrame.cpp<span style="font-size: 80%;"> (source / <a href="nsTextControlFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">521</td>
            <td class="headerCovTableEntry">544</td>
            <td class="headerCovTableEntryHi">95.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntry">49</td>
            <td class="headerCovTableEntryHi">95.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;nsFontMetrics.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsTextControlFrame.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsIPlaintextEditor.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsCaret.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsCSSPseudoElements.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsGenericHTMLElement.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsIEditor.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsIPhonetic.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsTextFragment.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsIDOMHTMLTextAreaElement.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsNameSpaceManager.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsFormControlFrame.h&quot; //for registering accesskeys
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;nsIContent.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsRenderingContext.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsIDOMElement.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsIDOMHTMLElement.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsIPresShell.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      32 </span>            : #include &quot;nsIDOMNodeList.h&quot; //for selection setting helper func
<span class="lineNum">      33 </span>            : #include &quot;nsIDOMRange.h&quot; //for selection setting helper func
<span class="lineNum">      34 </span>            : #include &quot;nsPIDOMWindow.h&quot; //needed for notify selection changed to update the menus ect.
<span class="lineNum">      35 </span>            : #include &quot;nsIDOMNode.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &quot;nsIDOMText.h&quot; //for multiline getselection
<span class="lineNum">      38 </span>            : #include &quot;nsFocusManager.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;nsPresState.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;nsContentList.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;nsAttrValueInlines.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;mozilla/dom/Selection.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;mozilla/TextEditRules.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;nsTextNode.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;mozilla/StyleSetHandle.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;mozilla/StyleSetHandleInlines.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;mozilla/dom/HTMLInputElement.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;mozilla/dom/HTMLTextAreaElement.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;mozilla/dom/ScriptSettings.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;mozilla/MathAlgorithms.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;nsFrameSelection.h&quot;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #define DEFAULT_COLUMN_WIDTH 20
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : using namespace mozilla;
<a name="57"><span class="lineNum">      57 </span>            : </a>
<span class="lineNum">      58 </span>            : nsIFrame*
<span class="lineNum">      59 </span><span class="lineCov">          1 : NS_NewTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)</span>
<span class="lineNum">      60 </span>            : {
<span class="lineNum">      61 </span><span class="lineCov">          1 :   return new (aPresShell) nsTextControlFrame(aContext);</span>
<a name="62"><span class="lineNum">      62 </span>            : }</a>
<span class="lineNum">      63 </span>            : 
<a name="64"><span class="lineNum">      64 </span><span class="lineCov">          1 : NS_IMPL_FRAMEARENA_HELPERS(nsTextControlFrame)</span></a>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineCov">          1 : NS_QUERYFRAME_HEAD(nsTextControlFrame)</span>
<span class="lineNum">      67 </span><span class="lineCov">          1 :   NS_QUERYFRAME_ENTRY(nsIFormControlFrame)</span>
<span class="lineNum">      68 </span><span class="lineCov">          1 :   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)</span>
<span class="lineNum">      69 </span><span class="lineCov">          1 :   NS_QUERYFRAME_ENTRY(nsITextControlFrame)</span>
<span class="lineNum">      70 </span><span class="lineCov">          1 :   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)</span>
<span class="lineNum">      71 </span><span class="lineCov">          1 : NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)</span>
<span class="lineNum">      72 </span>            : 
<a name="73"><span class="lineNum">      73 </span>            : #ifdef ACCESSIBILITY</a>
<span class="lineNum">      74 </span>            : a11y::AccType
<span class="lineNum">      75 </span><span class="lineCov">          1 : nsTextControlFrame::AccessibleType()</span>
<span class="lineNum">      76 </span>            : {
<span class="lineNum">      77 </span><span class="lineCov">          1 :   return a11y::eHTMLTextFieldType;</span>
<span class="lineNum">      78 </span>            : }
<span class="lineNum">      79 </span>            : #endif
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : #ifdef DEBUG
<span class="lineNum">      82 </span>            : class EditorInitializerEntryTracker {
<span class="lineNum">      83 </span>            : public:
<span class="lineNum">      84 </span>            :   explicit EditorInitializerEntryTracker(nsTextControlFrame &amp;frame)
<span class="lineNum">      85 </span>            :     : mFrame(frame)
<span class="lineNum">      86 </span>            :     , mFirstEntry(false)
<span class="lineNum">      87 </span>            :   {
<span class="lineNum">      88 </span>            :     if (!mFrame.mInEditorInitialization) {
<span class="lineNum">      89 </span>            :       mFrame.mInEditorInitialization = true;
<span class="lineNum">      90 </span>            :       mFirstEntry = true;
<span class="lineNum">      91 </span>            :     }
<span class="lineNum">      92 </span>            :   }
<span class="lineNum">      93 </span>            :   ~EditorInitializerEntryTracker()
<span class="lineNum">      94 </span>            :   {
<span class="lineNum">      95 </span>            :     if (mFirstEntry) {
<span class="lineNum">      96 </span>            :       mFrame.mInEditorInitialization = false;
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span>            :   }
<span class="lineNum">      99 </span>            :   bool EnteredMoreThanOnce() const { return !mFirstEntry; }
<span class="lineNum">     100 </span>            : private:
<span class="lineNum">     101 </span>            :   nsTextControlFrame &amp;mFrame;
<span class="lineNum">     102 </span>            :   bool mFirstEntry;
<span class="lineNum">     103 </span>            : };
<a name="104"><span class="lineNum">     104 </span>            : #endif</a>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineCov">          1 : nsTextControlFrame::nsTextControlFrame(nsStyleContext* aContext)</span>
<span class="lineNum">     107 </span>            :   : nsContainerFrame(aContext)
<span class="lineNum">     108 </span>            :   , mFirstBaseline(NS_INTRINSIC_WIDTH_UNKNOWN)
<span class="lineNum">     109 </span>            :   , mEditorHasBeenInitialized(false)
<span class="lineNum">     110 </span>            :   , mIsProcessing(false)
<span class="lineNum">     111 </span><span class="lineCov">          1 :   , mUsePlaceholder(false)</span>
<span class="lineNum">     112 </span>            : #ifdef DEBUG
<span class="lineNum">     113 </span>            :   , mInEditorInitialization(false)
<span class="lineNum">     114 </span>            : #endif
<span class="lineNum">     115 </span>            : {
<a name="116"><span class="lineNum">     116 </span>            : }</a>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineCov">          1 : nsTextControlFrame::~nsTextControlFrame()</span>
<span class="lineNum">     119 </span>            : {
<span class="lineNum">     120 </span><span class="lineCov">          1 : }</span>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<span class="lineNum">     122 </span>            : void
<span class="lineNum">     123 </span><span class="lineCov">          1 : nsTextControlFrame::DestroyFrom(nsIFrame* aDestructRoot)</span>
<span class="lineNum">     124 </span>            : {
<span class="lineNum">     125 </span><span class="lineCov">          1 :   mScrollEvent.Revoke();</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineCov">          1 :   EditorInitializer* initializer = Properties().Get(TextControlInitializer());</span>
<span class="lineNum">     128 </span><span class="lineCov">          1 :   if (initializer) {</span>
<span class="lineNum">     129 </span><span class="lineCov">          1 :     initializer-&gt;Revoke();</span>
<span class="lineNum">     130 </span><span class="lineCov">          1 :     Properties().Delete(TextControlInitializer());</span>
<span class="lineNum">     131 </span>            :   }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :   // Unbind the text editor state object from the frame.  The editor will live
<span class="lineNum">     134 </span>            :   // on, but things like controllers will be released.
<span class="lineNum">     135 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     136 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     137 </span><span class="lineCov">          1 :   txtCtrl-&gt;UnbindFromFrame(this);</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineCov">          1 :   nsFormControlFrame::RegUnRegAccessKey(static_cast&lt;nsIFrame*&gt;(this), false);</span>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span><span class="lineCov">          1 :   nsContainerFrame::DestroyFrom(aDestructRoot);</span>
<span class="lineNum">     142 </span><span class="lineCov">          1 : }</span>
<a name="143"><span class="lineNum">     143 </span>            : </a>
<span class="lineNum">     144 </span>            : nsIAtom*
<span class="lineNum">     145 </span><span class="lineCov">          1 : nsTextControlFrame::GetType() const </span>
<span class="lineNum">     146 </span>            : { 
<span class="lineNum">     147 </span><span class="lineCov">          1 :   return nsGkAtoms::textInputFrame;</span>
<span class="lineNum">     148 </span>            : }
<a name="149"><span class="lineNum">     149 </span>            : </a>
<span class="lineNum">     150 </span>            : LogicalSize
<span class="lineNum">     151 </span><span class="lineCov">          1 : nsTextControlFrame::CalcIntrinsicSize(nsRenderingContext* aRenderingContext,</span>
<span class="lineNum">     152 </span>            :                                       WritingMode aWM,
<span class="lineNum">     153 </span>            :                                       float aFontSizeInflation) const
<span class="lineNum">     154 </span>            : {
<span class="lineNum">     155 </span>            :   LogicalSize intrinsicSize(aWM);
<span class="lineNum">     156 </span>            :   // Get leading and the Average/MaxAdvance char width 
<span class="lineNum">     157 </span><span class="lineCov">          1 :   nscoord lineHeight  = 0;</span>
<span class="lineNum">     158 </span><span class="lineCov">          1 :   nscoord charWidth   = 0;</span>
<span class="lineNum">     159 </span><span class="lineCov">          1 :   nscoord charMaxAdvance  = 0;</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :   RefPtr&lt;nsFontMetrics&gt; fontMet =
<span class="lineNum">     162 </span><span class="lineCov">          1 :     nsLayoutUtils::GetFontMetricsForFrame(this, aFontSizeInflation);</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   lineHeight =
<span class="lineNum">     165 </span>            :     ReflowInput::CalcLineHeight(GetContent(), StyleContext(),
<span class="lineNum">     166 </span><span class="lineCov">          1 :                                       NS_AUTOHEIGHT, aFontSizeInflation);</span>
<span class="lineNum">     167 </span><span class="lineCov">          1 :   charWidth = fontMet-&gt;AveCharWidth();</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :   charMaxAdvance = fontMet-&gt;MaxAdvance();</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   // Set the width equal to the width in characters
<span class="lineNum">     171 </span><span class="lineCov">          1 :   int32_t cols = GetCols();</span>
<span class="lineNum">     172 </span><span class="lineCov">          1 :   intrinsicSize.ISize(aWM) = cols * charWidth;</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :   // To better match IE, take the maximum character width(in twips) and remove
<span class="lineNum">     175 </span>            :   // 4 pixels add this on as additional padding(internalPadding). But only do
<span class="lineNum">     176 </span>            :   // this if we think we have a fixed-width font.
<span class="lineNum">     177 </span><span class="lineCov">          1 :   if (mozilla::Abs(charWidth - charMaxAdvance) &gt; (unsigned)nsPresContext::CSSPixelsToAppUnits(1)) {</span>
<span class="lineNum">     178 </span>            :     nscoord internalPadding =
<span class="lineNum">     179 </span><span class="lineCov">          1 :       std::max(0, charMaxAdvance - nsPresContext::CSSPixelsToAppUnits(4));</span>
<span class="lineNum">     180 </span><span class="lineCov">          1 :     nscoord t = nsPresContext::CSSPixelsToAppUnits(1); </span>
<span class="lineNum">     181 </span>            :    // Round to a multiple of t
<span class="lineNum">     182 </span><span class="lineCov">          1 :     nscoord rest = internalPadding % t; </span>
<span class="lineNum">     183 </span><span class="lineCov">          1 :     if (rest &lt; t - rest) {</span>
<span class="lineNum">     184 </span><span class="lineCov">          1 :       internalPadding -= rest;</span>
<span class="lineNum">     185 </span>            :     } else {
<span class="lineNum">     186 </span><span class="lineCov">          1 :       internalPadding += t - rest;</span>
<span class="lineNum">     187 </span>            :     }
<span class="lineNum">     188 </span>            :     // Now add the extra padding on (so that small input sizes work well)
<span class="lineNum">     189 </span><span class="lineCov">          1 :     intrinsicSize.ISize(aWM) += internalPadding;</span>
<span class="lineNum">     190 </span>            :   } else {
<span class="lineNum">     191 </span>            :     // This is to account for the anonymous &lt;br&gt; having a 1 twip width
<span class="lineNum">     192 </span>            :     // in Full Standards mode, see BRFrame::Reflow and bug 228752.
<span class="lineNum">     193 </span><span class="lineCov">          1 :     if (PresContext()-&gt;CompatibilityMode() == eCompatibility_FullStandards) {</span>
<span class="lineNum">     194 </span><span class="lineCov">          1 :       intrinsicSize.ISize(aWM) += 1;</span>
<span class="lineNum">     195 </span>            :     }
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :   // Increment width with cols * letter-spacing.
<span class="lineNum">     199 </span>            :   {
<span class="lineNum">     200 </span><span class="lineCov">          1 :     const nsStyleCoord&amp; lsCoord = StyleText()-&gt;mLetterSpacing;</span>
<span class="lineNum">     201 </span><span class="lineCov">          1 :     if (eStyleUnit_Coord == lsCoord.GetUnit()) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :       nscoord letterSpacing = lsCoord.GetCoordValue();</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       if (letterSpacing != 0) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         intrinsicSize.ISize(aWM) += cols * letterSpacing;</span>
<span class="lineNum">     205 </span>            :       }
<span class="lineNum">     206 </span>            :     }
<span class="lineNum">     207 </span>            :   }
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   // Set the height equal to total number of rows (times the height of each
<span class="lineNum">     210 </span>            :   // line, of course)
<span class="lineNum">     211 </span><span class="lineCov">          1 :   intrinsicSize.BSize(aWM) = lineHeight * GetRows();</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :   // Add in the size of the scrollbars for textarea
<span class="lineNum">     214 </span><span class="lineCov">          1 :   if (IsTextArea()) {</span>
<span class="lineNum">     215 </span><span class="lineCov">          1 :     nsIFrame* first = PrincipalChildList().FirstChild();</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineCov">          1 :     nsIScrollableFrame *scrollableFrame = do_QueryFrame(first);</span>
<span class="lineNum">     218 </span>            :     NS_ASSERTION(scrollableFrame, &quot;Child must be scrollable&quot;);
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineCov">          1 :     if (scrollableFrame) {</span>
<span class="lineNum">     221 </span>            :       LogicalMargin scrollbarSizes(aWM,
<span class="lineNum">     222 </span>            :         scrollableFrame-&gt;GetDesiredScrollbarSizes(PresContext(),
<span class="lineNum">     223 </span><span class="lineCov">          1 :                                                   aRenderingContext));</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineCov">          1 :       intrinsicSize.ISize(aWM) += scrollbarSizes.IStartEnd(aWM);</span>
<span class="lineNum">     226 </span><span class="lineCov">          1 :       intrinsicSize.BSize(aWM) += scrollbarSizes.BStartEnd(aWM);</span>
<span class="lineNum">     227 </span>            :     }
<span class="lineNum">     228 </span>            :   }
<span class="lineNum">     229 </span><span class="lineCov">          1 :   return intrinsicSize;</span>
<span class="lineNum">     230 </span>            : }
<a name="231"><span class="lineNum">     231 </span>            : </a>
<span class="lineNum">     232 </span>            : nsresult
<span class="lineNum">     233 </span><span class="lineCov">          1 : nsTextControlFrame::EnsureEditorInitialized()</span>
<span class="lineNum">     234 </span>            : {
<span class="lineNum">     235 </span>            :   // This method initializes our editor, if needed.
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :   // This code used to be called from CreateAnonymousContent(), but
<span class="lineNum">     238 </span>            :   // when the editor set the initial string, it would trigger a
<span class="lineNum">     239 </span>            :   // PresShell listener which called FlushPendingNotifications()
<span class="lineNum">     240 </span>            :   // during frame construction. This was causing other form controls
<span class="lineNum">     241 </span>            :   // to display wrong values.  Additionally, calling this every time
<span class="lineNum">     242 </span>            :   // a text frame control is instantiated means that we're effectively
<span class="lineNum">     243 </span>            :   // instantiating the editor for all text fields, even if they
<span class="lineNum">     244 </span>            :   // never get used.  So, now this method is being called lazily only
<span class="lineNum">     245 </span>            :   // when we actually need an editor.
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">          1 :   if (mEditorHasBeenInitialized)</span>
<span class="lineNum">     248 </span>            :     return NS_OK;
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">          1 :   nsIDocument* doc = mContent-&gt;GetComposedDoc();</span>
<span class="lineNum">     251 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineCov">          1 :   AutoWeakFrame weakFrame(this);</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   // Flush out content on our document.  Have to do this, because script
<span class="lineNum">     256 </span>            :   // blockers don't prevent the sink flushing out content and notifying in the
<span class="lineNum">     257 </span>            :   // process, which can destroy frames.
<span class="lineNum">     258 </span><span class="lineCov">          1 :   doc-&gt;FlushPendingNotifications(FlushType::ContentAndNotify);</span>
<span class="lineNum">     259 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_ERROR_FAILURE);</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   // Make sure that editor init doesn't do things that would kill us off
<span class="lineNum">     262 </span>            :   // (especially off the script blockers it'll create for its DOM mutations).
<span class="lineNum">     263 </span>            :   {
<span class="lineNum">     264 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     265 </span>            :     MOZ_ASSERT(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :     // Hide selection changes during the initialization, as webpages should not
<span class="lineNum">     268 </span>            :     // be aware of these initializations
<span class="lineNum">     269 </span><span class="lineCov">          1 :     AutoHideSelectionChanges hideSelectionChanges(txtCtrl-&gt;GetConstFrameSelection());</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :     nsAutoScriptBlocker scriptBlocker;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :     // Time to mess with our security context... See comments in GetValue()
<span class="lineNum">     274 </span>            :     // for why this is needed.
<span class="lineNum">     275 </span><span class="lineCov">          1 :     mozilla::dom::AutoNoJSAPI nojsapi;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :     // Make sure that we try to focus the content even if the method fails
<span class="lineNum">     278 </span>            :     class EnsureSetFocus {
<span class="lineNum">     279 </span>            :     public:
<a name="280"><span class="lineNum">     280 </span>            :       explicit EnsureSetFocus(nsTextControlFrame* aFrame)</a>
<span class="lineNum">     281 </span><span class="lineCov">          1 :         : mFrame(aFrame) {}</span>
<span class="lineNum">     282 </span><span class="lineCov">          1 :       ~EnsureSetFocus() {</span>
<span class="lineNum">     283 </span><span class="lineCov">          1 :         if (nsContentUtils::IsFocusedContent(mFrame-&gt;GetContent()))</span>
<span class="lineNum">     284 </span><span class="lineCov">          1 :           mFrame-&gt;SetFocus(true, false);</span>
<span class="lineNum">     285 </span><span class="lineCov">          1 :       }</span>
<span class="lineNum">     286 </span>            :     private:
<span class="lineNum">     287 </span>            :       nsTextControlFrame *mFrame;
<span class="lineNum">     288 </span>            :     };
<span class="lineNum">     289 </span><span class="lineCov">          1 :     EnsureSetFocus makeSureSetFocusHappens(this);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : #ifdef DEBUG
<span class="lineNum">     292 </span>            :     // Make sure we are not being called again until we're finished.
<span class="lineNum">     293 </span>            :     // If reentrancy happens, just pretend that we don't have an editor.
<span class="lineNum">     294 </span>            :     const EditorInitializerEntryTracker tracker(*this);
<span class="lineNum">     295 </span>            :     NS_ASSERTION(!tracker.EnteredMoreThanOnce(),
<span class="lineNum">     296 </span>            :                  &quot;EnsureEditorInitialized has been called while a previous call was in progress&quot;);
<span class="lineNum">     297 </span>            : #endif
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :     // Create an editor for the frame, if one doesn't already exist
<span class="lineNum">     300 </span><span class="lineCov">          1 :     nsresult rv = txtCtrl-&gt;CreateEditor();</span>
<span class="lineNum">     301 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     302 </span><span class="lineCov">          1 :     NS_ENSURE_STATE(weakFrame.IsAlive());</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     // Set mEditorHasBeenInitialized so that subsequent calls will use the
<span class="lineNum">     305 </span>            :     // editor.
<span class="lineNum">     306 </span><span class="lineCov">          1 :     mEditorHasBeenInitialized = true;</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">          1 :     if (weakFrame.IsAlive()) {</span>
<span class="lineNum">     309 </span><span class="lineCov">          1 :       uint32_t position = 0;</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :       // Set the selection to the end of the text field (bug 1287655),
<span class="lineNum">     312 </span>            :       // but only if the contents has changed (bug 1337392).
<span class="lineNum">     313 </span><span class="lineCov">          1 :       if (txtCtrl-&gt;ValueChanged()) {</span>
<span class="lineNum">     314 </span><span class="lineCov">          1 :         nsAutoString val;</span>
<span class="lineNum">     315 </span><span class="lineCov">          1 :         txtCtrl-&gt;GetTextEditorValue(val, true);</span>
<span class="lineNum">     316 </span><span class="lineCov">          1 :         position = val.Length();</span>
<span class="lineNum">     317 </span>            :       }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineCov">          1 :       SetSelectionEndPoints(position, position);</span>
<span class="lineNum">     320 </span>            :     }
<span class="lineNum">     321 </span>            :   }
<span class="lineNum">     322 </span><span class="lineCov">          1 :   NS_ENSURE_STATE(weakFrame.IsAlive());</span>
<span class="lineNum">     323 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     324 </span>            : }
<a name="325"><span class="lineNum">     325 </span>            : </a>
<span class="lineNum">     326 </span>            : nsresult
<span class="lineNum">     327 </span><span class="lineCov">          1 : nsTextControlFrame::CreateAnonymousContent(nsTArray&lt;ContentInfo&gt;&amp; aElements)</span>
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span>            :   NS_ASSERTION(mContent, &quot;We should have a content!&quot;);
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineCov">          1 :   mState |= NS_FRAME_INDEPENDENT_SELECTION;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     334 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   // Bind the frame to its text control
<span class="lineNum">     337 </span><span class="lineCov">          1 :   nsresult rv = txtCtrl-&gt;BindToFrame(this);</span>
<span class="lineNum">     338 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">          1 :   nsIContent* rootNode = txtCtrl-&gt;GetRootEditorNode();</span>
<span class="lineNum">     341 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(rootNode, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineCov">          1 :   if (!aElements.AppendElement(rootNode))</span>
<span class="lineNum">     344 </span>            :     return NS_ERROR_OUT_OF_MEMORY;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            :   // Do we need a placeholder node?
<span class="lineNum">     347 </span><span class="lineCov">          1 :   nsAutoString placeholderTxt;</span>
<span class="lineNum">     348 </span>            :   mContent-&gt;GetAttr(kNameSpaceID_None, nsGkAtoms::placeholder,
<span class="lineNum">     349 </span><span class="lineCov">          1 :                     placeholderTxt);</span>
<span class="lineNum">     350 </span><span class="lineCov">          1 :   nsContentUtils::RemoveNewlines(placeholderTxt);</span>
<span class="lineNum">     351 </span><span class="lineCov">          1 :   mUsePlaceholder = !placeholderTxt.IsEmpty();</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :   // Create the placeholder anonymous content if needed.
<span class="lineNum">     354 </span><span class="lineCov">          1 :   if (mUsePlaceholder) {</span>
<span class="lineNum">     355 </span><span class="lineCov">          1 :     Element* placeholderNode = txtCtrl-&gt;CreatePlaceholderNode();</span>
<span class="lineNum">     356 </span><span class="lineCov">          1 :     NS_ENSURE_TRUE(placeholderNode, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :     // Associate ::placeholder pseudo-element with the placeholder node.
<span class="lineNum">     359 </span><span class="lineCov">          1 :     placeholderNode-&gt;SetPseudoElementType(CSSPseudoElementType::placeholder);</span>
<span class="lineNum">     360 </span><span class="lineCov">          1 :     aElements.AppendElement(placeholderNode);</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineCov">          1 :     if (!IsSingleLineTextControl()) {</span>
<span class="lineNum">     363 </span>            :       // For textareas, UpdateValueDisplay doesn't initialize the visibility
<span class="lineNum">     364 </span>            :       // status of the placeholder because it returns early, so we have to
<span class="lineNum">     365 </span>            :       // do that manually here.
<span class="lineNum">     366 </span><span class="lineCov">          1 :       txtCtrl-&gt;UpdatePlaceholderVisibility(true);</span>
<span class="lineNum">     367 </span>            :     }
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineCov">          1 :   rv = UpdateValueDisplay(false);</span>
<span class="lineNum">     371 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :   // textareas are eagerly initialized
<span class="lineNum">     374 </span><span class="lineCov">          1 :   bool initEagerly = !IsSingleLineTextControl();</span>
<span class="lineNum">     375 </span><span class="lineCov">          1 :   if (!initEagerly) {</span>
<span class="lineNum">     376 </span>            :     // Also, input elements which have a cached selection should get eager
<span class="lineNum">     377 </span>            :     // editor initialization.
<span class="lineNum">     378 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     379 </span>            :     NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     380 </span><span class="lineCov">          1 :     initEagerly = txtCtrl-&gt;HasCachedSelection();</span>
<span class="lineNum">     381 </span>            :   }
<span class="lineNum">     382 </span><span class="lineCov">          1 :   if (!initEagerly) {</span>
<span class="lineNum">     383 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsIDOMHTMLElement&gt; element = do_QueryInterface(txtCtrl);</span>
<span class="lineNum">     384 </span><span class="lineCov">          1 :     if (element) {</span>
<span class="lineNum">     385 </span>            :       // so are input text controls with spellcheck=true
<span class="lineNum">     386 </span><span class="lineCov">          1 :       element-&gt;GetSpellcheck(&amp;initEagerly);</span>
<span class="lineNum">     387 </span>            :     }
<span class="lineNum">     388 </span>            :   }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineCov">          1 :   if (initEagerly) {</span>
<span class="lineNum">     391 </span>            :     NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
<span class="lineNum">     392 </span>            :                  &quot;Someone forgot a script blocker?&quot;);
<span class="lineNum">     393 </span><span class="lineCov">          1 :     EditorInitializer* initializer = Properties().Get(TextControlInitializer());</span>
<span class="lineNum">     394 </span><span class="lineCov">          1 :     if (initializer) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :       initializer-&gt;Revoke();</span>
<span class="lineNum">     396 </span>            :     }
<span class="lineNum">     397 </span><span class="lineCov">          1 :     initializer = new EditorInitializer(this);</span>
<span class="lineNum">     398 </span><span class="lineCov">          1 :     Properties().Set(TextControlInitializer(),initializer);</span>
<span class="lineNum">     399 </span><span class="lineCov">          1 :     nsContentUtils::AddScriptRunner(initializer);</span>
<span class="lineNum">     400 </span>            :   }
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   return NS_OK;
<span class="lineNum">     403 </span>            : }
<a name="404"><span class="lineNum">     404 </span>            : </a>
<span class="lineNum">     405 </span>            : void
<span class="lineNum">     406 </span><span class="lineCov">          1 : nsTextControlFrame::AppendAnonymousContentTo(nsTArray&lt;nsIContent*&gt;&amp; aElements,</span>
<span class="lineNum">     407 </span>            :                                              uint32_t aFilter)
<span class="lineNum">     408 </span>            : {
<span class="lineNum">     409 </span>            :   // This can be called off-main-thread during Servo traversal, so we take care
<span class="lineNum">     410 </span>            :   // to avoid QI-ing the DOM node.
<span class="lineNum">     411 </span><span class="lineCov">          1 :   nsITextControlElement* txtCtrl = nullptr;</span>
<span class="lineNum">     412 </span><span class="lineCov">          1 :   nsIContent* content = GetContent();</span>
<span class="lineNum">     413 </span><span class="lineCov">          1 :   if (content-&gt;IsHTMLElement(nsGkAtoms::input)) {</span>
<span class="lineNum">     414 </span><span class="lineCov">          1 :     txtCtrl = static_cast&lt;HTMLInputElement*&gt;(content);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   } else if (content-&gt;IsHTMLElement(nsGkAtoms::textarea)) {</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     txtCtrl = static_cast&lt;HTMLTextAreaElement*&gt;(content);</span>
<span class="lineNum">     417 </span>            :   } else {
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Unexpected content type for nsTextControlFrame&quot;);</span>
<span class="lineNum">     419 </span>            :   }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineCov">          1 :   nsIContent* root = txtCtrl-&gt;GetRootEditorNode();</span>
<span class="lineNum">     422 </span><span class="lineCov">          1 :   if (root) {</span>
<span class="lineNum">     423 </span><span class="lineCov">          1 :     aElements.AppendElement(root);</span>
<span class="lineNum">     424 </span>            :   }
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineCov">          1 :   nsIContent* placeholder = txtCtrl-&gt;GetPlaceholderNode();</span>
<span class="lineNum">     427 </span><span class="lineCov">          1 :   if (placeholder &amp;&amp; !(aFilter &amp; nsIContent::eSkipPlaceholderContent))</span>
<span class="lineNum">     428 </span><span class="lineCov">          1 :     aElements.AppendElement(placeholder);</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineCov">          1 : }</span>
<a name="431"><span class="lineNum">     431 </span>            : </a>
<span class="lineNum">     432 </span>            : nscoord
<span class="lineNum">     433 </span><span class="lineCov">          1 : nsTextControlFrame::GetPrefISize(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">     434 </span>            : {
<span class="lineNum">     435 </span><span class="lineCov">          1 :   nscoord result = 0;</span>
<span class="lineNum">     436 </span>            :   DISPLAY_PREF_WIDTH(this, result);
<span class="lineNum">     437 </span><span class="lineCov">          1 :   float inflation = nsLayoutUtils::FontSizeInflationFor(this);</span>
<span class="lineNum">     438 </span><span class="lineCov">          1 :   WritingMode wm = GetWritingMode();</span>
<span class="lineNum">     439 </span><span class="lineCov">          1 :   result = CalcIntrinsicSize(aRenderingContext, wm, inflation).ISize(wm);</span>
<span class="lineNum">     440 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">     441 </span>            : }
<a name="442"><span class="lineNum">     442 </span>            : </a>
<span class="lineNum">     443 </span>            : nscoord
<span class="lineNum">     444 </span><span class="lineCov">          1 : nsTextControlFrame::GetMinISize(nsRenderingContext* aRenderingContext)</span>
<span class="lineNum">     445 </span>            : {
<span class="lineNum">     446 </span>            :   // Our min width is just our preferred width if we have auto width.
<span class="lineNum">     447 </span>            :   nscoord result;
<span class="lineNum">     448 </span>            :   DISPLAY_MIN_WIDTH(this, result);
<span class="lineNum">     449 </span><span class="lineCov">          1 :   result = GetPrefISize(aRenderingContext);</span>
<span class="lineNum">     450 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">     451 </span>            : }
<a name="452"><span class="lineNum">     452 </span>            : </a>
<span class="lineNum">     453 </span>            : LogicalSize
<span class="lineNum">     454 </span><span class="lineCov">          1 : nsTextControlFrame::ComputeAutoSize(nsRenderingContext* aRenderingContext,</span>
<span class="lineNum">     455 </span>            :                                     WritingMode         aWM,
<span class="lineNum">     456 </span>            :                                     const LogicalSize&amp;  aCBSize,
<span class="lineNum">     457 </span>            :                                     nscoord             aAvailableISize,
<span class="lineNum">     458 </span>            :                                     const LogicalSize&amp;  aMargin,
<span class="lineNum">     459 </span>            :                                     const LogicalSize&amp;  aBorder,
<span class="lineNum">     460 </span>            :                                     const LogicalSize&amp;  aPadding,
<span class="lineNum">     461 </span>            :                                     ComputeSizeFlags    aFlags)
<span class="lineNum">     462 </span>            : {
<span class="lineNum">     463 </span><span class="lineCov">          1 :   float inflation = nsLayoutUtils::FontSizeInflationFor(this);</span>
<span class="lineNum">     464 </span><span class="lineCov">          1 :   LogicalSize autoSize = CalcIntrinsicSize(aRenderingContext, aWM, inflation);</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   // Note: nsContainerFrame::ComputeAutoSize only computes the inline-size (and
<span class="lineNum">     467 </span>            :   // only for 'auto'), the block-size it returns is always NS_UNCONSTRAINEDSIZE.
<span class="lineNum">     468 </span><span class="lineCov">          1 :   const nsStyleCoord&amp; iSizeCoord = StylePosition()-&gt;ISize(aWM);</span>
<span class="lineNum">     469 </span><span class="lineCov">          1 :   if (iSizeCoord.GetUnit() == eStyleUnit_Auto) {</span>
<span class="lineNum">     470 </span><span class="lineCov">          1 :     if (aFlags &amp; ComputeSizeFlags::eIClampMarginBoxMinSize) {</span>
<span class="lineNum">     471 </span>            :       // CalcIntrinsicSize isn't aware of grid-item margin-box clamping, so we
<span class="lineNum">     472 </span>            :       // fall back to nsContainerFrame's ComputeAutoSize to handle that.
<span class="lineNum">     473 </span>            :       // XXX maybe a font-inflation issue here? (per the assertion below).
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :       autoSize.ISize(aWM) =</span>
<span class="lineNum">     475 </span>            :         nsContainerFrame::ComputeAutoSize(aRenderingContext, aWM,
<span class="lineNum">     476 </span>            :                                           aCBSize, aAvailableISize,
<span class="lineNum">     477 </span>            :                                           aMargin, aBorder,
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                                           aPadding, aFlags).ISize(aWM);</span>
<span class="lineNum">     479 </span>            :     }
<span class="lineNum">     480 </span>            : #ifdef DEBUG
<span class="lineNum">     481 </span>            :     else {
<span class="lineNum">     482 </span>            :       LogicalSize ancestorAutoSize =
<span class="lineNum">     483 </span>            :         nsContainerFrame::ComputeAutoSize(aRenderingContext, aWM,
<span class="lineNum">     484 </span>            :                                           aCBSize, aAvailableISize,
<span class="lineNum">     485 </span>            :                                           aMargin, aBorder,
<span class="lineNum">     486 </span>            :                                           aPadding, aFlags);
<span class="lineNum">     487 </span>            :       // Disabled when there's inflation; see comment in GetXULPrefSize.
<span class="lineNum">     488 </span>            :       MOZ_ASSERT(inflation != 1.0f ||
<span class="lineNum">     489 </span>            :                  ancestorAutoSize.ISize(aWM) == autoSize.ISize(aWM),
<span class="lineNum">     490 </span>            :                  &quot;Incorrect size computed by ComputeAutoSize?&quot;);
<span class="lineNum">     491 </span>            :     }
<span class="lineNum">     492 </span>            : #endif
<span class="lineNum">     493 </span>            :   }
<span class="lineNum">     494 </span><span class="lineCov">          1 :   return autoSize;</span>
<span class="lineNum">     495 </span>            : }
<a name="496"><span class="lineNum">     496 </span>            : </a>
<span class="lineNum">     497 </span>            : void
<span class="lineNum">     498 </span><span class="lineCov">          1 : nsTextControlFrame::Reflow(nsPresContext*   aPresContext,</span>
<span class="lineNum">     499 </span>            :                            ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">     500 </span>            :                            const ReflowInput&amp; aReflowInput,
<span class="lineNum">     501 </span>            :                            nsReflowStatus&amp;          aStatus)
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineCov">          1 :   MarkInReflow();</span>
<span class="lineNum">     504 </span>            :   DO_GLOBAL_REFLOW_COUNT(&quot;nsTextControlFrame&quot;);
<span class="lineNum">     505 </span>            :   DISPLAY_REFLOW(aPresContext, this, aReflowInput, aDesiredSize, aStatus);
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :   // make sure that the form registers itself on the initial/first reflow
<span class="lineNum">     508 </span><span class="lineCov">          1 :   if (mState &amp; NS_FRAME_FIRST_REFLOW) {</span>
<span class="lineNum">     509 </span><span class="lineCov">          1 :     nsFormControlFrame::RegUnRegAccessKey(this, true);</span>
<span class="lineNum">     510 </span>            :   }
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   // set values of reflow's out parameters
<span class="lineNum">     513 </span><span class="lineCov">          1 :   WritingMode wm = aReflowInput.GetWritingMode();</span>
<span class="lineNum">     514 </span>            :   LogicalSize
<span class="lineNum">     515 </span>            :     finalSize(wm,
<span class="lineNum">     516 </span><span class="lineCov">          1 :               aReflowInput.ComputedISize() +</span>
<span class="lineNum">     517 </span><span class="lineCov">          1 :               aReflowInput.ComputedLogicalBorderPadding().IStartEnd(wm),</span>
<span class="lineNum">     518 </span><span class="lineCov">          1 :               aReflowInput.ComputedBSize() +</span>
<span class="lineNum">     519 </span><span class="lineCov">          1 :               aReflowInput.ComputedLogicalBorderPadding().BStartEnd(wm));</span>
<span class="lineNum">     520 </span><span class="lineCov">          1 :   aDesiredSize.SetSize(wm, finalSize);</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :   // Calculate the baseline and store it in mFirstBaseline.
<span class="lineNum">     523 </span><span class="lineCov">          1 :   nscoord lineHeight = aReflowInput.ComputedBSize();</span>
<span class="lineNum">     524 </span><span class="lineCov">          1 :   float inflation = nsLayoutUtils::FontSizeInflationFor(this);</span>
<span class="lineNum">     525 </span><span class="lineCov">          1 :   if (!IsSingleLineTextControl()) {</span>
<span class="lineNum">     526 </span>            :     lineHeight = ReflowInput::CalcLineHeight(GetContent(), StyleContext(),
<span class="lineNum">     527 </span><span class="lineCov">          1 :                                              NS_AUTOHEIGHT, inflation);</span>
<span class="lineNum">     528 </span>            :   }
<span class="lineNum">     529 </span>            :   RefPtr&lt;nsFontMetrics&gt; fontMet =
<span class="lineNum">     530 </span><span class="lineCov">          1 :     nsLayoutUtils::GetFontMetricsForFrame(this, inflation);</span>
<span class="lineNum">     531 </span>            :   mFirstBaseline =
<span class="lineNum">     532 </span>            :     nsLayoutUtils::GetCenteredFontBaseline(fontMet, lineHeight,
<span class="lineNum">     533 </span><span class="lineCov">          1 :                                            wm.IsLineInverted()) +</span>
<span class="lineNum">     534 </span><span class="lineCov">          1 :     aReflowInput.ComputedLogicalBorderPadding().BStart(wm);</span>
<span class="lineNum">     535 </span><span class="lineCov">          1 :   aDesiredSize.SetBlockStartAscent(mFirstBaseline);</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :   // overflow handling
<span class="lineNum">     538 </span><span class="lineCov">          1 :   aDesiredSize.SetOverflowAreasToDesiredBounds();</span>
<span class="lineNum">     539 </span>            :   // perform reflow on all kids
<span class="lineNum">     540 </span><span class="lineCov">          1 :   nsIFrame* kid = mFrames.FirstChild();</span>
<span class="lineNum">     541 </span><span class="lineCov">          1 :   while (kid) {</span>
<span class="lineNum">     542 </span><span class="lineCov">          1 :     ReflowTextControlChild(kid, aPresContext, aReflowInput, aStatus, aDesiredSize);</span>
<span class="lineNum">     543 </span><span class="lineCov">          1 :     kid = kid-&gt;GetNextSibling();</span>
<span class="lineNum">     544 </span>            :   }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   // take into account css properties that affect overflow handling
<span class="lineNum">     547 </span><span class="lineCov">          1 :   FinishAndStoreOverflow(&amp;aDesiredSize);</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">          1 :   aStatus.Reset();</span>
<span class="lineNum">     550 </span><span class="lineCov">          1 :   NS_FRAME_SET_TRUNCATION(aStatus, aReflowInput, aDesiredSize);</span>
<span class="lineNum">     551 </span><span class="lineCov">          1 : }</span>
<a name="552"><span class="lineNum">     552 </span>            : </a>
<span class="lineNum">     553 </span>            : void
<span class="lineNum">     554 </span><span class="lineCov">          1 : nsTextControlFrame::ReflowTextControlChild(nsIFrame*                aKid,</span>
<span class="lineNum">     555 </span>            :                                            nsPresContext*           aPresContext,
<span class="lineNum">     556 </span>            :                                            const ReflowInput&amp; aReflowInput,
<span class="lineNum">     557 </span>            :                                            nsReflowStatus&amp;          aStatus,
<span class="lineNum">     558 </span>            :                                            ReflowOutput&amp; aParentDesiredSize)
<span class="lineNum">     559 </span>            : {
<span class="lineNum">     560 </span>            :   // compute available size and frame offsets for child
<span class="lineNum">     561 </span><span class="lineCov">          1 :   WritingMode wm = aKid-&gt;GetWritingMode();</span>
<span class="lineNum">     562 </span><span class="lineCov">          1 :   LogicalSize availSize = aReflowInput.ComputedSizeWithPadding(wm);</span>
<span class="lineNum">     563 </span><span class="lineCov">          1 :   availSize.BSize(wm) = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :   ReflowInput kidReflowInput(aPresContext, aReflowInput, 
<span class="lineNum">     566 </span>            :                                    aKid, availSize, nullptr,
<span class="lineNum">     567 </span><span class="lineCov">          1 :                                    ReflowInput::CALLER_WILL_INIT);</span>
<span class="lineNum">     568 </span>            :   // Override padding with our computed padding in case we got it from theming or percentage
<span class="lineNum">     569 </span><span class="lineCov">          1 :   kidReflowInput.Init(aPresContext, nullptr, nullptr, &amp;aReflowInput.ComputedPhysicalPadding());</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :   // Set computed width and computed height for the child
<span class="lineNum">     572 </span><span class="lineCov">          1 :   kidReflowInput.SetComputedWidth(aReflowInput.ComputedWidth());</span>
<span class="lineNum">     573 </span><span class="lineCov">          1 :   kidReflowInput.SetComputedHeight(aReflowInput.ComputedHeight());</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :   // Offset the frame by the size of the parent's border
<span class="lineNum">     576 </span><span class="lineCov">          1 :   nscoord xOffset = aReflowInput.ComputedPhysicalBorderPadding().left -</span>
<span class="lineNum">     577 </span><span class="lineCov">          1 :                     aReflowInput.ComputedPhysicalPadding().left;</span>
<span class="lineNum">     578 </span><span class="lineCov">          1 :   nscoord yOffset = aReflowInput.ComputedPhysicalBorderPadding().top -</span>
<span class="lineNum">     579 </span><span class="lineCov">          1 :                     aReflowInput.ComputedPhysicalPadding().top;</span>
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            :   // reflow the child
<span class="lineNum">     582 </span><span class="lineCov">          1 :   ReflowOutput desiredSize(aReflowInput);</span>
<span class="lineNum">     583 </span>            :   ReflowChild(aKid, aPresContext, desiredSize, kidReflowInput, 
<span class="lineNum">     584 </span><span class="lineCov">          1 :               xOffset, yOffset, 0, aStatus);</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :   // place the child
<span class="lineNum">     587 </span>            :   FinishReflowChild(aKid, aPresContext, desiredSize,
<span class="lineNum">     588 </span><span class="lineCov">          1 :                     &amp;kidReflowInput, xOffset, yOffset, 0);</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   // consider the overflow
<span class="lineNum">     591 </span><span class="lineCov">          1 :   aParentDesiredSize.mOverflowAreas.UnionWith(desiredSize.mOverflowAreas);</span>
<span class="lineNum">     592 </span><span class="lineCov">          1 : }</span>
<a name="593"><span class="lineNum">     593 </span>            : </a>
<span class="lineNum">     594 </span>            : nsSize
<span class="lineNum">     595 </span><span class="lineCov">          1 : nsTextControlFrame::GetXULMinSize(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">     596 </span>            : {
<span class="lineNum">     597 </span>            :   // XXXbz why?  Why not the nsBoxFrame sizes?
<span class="lineNum">     598 </span><span class="lineCov">          1 :   return nsBox::GetXULMinSize(aState);</span>
<span class="lineNum">     599 </span>            : }
<a name="600"><span class="lineNum">     600 </span>            : </a>
<span class="lineNum">     601 </span>            : bool
<span class="lineNum">     602 </span><span class="lineCov">          1 : nsTextControlFrame::IsXULCollapsed()</span>
<span class="lineNum">     603 </span>            : {
<span class="lineNum">     604 </span>            :   // We're never collapsed in the box sense.
<span class="lineNum">     605 </span><span class="lineCov">          1 :   return false;</span>
<span class="lineNum">     606 </span>            : }
<a name="607"><span class="lineNum">     607 </span>            : </a>
<span class="lineNum">     608 </span>            : bool
<span class="lineNum">     609 </span><span class="lineCov">          1 : nsTextControlFrame::IsLeaf() const</span>
<span class="lineNum">     610 </span>            : {
<span class="lineNum">     611 </span><span class="lineCov">          1 :   return true;</span>
<span class="lineNum">     612 </span>            : }
<a name="613"><span class="lineNum">     613 </span>            : </a>
<span class="lineNum">     614 </span>            : NS_IMETHODIMP
<span class="lineNum">     615 </span><span class="lineCov">          1 : nsTextControlFrame::ScrollOnFocusEvent::Run()</span>
<span class="lineNum">     616 </span>            : {
<span class="lineNum">     617 </span><span class="lineCov">          1 :   if (mFrame) {</span>
<span class="lineNum">     618 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(mFrame-&gt;GetContent());</span>
<span class="lineNum">     619 </span>            :     NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     620 </span><span class="lineCov">          1 :     nsISelectionController* selCon = txtCtrl-&gt;GetSelectionController();</span>
<span class="lineNum">     621 </span><span class="lineCov">          1 :     if (selCon) {</span>
<span class="lineNum">     622 </span><span class="lineCov">          1 :       mFrame-&gt;mScrollEvent.Forget();</span>
<span class="lineNum">     623 </span>            :       selCon-&gt;ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
<span class="lineNum">     624 </span>            :                                       nsISelectionController::SELECTION_FOCUS_REGION,
<span class="lineNum">     625 </span><span class="lineCov">          1 :                                       nsISelectionController::SCROLL_SYNCHRONOUS);</span>
<span class="lineNum">     626 </span>            :     }
<span class="lineNum">     627 </span>            :   }
<span class="lineNum">     628 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     629 </span>            : }
<a name="630"><span class="lineNum">     630 </span>            : </a>
<span class="lineNum">     631 </span>            : //IMPLEMENTING NS_IFORMCONTROLFRAME
<span class="lineNum">     632 </span><span class="lineCov">          1 : void nsTextControlFrame::SetFocus(bool aOn, bool aRepaint)</span>
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     635 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :   // Revoke the previous scroll event if one exists
<span class="lineNum">     638 </span><span class="lineCov">          1 :   mScrollEvent.Revoke();</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :   // If 'dom.placeholeder.show_on_focus' preference is 'false', focusing or
<span class="lineNum">     641 </span>            :   // blurring the frame can have an impact on the placeholder visibility.
<span class="lineNum">     642 </span><span class="lineCov">          1 :   if (mUsePlaceholder) {</span>
<span class="lineNum">     643 </span><span class="lineCov">          1 :     txtCtrl-&gt;UpdatePlaceholderVisibility(true);</span>
<span class="lineNum">     644 </span>            :   }
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineCov">          1 :   if (!aOn) {</span>
<span class="lineNum">     647 </span>            :     return;
<span class="lineNum">     648 </span>            :   }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineCov">          1 :   nsISelectionController* selCon = txtCtrl-&gt;GetSelectionController();</span>
<span class="lineNum">     651 </span><span class="lineCov">          1 :   if (!selCon)</span>
<span class="lineNum">     652 </span>            :     return;
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :   nsCOMPtr&lt;nsISelection&gt; ourSel;
<span class="lineNum">     655 </span>            :   selCon-&gt;GetSelection(nsISelectionController::SELECTION_NORMAL, 
<span class="lineNum">     656 </span><span class="lineCov">          1 :     getter_AddRefs(ourSel));</span>
<span class="lineNum">     657 </span><span class="lineCov">          1 :   if (!ourSel) return;</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span><span class="lineCov">          1 :   nsIPresShell* presShell = PresContext()-&gt;GetPresShell();</span>
<span class="lineNum">     660 </span><span class="lineCov">          1 :   RefPtr&lt;nsCaret&gt; caret = presShell-&gt;GetCaret();</span>
<span class="lineNum">     661 </span><span class="lineCov">          1 :   if (!caret) return;</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            :   // Scroll the current selection into view
<span class="lineNum">     664 </span><span class="lineCov">          1 :   nsISelection *caretSelection = caret-&gt;GetSelection();</span>
<span class="lineNum">     665 </span><span class="lineCov">          1 :   const bool isFocusedRightNow = ourSel == caretSelection;</span>
<span class="lineNum">     666 </span><span class="lineCov">          1 :   if (!isFocusedRightNow) {</span>
<span class="lineNum">     667 </span>            :     // Don't scroll the current selection if we've been focused using the mouse.
<span class="lineNum">     668 </span><span class="lineCov">          1 :     uint32_t lastFocusMethod = 0;</span>
<span class="lineNum">     669 </span><span class="lineCov">          1 :     nsIDocument* doc = GetContent()-&gt;GetComposedDoc();</span>
<span class="lineNum">     670 </span><span class="lineCov">          1 :     if (doc) {</span>
<span class="lineNum">     671 </span><span class="lineCov">          1 :       nsIFocusManager* fm = nsFocusManager::GetFocusManager();</span>
<span class="lineNum">     672 </span><span class="lineCov">          1 :       if (fm) {</span>
<span class="lineNum">     673 </span><span class="lineCov">          1 :         fm-&gt;GetLastFocusMethod(doc-&gt;GetWindow(), &amp;lastFocusMethod);</span>
<span class="lineNum">     674 </span>            :       }
<span class="lineNum">     675 </span>            :     }
<span class="lineNum">     676 </span><span class="lineCov">          1 :     if (!(lastFocusMethod &amp; nsIFocusManager::FLAG_BYMOUSE)) {</span>
<span class="lineNum">     677 </span><span class="lineCov">          1 :       RefPtr&lt;ScrollOnFocusEvent&gt; event = new ScrollOnFocusEvent(this);</span>
<span class="lineNum">     678 </span><span class="lineCov">          1 :       nsresult rv = mContent-&gt;OwnerDoc()-&gt;Dispatch(&quot;ScrollOnFocusEvent&quot;,</span>
<span class="lineNum">     679 </span>            :                                                    TaskCategory::Other,
<span class="lineNum">     680 </span><span class="lineCov">          1 :                                                    do_AddRef(event));</span>
<span class="lineNum">     681 </span><span class="lineCov">          1 :       if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     682 </span><span class="lineCov">          1 :         mScrollEvent = event;</span>
<span class="lineNum">     683 </span><span class="lineCov">          1 :       }</span>
<span class="lineNum">     684 </span>            :     }
<span class="lineNum">     685 </span>            :   }
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :   // tell the caret to use our selection
<span class="lineNum">     688 </span><span class="lineCov">          1 :   caret-&gt;SetSelection(ourSel);</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :   // mutual-exclusion: the selection is either controlled by the
<span class="lineNum">     691 </span>            :   // document or by the text input/area. Clear any selection in the
<span class="lineNum">     692 </span>            :   // document since the focus is now on our independent selection.
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsISelectionController&gt; selcon = do_QueryInterface(presShell);</span>
<span class="lineNum">     695 </span>            :   nsCOMPtr&lt;nsISelection&gt; docSel;
<span class="lineNum">     696 </span>            :   selcon-&gt;GetSelection(nsISelectionController::SELECTION_NORMAL,
<span class="lineNum">     697 </span><span class="lineCov">          1 :     getter_AddRefs(docSel));</span>
<span class="lineNum">     698 </span><span class="lineCov">          1 :   if (!docSel) return;</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineCov">          1 :   bool isCollapsed = false;</span>
<span class="lineNum">     701 </span><span class="lineCov">          1 :   docSel-&gt;GetIsCollapsed(&amp;isCollapsed);</span>
<span class="lineNum">     702 </span><span class="lineCov">          1 :   if (!isCollapsed)</span>
<span class="lineNum">     703 </span><span class="lineCov">          1 :     docSel-&gt;RemoveAllRanges();</span>
<a name="704"><span class="lineNum">     704 </span>            : }</a>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineCov">          1 : nsresult nsTextControlFrame::SetFormProperty(nsIAtom* aName, const nsAString&amp; aValue)</span>
<span class="lineNum">     707 </span>            : {
<span class="lineNum">     708 </span><span class="lineCov">          1 :   if (!mIsProcessing)//some kind of lock.</span>
<span class="lineNum">     709 </span>            :   {
<span class="lineNum">     710 </span><span class="lineCov">          1 :     mIsProcessing = true;</span>
<span class="lineNum">     711 </span><span class="lineCov">          1 :     if (nsGkAtoms::select == aName)</span>
<span class="lineNum">     712 </span>            :     {
<span class="lineNum">     713 </span>            :       // Select all the text.
<span class="lineNum">     714 </span>            :       //
<span class="lineNum">     715 </span>            :       // XXX: This is lame, we can't call editor's SelectAll method
<span class="lineNum">     716 </span>            :       //      because that triggers AutoCopies in unix builds.
<span class="lineNum">     717 </span>            :       //      Instead, we have to call our own homegrown version
<span class="lineNum">     718 </span>            :       //      of select all which merely builds a range that selects
<span class="lineNum">     719 </span>            :       //      all of the content and adds that to the selection.
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineCov">          1 :       AutoWeakFrame weakThis = this;</span>
<span class="lineNum">     722 </span><span class="lineCov">          1 :       SelectAllOrCollapseToEndOfText(true);  // NOTE: can destroy the world</span>
<span class="lineNum">     723 </span><span class="lineCov">          1 :       if (!weakThis.IsAlive()) {</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">     725 </span><span class="lineCov">          1 :       }</span>
<span class="lineNum">     726 </span>            :     }
<span class="lineNum">     727 </span><span class="lineCov">          1 :     mIsProcessing = false;</span>
<span class="lineNum">     728 </span>            :   }
<span class="lineNum">     729 </span>            :   return NS_OK;
<span class="lineNum">     730 </span>            : }
<a name="731"><span class="lineNum">     731 </span>            : </a>
<span class="lineNum">     732 </span>            : NS_IMETHODIMP
<span class="lineNum">     733 </span><span class="lineCov">          1 : nsTextControlFrame::GetEditor(nsIEditor **aEditor)</span>
<span class="lineNum">     734 </span>            : {
<span class="lineNum">     735 </span><span class="lineCov">          1 :   NS_ENSURE_ARG_POINTER(aEditor);</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">          1 :   nsresult rv = EnsureEditorInitialized();</span>
<span class="lineNum">     738 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     741 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     742 </span>            :   *aEditor = txtCtrl-&gt;GetTextEditor();
<span class="lineNum">     743 </span><span class="lineCov">          1 :   NS_IF_ADDREF(*aEditor);</span>
<span class="lineNum">     744 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     745 </span>            : }
<a name="746"><span class="lineNum">     746 </span>            : </a>
<span class="lineNum">     747 </span>            : nsresult
<span class="lineNum">     748 </span><span class="lineCov">          1 : nsTextControlFrame::SetSelectionInternal(nsIDOMNode *aStartNode,</span>
<span class="lineNum">     749 </span>            :                                          uint32_t aStartOffset,
<span class="lineNum">     750 </span>            :                                          nsIDOMNode *aEndNode,
<span class="lineNum">     751 </span>            :                                          uint32_t aEndOffset,
<span class="lineNum">     752 </span>            :                                          nsITextControlFrame::SelectionDirection aDirection)
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span>            :   // Create a new range to represent the new selection.
<span class="lineNum">     755 </span>            :   // Note that we use a new range to avoid having to do
<span class="lineNum">     756 </span>            :   // isIncreasing checks to avoid possible errors.
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineCov">          1 :   RefPtr&lt;nsRange&gt; range = new nsRange(mContent);</span>
<span class="lineNum">     759 </span>            :   // Be careful to use internal nsRange methods which do not check to make sure
<span class="lineNum">     760 </span>            :   // we have access to the node.
<span class="lineNum">     761 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsINode&gt; start = do_QueryInterface(aStartNode);</span>
<span class="lineNum">     762 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsINode&gt; end = do_QueryInterface(aEndNode);</span>
<span class="lineNum">     763 </span>            :   // XXXbz nsRange::Set takes int32_t (and ranges generally work on int32_t),
<span class="lineNum">     764 </span>            :   // but we're passing uint32_t.  The good news is that at this point our
<span class="lineNum">     765 </span>            :   // endpoints should really be within our length, so not really that big.  And
<span class="lineNum">     766 </span>            :   // if they _are_ that big, Set() will simply error out, which is not too bad
<span class="lineNum">     767 </span>            :   // for a case we don't expect to happen.
<span class="lineNum">     768 </span><span class="lineCov">          1 :   nsresult rv = range-&gt;Set(start, aStartOffset, end, aEndOffset);</span>
<span class="lineNum">     769 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :   // Get the selection, clear it and add the new range to it!
<span class="lineNum">     772 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     773 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     774 </span><span class="lineCov">          1 :   nsISelectionController* selCon = txtCtrl-&gt;GetSelectionController();</span>
<span class="lineNum">     775 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :   nsCOMPtr&lt;nsISelection&gt; selection;
<span class="lineNum">     778 </span><span class="lineCov">          1 :   selCon-&gt;GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  </span>
<span class="lineNum">     779 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsISelectionPrivate&gt; selPriv = do_QueryInterface(selection, &amp;rv);</span>
<span class="lineNum">     782 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :   nsDirection direction;
<span class="lineNum">     785 </span><span class="lineCov">          1 :   if (aDirection == eNone) {</span>
<span class="lineNum">     786 </span>            :     // Preserve the direction
<span class="lineNum">     787 </span><span class="lineCov">          1 :     direction = selPriv-&gt;GetSelectionDirection();</span>
<span class="lineNum">     788 </span>            :   } else {
<span class="lineNum">     789 </span><span class="lineCov">          1 :     direction = (aDirection == eBackward) ? eDirPrevious : eDirNext;</span>
<span class="lineNum">     790 </span>            :   }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">          1 :   rv = selection-&gt;RemoveAllRanges();</span>
<span class="lineNum">     793 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineCov">          1 :   rv = selection-&gt;AddRange(range);  // NOTE: can destroy the world</span>
<span class="lineNum">     796 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineCov">          1 :   selPriv-&gt;SetSelectionDirection(direction);</span>
<span class="lineNum">     799 </span><span class="lineCov">          1 :   return rv;</span>
<span class="lineNum">     800 </span>            : }
<a name="801"><span class="lineNum">     801 </span>            : </a>
<span class="lineNum">     802 </span>            : nsresult
<span class="lineNum">     803 </span><span class="lineCov">          1 : nsTextControlFrame::ScrollSelectionIntoView()</span>
<span class="lineNum">     804 </span>            : {
<span class="lineNum">     805 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     806 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     807 </span><span class="lineCov">          1 :   nsISelectionController* selCon = txtCtrl-&gt;GetSelectionController();</span>
<span class="lineNum">     808 </span><span class="lineCov">          1 :   if (selCon) {</span>
<span class="lineNum">     809 </span>            :     // Scroll the selection into view (see bug 231389).
<span class="lineNum">     810 </span>            :     return selCon-&gt;ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
<span class="lineNum">     811 </span>            :                                            nsISelectionController::SELECTION_FOCUS_REGION,
<span class="lineNum">     812 </span><span class="lineCov">          1 :                                            nsISelectionController::SCROLL_FIRST_ANCESTOR_ONLY);</span>
<span class="lineNum">     813 </span>            :   }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :   return NS_ERROR_FAILURE;
<span class="lineNum">     816 </span>            : }
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : nsresult
<span class="lineNum">     819 </span><span class="lineCov">          1 : nsTextControlFrame::GetRootNodeAndInitializeEditor(nsIDOMElement **aRootElement)</span>
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span><span class="lineCov">          1 :   NS_ENSURE_ARG_POINTER(aRootElement);</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :   nsCOMPtr&lt;nsIEditor&gt; editor;
<span class="lineNum">     824 </span><span class="lineCov">          1 :   GetEditor(getter_AddRefs(editor));</span>
<span class="lineNum">     825 </span><span class="lineCov">          1 :   if (!editor)</span>
<span class="lineNum">     826 </span>            :     return NS_OK;
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineCov">          1 :   return editor-&gt;GetRootElement(aRootElement);</span>
<span class="lineNum">     829 </span>            : }
<a name="830"><span class="lineNum">     830 </span>            : </a>
<span class="lineNum">     831 </span>            : nsresult
<span class="lineNum">     832 </span><span class="lineCov">          1 : nsTextControlFrame::SelectAllOrCollapseToEndOfText(bool aSelect)</span>
<span class="lineNum">     833 </span>            : {
<span class="lineNum">     834 </span>            :   nsCOMPtr&lt;nsIDOMElement&gt; rootElement;
<span class="lineNum">     835 </span><span class="lineCov">          1 :   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));</span>
<span class="lineNum">     836 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIContent&gt; rootContent = do_QueryInterface(rootElement);</span>
<span class="lineNum">     839 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDOMNode&gt; rootNode(do_QueryInterface(rootElement));</span>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(rootNode &amp;&amp; rootContent, NS_ERROR_FAILURE);</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span><span class="lineCov">          1 :   int32_t numChildren = rootContent-&gt;GetChildCount();</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineCov">          1 :   if (numChildren &gt; 0) {</span>
<span class="lineNum">     846 </span>            :     // We never want to place the selection after the last
<span class="lineNum">     847 </span>            :     // br under the root node!
<span class="lineNum">     848 </span><span class="lineCov">          1 :     nsIContent *child = rootContent-&gt;GetChildAt(numChildren - 1);</span>
<span class="lineNum">     849 </span><span class="lineCov">          1 :     if (child) {</span>
<span class="lineNum">     850 </span><span class="lineCov">          1 :       if (child-&gt;IsHTMLElement(nsGkAtoms::br))</span>
<span class="lineNum">     851 </span><span class="lineCov">          1 :         --numChildren;</span>
<span class="lineNum">     852 </span>            :     }
<span class="lineNum">     853 </span><span class="lineCov">          1 :     if (!aSelect &amp;&amp; numChildren) {</span>
<span class="lineNum">     854 </span><span class="lineCov">          1 :       child = rootContent-&gt;GetChildAt(numChildren - 1);</span>
<span class="lineNum">     855 </span><span class="lineCov">          1 :       if (child &amp;&amp; child-&gt;IsNodeOfType(nsINode::eTEXT)) {</span>
<span class="lineNum">     856 </span><span class="lineCov">          1 :         rootNode = do_QueryInterface(child);</span>
<span class="lineNum">     857 </span><span class="lineCov">          1 :         const nsTextFragment* fragment = child-&gt;GetText();</span>
<span class="lineNum">     858 </span><span class="lineCov">          1 :         numChildren = fragment ? fragment-&gt;GetLength() : 0;</span>
<span class="lineNum">     859 </span>            :       }
<span class="lineNum">     860 </span>            :     }
<span class="lineNum">     861 </span>            :   }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            :   rv = SetSelectionInternal(rootNode, aSelect ? 0 : numChildren,
<span class="lineNum">     864 </span><span class="lineCov">          1 :                             rootNode, numChildren);</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineCov">          1 :   return ScrollSelectionIntoView();</span>
<span class="lineNum">     868 </span>            : }
<a name="869"><span class="lineNum">     869 </span>            : </a>
<span class="lineNum">     870 </span>            : nsresult
<span class="lineNum">     871 </span><span class="lineCov">          1 : nsTextControlFrame::SetSelectionEndPoints(uint32_t aSelStart, uint32_t aSelEnd,</span>
<span class="lineNum">     872 </span>            :                                           nsITextControlFrame::SelectionDirection aDirection)
<span class="lineNum">     873 </span>            : {
<span class="lineNum">     874 </span>            :   NS_ASSERTION(aSelStart &lt;= aSelEnd, &quot;Invalid selection offsets!&quot;);
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineCov">          1 :   if (aSelStart &gt; aSelEnd)</span>
<span class="lineNum">     877 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            :   nsCOMPtr&lt;nsIDOMNode&gt; startNode, endNode;
<span class="lineNum">     880 </span>            :   uint32_t startOffset, endOffset;
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            :   // Calculate the selection start point.
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">          1 :   nsresult rv = OffsetToDOMPoint(aSelStart, getter_AddRefs(startNode), &amp;startOffset);</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineCov">          1 :   if (aSelStart == aSelEnd) {</span>
<span class="lineNum">     889 </span>            :     // Collapsed selection, so start and end are the same!
<span class="lineNum">     890 </span><span class="lineCov">          1 :     endNode   = startNode;</span>
<span class="lineNum">     891 </span><span class="lineCov">          1 :     endOffset = startOffset;</span>
<span class="lineNum">     892 </span>            :   }
<span class="lineNum">     893 </span>            :   else {
<span class="lineNum">     894 </span>            :     // Selection isn't collapsed so we have to calculate
<span class="lineNum">     895 </span>            :     // the end point too.
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineCov">          1 :     rv = OffsetToDOMPoint(aSelEnd, getter_AddRefs(endNode), &amp;endOffset);</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     900 </span>            :   }
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineCov">          1 :   return SetSelectionInternal(startNode, startOffset, endNode, endOffset, aDirection);</span>
<span class="lineNum">     903 </span>            : }
<a name="904"><span class="lineNum">     904 </span>            : </a>
<span class="lineNum">     905 </span>            : NS_IMETHODIMP
<span class="lineNum">     906 </span><span class="lineCov">          1 : nsTextControlFrame::SetSelectionRange(uint32_t aSelStart, uint32_t aSelEnd,</span>
<span class="lineNum">     907 </span>            :                                       nsITextControlFrame::SelectionDirection aDirection)
<span class="lineNum">     908 </span>            : {
<span class="lineNum">     909 </span><span class="lineCov">          1 :   nsresult rv = EnsureEditorInitialized();</span>
<span class="lineNum">     910 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span><span class="lineCov">          1 :   if (aSelStart &gt; aSelEnd) {</span>
<span class="lineNum">     913 </span>            :     // Simulate what we'd see SetSelectionStart() was called, followed
<span class="lineNum">     914 </span>            :     // by a SetSelectionEnd().
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     aSelStart   = aSelEnd;</span>
<span class="lineNum">     917 </span>            :   }
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineCov">          1 :   return SetSelectionEndPoints(aSelStart, aSelEnd, aDirection);</span>
<span class="lineNum">     920 </span>            : }
<span class="lineNum">     921 </span>            : 
<a name="922"><span class="lineNum">     922 </span>            : </a>
<span class="lineNum">     923 </span>            : nsresult
<span class="lineNum">     924 </span><span class="lineCov">          1 : nsTextControlFrame::OffsetToDOMPoint(uint32_t aOffset,</span>
<span class="lineNum">     925 </span>            :                                      nsIDOMNode** aResult,
<span class="lineNum">     926 </span>            :                                      uint32_t* aPosition)
<span class="lineNum">     927 </span>            : {
<span class="lineNum">     928 </span><span class="lineCov">          1 :   NS_ENSURE_ARG_POINTER(aResult &amp;&amp; aPosition);</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span><span class="lineCov">          1 :   *aResult = nullptr;</span>
<span class="lineNum">     931 </span><span class="lineCov">          1 :   *aPosition = 0;</span>
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            :   nsCOMPtr&lt;nsIDOMElement&gt; rootElement;
<span class="lineNum">     934 </span><span class="lineCov">          1 :   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));</span>
<span class="lineNum">     935 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     936 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDOMNode&gt; rootNode(do_QueryInterface(rootElement));</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :   nsCOMPtr&lt;nsIDOMNodeList&gt; nodeList;
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineCov">          1 :   rv = rootNode-&gt;GetChildNodes(getter_AddRefs(nodeList));</span>
<span class="lineNum">     943 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     944 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">          1 :   uint32_t length = 0;</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineCov">          1 :   rv = nodeList-&gt;GetLength(&amp;length);</span>
<span class="lineNum">     949 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :   NS_ASSERTION(length &lt;= 2, &quot;We should have one text node and one mozBR at most&quot;);
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :   nsCOMPtr&lt;nsIDOMNode&gt; firstNode;
<span class="lineNum">     954 </span><span class="lineCov">          1 :   rv = nodeList-&gt;Item(0, getter_AddRefs(firstNode));</span>
<span class="lineNum">     955 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     956 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDOMText&gt; textNode = do_QueryInterface(firstNode);</span>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineCov">          1 :   if (length == 0) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     NS_IF_ADDREF(*aResult = rootNode);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     *aPosition = 0;</span>
<span class="lineNum">     961 </span><span class="lineCov">          1 :   } else if (textNode) {</span>
<span class="lineNum">     962 </span><span class="lineCov">          1 :     uint32_t textLength = 0;</span>
<span class="lineNum">     963 </span><span class="lineCov">          1 :     textNode-&gt;GetLength(&amp;textLength);</span>
<span class="lineNum">     964 </span><span class="lineCov">          1 :     if (length == 2 &amp;&amp; aOffset == textLength) {</span>
<span class="lineNum">     965 </span>            :       // If we're at the end of the text node and we have a trailing BR node,
<span class="lineNum">     966 </span>            :       // set the selection on the BR node.
<span class="lineNum">     967 </span><span class="lineCov">          1 :       NS_IF_ADDREF(*aResult = rootNode);</span>
<span class="lineNum">     968 </span><span class="lineCov">          1 :       *aPosition = 1;</span>
<span class="lineNum">     969 </span>            :     } else {
<span class="lineNum">     970 </span>            :       // Otherwise, set the selection on the textnode itself.
<span class="lineNum">     971 </span><span class="lineCov">          1 :       NS_IF_ADDREF(*aResult = firstNode);</span>
<span class="lineNum">     972 </span><span class="lineCov">          1 :       *aPosition = std::min(aOffset, textLength);</span>
<span class="lineNum">     973 </span>            :     }
<span class="lineNum">     974 </span>            :   } else {
<span class="lineNum">     975 </span><span class="lineCov">          1 :     NS_IF_ADDREF(*aResult = rootNode);</span>
<span class="lineNum">     976 </span><span class="lineCov">          1 :     *aPosition = 0;</span>
<span class="lineNum">     977 </span>            :   }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     980 </span>            : }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            : /////END INTERFACE IMPLEMENTATIONS
<span class="lineNum">     983 </span>            : 
<a name="984"><span class="lineNum">     984 </span>            : ////NSIFRAME</a>
<span class="lineNum">     985 </span>            : nsresult
<span class="lineNum">     986 </span><span class="lineCov">          1 : nsTextControlFrame::AttributeChanged(int32_t         aNameSpaceID,</span>
<span class="lineNum">     987 </span>            :                                      nsIAtom*        aAttribute,
<span class="lineNum">     988 </span>            :                                      int32_t         aModType)
<span class="lineNum">     989 </span>            : {
<span class="lineNum">     990 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">     991 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">     992 </span><span class="lineCov">          1 :   nsISelectionController* selCon = txtCtrl-&gt;GetSelectionController();</span>
<span class="lineNum">     993 </span><span class="lineCov">          1 :   const bool needEditor = nsGkAtoms::maxlength == aAttribute ||</span>
<span class="lineNum">     994 </span><span class="lineCov">          1 :                             nsGkAtoms::readonly == aAttribute ||</span>
<span class="lineNum">     995 </span><span class="lineCov">          1 :                             nsGkAtoms::disabled == aAttribute ||</span>
<span class="lineNum">     996 </span><span class="lineCov">          1 :                             nsGkAtoms::spellcheck == aAttribute;</span>
<span class="lineNum">     997 </span>            :   nsCOMPtr&lt;nsIEditor&gt; editor;
<span class="lineNum">     998 </span><span class="lineCov">          1 :   if (needEditor) {</span>
<span class="lineNum">     999 </span><span class="lineCov">          1 :     GetEditor(getter_AddRefs(editor));</span>
<span class="lineNum">    1000 </span>            :   }
<span class="lineNum">    1001 </span><span class="lineCov">          1 :   if ((needEditor &amp;&amp; !editor) || !selCon) {</span>
<span class="lineNum">    1002 </span><span class="lineCov">          1 :     return nsContainerFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);</span>
<span class="lineNum">    1003 </span>            :   }
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineCov">          1 :   if (nsGkAtoms::maxlength == aAttribute) {</span>
<span class="lineNum">    1006 </span>            :     int32_t maxLength;
<span class="lineNum">    1007 </span><span class="lineCov">          1 :     bool maxDefined = GetMaxLength(&amp;maxLength);</span>
<span class="lineNum">    1008 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsIPlaintextEditor&gt; textEditor = do_QueryInterface(editor);</span>
<span class="lineNum">    1009 </span><span class="lineCov">          1 :     if (textEditor) {</span>
<span class="lineNum">    1010 </span><span class="lineCov">          1 :       if (maxDefined) { // set the maxLength attribute</span>
<span class="lineNum">    1011 </span><span class="lineCov">          1 :         textEditor-&gt;SetMaxTextLength(maxLength);</span>
<span class="lineNum">    1012 </span>            :         // if maxLength&gt;docLength, we need to truncate the doc content
<span class="lineNum">    1013 </span>            :       } else { // unset the maxLength attribute
<span class="lineNum">    1014 </span><span class="lineCov">          1 :         textEditor-&gt;SetMaxTextLength(-1);</span>
<span class="lineNum">    1015 </span>            :       }
<span class="lineNum">    1016 </span>            :     }
<span class="lineNum">    1017 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">    1018 </span>            :   }
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineCov">          1 :   if (nsGkAtoms::readonly == aAttribute) {</span>
<span class="lineNum">    1021 </span>            :     uint32_t flags;
<span class="lineNum">    1022 </span><span class="lineCov">          1 :     editor-&gt;GetFlags(&amp;flags);</span>
<span class="lineNum">    1023 </span><span class="lineCov">          1 :     if (AttributeExists(nsGkAtoms::readonly)) { // set readonly</span>
<span class="lineNum">    1024 </span><span class="lineCov">          1 :       flags |= nsIPlaintextEditor::eEditorReadonlyMask;</span>
<span class="lineNum">    1025 </span><span class="lineCov">          1 :       if (nsContentUtils::IsFocusedContent(mContent)) {</span>
<span class="lineNum">    1026 </span><span class="lineCov">          1 :         selCon-&gt;SetCaretEnabled(false);</span>
<span class="lineNum">    1027 </span>            :       }
<span class="lineNum">    1028 </span>            :     } else { // unset readonly
<span class="lineNum">    1029 </span><span class="lineCov">          1 :       flags &amp;= ~(nsIPlaintextEditor::eEditorReadonlyMask);</span>
<span class="lineNum">    1030 </span><span class="lineCov">          1 :       if (!(flags &amp; nsIPlaintextEditor::eEditorDisabledMask) &amp;&amp;</span>
<span class="lineNum">    1031 </span><span class="lineCov">          1 :           nsContentUtils::IsFocusedContent(mContent)) {</span>
<span class="lineNum">    1032 </span><span class="lineCov">          1 :         selCon-&gt;SetCaretEnabled(true);</span>
<span class="lineNum">    1033 </span>            :       }
<span class="lineNum">    1034 </span>            :     }
<span class="lineNum">    1035 </span><span class="lineCov">          1 :     editor-&gt;SetFlags(flags);</span>
<span class="lineNum">    1036 </span>            :     return NS_OK;
<span class="lineNum">    1037 </span>            :   }
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineCov">          1 :   if (nsGkAtoms::disabled == aAttribute) {</span>
<span class="lineNum">    1040 </span>            :     uint32_t flags;
<span class="lineNum">    1041 </span><span class="lineCov">          1 :     editor-&gt;GetFlags(&amp;flags);</span>
<span class="lineNum">    1042 </span><span class="lineCov">          1 :     int16_t displaySelection = nsISelectionController::SELECTION_OFF;</span>
<span class="lineNum">    1043 </span><span class="lineCov">          1 :     const bool focused = nsContentUtils::IsFocusedContent(mContent);</span>
<span class="lineNum">    1044 </span><span class="lineCov">          1 :     const bool hasAttr = AttributeExists(nsGkAtoms::disabled);</span>
<span class="lineNum">    1045 </span><span class="lineCov">          1 :     if (hasAttr) { // set disabled</span>
<span class="lineNum">    1046 </span><span class="lineCov">          1 :       flags |= nsIPlaintextEditor::eEditorDisabledMask;</span>
<span class="lineNum">    1047 </span>            :     } else { // unset disabled
<span class="lineNum">    1048 </span><span class="lineCov">          1 :       flags &amp;= ~(nsIPlaintextEditor::eEditorDisabledMask);</span>
<span class="lineNum">    1049 </span>            :       displaySelection = focused ? nsISelectionController::SELECTION_ON
<span class="lineNum">    1050 </span><span class="lineCov">          1 :                                  : nsISelectionController::SELECTION_HIDDEN;</span>
<span class="lineNum">    1051 </span>            :     }
<span class="lineNum">    1052 </span><span class="lineCov">          1 :     selCon-&gt;SetDisplaySelection(displaySelection);</span>
<span class="lineNum">    1053 </span><span class="lineCov">          1 :     if (focused) {</span>
<span class="lineNum">    1054 </span><span class="lineCov">          1 :       selCon-&gt;SetCaretEnabled(!hasAttr);</span>
<span class="lineNum">    1055 </span>            :     }
<span class="lineNum">    1056 </span><span class="lineCov">          1 :     editor-&gt;SetFlags(flags);</span>
<span class="lineNum">    1057 </span>            :     return NS_OK;
<span class="lineNum">    1058 </span>            :   }
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineCov">          1 :   if (!mEditorHasBeenInitialized &amp;&amp; nsGkAtoms::value == aAttribute) {</span>
<span class="lineNum">    1061 </span><span class="lineCov">          1 :     UpdateValueDisplay(true);</span>
<span class="lineNum">    1062 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">    1063 </span>            :   }
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :   // Allow the base class to handle common attributes supported by all form
<span class="lineNum">    1066 </span>            :   // elements...
<span class="lineNum">    1067 </span><span class="lineCov">          1 :   return nsContainerFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);</span>
<span class="lineNum">    1068 </span>            : }
<span class="lineNum">    1069 </span>            : 
<a name="1070"><span class="lineNum">    1070 </span>            : </a>
<span class="lineNum">    1071 </span>            : nsresult
<span class="lineNum">    1072 </span><span class="lineCov">          1 : nsTextControlFrame::GetText(nsString&amp; aText)</span>
<span class="lineNum">    1073 </span>            : {
<span class="lineNum">    1074 </span><span class="lineCov">          1 :   nsresult rv = NS_OK;</span>
<span class="lineNum">    1075 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1076 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1077 </span><span class="lineCov">          1 :   if (IsSingleLineTextControl()) {</span>
<span class="lineNum">    1078 </span>            :     // There will be no line breaks so we can ignore the wrap property.
<span class="lineNum">    1079 </span><span class="lineCov">          1 :     txtCtrl-&gt;GetTextEditorValue(aText, true);</span>
<span class="lineNum">    1080 </span>            :   } else {
<span class="lineNum">    1081 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsIDOMHTMLTextAreaElement&gt; textArea = do_QueryInterface(mContent);</span>
<span class="lineNum">    1082 </span><span class="lineCov">          1 :     if (textArea) {</span>
<span class="lineNum">    1083 </span><span class="lineCov">          1 :       rv = textArea-&gt;GetValue(aText);</span>
<span class="lineNum">    1084 </span>            :     }
<span class="lineNum">    1085 </span>            :   }
<span class="lineNum">    1086 </span><span class="lineCov">          1 :   return rv;</span>
<span class="lineNum">    1087 </span>            : }
<span class="lineNum">    1088 </span>            : 
<a name="1089"><span class="lineNum">    1089 </span>            : </a>
<span class="lineNum">    1090 </span>            : nsresult
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 : nsTextControlFrame::GetPhonetic(nsAString&amp; aPhonetic)</span>
<span class="lineNum">    1092 </span>            : {
<span class="lineNum">    1093 </span>            :   aPhonetic.Truncate(0);
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :   nsCOMPtr&lt;nsIEditor&gt; editor;
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   nsresult rv = GetEditor(getter_AddRefs(editor));</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIPhonetic&gt; phonetic = do_QueryInterface(editor);</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   if (phonetic) {</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     phonetic-&gt;GetPhonetic(aPhonetic);</span>
<span class="lineNum">    1102 </span>            :   }
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1104 </span>            : }
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            : ///END NSIFRAME OVERLOADS
<span class="lineNum">    1107 </span>            : /////BEGIN PROTECTED METHODS
<a name="1108"><span class="lineNum">    1108 </span>            : </a>
<span class="lineNum">    1109 </span>            : bool
<span class="lineNum">    1110 </span><span class="lineCov">          1 : nsTextControlFrame::GetMaxLength(int32_t* aSize)</span>
<span class="lineNum">    1111 </span>            : {
<span class="lineNum">    1112 </span><span class="lineCov">          1 :   *aSize = -1;</span>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">          1 :   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);</span>
<span class="lineNum">    1115 </span><span class="lineCov">          1 :   if (content) {</span>
<span class="lineNum">    1116 </span><span class="lineCov">          1 :     const nsAttrValue* attr = content-&gt;GetParsedAttr(nsGkAtoms::maxlength);</span>
<span class="lineNum">    1117 </span><span class="lineCov">          1 :     if (attr &amp;&amp; attr-&gt;Type() == nsAttrValue::eInteger) {</span>
<span class="lineNum">    1118 </span><span class="lineCov">          1 :       *aSize = attr-&gt;GetIntegerValue();</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineCov">          1 :       return true;</span>
<span class="lineNum">    1121 </span>            :     }
<span class="lineNum">    1122 </span>            :   }
<span class="lineNum">    1123 </span>            :   return false;
<span class="lineNum">    1124 </span>            : }
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : // END IMPLEMENTING NS_IFORMCONTROLFRAME
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<span class="lineNum">    1128 </span>            : void
<span class="lineNum">    1129 </span><span class="lineCov">          1 : nsTextControlFrame::SetInitialChildList(ChildListID     aListID,</span>
<span class="lineNum">    1130 </span>            :                                         nsFrameList&amp;    aChildList)
<span class="lineNum">    1131 </span>            : {
<span class="lineNum">    1132 </span><span class="lineCov">          1 :   nsContainerFrame::SetInitialChildList(aListID, aChildList);</span>
<span class="lineNum">    1133 </span><span class="lineCov">          1 :   if (aListID != kPrincipalList) {</span>
<span class="lineNum">    1134 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1135 </span>            :   }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :   // Mark the scroll frame as being a reflow root. This will allow
<span class="lineNum">    1138 </span>            :   // incremental reflows to be initiated at the scroll frame, rather
<span class="lineNum">    1139 </span>            :   // than descending from the root frame of the frame hierarchy.
<span class="lineNum">    1140 </span><span class="lineCov">          1 :   if (nsIFrame* first = PrincipalChildList().FirstChild()) {</span>
<span class="lineNum">    1141 </span>            :     first-&gt;AddStateBits(NS_FRAME_REFLOW_ROOT);
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1144 </span>            :     NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1145 </span><span class="lineCov">          1 :     txtCtrl-&gt;InitializeKeyboardEventListeners();</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineCov">          1 :     nsPoint* contentScrollPos = Properties().Get(ContentScrollPos());</span>
<span class="lineNum">    1148 </span><span class="lineCov">          1 :     if (contentScrollPos) {</span>
<span class="lineNum">    1149 </span>            :       // If we have a scroll pos stored to be passed to our anonymous
<span class="lineNum">    1150 </span>            :       // div, do it here!
<span class="lineNum">    1151 </span><span class="lineCov">          1 :       nsIStatefulFrame* statefulFrame = do_QueryFrame(first);</span>
<span class="lineNum">    1152 </span>            :       NS_ASSERTION(statefulFrame, &quot;unexpected type of frame for the anonymous div&quot;);
<span class="lineNum">    1153 </span><span class="lineCov">          1 :       nsPresState fakePresState;</span>
<span class="lineNum">    1154 </span>            :       fakePresState.SetScrollState(*contentScrollPos);
<span class="lineNum">    1155 </span><span class="lineCov">          1 :       statefulFrame-&gt;RestoreState(&amp;fakePresState);</span>
<span class="lineNum">    1156 </span><span class="lineCov">          1 :       Properties().Remove(ContentScrollPos());</span>
<span class="lineNum">    1157 </span>            :       delete contentScrollPos;
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span>            :   }
<span class="lineNum">    1160 </span>            : }
<a name="1161"><span class="lineNum">    1161 </span>            : </a>
<span class="lineNum">    1162 </span>            : void
<span class="lineNum">    1163 </span><span class="lineCov">          1 : nsTextControlFrame::SetValueChanged(bool aValueChanged)</span>
<span class="lineNum">    1164 </span>            : {
<span class="lineNum">    1165 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1166 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">          1 :   if (mUsePlaceholder) {</span>
<span class="lineNum">    1169 </span><span class="lineCov">          1 :     AutoWeakFrame weakFrame(this);</span>
<span class="lineNum">    1170 </span><span class="lineCov">          1 :     txtCtrl-&gt;UpdatePlaceholderVisibility(true);</span>
<span class="lineNum">    1171 </span><span class="lineCov">          1 :     if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    1172 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">    1173 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    1174 </span>            :   }
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span><span class="lineCov">          1 :   txtCtrl-&gt;SetValueChanged(aValueChanged);</span>
<span class="lineNum">    1177 </span>            : }
<span class="lineNum">    1178 </span>            : 
<a name="1179"><span class="lineNum">    1179 </span>            : </a>
<span class="lineNum">    1180 </span>            : nsresult
<span class="lineNum">    1181 </span><span class="lineCov">          1 : nsTextControlFrame::UpdateValueDisplay(bool aNotify,</span>
<span class="lineNum">    1182 </span>            :                                        bool aBeforeEditorInit,
<span class="lineNum">    1183 </span>            :                                        const nsAString *aValue)
<span class="lineNum">    1184 </span>            : {
<span class="lineNum">    1185 </span><span class="lineCov">          1 :   if (!IsSingleLineTextControl()) // textareas don't use this</span>
<span class="lineNum">    1186 </span>            :     return NS_OK;
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1189 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1190 </span><span class="lineCov">          1 :   nsIContent* rootNode = txtCtrl-&gt;GetRootEditorNode();</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            :   NS_PRECONDITION(rootNode, &quot;Must have a div content\n&quot;);
<span class="lineNum">    1193 </span>            :   NS_PRECONDITION(!mEditorHasBeenInitialized,
<span class="lineNum">    1194 </span>            :                   &quot;Do not call this after editor has been initialized&quot;);
<span class="lineNum">    1195 </span>            :   NS_ASSERTION(!mUsePlaceholder || txtCtrl-&gt;GetPlaceholderNode(),
<span class="lineNum">    1196 </span>            :                &quot;A placeholder div must exist&quot;);
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineCov">          1 :   nsIContent *textContent = rootNode-&gt;GetChildAt(0);</span>
<span class="lineNum">    1199 </span><span class="lineCov">          1 :   if (!textContent) {</span>
<span class="lineNum">    1200 </span>            :     // Set up a textnode with our value
<span class="lineNum">    1201 </span>            :     RefPtr&lt;nsTextNode&gt; textNode =
<span class="lineNum">    1202 </span><span class="lineCov">          1 :       new nsTextNode(mContent-&gt;NodeInfo()-&gt;NodeInfoManager());</span>
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            :     NS_ASSERTION(textNode, &quot;Must have textcontent!\n&quot;);
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span><span class="lineCov">          1 :     rootNode-&gt;AppendChildTo(textNode, aNotify);</span>
<span class="lineNum">    1207 </span><span class="lineCov">          1 :     textContent = textNode;</span>
<span class="lineNum">    1208 </span>            :   }
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span><span class="lineCov">          1 :   NS_ENSURE_TRUE(textContent, NS_ERROR_UNEXPECTED);</span>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :   // Get the current value of the textfield from the content.
<span class="lineNum">    1213 </span><span class="lineCov">          1 :   nsAutoString value;</span>
<span class="lineNum">    1214 </span><span class="lineCov">          1 :   if (aValue) {</span>
<span class="lineNum">    1215 </span>            :     value = *aValue;
<span class="lineNum">    1216 </span>            :   } else {
<span class="lineNum">    1217 </span><span class="lineCov">          1 :     txtCtrl-&gt;GetTextEditorValue(value, true);</span>
<span class="lineNum">    1218 </span>            :   }
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            :   // Update the display of the placeholder value if needed.
<span class="lineNum">    1221 </span>            :   // We don't need to do this if we're about to initialize the
<span class="lineNum">    1222 </span>            :   // editor, since EnsureEditorInitialized takes care of this.
<span class="lineNum">    1223 </span><span class="lineCov">          1 :   if (mUsePlaceholder &amp;&amp; !aBeforeEditorInit)</span>
<span class="lineNum">    1224 </span>            :   {
<span class="lineNum">    1225 </span><span class="lineCov">          1 :     AutoWeakFrame weakFrame(this);</span>
<span class="lineNum">    1226 </span><span class="lineCov">          1 :     txtCtrl-&gt;UpdatePlaceholderVisibility(aNotify);</span>
<span class="lineNum">    1227 </span><span class="lineCov">          1 :     NS_ENSURE_STATE(weakFrame.IsAlive());</span>
<span class="lineNum">    1228 </span>            :   }
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span><span class="lineCov">          1 :   if (aBeforeEditorInit &amp;&amp; value.IsEmpty()) {</span>
<span class="lineNum">    1231 </span><span class="lineCov">          1 :     rootNode-&gt;RemoveChildAt(0, true);</span>
<span class="lineNum">    1232 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">    1233 </span>            :   }
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineCov">          1 :   if (!value.IsEmpty() &amp;&amp; IsPasswordTextControl()) {</span>
<span class="lineNum">    1236 </span><span class="lineCov">          1 :     TextEditRules::FillBufWithPWChars(&amp;value, value.Length());</span>
<span class="lineNum">    1237 </span>            :   }
<span class="lineNum">    1238 </span><span class="lineCov">          1 :   return textContent-&gt;SetText(value, aNotify);</span>
<span class="lineNum">    1239 </span>            : }
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<span class="lineNum">    1241 </span>            : NS_IMETHODIMP
<span class="lineNum">    1242 </span><span class="lineCov">          1 : nsTextControlFrame::GetOwnedSelectionController(nsISelectionController** aSelCon)</span>
<span class="lineNum">    1243 </span>            : {
<span class="lineNum">    1244 </span><span class="lineCov">          1 :   NS_ENSURE_ARG_POINTER(aSelCon);</span>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1247 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineCov">          1 :   *aSelCon = txtCtrl-&gt;GetSelectionController();</span>
<span class="lineNum">    1250 </span><span class="lineCov">          1 :   NS_IF_ADDREF(*aSelCon);</span>
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1253 </span>            : }
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<span class="lineNum">    1255 </span>            : nsFrameSelection*
<span class="lineNum">    1256 </span><span class="lineCov">          1 : nsTextControlFrame::GetOwnedFrameSelection()</span>
<span class="lineNum">    1257 </span>            : {
<span class="lineNum">    1258 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1259 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineCov">          1 :   return txtCtrl-&gt;GetConstFrameSelection();</span>
<span class="lineNum">    1262 </span>            : }
<a name="1263"><span class="lineNum">    1263 </span>            : </a>
<span class="lineNum">    1264 </span>            : NS_IMETHODIMP
<span class="lineNum">    1265 </span><span class="lineCov">          1 : nsTextControlFrame::SaveState(nsPresState** aState)</span>
<span class="lineNum">    1266 </span>            : {
<span class="lineNum">    1267 </span><span class="lineCov">          1 :   NS_ENSURE_ARG_POINTER(aState);</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineCov">          1 :   *aState = nullptr;</span>
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1272 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span><span class="lineCov">          1 :   nsIContent* rootNode = txtCtrl-&gt;GetRootEditorNode();</span>
<span class="lineNum">    1275 </span><span class="lineCov">          1 :   if (rootNode) {</span>
<span class="lineNum">    1276 </span>            :     // Query the nsIStatefulFrame from the HTMLScrollFrame
<span class="lineNum">    1277 </span><span class="lineCov">          1 :     nsIStatefulFrame* scrollStateFrame = do_QueryFrame(rootNode-&gt;GetPrimaryFrame());</span>
<span class="lineNum">    1278 </span><span class="lineCov">          1 :     if (scrollStateFrame) {</span>
<span class="lineNum">    1279 </span><span class="lineCov">          1 :       return scrollStateFrame-&gt;SaveState(aState);</span>
<span class="lineNum">    1280 </span>            :     }
<span class="lineNum">    1281 </span>            :   }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :   return NS_OK;
<span class="lineNum">    1284 </span>            : }
<a name="1285"><span class="lineNum">    1285 </span>            : </a>
<span class="lineNum">    1286 </span>            : NS_IMETHODIMP
<span class="lineNum">    1287 </span><span class="lineCov">          1 : nsTextControlFrame::RestoreState(nsPresState* aState)</span>
<span class="lineNum">    1288 </span>            : {
<span class="lineNum">    1289 </span><span class="lineCov">          1 :   NS_ENSURE_ARG_POINTER(aState);</span>
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1292 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element&quot;);
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">          1 :   nsIContent* rootNode = txtCtrl-&gt;GetRootEditorNode();</span>
<span class="lineNum">    1295 </span><span class="lineCov">          1 :   if (rootNode) {</span>
<span class="lineNum">    1296 </span>            :     // Query the nsIStatefulFrame from the HTMLScrollFrame
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     nsIStatefulFrame* scrollStateFrame = do_QueryFrame(rootNode-&gt;GetPrimaryFrame());</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     if (scrollStateFrame) {</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :       return scrollStateFrame-&gt;RestoreState(aState);</span>
<span class="lineNum">    1300 </span>            :     }
<span class="lineNum">    1301 </span>            :   }
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            :   // Most likely, we don't have our anonymous content constructed yet, which
<span class="lineNum">    1304 </span>            :   // would cause us to end up here.  In this case, we'll just store the scroll
<span class="lineNum">    1305 </span>            :   // pos ourselves, and forward it to the scroll frame later when it's created.
<span class="lineNum">    1306 </span><span class="lineCov">          1 :   Properties().Set(ContentScrollPos(), new nsPoint(aState-&gt;GetScrollPosition()));</span>
<span class="lineNum">    1307 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1308 </span>            : }
<a name="1309"><span class="lineNum">    1309 </span>            : </a>
<span class="lineNum">    1310 </span>            : nsresult
<span class="lineNum">    1311 </span><span class="lineCov">          1 : nsTextControlFrame::PeekOffset(nsPeekOffsetStruct *aPos)</span>
<span class="lineNum">    1312 </span>            : {
<span class="lineNum">    1313 </span><span class="lineCov">          1 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">    1314 </span>            : }
<a name="1315"><span class="lineNum">    1315 </span>            : </a>
<span class="lineNum">    1316 </span>            : void
<span class="lineNum">    1317 </span><span class="lineCov">          1 : nsTextControlFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    1318 </span>            :                                      const nsRect&amp;           aDirtyRect,
<span class="lineNum">    1319 </span>            :                                      const nsDisplayListSet&amp; aLists)
<span class="lineNum">    1320 </span>            : {
<span class="lineNum">    1321 </span>            :   /*
<span class="lineNum">    1322 </span>            :    * The implementation of this method is equivalent as:
<span class="lineNum">    1323 </span>            :    * nsContainerFrame::BuildDisplayList()
<span class="lineNum">    1324 </span>            :    * with the difference that we filter-out the placeholder frame when it
<span class="lineNum">    1325 </span>            :    * should not be visible.
<span class="lineNum">    1326 </span>            :    */
<span class="lineNum">    1327 </span>            :   DO_GLOBAL_REFLOW_COUNT_DSP(&quot;nsTextControlFrame&quot;);
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1330 </span>            :   NS_ASSERTION(txtCtrl, &quot;Content not a text control element!&quot;);
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineCov">          1 :   DisplayBorderBackgroundOutline(aBuilder, aLists);</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span><span class="lineCov">          1 :   nsIFrame* kid = mFrames.FirstChild();</span>
<span class="lineNum">    1335 </span>            :   // Redirect all lists to the Content list so that nothing can escape, ie
<span class="lineNum">    1336 </span>            :   // opacity creating stacking contexts that then get sorted with stacking
<span class="lineNum">    1337 </span>            :   // contexts external to us.
<span class="lineNum">    1338 </span><span class="lineCov">          1 :   nsDisplayList* content = aLists.Content();</span>
<span class="lineNum">    1339 </span>            :   nsDisplayListSet set(content, content, content, content, content, content);
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineCov">          1 :   while (kid) {</span>
<span class="lineNum">    1342 </span>            :     // If the frame is the placeholder frame, we should only show it if the
<span class="lineNum">    1343 </span>            :     // placeholder has to be visible.
<span class="lineNum">    1344 </span><span class="lineCov">          1 :     if (kid-&gt;GetContent() != txtCtrl-&gt;GetPlaceholderNode() ||</span>
<span class="lineNum">    1345 </span><span class="lineCov">          1 :         txtCtrl-&gt;GetPlaceholderVisibility()) {</span>
<span class="lineNum">    1346 </span><span class="lineCov">          1 :       BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set, 0);</span>
<span class="lineNum">    1347 </span>            :     }
<span class="lineNum">    1348 </span><span class="lineCov">          1 :     kid = kid-&gt;GetNextSibling();</span>
<span class="lineNum">    1349 </span>            :   }
<span class="lineNum">    1350 </span><span class="lineCov">          1 : }</span>
<a name="1351"><span class="lineNum">    1351 </span>            : </a>
<span class="lineNum">    1352 </span>            : mozilla::dom::Element*
<span class="lineNum">    1353 </span><span class="lineCov">          1 : nsTextControlFrame::GetPseudoElement(CSSPseudoElementType aType)</span>
<span class="lineNum">    1354 </span>            : {
<span class="lineNum">    1355 </span><span class="lineCov">          1 :   if (aType == CSSPseudoElementType::placeholder) {</span>
<span class="lineNum">    1356 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsITextControlElement&gt; txtCtrl = do_QueryInterface(GetContent());</span>
<span class="lineNum">    1357 </span><span class="lineCov">          1 :     return txtCtrl-&gt;GetPlaceholderNode();</span>
<span class="lineNum">    1358 </span>            :   }
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span><span class="lineCov">          1 :   return nsContainerFrame::GetPseudoElement(aType);</span>
<span class="lineNum">    1361 </span>            : }
<a name="1362"><span class="lineNum">    1362 </span>            : </a>
<span class="lineNum">    1363 </span>            : NS_IMETHODIMP
<span class="lineNum">    1364 </span><span class="lineCov">          1 : nsTextControlFrame::EditorInitializer::Run()</span>
<span class="lineNum">    1365 </span>            : {
<span class="lineNum">    1366 </span><span class="lineCov">          1 :   if (!mFrame) {</span>
<span class="lineNum">    1367 </span>            :     return NS_OK;
<span class="lineNum">    1368 </span>            :   }
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :   // Need to block script to avoid bug 669767.
<span class="lineNum">    1371 </span>            :   nsAutoScriptBlocker scriptBlocker;
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :   nsCOMPtr&lt;nsIPresShell&gt; shell =
<span class="lineNum">    1374 </span><span class="lineCov">          1 :     mFrame-&gt;PresContext()-&gt;GetPresShell();</span>
<span class="lineNum">    1375 </span><span class="lineCov">          1 :   bool observes = shell-&gt;ObservesNativeAnonMutationsForPrint();</span>
<span class="lineNum">    1376 </span><span class="lineCov">          1 :   shell-&gt;ObserveNativeAnonMutationsForPrint(true);</span>
<span class="lineNum">    1377 </span>            :   // This can cause the frame to be destroyed (and call Revoke()).
<span class="lineNum">    1378 </span><span class="lineCov">          1 :   mFrame-&gt;EnsureEditorInitialized();</span>
<span class="lineNum">    1379 </span><span class="lineCov">          1 :   shell-&gt;ObserveNativeAnonMutationsForPrint(observes);</span>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :   // The frame can *still* be destroyed even though we have a scriptblocker,
<span class="lineNum">    1382 </span>            :   // bug 682684.
<span class="lineNum">    1383 </span><span class="lineCov">          1 :   if (!mFrame) {</span>
<span class="lineNum">    1384 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">    1385 </span>            :   }
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span><span class="lineCov">          1 :   mFrame-&gt;FinishedInitializer();</span>
<span class="lineNum">    1388 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">    1389 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
