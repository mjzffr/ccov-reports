<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - accessible/generic/DocAccessible.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">accessible/generic</a> - DocAccessible.cpp<span style="font-size: 80%;"> (source / <a href="DocAccessible.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">746</td>
            <td class="headerCovTableEntry">991</td>
            <td class="headerCovTableEntryMed">75.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">67</td>
            <td class="headerCovTableEntry">89</td>
            <td class="headerCovTableEntryMed">75.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;Accessible-inl.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;AccIterator.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;DocAccessible-inl.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;DocAccessibleChild.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;HTMLImageMapAccessible.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsAccCache.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsAccessiblePivot.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsAccUtils.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsEventShell.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsTextEquivUtils.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;Role.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;RootAccessible.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;TreeWalker.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;xpcAccessibleDocument.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;nsIMutableArray.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsICommandManager.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIDocShell.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIDocument.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsIDOMAttr.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsIDOMCharacterData.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsIDOMDocument.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsIDOMXULDocument.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsIDOMMutationEvent.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsPIDOMWindow.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;nsIDOMXULPopupElement.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsIEditingSession.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nsIFrame.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;nsIInterfaceRequestorUtils.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;nsImageFrame.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsIPersistentProperties2.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;nsIPresShell.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;nsIServiceManager.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;nsViewManager.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;nsIScrollableFrame.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;nsUnicharUtils.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;nsIURI.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;nsIWebNavigation.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;nsFocusManager.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;mozilla/ArrayUtils.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;mozilla/EventStates.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;mozilla/dom/TabChild.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;mozilla/dom/DocumentType.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;mozilla/dom/Element.h&quot;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : #ifdef MOZ_XUL
<span class="lineNum">      54 </span>            : #include &quot;nsIXULDocument.h&quot;
<span class="lineNum">      55 </span>            : #endif
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : using namespace mozilla;
<span class="lineNum">      58 </span>            : using namespace mozilla::a11y;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      61 </span>            : // Static member initialization
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : static nsIAtom** kRelationAttrs[] =
<span class="lineNum">      64 </span>            : {
<span class="lineNum">      65 </span>            :   &amp;nsGkAtoms::aria_labelledby,
<span class="lineNum">      66 </span>            :   &amp;nsGkAtoms::aria_describedby,
<span class="lineNum">      67 </span>            :   &amp;nsGkAtoms::aria_details,
<span class="lineNum">      68 </span>            :   &amp;nsGkAtoms::aria_owns,
<span class="lineNum">      69 </span>            :   &amp;nsGkAtoms::aria_controls,
<span class="lineNum">      70 </span>            :   &amp;nsGkAtoms::aria_flowto,
<span class="lineNum">      71 </span>            :   &amp;nsGkAtoms::aria_errormessage,
<span class="lineNum">      72 </span>            :   &amp;nsGkAtoms::_for,
<span class="lineNum">      73 </span>            :   &amp;nsGkAtoms::control
<span class="lineNum">      74 </span>            : };
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : static const uint32_t kRelationAttrsLen = ArrayLength(kRelationAttrs);
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : ////////////////////////////////////////////////////////////////////////////////
<a name="79"><span class="lineNum">      79 </span>            : // Constructor/desctructor</a>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span><span class="lineCov">          1 : DocAccessible::</span>
<span class="lineNum">      82 </span>            :   DocAccessible(nsIDocument* aDocument, nsIPresShell* aPresShell) :
<span class="lineNum">      83 </span>            :     // XXX don't pass a document to the Accessible constructor so that we don't
<span class="lineNum">      84 </span>            :     // set mDoc until our vtable is fully setup.  If we set mDoc before setting
<span class="lineNum">      85 </span>            :     // up the vtable we will call Accessible::AddRef() but not the overrides of
<span class="lineNum">      86 </span>            :     // it for subclasses.  It is important to call those overrides to avoid
<span class="lineNum">      87 </span>            :     // confusing leak checking machinary.
<span class="lineNum">      88 </span>            :   HyperTextAccessibleWrap(nullptr, nullptr),
<span class="lineNum">      89 </span>            :   // XXX aaronl should we use an algorithm for the initial cache size?
<span class="lineNum">      90 </span>            :   mAccessibleCache(kDefaultCacheLength),
<span class="lineNum">      91 </span>            :   mNodeToAccessibleMap(kDefaultCacheLength),
<span class="lineNum">      92 </span>            :   mDocumentNode(aDocument),
<span class="lineNum">      93 </span>            :   mScrollPositionChangedTicks(0),
<span class="lineNum">      94 </span>            :   mLoadState(eTreeConstructionPending), mDocFlags(0), mLoadEventType(0),
<span class="lineNum">      95 </span>            :   mVirtualCursor(nullptr),
<span class="lineNum">      96 </span><span class="lineCov">          1 :   mPresShell(aPresShell), mIPCDoc(nullptr)</span>
<span class="lineNum">      97 </span>            : {
<span class="lineNum">      98 </span><span class="lineCov">          1 :   mGenericTypes |= eDocument;</span>
<span class="lineNum">      99 </span><span class="lineCov">          1 :   mStateFlags |= eNotNodeMapEntry;</span>
<span class="lineNum">     100 </span><span class="lineCov">          1 :   mDoc = this;</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   MOZ_ASSERT(mPresShell, &quot;should have been given a pres shell&quot;);
<span class="lineNum">     103 </span><span class="lineCov">          1 :   mPresShell-&gt;SetDocAccessible(this);</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :   // If this is a XUL Document, it should not implement nsHyperText
<span class="lineNum">     106 </span><span class="lineCov">          1 :   if (mDocumentNode &amp;&amp; mDocumentNode-&gt;IsXULDocument())</span>
<span class="lineNum">     107 </span><span class="lineCov">          1 :     mGenericTypes &amp;= ~eHyperText;</span>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineCov">          1 : DocAccessible::~DocAccessible()</span>
<span class="lineNum">     111 </span>            : {
<span class="lineNum">     112 </span>            :   NS_ASSERTION(!mPresShell, &quot;LastRelease was never called!?!&quot;);
<span class="lineNum">     113 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     117 </span>            : // nsISupports
<span class="lineNum">     118 </span>            : 
<a name="119"><span class="lineNum">     119 </span>            : NS_IMPL_CYCLE_COLLECTION_CLASS(DocAccessible)</a>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">          1 : NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(DocAccessible, Accessible)</span>
<span class="lineNum">     122 </span><span class="lineCov">          1 :   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mNotificationController)</span>
<span class="lineNum">     123 </span><span class="lineCov">          1 :   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mVirtualCursor)</span>
<span class="lineNum">     124 </span><span class="lineCov">          1 :   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mChildDocuments)</span>
<span class="lineNum">     125 </span><span class="lineCov">          1 :   for (auto iter = tmp-&gt;mDependentIDsHash.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     126 </span><span class="lineCov">          1 :     AttrRelProviderArray* providers = iter.UserData();</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineCov">          1 :     for (int32_t jdx = providers-&gt;Length() - 1; jdx &gt;= 0; jdx--) {</span>
<span class="lineNum">     129 </span>            :       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(
<span class="lineNum">     130 </span>            :         cb, &quot;content of dependent ids hash entry of document accessible&quot;);
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">          1 :       AttrRelProvider* provider = (*providers)[jdx];</span>
<span class="lineNum">     133 </span><span class="lineCov">          1 :       cb.NoteXPCOMChild(provider-&gt;mContent);</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :       NS_ASSERTION(provider-&gt;mContent-&gt;IsInUncomposedDoc(),
<span class="lineNum">     136 </span>            :                    &quot;Referred content is not in document!&quot;);
<span class="lineNum">     137 </span>            :     }
<span class="lineNum">     138 </span>            :   }
<span class="lineNum">     139 </span><span class="lineCov">          1 :   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mAccessibleCache)</span>
<span class="lineNum">     140 </span><span class="lineCov">          1 :   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mAnchorJumpElm)</span>
<span class="lineNum">     141 </span><span class="lineCov">          1 :   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mInvalidationList)</span>
<span class="lineNum">     142 </span><span class="lineCov">          1 :   for (auto it = tmp-&gt;mARIAOwnsHash.ConstIter(); !it.Done(); it.Next()) {</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     nsTArray&lt;RefPtr&lt;Accessible&gt; &gt;* ar = it.UserData();</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; ar-&gt;Length(); i++) {</span>
<span class="lineNum">     145 </span>            :       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
<span class="lineNum">     146 </span>            :                                          &quot;mARIAOwnsHash entry item&quot;);
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :       cb.NoteXPCOMChild(ar-&gt;ElementAt(i));</span>
<span class="lineNum">     148 </span>            :     }
<span class="lineNum">     149 </span>            :   }
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">          1 : NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</span></a>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(DocAccessible, Accessible)</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   NS_IMPL_CYCLE_COLLECTION_UNLINK(mNotificationController)</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   NS_IMPL_CYCLE_COLLECTION_UNLINK(mVirtualCursor)</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   NS_IMPL_CYCLE_COLLECTION_UNLINK(mChildDocuments)</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   tmp-&gt;mDependentIDsHash.Clear();</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   tmp-&gt;mNodeToAccessibleMap.Clear();</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   NS_IMPL_CYCLE_COLLECTION_UNLINK(mAccessibleCache)</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   NS_IMPL_CYCLE_COLLECTION_UNLINK(mAnchorJumpElm)</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   NS_IMPL_CYCLE_COLLECTION_UNLINK(mInvalidationList)</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   tmp-&gt;mARIAOwnsHash.Clear();</span>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_UNLINK_END</span></a>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">          1 : NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(DocAccessible)</span>
<span class="lineNum">     165 </span><span class="lineCov">          1 :   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)</span>
<span class="lineNum">     166 </span><span class="lineCov">          1 :   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)</span>
<span class="lineNum">     167 </span><span class="lineCov">          1 :   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :   NS_INTERFACE_MAP_ENTRY(nsIObserver)</span>
<span class="lineNum">     169 </span><span class="lineCov">          1 :   NS_INTERFACE_MAP_ENTRY(nsIAccessiblePivotObserver)</span>
<a name="170"><span class="lineNum">     170 </span><span class="lineCov">          1 : NS_INTERFACE_MAP_END_INHERITING(HyperTextAccessible)</span></a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<span class="lineNum">     172 </span><span class="lineCov">          1 : NS_IMPL_ADDREF_INHERITED(DocAccessible, HyperTextAccessible)</span>
<span class="lineNum">     173 </span><span class="lineCov">          1 : NS_IMPL_RELEASE_INHERITED(DocAccessible, HyperTextAccessible)</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     176 </span>            : // nsIAccessible
<a name="177"><span class="lineNum">     177 </span>            : </a>
<span class="lineNum">     178 </span>            : ENameValueFlag
<span class="lineNum">     179 </span><span class="lineCov">          1 : DocAccessible::Name(nsString&amp; aName)</span>
<span class="lineNum">     180 </span>            : {
<span class="lineNum">     181 </span><span class="lineCov">          1 :   aName.Truncate();</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">          1 :   if (mParent) {</span>
<span class="lineNum">     184 </span><span class="lineCov">          1 :     mParent-&gt;Name(aName); // Allow owning iframe to override the name</span>
<span class="lineNum">     185 </span>            :   }
<span class="lineNum">     186 </span><span class="lineCov">          1 :   if (aName.IsEmpty()) {</span>
<span class="lineNum">     187 </span>            :     // Allow name via aria-labelledby or title attribute
<span class="lineNum">     188 </span><span class="lineCov">          1 :     Accessible::Name(aName);</span>
<span class="lineNum">     189 </span>            :   }
<span class="lineNum">     190 </span><span class="lineCov">          1 :   if (aName.IsEmpty()) {</span>
<span class="lineNum">     191 </span><span class="lineCov">          1 :     Title(aName); // Try title element</span>
<span class="lineNum">     192 </span>            :   }
<span class="lineNum">     193 </span><span class="lineCov">          1 :   if (aName.IsEmpty()) {   // Last resort: use URL</span>
<span class="lineNum">     194 </span><span class="lineCov">          1 :     URL(aName);</span>
<span class="lineNum">     195 </span>            :   }
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineCov">          1 :   return eNameOK;</span>
<span class="lineNum">     198 </span>            : }
<span class="lineNum">     199 </span>            : 
<a name="200"><span class="lineNum">     200 </span>            : // Accessible public method</a>
<span class="lineNum">     201 </span>            : role
<span class="lineNum">     202 </span><span class="lineCov">          1 : DocAccessible::NativeRole()</span>
<span class="lineNum">     203 </span>            : {
<span class="lineNum">     204 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDocShell&gt; docShell = nsCoreUtils::GetDocShellFor(mDocumentNode);</span>
<span class="lineNum">     205 </span><span class="lineCov">          1 :   if (docShell) {</span>
<span class="lineNum">     206 </span>            :     nsCOMPtr&lt;nsIDocShellTreeItem&gt; sameTypeRoot;
<span class="lineNum">     207 </span><span class="lineCov">          1 :     docShell-&gt;GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));</span>
<span class="lineNum">     208 </span><span class="lineCov">          1 :     int32_t itemType = docShell-&gt;ItemType();</span>
<span class="lineNum">     209 </span><span class="lineCov">          1 :     if (sameTypeRoot == docShell) {</span>
<span class="lineNum">     210 </span>            :       // Root of content or chrome tree
<span class="lineNum">     211 </span><span class="lineCov">          1 :       if (itemType == nsIDocShellTreeItem::typeChrome)</span>
<span class="lineNum">     212 </span>            :         return roles::CHROME_WINDOW;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span><span class="lineCov">          1 :       if (itemType == nsIDocShellTreeItem::typeContent) {</span>
<span class="lineNum">     215 </span>            : #ifdef MOZ_XUL
<span class="lineNum">     216 </span><span class="lineCov">          1 :         nsCOMPtr&lt;nsIXULDocument&gt; xulDoc(do_QueryInterface(mDocumentNode));</span>
<span class="lineNum">     217 </span><span class="lineCov">          1 :         if (xulDoc)</span>
<span class="lineNum">     218 </span>            :           return roles::APPLICATION;
<span class="lineNum">     219 </span>            : #endif
<span class="lineNum">     220 </span><span class="lineCov">          1 :         return roles::DOCUMENT;</span>
<span class="lineNum">     221 </span>            :       }
<span class="lineNum">     222 </span>            :     }
<span class="lineNum">     223 </span><span class="lineCov">          1 :     else if (itemType == nsIDocShellTreeItem::typeContent) {</span>
<span class="lineNum">     224 </span>            :       return roles::DOCUMENT;
<span class="lineNum">     225 </span>            :     }
<span class="lineNum">     226 </span>            :   }
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   return roles::PANE; // Fall back;
<span class="lineNum">     229 </span>            : }
<a name="230"><span class="lineNum">     230 </span>            : </a>
<span class="lineNum">     231 </span>            : void
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : DocAccessible::Description(nsString&amp; aDescription)</span>
<span class="lineNum">     233 </span>            : {
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   if (mParent)</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     mParent-&gt;Description(aDescription);</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   if (HasOwnContent() &amp;&amp; aDescription.IsEmpty()) {</span>
<span class="lineNum">     238 </span>            :     nsTextEquivUtils::
<span class="lineNum">     239 </span>            :       GetTextEquivFromIDRefs(this, nsGkAtoms::aria_describedby,
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                              aDescription);</span>
<span class="lineNum">     241 </span>            :   }
<span class="lineNum">     242 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     243 </span>            : 
<a name="244"><span class="lineNum">     244 </span>            : // Accessible public method</a>
<span class="lineNum">     245 </span>            : uint64_t
<span class="lineNum">     246 </span><span class="lineCov">          1 : DocAccessible::NativeState()</span>
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span>            :   // Document is always focusable.
<span class="lineNum">     249 </span><span class="lineCov">          1 :   uint64_t state = states::FOCUSABLE; // keep in sync with NativeInteractiveState() impl</span>
<span class="lineNum">     250 </span><span class="lineCov">          1 :   if (FocusMgr()-&gt;IsFocused(this))</span>
<span class="lineNum">     251 </span><span class="lineCov">          1 :     state |= states::FOCUSED;</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :   // Expose stale state until the document is ready (DOM is loaded and tree is
<span class="lineNum">     254 </span>            :   // constructed).
<span class="lineNum">     255 </span><span class="lineCov">          1 :   if (!HasLoadState(eReady))</span>
<span class="lineNum">     256 </span><span class="lineCov">          1 :     state |= states::STALE;</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :   // Expose state busy until the document and all its subdocuments is completely
<span class="lineNum">     259 </span>            :   // loaded.
<span class="lineNum">     260 </span><span class="lineCov">          1 :   if (!HasLoadState(eCompletelyLoaded))</span>
<span class="lineNum">     261 </span><span class="lineCov">          1 :     state |= states::BUSY;</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineCov">          1 :   nsIFrame* frame = GetFrame();</span>
<span class="lineNum">     264 </span><span class="lineCov">          1 :   if (!frame ||</span>
<span class="lineNum">     265 </span><span class="lineCov">          1 :       !frame-&gt;IsVisibleConsideringAncestors(nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY)) {</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     state |= states::INVISIBLE | states::OFFSCREEN;</span>
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIEditor&gt; editor = GetEditor();</span>
<span class="lineNum">     270 </span><span class="lineCov">          1 :   state |= editor ? states::EDITABLE : states::READONLY;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineCov">          1 :   return state;</span>
<span class="lineNum">     273 </span>            : }
<a name="274"><span class="lineNum">     274 </span>            : </a>
<span class="lineNum">     275 </span>            : uint64_t
<span class="lineNum">     276 </span><span class="lineCov">          1 : DocAccessible::NativeInteractiveState() const</span>
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span>            :   // Document is always focusable.
<span class="lineNum">     279 </span><span class="lineCov">          1 :   return states::FOCUSABLE;</span>
<span class="lineNum">     280 </span>            : }
<a name="281"><span class="lineNum">     281 </span>            : </a>
<span class="lineNum">     282 </span>            : bool
<span class="lineNum">     283 </span><span class="lineNoCov">          0 : DocAccessible::NativelyUnavailable() const</span>
<span class="lineNum">     284 </span>            : {
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     286 </span>            : }
<span class="lineNum">     287 </span>            : 
<a name="288"><span class="lineNum">     288 </span>            : // Accessible public method</a>
<span class="lineNum">     289 </span>            : void
<span class="lineNum">     290 </span><span class="lineCov">          1 : DocAccessible::ApplyARIAState(uint64_t* aState) const</span>
<span class="lineNum">     291 </span>            : {
<span class="lineNum">     292 </span>            :   // Grab states from content element.
<span class="lineNum">     293 </span><span class="lineCov">          1 :   if (mContent)</span>
<span class="lineNum">     294 </span><span class="lineCov">          1 :     Accessible::ApplyARIAState(aState);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   // Allow iframe/frame etc. to have final state override via ARIA.
<span class="lineNum">     297 </span><span class="lineCov">          1 :   if (mParent)</span>
<span class="lineNum">     298 </span><span class="lineCov">          1 :     mParent-&gt;ApplyARIAState(aState);</span>
<span class="lineNum">     299 </span><span class="lineCov">          1 : }</span>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<span class="lineNum">     301 </span>            : already_AddRefed&lt;nsIPersistentProperties&gt;
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : DocAccessible::Attributes()</span>
<span class="lineNum">     303 </span>            : {
<span class="lineNum">     304 </span>            :   nsCOMPtr&lt;nsIPersistentProperties&gt; attributes =
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     HyperTextAccessibleWrap::Attributes();</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   // No attributes if document is not attached to the tree or if it's a root
<span class="lineNum">     308 </span>            :   // document.
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   if (!mParent || IsRoot())</span>
<span class="lineNum">     310 </span>            :     return attributes.forget();
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :   // Override ARIA object attributes from outerdoc.
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   aria::AttrIterator attribIter(mParent-&gt;GetContent());</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   nsAutoString name, value, unused;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   while(attribIter.Next(name, value))</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     attributes-&gt;SetStringProperty(NS_ConvertUTF16toUTF8(name), value, unused);</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   return attributes.forget();
<span class="lineNum">     319 </span>            : }
<a name="320"><span class="lineNum">     320 </span>            : </a>
<span class="lineNum">     321 </span>            : Accessible*
<span class="lineNum">     322 </span><span class="lineNoCov">          0 : DocAccessible::FocusedChild()</span>
<span class="lineNum">     323 </span>            : {
<span class="lineNum">     324 </span>            :   // Return an accessible for the current global focus, which does not have to
<span class="lineNum">     325 </span>            :   // be contained within the current document.
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   return FocusMgr()-&gt;FocusedAccessible();</span>
<span class="lineNum">     327 </span>            : }
<a name="328"><span class="lineNum">     328 </span>            : </a>
<span class="lineNum">     329 </span>            : void
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : DocAccessible::TakeFocus()</span>
<span class="lineNum">     331 </span>            : {
<span class="lineNum">     332 </span>            :   // Focus the document.
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   nsFocusManager* fm = nsFocusManager::GetFocusManager();</span>
<span class="lineNum">     334 </span>            :   nsCOMPtr&lt;nsIDOMElement&gt; newFocus;
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   fm-&gt;MoveFocus(mDocumentNode-&gt;GetWindow(), nullptr,</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                 nsFocusManager::MOVEFOCUS_ROOT, 0, getter_AddRefs(newFocus));</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     338 </span>            : 
<a name="339"><span class="lineNum">     339 </span>            : // HyperTextAccessible method</a>
<span class="lineNum">     340 </span>            : already_AddRefed&lt;nsIEditor&gt;
<span class="lineNum">     341 </span><span class="lineCov">          1 : DocAccessible::GetEditor() const</span>
<span class="lineNum">     342 </span>            : {
<span class="lineNum">     343 </span>            :   // Check if document is editable (designMode=&quot;on&quot; case). Otherwise check if
<span class="lineNum">     344 </span>            :   // the html:body (for HTML document case) or document element is editable.
<span class="lineNum">     345 </span><span class="lineCov">          1 :   if (!mDocumentNode-&gt;HasFlag(NODE_IS_EDITABLE) &amp;&amp;</span>
<span class="lineNum">     346 </span><span class="lineCov">          1 :       (!mContent || !mContent-&gt;HasFlag(NODE_IS_EDITABLE)))</span>
<span class="lineNum">     347 </span><span class="lineCov">          1 :     return nullptr;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDocShell&gt; docShell = mDocumentNode-&gt;GetDocShell();</span>
<span class="lineNum">     350 </span><span class="lineCov">          1 :   if (!docShell) {</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     352 </span>            :   }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   nsCOMPtr&lt;nsIEditingSession&gt; editingSession;
<span class="lineNum">     355 </span><span class="lineCov">          1 :   docShell-&gt;GetEditingSession(getter_AddRefs(editingSession));</span>
<span class="lineNum">     356 </span><span class="lineCov">          1 :   if (!editingSession)</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     return nullptr; // No editing session interface</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   nsCOMPtr&lt;nsIEditor&gt; editor;
<span class="lineNum">     360 </span><span class="lineCov">          1 :   editingSession-&gt;GetEditorForWindow(mDocumentNode-&gt;GetWindow(), getter_AddRefs(editor));</span>
<span class="lineNum">     361 </span><span class="lineCov">          1 :   if (!editor)</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineCov">          1 :   bool isEditable = false;</span>
<span class="lineNum">     365 </span><span class="lineCov">          1 :   editor-&gt;GetIsDocumentEditable(&amp;isEditable);</span>
<span class="lineNum">     366 </span><span class="lineCov">          1 :   if (isEditable)</span>
<span class="lineNum">     367 </span>            :     return editor.forget();
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">     370 </span>            : }
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : // DocAccessible public method
<a name="373"><span class="lineNum">     373 </span>            : </a>
<span class="lineNum">     374 </span>            : void
<span class="lineNum">     375 </span><span class="lineCov">          1 : DocAccessible::URL(nsAString&amp; aURL) const</span>
<span class="lineNum">     376 </span>            : {
<span class="lineNum">     377 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsISupports&gt; container = mDocumentNode-&gt;GetContainer();</span>
<span class="lineNum">     378 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIWebNavigation&gt; webNav(do_GetInterface(container));</span>
<span class="lineNum">     379 </span><span class="lineCov">          1 :   nsAutoCString theURL;</span>
<span class="lineNum">     380 </span><span class="lineCov">          1 :   if (webNav) {</span>
<span class="lineNum">     381 </span>            :     nsCOMPtr&lt;nsIURI&gt; pURI;
<span class="lineNum">     382 </span><span class="lineCov">          1 :     webNav-&gt;GetCurrentURI(getter_AddRefs(pURI));</span>
<span class="lineNum">     383 </span><span class="lineCov">          1 :     if (pURI)</span>
<span class="lineNum">     384 </span><span class="lineCov">          1 :       pURI-&gt;GetSpec(theURL);</span>
<span class="lineNum">     385 </span>            :   }
<span class="lineNum">     386 </span><span class="lineCov">          1 :   CopyUTF8toUTF16(theURL, aURL);</span>
<span class="lineNum">     387 </span><span class="lineCov">          1 : }</span>
<a name="388"><span class="lineNum">     388 </span>            : </a>
<span class="lineNum">     389 </span>            : void
<span class="lineNum">     390 </span><span class="lineNoCov">          0 : DocAccessible::DocType(nsAString&amp; aType) const</span>
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            : #ifdef MOZ_XUL
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIXULDocument&gt; xulDoc(do_QueryInterface(mDocumentNode));</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   if (xulDoc) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     aType.AssignLiteral(&quot;window&quot;); // doctype not implemented for XUL at time of writing - causes assertion</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     397 </span>            :   }
<span class="lineNum">     398 </span>            : #endif
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :   dom::DocumentType* docType = mDocumentNode-&gt;GetDoctype();</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   if (docType)</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     docType-&gt;GetPublicId(aType);</span>
<span class="lineNum">     402 </span>            : }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     405 </span>            : // Accessible
<a name="406"><span class="lineNum">     406 </span>            : </a>
<span class="lineNum">     407 </span>            : void
<span class="lineNum">     408 </span><span class="lineCov">          1 : DocAccessible::Init()</span>
<span class="lineNum">     409 </span>            : {
<span class="lineNum">     410 </span>            : #ifdef A11Y_LOG
<span class="lineNum">     411 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eDocCreate))</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     logging::DocCreate(&quot;document initialize&quot;, mDocumentNode, this);</span>
<span class="lineNum">     413 </span>            : #endif
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :   // Initialize notification controller.
<span class="lineNum">     416 </span><span class="lineCov">          1 :   mNotificationController = new NotificationController(this, mPresShell);</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   // Mark the document accessible as loaded if its DOM document was loaded at
<span class="lineNum">     419 </span>            :   // this point (this can happen because a11y is started late or DOM document
<span class="lineNum">     420 </span>            :   // having no container was loaded.
<span class="lineNum">     421 </span><span class="lineCov">          1 :   if (mDocumentNode-&gt;GetReadyStateEnum() == nsIDocument::READYSTATE_COMPLETE)</span>
<span class="lineNum">     422 </span><span class="lineCov">          1 :     mLoadState |= eDOMLoaded;</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">          1 :   AddEventListeners();</span>
<span class="lineNum">     425 </span><span class="lineCov">          1 : }</span>
<a name="426"><span class="lineNum">     426 </span>            : </a>
<span class="lineNum">     427 </span>            : void
<span class="lineNum">     428 </span><span class="lineCov">          1 : DocAccessible::Shutdown()</span>
<span class="lineNum">     429 </span>            : {
<span class="lineNum">     430 </span><span class="lineCov">          1 :   if (!mPresShell) // already shutdown</span>
<span class="lineNum">     431 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : #ifdef A11Y_LOG
<span class="lineNum">     434 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eDocDestroy))</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     logging::DocDestroy(&quot;document shutdown&quot;, mDocumentNode, this);</span>
<span class="lineNum">     436 </span>            : #endif
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :   // Mark the document as shutdown before AT is notified about the document
<span class="lineNum">     439 </span>            :   // removal from its container (valid for root documents on ATK and due to
<span class="lineNum">     440 </span>            :   // some reason for MSAA, refer to bug 757392 for details).
<span class="lineNum">     441 </span><span class="lineCov">          1 :   mStateFlags |= eIsDefunct;</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineCov">          1 :   if (mNotificationController) {</span>
<span class="lineNum">     444 </span><span class="lineCov">          1 :     mNotificationController-&gt;Shutdown();</span>
<span class="lineNum">     445 </span><span class="lineCov">          1 :     mNotificationController = nullptr;</span>
<span class="lineNum">     446 </span>            :   }
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">          1 :   RemoveEventListeners();</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDocument&gt; kungFuDeathGripDoc = mDocumentNode;</span>
<span class="lineNum">     451 </span><span class="lineCov">          1 :   mDocumentNode = nullptr;</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">          1 :   if (mParent) {</span>
<span class="lineNum">     454 </span><span class="lineCov">          1 :     DocAccessible* parentDocument = mParent-&gt;Document();</span>
<span class="lineNum">     455 </span><span class="lineCov">          1 :     if (parentDocument)</span>
<span class="lineNum">     456 </span>            :       parentDocument-&gt;RemoveChildDocument(this);
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">          1 :     mParent-&gt;RemoveChild(this);</span>
<span class="lineNum">     459 </span>            :   }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :   // Walk the array backwards because child documents remove themselves from the
<span class="lineNum">     462 </span>            :   // array as they are shutdown.
<span class="lineNum">     463 </span><span class="lineCov">          1 :   int32_t childDocCount = mChildDocuments.Length();</span>
<span class="lineNum">     464 </span><span class="lineCov">          1 :   for (int32_t idx = childDocCount - 1; idx &gt;= 0; idx--)</span>
<span class="lineNum">     465 </span><span class="lineCov">          1 :     mChildDocuments[idx]-&gt;Shutdown();</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineCov">          1 :   mChildDocuments.Clear();</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :   // XXX thinking about ordering?
<span class="lineNum">     470 </span><span class="lineCov">          1 :   if (mIPCDoc) {</span>
<span class="lineNum">     471 </span>            :     MOZ_ASSERT(IPCAccessibilityActive());
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     mIPCDoc-&gt;Shutdown();</span>
<span class="lineNum">     473 </span>            :     MOZ_ASSERT(!mIPCDoc);
<span class="lineNum">     474 </span>            :   }
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">          1 :   if (mVirtualCursor) {</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     mVirtualCursor-&gt;RemoveObserver(this);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     mVirtualCursor = nullptr;</span>
<span class="lineNum">     479 </span>            :   }
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">          1 :   mPresShell-&gt;SetDocAccessible(nullptr);</span>
<span class="lineNum">     482 </span><span class="lineCov">          1 :   mPresShell = nullptr;  // Avoid reentrancy</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineCov">          1 :   mDependentIDsHash.Clear();</span>
<span class="lineNum">     485 </span><span class="lineCov">          1 :   mNodeToAccessibleMap.Clear();</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineCov">          1 :   for (auto iter = mAccessibleCache.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     488 </span><span class="lineCov">          1 :     Accessible* accessible = iter.Data();</span>
<span class="lineNum">     489 </span>            :     MOZ_ASSERT(accessible);
<span class="lineNum">     490 </span><span class="lineCov">          1 :     if (accessible &amp;&amp; !accessible-&gt;IsDefunct()) {</span>
<span class="lineNum">     491 </span>            :       // Unlink parent to avoid its cleaning overhead in shutdown.
<span class="lineNum">     492 </span><span class="lineCov">          1 :       accessible-&gt;mParent = nullptr;</span>
<span class="lineNum">     493 </span><span class="lineCov">          1 :       accessible-&gt;Shutdown();</span>
<span class="lineNum">     494 </span>            :     }
<span class="lineNum">     495 </span><span class="lineCov">          1 :     iter.Remove();</span>
<span class="lineNum">     496 </span>            :   }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineCov">          1 :   HyperTextAccessibleWrap::Shutdown();</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">          1 :   GetAccService()-&gt;NotifyOfDocumentShutdown(this, kungFuDeathGripDoc);</span>
<span class="lineNum">     501 </span>            : }
<a name="502"><span class="lineNum">     502 </span>            : </a>
<span class="lineNum">     503 </span>            : nsIFrame*
<span class="lineNum">     504 </span><span class="lineCov">          1 : DocAccessible::GetFrame() const</span>
<span class="lineNum">     505 </span>            : {
<span class="lineNum">     506 </span><span class="lineCov">          1 :   nsIFrame* root = nullptr;</span>
<span class="lineNum">     507 </span><span class="lineCov">          1 :   if (mPresShell)</span>
<span class="lineNum">     508 </span><span class="lineCov">          1 :     root = mPresShell-&gt;GetRootFrame();</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineCov">          1 :   return root;</span>
<span class="lineNum">     511 </span>            : }
<span class="lineNum">     512 </span>            : 
<a name="513"><span class="lineNum">     513 </span>            : // DocAccessible protected member</a>
<span class="lineNum">     514 </span>            : nsRect
<span class="lineNum">     515 </span><span class="lineNoCov">          0 : DocAccessible::RelativeBounds(nsIFrame** aRelativeFrame) const</span>
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   *aRelativeFrame = GetFrame();</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   nsIDocument *document = mDocumentNode;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   nsIDocument *parentDoc = nullptr;</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :   nsRect bounds;
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   while (document) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     nsIPresShell *presShell = document-&gt;GetShell();</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     if (!presShell)</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       return nsRect();</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :     nsRect scrollPort;
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     nsIScrollableFrame* sf = presShell-&gt;GetRootScrollFrameAsScrollableExternal();</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     if (sf) {</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       scrollPort = sf-&gt;GetScrollPortRect();</span>
<span class="lineNum">     532 </span>            :     } else {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       nsIFrame* rootFrame = presShell-&gt;GetRootFrame();</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       if (!rootFrame)</span>
<span class="lineNum">     535 </span>            :         return nsRect();
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :       scrollPort = rootFrame-&gt;GetRect();</span>
<span class="lineNum">     538 </span>            :     }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     if (parentDoc) {  // After first time thru loop</span>
<span class="lineNum">     541 </span>            :       // XXXroc bogus code! scrollPort is relative to the viewport of
<span class="lineNum">     542 </span>            :       // this document, but we're intersecting rectangles derived from
<span class="lineNum">     543 </span>            :       // multiple documents and assuming they're all in the same coordinate
<span class="lineNum">     544 </span>            :       // system. See bug 514117.
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :       bounds.IntersectRect(scrollPort, bounds);</span>
<span class="lineNum">     546 </span>            :     }
<span class="lineNum">     547 </span>            :     else {  // First time through loop
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :       bounds = scrollPort;</span>
<span class="lineNum">     549 </span>            :     }
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     document = parentDoc = document-&gt;GetParentDocument();</span>
<span class="lineNum">     552 </span>            :   }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   return bounds;
<span class="lineNum">     555 </span>            : }
<span class="lineNum">     556 </span>            : 
<a name="557"><span class="lineNum">     557 </span>            : // DocAccessible protected member</a>
<span class="lineNum">     558 </span>            : nsresult
<span class="lineNum">     559 </span><span class="lineCov">          1 : DocAccessible::AddEventListeners()</span>
<span class="lineNum">     560 </span>            : {
<span class="lineNum">     561 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDocShell&gt; docShell(mDocumentNode-&gt;GetDocShell());</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            :   // We want to add a command observer only if the document is content and has
<span class="lineNum">     564 </span>            :   // an editor.
<span class="lineNum">     565 </span><span class="lineCov">          1 :   if (docShell-&gt;ItemType() == nsIDocShellTreeItem::typeContent) {</span>
<span class="lineNum">     566 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsICommandManager&gt; commandManager = docShell-&gt;GetCommandManager();</span>
<span class="lineNum">     567 </span><span class="lineCov">          1 :     if (commandManager)</span>
<span class="lineNum">     568 </span><span class="lineCov">          1 :       commandManager-&gt;AddCommandObserver(this, &quot;obs_documentCreated&quot;);</span>
<span class="lineNum">     569 </span>            :   }
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineCov">          1 :   SelectionMgr()-&gt;AddDocSelectionListener(mPresShell);</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :   // Add document observer.
<span class="lineNum">     574 </span><span class="lineCov">          1 :   mDocumentNode-&gt;AddObserver(this);</span>
<span class="lineNum">     575 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     576 </span>            : }
<span class="lineNum">     577 </span>            : 
<a name="578"><span class="lineNum">     578 </span>            : // DocAccessible protected member</a>
<span class="lineNum">     579 </span>            : nsresult
<span class="lineNum">     580 </span><span class="lineCov">          1 : DocAccessible::RemoveEventListeners()</span>
<span class="lineNum">     581 </span>            : {
<span class="lineNum">     582 </span>            :   // Remove listeners associated with content documents
<span class="lineNum">     583 </span>            :   // Remove scroll position listener
<span class="lineNum">     584 </span><span class="lineCov">          1 :   RemoveScrollListener();</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :   NS_ASSERTION(mDocumentNode, &quot;No document during removal of listeners.&quot;);
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineCov">          1 :   if (mDocumentNode) {</span>
<span class="lineNum">     589 </span><span class="lineCov">          1 :     mDocumentNode-&gt;RemoveObserver(this);</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineCov">          1 :     nsCOMPtr&lt;nsIDocShell&gt; docShell(mDocumentNode-&gt;GetDocShell());</span>
<span class="lineNum">     592 </span>            :     NS_ASSERTION(docShell, &quot;doc should support nsIDocShellTreeItem.&quot;);
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">          1 :     if (docShell) {</span>
<span class="lineNum">     595 </span><span class="lineCov">          1 :       if (docShell-&gt;ItemType() == nsIDocShellTreeItem::typeContent) {</span>
<span class="lineNum">     596 </span><span class="lineCov">          1 :         nsCOMPtr&lt;nsICommandManager&gt; commandManager = docShell-&gt;GetCommandManager();</span>
<span class="lineNum">     597 </span><span class="lineCov">          1 :         if (commandManager) {</span>
<span class="lineNum">     598 </span><span class="lineCov">          1 :           commandManager-&gt;RemoveCommandObserver(this, &quot;obs_documentCreated&quot;);</span>
<span class="lineNum">     599 </span>            :         }
<span class="lineNum">     600 </span>            :       }
<span class="lineNum">     601 </span>            :     }
<span class="lineNum">     602 </span>            :   }
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineCov">          1 :   if (mScrollWatchTimer) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     mScrollWatchTimer-&gt;Cancel();</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     mScrollWatchTimer = nullptr;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     NS_RELEASE_THIS(); // Kung fu death grip</span>
<span class="lineNum">     608 </span>            :   }
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">          1 :   SelectionMgr()-&gt;RemoveDocSelectionListener(mPresShell);</span>
<span class="lineNum">     611 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     612 </span>            : }
<a name="613"><span class="lineNum">     613 </span>            : </a>
<span class="lineNum">     614 </span>            : void
<span class="lineNum">     615 </span><span class="lineNoCov">          0 : DocAccessible::ScrollTimerCallback(nsITimer* aTimer, void* aClosure)</span>
<span class="lineNum">     616 </span>            : {
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   DocAccessible* docAcc = reinterpret_cast&lt;DocAccessible*&gt;(aClosure);</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   if (docAcc &amp;&amp; docAcc-&gt;mScrollPositionChangedTicks &amp;&amp;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :       ++docAcc-&gt;mScrollPositionChangedTicks &gt; 2) {</span>
<span class="lineNum">     621 </span>            :     // Whenever scroll position changes, mScrollPositionChangeTicks gets reset to 1
<span class="lineNum">     622 </span>            :     // We only want to fire accessibilty scroll event when scrolling stops or pauses
<span class="lineNum">     623 </span>            :     // Therefore, we wait for no scroll events to occur between 2 ticks of this timer
<span class="lineNum">     624 </span>            :     // That indicates a pause in scrolling, so we fire the accessibilty scroll event
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SCROLLING_END, docAcc);</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     docAcc-&gt;mScrollPositionChangedTicks = 0;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     if (docAcc-&gt;mScrollWatchTimer) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       docAcc-&gt;mScrollWatchTimer-&gt;Cancel();</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :       docAcc-&gt;mScrollWatchTimer = nullptr;</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       NS_RELEASE(docAcc); // Release kung fu death grip</span>
<span class="lineNum">     632 </span>            :     }
<span class="lineNum">     633 </span>            :   }
<span class="lineNum">     634 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     637 </span>            : // nsIScrollPositionListener
<a name="638"><span class="lineNum">     638 </span>            : </a>
<span class="lineNum">     639 </span>            : void
<span class="lineNum">     640 </span><span class="lineNoCov">          0 : DocAccessible::ScrollPositionDidChange(nscoord aX, nscoord aY)</span>
<span class="lineNum">     641 </span>            : {
<span class="lineNum">     642 </span>            :   // Start new timer, if the timer cycles at least 1 full cycle without more scroll position changes,
<span class="lineNum">     643 </span>            :   // then the ::Notify() method will fire the accessibility event for scroll position changes
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   const uint32_t kScrollPosCheckWait = 50;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   if (mScrollWatchTimer) {</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     mScrollWatchTimer-&gt;SetDelay(kScrollPosCheckWait);  // Create new timer, to avoid leaks</span>
<span class="lineNum">     647 </span>            :   }
<span class="lineNum">     648 </span>            :   else {
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     mScrollWatchTimer = do_CreateInstance(&quot;@mozilla.org/timer;1&quot;);</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     if (mScrollWatchTimer) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :       NS_ADDREF_THIS(); // Kung fu death grip</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :       mScrollWatchTimer-&gt;InitWithFuncCallback(ScrollTimerCallback, this,</span>
<span class="lineNum">     653 </span>            :                                               kScrollPosCheckWait,
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                                               nsITimer::TYPE_REPEATING_SLACK);</span>
<span class="lineNum">     655 </span>            :     }
<span class="lineNum">     656 </span>            :   }
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   mScrollPositionChangedTicks = 1;</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     661 </span>            : // nsIObserver
<a name="662"><span class="lineNum">     662 </span>            : </a>
<span class="lineNum">     663 </span>            : NS_IMETHODIMP
<span class="lineNum">     664 </span><span class="lineCov">          1 : DocAccessible::Observe(nsISupports* aSubject, const char* aTopic,</span>
<span class="lineNum">     665 </span>            :                        const char16_t* aData)
<span class="lineNum">     666 </span>            : {
<span class="lineNum">     667 </span><span class="lineCov">          1 :   if (!nsCRT::strcmp(aTopic,&quot;obs_documentCreated&quot;)) {    </span>
<span class="lineNum">     668 </span>            :     // State editable will now be set, readonly is now clear
<span class="lineNum">     669 </span>            :     // Normally we only fire delayed events created from the node, not an
<span class="lineNum">     670 </span>            :     // accessible object. See the AccStateChangeEvent constructor for details
<span class="lineNum">     671 </span>            :     // about this exceptional case.
<span class="lineNum">     672 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     673 </span><span class="lineCov">          1 :       new AccStateChangeEvent(this, states::EDITABLE, true);</span>
<span class="lineNum">     674 </span><span class="lineCov">          1 :     FireDelayedEvent(event);</span>
<span class="lineNum">     675 </span>            :   }
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     678 </span>            : }
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     681 </span>            : // nsIAccessiblePivotObserver
<a name="682"><span class="lineNum">     682 </span>            : </a>
<span class="lineNum">     683 </span>            : NS_IMETHODIMP
<span class="lineNum">     684 </span><span class="lineNoCov">          0 : DocAccessible::OnPivotChanged(nsIAccessiblePivot* aPivot,</span>
<span class="lineNum">     685 </span>            :                               nsIAccessible* aOldAccessible,
<span class="lineNum">     686 </span>            :                               int32_t aOldStart, int32_t aOldEnd,
<span class="lineNum">     687 </span>            :                               PivotMoveReason aReason,
<span class="lineNum">     688 </span>            :                               bool aIsFromUserInput)
<span class="lineNum">     689 </span>            : {
<span class="lineNum">     690 </span>            :   RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     691 </span>            :     new AccVCChangeEvent(
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :       this, (aOldAccessible ? aOldAccessible-&gt;ToInternalAccessible() : nullptr),</span>
<span class="lineNum">     693 </span>            :       aOldStart, aOldEnd, aReason,
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       aIsFromUserInput ? eFromUserInput : eNoUserInput);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :   nsEventShell::FireEvent(event);</span>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     698 </span>            : }
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            : ////////////////////////////////////////////////////////////////////////////////
<a name="701"><span class="lineNum">     701 </span>            : // nsIDocumentObserver</a>
<a name="702"><span class="lineNum">     702 </span>            : </a>
<a name="703"><span class="lineNum">     703 </span><span class="lineCov">          1 : NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB(DocAccessible)</span></a>
<span class="lineNum">     704 </span><span class="lineCov">          1 : NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB(DocAccessible)</span>
<span class="lineNum">     705 </span><span class="lineCov">          1 : NS_IMPL_NSIDOCUMENTOBSERVER_STYLE_STUB(DocAccessible)</span>
<a name="706"><span class="lineNum">     706 </span>            : </a>
<span class="lineNum">     707 </span>            : void
<span class="lineNum">     708 </span><span class="lineCov">          1 : DocAccessible::AttributeWillChange(nsIDocument* aDocument,</span>
<span class="lineNum">     709 </span>            :                                    dom::Element* aElement,
<span class="lineNum">     710 </span>            :                                    int32_t aNameSpaceID,
<span class="lineNum">     711 </span>            :                                    nsIAtom* aAttribute, int32_t aModType,
<span class="lineNum">     712 </span>            :                                    const nsAttrValue* aNewValue)
<span class="lineNum">     713 </span>            : {
<span class="lineNum">     714 </span><span class="lineCov">          1 :   Accessible* accessible = GetAccessible(aElement);</span>
<span class="lineNum">     715 </span><span class="lineCov">          1 :   if (!accessible) {</span>
<span class="lineNum">     716 </span><span class="lineCov">          1 :     if (aElement != mContent)</span>
<span class="lineNum">     717 </span>            :       return;
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span><span class="lineCov">          1 :     accessible = this;</span>
<span class="lineNum">     720 </span>            :   }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :   // Update dependent IDs cache. Take care of elements that are accessible
<span class="lineNum">     723 </span>            :   // because dependent IDs cache doesn't contain IDs from non accessible
<span class="lineNum">     724 </span>            :   // elements.
<span class="lineNum">     725 </span><span class="lineCov">          1 :   if (aModType != nsIDOMMutationEvent::ADDITION)</span>
<span class="lineNum">     726 </span><span class="lineCov">          1 :     RemoveDependentIDsFor(accessible, aAttribute);</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::id) {</span>
<span class="lineNum">     729 </span><span class="lineCov">          1 :     RelocateARIAOwnedIfNeeded(aElement);</span>
<span class="lineNum">     730 </span>            :   }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :   // Store the ARIA attribute old value so that it can be used after
<span class="lineNum">     733 </span>            :   // attribute change. Note, we assume there's no nested ARIA attribute
<span class="lineNum">     734 </span>            :   // changes. If this happens then we should end up with keeping a stack of
<span class="lineNum">     735 </span>            :   // old values.
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   // XXX TODO: bugs 472142, 472143.
<span class="lineNum">     738 </span>            :   // Here we will want to cache whatever attribute values we are interested
<span class="lineNum">     739 </span>            :   // in, such as the existence of aria-pressed for button (so we know if we
<span class="lineNum">     740 </span>            :   // need to newly expose it as a toggle button) etc.
<span class="lineNum">     741 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_checked ||</span>
<span class="lineNum">     742 </span><span class="lineCov">          1 :       aAttribute == nsGkAtoms::aria_pressed) {</span>
<span class="lineNum">     743 </span>            :     mARIAAttrOldValue = (aModType != nsIDOMMutationEvent::ADDITION) ?
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       nsAccUtils::GetARIAToken(aElement, aAttribute) : nullptr;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     746 </span>            :   }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_disabled ||</span>
<span class="lineNum">     749 </span><span class="lineCov">          1 :       aAttribute == nsGkAtoms::disabled)</span>
<span class="lineNum">     750 </span><span class="lineCov">          1 :     mStateBitWasOn = accessible-&gt;Unavailable();</span>
<span class="lineNum">     751 </span>            : }
<a name="752"><span class="lineNum">     752 </span>            : </a>
<span class="lineNum">     753 </span>            : void
<span class="lineNum">     754 </span><span class="lineCov">          1 : DocAccessible::NativeAnonymousChildListChange(nsIDocument* aDocument,</span>
<span class="lineNum">     755 </span>            :                                               nsIContent* aContent,
<span class="lineNum">     756 </span>            :                                               bool aIsRemove)
<span class="lineNum">     757 </span>            : {
<span class="lineNum">     758 </span><span class="lineCov">          1 : }</span>
<a name="759"><span class="lineNum">     759 </span>            : </a>
<span class="lineNum">     760 </span>            : void
<span class="lineNum">     761 </span><span class="lineCov">          1 : DocAccessible::AttributeChanged(nsIDocument* aDocument,</span>
<span class="lineNum">     762 </span>            :                                 dom::Element* aElement,
<span class="lineNum">     763 </span>            :                                 int32_t aNameSpaceID, nsIAtom* aAttribute,
<span class="lineNum">     764 </span>            :                                 int32_t aModType,
<span class="lineNum">     765 </span>            :                                 const nsAttrValue* aOldValue)
<span class="lineNum">     766 </span>            : {
<span class="lineNum">     767 </span>            :   NS_ASSERTION(!IsDefunct(),
<span class="lineNum">     768 </span>            :                &quot;Attribute changed called on defunct document accessible!&quot;);
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :   // Proceed even if the element is not accessible because element may become
<span class="lineNum">     771 </span>            :   // accessible if it gets certain attribute.
<span class="lineNum">     772 </span><span class="lineCov">          1 :   if (UpdateAccessibleOnAttrChange(aElement, aAttribute))</span>
<span class="lineNum">     773 </span>            :     return;
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :   // Ignore attribute change if the element doesn't have an accessible (at all
<span class="lineNum">     776 </span>            :   // or still) iff the element is not a root content of this document accessible
<span class="lineNum">     777 </span>            :   // (which is treated as attribute change on this document accessible).
<span class="lineNum">     778 </span>            :   // Note: we don't bail if all the content hasn't finished loading because
<span class="lineNum">     779 </span>            :   // these attributes are changing for a loaded part of the content.
<span class="lineNum">     780 </span><span class="lineCov">          1 :   Accessible* accessible = GetAccessible(aElement);</span>
<span class="lineNum">     781 </span><span class="lineCov">          1 :   if (!accessible) {</span>
<span class="lineNum">     782 </span><span class="lineCov">          1 :     if (mContent != aElement)</span>
<span class="lineNum">     783 </span>            :       return;
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineCov">          1 :     accessible = this;</span>
<span class="lineNum">     786 </span>            :   }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :   MOZ_ASSERT(accessible-&gt;IsBoundToParent() || accessible-&gt;IsDoc(),
<span class="lineNum">     789 </span>            :              &quot;DOM attribute change on an accessible detached from the tree&quot;);
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :   // Fire accessible events iff there's an accessible, otherwise we consider
<span class="lineNum">     792 </span>            :   // the accessible state wasn't changed, i.e. its state is initial state.
<span class="lineNum">     793 </span><span class="lineCov">          1 :   AttributeChangedImpl(accessible, aNameSpaceID, aAttribute);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :   // Update dependent IDs cache. Take care of accessible elements because no
<span class="lineNum">     796 </span>            :   // accessible element means either the element is not accessible at all or
<span class="lineNum">     797 </span>            :   // its accessible will be created later. It doesn't make sense to keep
<span class="lineNum">     798 </span>            :   // dependent IDs for non accessible elements. For the second case we'll update
<span class="lineNum">     799 </span>            :   // dependent IDs cache when its accessible is created.
<span class="lineNum">     800 </span><span class="lineCov">          1 :   if (aModType == nsIDOMMutationEvent::MODIFICATION ||</span>
<span class="lineNum">     801 </span>            :       aModType == nsIDOMMutationEvent::ADDITION) {
<span class="lineNum">     802 </span><span class="lineCov">          1 :     AddDependentIDsFor(accessible, aAttribute);</span>
<span class="lineNum">     803 </span>            :   }
<span class="lineNum">     804 </span>            : }
<span class="lineNum">     805 </span>            : 
<a name="806"><span class="lineNum">     806 </span>            : // DocAccessible protected member</a>
<span class="lineNum">     807 </span>            : void
<span class="lineNum">     808 </span><span class="lineCov">          1 : DocAccessible::AttributeChangedImpl(Accessible* aAccessible,</span>
<span class="lineNum">     809 </span>            :                                     int32_t aNameSpaceID, nsIAtom* aAttribute)
<span class="lineNum">     810 </span>            : {
<span class="lineNum">     811 </span>            :   // Fire accessible event after short timer, because we need to wait for
<span class="lineNum">     812 </span>            :   // DOM attribute &amp; resulting layout to actually change. Otherwise,
<span class="lineNum">     813 </span>            :   // assistive technology will retrieve the wrong state/value/selection info.
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :   // XXX todo
<span class="lineNum">     816 </span>            :   // We still need to handle special HTML cases here
<span class="lineNum">     817 </span>            :   // For example, if an &lt;img&gt;'s usemap attribute is modified
<span class="lineNum">     818 </span>            :   // Otherwise it may just be a state change, for example an object changing
<span class="lineNum">     819 </span>            :   // its visibility
<span class="lineNum">     820 </span>            :   // 
<span class="lineNum">     821 </span>            :   // XXX todo: report aria state changes for &quot;undefined&quot; literal value changes
<span class="lineNum">     822 </span>            :   // filed as bug 472142
<span class="lineNum">     823 </span>            :   //
<span class="lineNum">     824 </span>            :   // XXX todo:  invalidate accessible when aria state changes affect exposed role
<span class="lineNum">     825 </span>            :   // filed as bug 472143
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :   // Universal boolean properties that don't require a role. Fire the state
<span class="lineNum">     828 </span>            :   // change when disabled or aria-disabled attribute is set.
<span class="lineNum">     829 </span>            :   // Note. Checking the XUL or HTML namespace would not seem to gain us
<span class="lineNum">     830 </span>            :   // anything, because disabled attribute really is going to mean the same
<span class="lineNum">     831 </span>            :   // thing in any namespace.
<span class="lineNum">     832 </span>            :   // Note. We use the attribute instead of the disabled state bit because
<span class="lineNum">     833 </span>            :   // ARIA's aria-disabled does not affect the disabled state bit.
<span class="lineNum">     834 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::disabled ||</span>
<span class="lineNum">     835 </span><span class="lineCov">          1 :       aAttribute == nsGkAtoms::aria_disabled) {</span>
<span class="lineNum">     836 </span>            :     // Do nothing if state wasn't changed (like @aria-disabled was removed but
<span class="lineNum">     837 </span>            :     // @disabled is still presented).
<span class="lineNum">     838 </span><span class="lineCov">          1 :     if (aAccessible-&gt;Unavailable() == mStateBitWasOn)</span>
<span class="lineNum">     839 </span>            :       return;
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :     RefPtr&lt;AccEvent&gt; enabledChangeEvent =
<span class="lineNum">     842 </span><span class="lineCov">          1 :       new AccStateChangeEvent(aAccessible, states::ENABLED, mStateBitWasOn);</span>
<span class="lineNum">     843 </span><span class="lineCov">          1 :     FireDelayedEvent(enabledChangeEvent);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :     RefPtr&lt;AccEvent&gt; sensitiveChangeEvent =
<span class="lineNum">     846 </span><span class="lineCov">          1 :       new AccStateChangeEvent(aAccessible, states::SENSITIVE, mStateBitWasOn);</span>
<span class="lineNum">     847 </span><span class="lineCov">          1 :     FireDelayedEvent(sensitiveChangeEvent);</span>
<span class="lineNum">     848 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     849 </span>            :   }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :   // Check for namespaced ARIA attribute
<span class="lineNum">     852 </span><span class="lineCov">          1 :   if (aNameSpaceID == kNameSpaceID_None) {</span>
<span class="lineNum">     853 </span>            :     // Check for hyphenated aria-foo property?
<span class="lineNum">     854 </span><span class="lineCov">          1 :     if (StringBeginsWith(nsDependentAtomString(aAttribute),</span>
<span class="lineNum">     855 </span><span class="lineCov">          1 :                          NS_LITERAL_STRING(&quot;aria-&quot;))) {</span>
<span class="lineNum">     856 </span><span class="lineCov">          1 :       ARIAAttributeChanged(aAccessible, aAttribute);</span>
<span class="lineNum">     857 </span>            :     }
<span class="lineNum">     858 </span>            :   }
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :   // Fire name change and description change events. XXX: it's not complete and
<span class="lineNum">     861 </span>            :   // dupes the code logic of accessible name and description calculation, we do
<span class="lineNum">     862 </span>            :   // that for performance reasons.
<span class="lineNum">     863 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_label) {</span>
<span class="lineNum">     864 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, aAccessible);</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     866 </span>            :   }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_describedby) {</span>
<span class="lineNum">     869 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_DESCRIPTION_CHANGE, aAccessible);</span>
<span class="lineNum">     870 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     871 </span>            :   }
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span><span class="lineCov">          1 :   nsIContent* elm = aAccessible-&gt;GetContent();</span>
<span class="lineNum">     874 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_labelledby &amp;&amp;</span>
<span class="lineNum">     875 </span><span class="lineCov">          1 :       !elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_label)) {</span>
<span class="lineNum">     876 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, aAccessible);</span>
<span class="lineNum">     877 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     878 </span>            :   }
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::alt &amp;&amp;</span>
<span class="lineNum">     881 </span><span class="lineCov">          1 :       !elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_label) &amp;&amp;</span>
<span class="lineNum">     882 </span><span class="lineCov">          1 :       !elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_labelledby)) {</span>
<span class="lineNum">     883 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, aAccessible);</span>
<span class="lineNum">     884 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     885 </span>            :   }
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::title) {</span>
<span class="lineNum">     888 </span><span class="lineCov">          1 :     if (!elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_label) &amp;&amp;</span>
<span class="lineNum">     889 </span><span class="lineCov">          1 :         !elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_labelledby) &amp;&amp;</span>
<span class="lineNum">     890 </span><span class="lineCov">          1 :         !elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::alt)) {</span>
<span class="lineNum">     891 </span><span class="lineCov">          1 :       FireDelayedEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, aAccessible);</span>
<span class="lineNum">     892 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     893 </span>            :     }
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">          1 :     if (!elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_describedby))</span>
<span class="lineNum">     896 </span><span class="lineCov">          1 :       FireDelayedEvent(nsIAccessibleEvent::EVENT_DESCRIPTION_CHANGE, aAccessible);</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            :     return;
<span class="lineNum">     899 </span>            :   }
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_busy) {</span>
<span class="lineNum">     902 </span>            :     bool isOn = elm-&gt;AttrValueIs(aNameSpaceID, aAttribute, nsGkAtoms::_true,
<span class="lineNum">     903 </span><span class="lineCov">          1 :                                  eCaseMatters);</span>
<span class="lineNum">     904 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     905 </span><span class="lineCov">          1 :       new AccStateChangeEvent(aAccessible, states::BUSY, isOn);</span>
<span class="lineNum">     906 </span><span class="lineCov">          1 :     FireDelayedEvent(event);</span>
<span class="lineNum">     907 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     908 </span>            :   }
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::id) {</span>
<span class="lineNum">     911 </span><span class="lineCov">          1 :     RelocateARIAOwnedIfNeeded(elm);</span>
<span class="lineNum">     912 </span>            :   }
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            :   // ARIA or XUL selection
<span class="lineNum">     915 </span><span class="lineCov">          1 :   if ((aAccessible-&gt;GetContent()-&gt;IsXULElement() &amp;&amp;</span>
<span class="lineNum">     916 </span><span class="lineCov">          1 :        aAttribute == nsGkAtoms::selected) ||</span>
<span class="lineNum">     917 </span><span class="lineCov">          1 :       aAttribute == nsGkAtoms::aria_selected) {</span>
<span class="lineNum">     918 </span>            :     Accessible* widget =
<span class="lineNum">     919 </span><span class="lineCov">          1 :       nsAccUtils::GetSelectableContainer(aAccessible, aAccessible-&gt;State());</span>
<span class="lineNum">     920 </span><span class="lineCov">          1 :     if (widget) {</span>
<span class="lineNum">     921 </span>            :       AccSelChangeEvent::SelChangeType selChangeType =
<span class="lineNum">     922 </span><span class="lineCov">          1 :         elm-&gt;AttrValueIs(aNameSpaceID, aAttribute, nsGkAtoms::_true, eCaseMatters) ?</span>
<span class="lineNum">     923 </span><span class="lineCov">          1 :           AccSelChangeEvent::eSelectionAdd : AccSelChangeEvent::eSelectionRemove;</span>
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :       RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     926 </span><span class="lineCov">          1 :         new AccSelChangeEvent(widget, aAccessible, selChangeType);</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :       FireDelayedEvent(event);</span>
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     return;
<span class="lineNum">     931 </span>            :   }
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::contenteditable) {</span>
<span class="lineNum">     934 </span>            :     RefPtr&lt;AccEvent&gt; editableChangeEvent =
<span class="lineNum">     935 </span><span class="lineCov">          1 :       new AccStateChangeEvent(aAccessible, states::EDITABLE);</span>
<span class="lineNum">     936 </span><span class="lineCov">          1 :     FireDelayedEvent(editableChangeEvent);</span>
<span class="lineNum">     937 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     938 </span>            :   }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::value) {</span>
<span class="lineNum">     941 </span><span class="lineCov">          1 :     if (aAccessible-&gt;IsProgress())</span>
<span class="lineNum">     942 </span><span class="lineCov">          1 :       FireDelayedEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, aAccessible);</span>
<span class="lineNum">     943 </span>            :   }
<span class="lineNum">     944 </span>            : }
<span class="lineNum">     945 </span>            : 
<a name="946"><span class="lineNum">     946 </span>            : // DocAccessible protected member</a>
<span class="lineNum">     947 </span>            : void
<span class="lineNum">     948 </span><span class="lineCov">          1 : DocAccessible::ARIAAttributeChanged(Accessible* aAccessible, nsIAtom* aAttribute)</span>
<span class="lineNum">     949 </span>            : {
<span class="lineNum">     950 </span>            :   // Note: For universal/global ARIA states and properties we don't care if
<span class="lineNum">     951 </span>            :   // there is an ARIA role present or not.
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_required) {</span>
<span class="lineNum">     954 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     955 </span><span class="lineCov">          1 :       new AccStateChangeEvent(aAccessible, states::REQUIRED);</span>
<span class="lineNum">     956 </span><span class="lineCov">          1 :     FireDelayedEvent(event);</span>
<span class="lineNum">     957 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     958 </span>            :   }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_invalid) {</span>
<span class="lineNum">     961 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     962 </span><span class="lineCov">          1 :       new AccStateChangeEvent(aAccessible, states::INVALID);</span>
<span class="lineNum">     963 </span><span class="lineCov">          1 :     FireDelayedEvent(event);</span>
<span class="lineNum">     964 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     965 </span>            :   }
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :   // The activedescendant universal property redirects accessible focus events
<span class="lineNum">     968 </span>            :   // to the element with the id that activedescendant points to. Make sure
<span class="lineNum">     969 </span>            :   // the tree up to date before processing.
<span class="lineNum">     970 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_activedescendant) {</span>
<span class="lineNum">     971 </span>            :     mNotificationController-&gt;HandleNotification&lt;DocAccessible, Accessible&gt;
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :       (this, &amp;DocAccessible::ARIAActiveDescendantChanged, aAccessible);</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     975 </span>            :   }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :   // We treat aria-expanded as a global ARIA state for historical reasons
<span class="lineNum">     978 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_expanded) {</span>
<span class="lineNum">     979 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :       new AccStateChangeEvent(aAccessible, states::EXPANDED);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     FireDelayedEvent(event);</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     983 </span>            :   }
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :   // For aria attributes like drag and drop changes we fire a generic attribute
<span class="lineNum">     986 </span>            :   // change event; at least until native API comes up with a more meaningful event.
<span class="lineNum">     987 </span><span class="lineCov">          1 :   uint8_t attrFlags = aria::AttrCharacteristicsFor(aAttribute);</span>
<span class="lineNum">     988 </span><span class="lineCov">          1 :   if (!(attrFlags &amp; ATTR_BYPASSOBJ)) {</span>
<span class="lineNum">     989 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">     990 </span><span class="lineCov">          1 :       new AccObjectAttrChangedEvent(aAccessible, aAttribute);</span>
<span class="lineNum">     991 </span><span class="lineCov">          1 :     FireDelayedEvent(event);</span>
<span class="lineNum">     992 </span>            :   }
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineCov">          1 :   nsIContent* elm = aAccessible-&gt;GetContent();</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :   // Update aria-hidden flag for the whole subtree iff aria-hidden is changed
<span class="lineNum">     997 </span>            :   // on the root, i.e. ignore any affiliated aria-hidden changes in the subtree
<span class="lineNum">     998 </span>            :   // of top aria-hidden.
<span class="lineNum">     999 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_hidden) {</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     bool isDefined = aria::HasDefinedARIAHidden(elm);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     if (isDefined != aAccessible-&gt;IsARIAHidden() &amp;&amp;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         (!aAccessible-&gt;Parent() || !aAccessible-&gt;Parent()-&gt;IsARIAHidden())) {</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :       aAccessible-&gt;SetARIAHidden(isDefined);</span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            :       RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         new AccObjectAttrChangedEvent(aAccessible, aAttribute);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :       FireDelayedEvent(event);</span>
<span class="lineNum">    1008 </span>            :     }
<span class="lineNum">    1009 </span>            :     return;
<span class="lineNum">    1010 </span>            :   }
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_checked ||</span>
<span class="lineNum">    1013 </span><span class="lineCov">          1 :       (aAccessible-&gt;IsButton() &amp;&amp;</span>
<span class="lineNum">    1014 </span><span class="lineCov">          1 :        aAttribute == nsGkAtoms::aria_pressed)) {</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     const uint64_t kState = (aAttribute == nsGkAtoms::aria_checked) ?</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :                             states::CHECKED : states::PRESSED;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     RefPtr&lt;AccEvent&gt; event = new AccStateChangeEvent(aAccessible, kState);</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     FireDelayedEvent(event);</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     bool wasMixed = (mARIAAttrOldValue == nsGkAtoms::mixed);</span>
<span class="lineNum">    1021 </span>            :     bool isMixed = elm-&gt;AttrValueIs(kNameSpaceID_None, aAttribute,
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                                     nsGkAtoms::mixed, eCaseMatters);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     if (isMixed != wasMixed) {</span>
<span class="lineNum">    1024 </span>            :       RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :         new AccStateChangeEvent(aAccessible, states::MIXED, isMixed);</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :       FireDelayedEvent(event);</span>
<span class="lineNum">    1027 </span>            :     }
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1029 </span>            :   }
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_readonly) {</span>
<span class="lineNum">    1032 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :       new AccStateChangeEvent(aAccessible, states::READONLY);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     FireDelayedEvent(event);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1036 </span>            :   }
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :   // Fire text value change event whenever aria-valuetext is changed.
<span class="lineNum">    1039 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_valuetext) {</span>
<span class="lineNum">    1040 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_TEXT_VALUE_CHANGE, aAccessible);</span>
<span class="lineNum">    1041 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1042 </span>            :   }
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :   // Fire numeric value change event when aria-valuenow is changed and
<span class="lineNum">    1045 </span>            :   // aria-valuetext is empty
<span class="lineNum">    1046 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_valuenow &amp;&amp;</span>
<span class="lineNum">    1047 </span><span class="lineCov">          1 :       (!elm-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_valuetext) ||</span>
<span class="lineNum">    1048 </span>            :        elm-&gt;AttrValueIs(kNameSpaceID_None, nsGkAtoms::aria_valuetext,
<span class="lineNum">    1049 </span><span class="lineCov">          1 :                         nsGkAtoms::_empty, eCaseMatters))) {</span>
<span class="lineNum">    1050 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, aAccessible);</span>
<span class="lineNum">    1051 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1052 </span>            :   }
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_owns) {</span>
<span class="lineNum">    1055 </span><span class="lineCov">          1 :     mNotificationController-&gt;ScheduleRelocation(aAccessible);</span>
<span class="lineNum">    1056 </span>            :   }
<span class="lineNum">    1057 </span>            : }
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<span class="lineNum">    1059 </span>            : void
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 : DocAccessible::ARIAActiveDescendantChanged(Accessible* aAccessible)</span>
<span class="lineNum">    1061 </span>            : {
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   nsIContent* elm = aAccessible-&gt;GetContent();</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   if (elm &amp;&amp; aAccessible-&gt;IsActiveWidget()) {</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     nsAutoString id;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     if (elm-&gt;GetAttr(kNameSpaceID_None, nsGkAtoms::aria_activedescendant, id)) {</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :       dom::Element* activeDescendantElm = elm-&gt;OwnerDoc()-&gt;GetElementById(id);</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       if (activeDescendantElm) {</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         Accessible* activeDescendant = GetAccessible(activeDescendantElm);</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :         if (activeDescendant) {</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :           FocusMgr()-&gt;ActiveItemChanged(activeDescendant, false);</span>
<span class="lineNum">    1071 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :           if (logging::IsEnabled(logging::eFocus))</span>
<span class="lineNum">    1073 </span>            :             logging::ActiveItemChangeCausedBy(&quot;ARIA activedescedant changed&quot;,
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                                               activeDescendant);</span>
<span class="lineNum">    1075 </span>            : #endif
<span class="lineNum">    1076 </span>            :         }
<span class="lineNum">    1077 </span>            :       }
<span class="lineNum">    1078 </span>            :     }
<span class="lineNum">    1079 </span>            :   }
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 : }</span>
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<span class="lineNum">    1082 </span>            : void
<span class="lineNum">    1083 </span><span class="lineCov">          1 : DocAccessible::ContentAppended(nsIDocument* aDocument,</span>
<span class="lineNum">    1084 </span>            :                                nsIContent* aContainer,
<span class="lineNum">    1085 </span>            :                                nsIContent* aFirstNewContent,
<span class="lineNum">    1086 </span>            :                                int32_t /* unused */)
<span class="lineNum">    1087 </span>            : {
<span class="lineNum">    1088 </span><span class="lineCov">          1 : }</span>
<a name="1089"><span class="lineNum">    1089 </span>            : </a>
<span class="lineNum">    1090 </span>            : void
<span class="lineNum">    1091 </span><span class="lineCov">          1 : DocAccessible::ContentStateChanged(nsIDocument* aDocument,</span>
<span class="lineNum">    1092 </span>            :                                    nsIContent* aContent,
<span class="lineNum">    1093 </span>            :                                    EventStates aStateMask)
<span class="lineNum">    1094 </span>            : {
<span class="lineNum">    1095 </span><span class="lineCov">          1 :   Accessible* accessible = GetAccessible(aContent);</span>
<span class="lineNum">    1096 </span><span class="lineCov">          1 :   if (!accessible)</span>
<span class="lineNum">    1097 </span>            :     return;
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span><span class="lineCov">          1 :   if (aStateMask.HasState(NS_EVENT_STATE_CHECKED)) {</span>
<span class="lineNum">    1100 </span><span class="lineCov">          1 :     Accessible* widget = accessible-&gt;ContainerWidget();</span>
<span class="lineNum">    1101 </span><span class="lineCov">          1 :     if (widget &amp;&amp; widget-&gt;IsSelect()) {</span>
<span class="lineNum">    1102 </span>            :       AccSelChangeEvent::SelChangeType selChangeType =
<span class="lineNum">    1103 </span><span class="lineCov">          1 :         aContent-&gt;AsElement()-&gt;State().HasState(NS_EVENT_STATE_CHECKED) ?</span>
<span class="lineNum">    1104 </span><span class="lineCov">          1 :           AccSelChangeEvent::eSelectionAdd : AccSelChangeEvent::eSelectionRemove;</span>
<span class="lineNum">    1105 </span>            :       RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1106 </span><span class="lineCov">          1 :         new AccSelChangeEvent(widget, accessible, selChangeType);</span>
<span class="lineNum">    1107 </span><span class="lineCov">          1 :       FireDelayedEvent(event);</span>
<span class="lineNum">    1108 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">    1109 </span>            :     }
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1112 </span>            :       new AccStateChangeEvent(accessible, states::CHECKED,
<span class="lineNum">    1113 </span><span class="lineCov">          1 :                               aContent-&gt;AsElement()-&gt;State().HasState(NS_EVENT_STATE_CHECKED));</span>
<span class="lineNum">    1114 </span><span class="lineCov">          1 :     FireDelayedEvent(event);</span>
<span class="lineNum">    1115 </span>            :   }
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineCov">          1 :   if (aStateMask.HasState(NS_EVENT_STATE_INVALID)) {</span>
<span class="lineNum">    1118 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       new AccStateChangeEvent(accessible, states::INVALID, true);</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     FireDelayedEvent(event);</span>
<span class="lineNum">    1121 </span>            :   }
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineCov">          1 :   if (aStateMask.HasState(NS_EVENT_STATE_VISITED)) {</span>
<span class="lineNum">    1124 </span>            :     RefPtr&lt;AccEvent&gt; event =
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :       new AccStateChangeEvent(accessible, states::TRAVERSED, true);</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     FireDelayedEvent(event);</span>
<span class="lineNum">    1127 </span>            :   }
<span class="lineNum">    1128 </span>            : }
<a name="1129"><span class="lineNum">    1129 </span>            : </a>
<span class="lineNum">    1130 </span>            : void
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 : DocAccessible::DocumentStatesChanged(nsIDocument* aDocument,</span>
<span class="lineNum">    1132 </span>            :                                      EventStates aStateMask)
<span class="lineNum">    1133 </span>            : {
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 : }</span>
<a name="1135"><span class="lineNum">    1135 </span>            : </a>
<span class="lineNum">    1136 </span>            : void
<span class="lineNum">    1137 </span><span class="lineCov">          1 : DocAccessible::CharacterDataWillChange(nsIDocument* aDocument,</span>
<span class="lineNum">    1138 </span>            :                                        nsIContent* aContent,
<span class="lineNum">    1139 </span>            :                                        CharacterDataChangeInfo* aInfo)
<span class="lineNum">    1140 </span>            : {
<span class="lineNum">    1141 </span><span class="lineCov">          1 : }</span>
<a name="1142"><span class="lineNum">    1142 </span>            : </a>
<span class="lineNum">    1143 </span>            : void
<span class="lineNum">    1144 </span><span class="lineCov">          1 : DocAccessible::CharacterDataChanged(nsIDocument* aDocument,</span>
<span class="lineNum">    1145 </span>            :                                     nsIContent* aContent,
<span class="lineNum">    1146 </span>            :                                     CharacterDataChangeInfo* aInfo)
<span class="lineNum">    1147 </span>            : {
<span class="lineNum">    1148 </span><span class="lineCov">          1 : }</span>
<a name="1149"><span class="lineNum">    1149 </span>            : </a>
<span class="lineNum">    1150 </span>            : void
<span class="lineNum">    1151 </span><span class="lineCov">          1 : DocAccessible::ContentInserted(nsIDocument* aDocument, nsIContent* aContainer,</span>
<span class="lineNum">    1152 </span>            :                                nsIContent* aChild, int32_t /* unused */)
<span class="lineNum">    1153 </span>            : {
<span class="lineNum">    1154 </span><span class="lineCov">          1 : }</span>
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<span class="lineNum">    1156 </span>            : void
<span class="lineNum">    1157 </span><span class="lineCov">          1 : DocAccessible::ContentRemoved(nsIDocument* aDocument,</span>
<span class="lineNum">    1158 </span>            :                               nsIContent* aContainerNode,
<span class="lineNum">    1159 </span>            :                               nsIContent* aChildNode, int32_t /* unused */,
<span class="lineNum">    1160 </span>            :                               nsIContent* aPreviousSiblingNode)
<span class="lineNum">    1161 </span>            : {
<span class="lineNum">    1162 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1163 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eTree)) {</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :     logging::MsgBegin(&quot;TREE&quot;, &quot;DOM content removed; doc: %p&quot;, this);</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :     logging::Node(&quot;container node&quot;, aContainerNode);</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :     logging::Node(&quot;content node&quot;, aChildNode);</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     logging::MsgEnd();</span>
<span class="lineNum">    1168 </span>            :   }
<span class="lineNum">    1169 </span>            : #endif
<span class="lineNum">    1170 </span>            :   // This one and content removal notification from layout may result in
<span class="lineNum">    1171 </span>            :   // double processing of same subtrees. If it pops up in profiling, then
<span class="lineNum">    1172 </span>            :   // consider reusing a document node cache to reject these notifications early.
<span class="lineNum">    1173 </span><span class="lineCov">          1 :   Accessible* container = GetAccessibleOrContainer(aContainerNode);</span>
<span class="lineNum">    1174 </span><span class="lineCov">          1 :   if (container) {</span>
<span class="lineNum">    1175 </span><span class="lineCov">          1 :     UpdateTreeOnRemoval(container, aChildNode);</span>
<span class="lineNum">    1176 </span>            :   }
<span class="lineNum">    1177 </span><span class="lineCov">          1 : }</span>
<a name="1178"><span class="lineNum">    1178 </span>            : </a>
<span class="lineNum">    1179 </span>            : void
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 : DocAccessible::ParentChainChanged(nsIContent* aContent)</span>
<span class="lineNum">    1181 </span>            : {
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1186 </span>            : // Accessible
<span class="lineNum">    1187 </span>            : 
<a name="1188"><span class="lineNum">    1188 </span>            : #ifdef A11Y_LOG</a>
<span class="lineNum">    1189 </span>            : nsresult
<span class="lineNum">    1190 </span><span class="lineCov">          1 : DocAccessible::HandleAccEvent(AccEvent* aEvent)</span>
<span class="lineNum">    1191 </span>            : {
<span class="lineNum">    1192 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eDocLoad))</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     logging::DocLoadEventHandled(aEvent);</span>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineCov">          1 :   return HyperTextAccessible::HandleAccEvent(aEvent);</span>
<span class="lineNum">    1196 </span>            : }
<span class="lineNum">    1197 </span>            : #endif
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1200 </span>            : // Public members
<a name="1201"><span class="lineNum">    1201 </span>            : </a>
<span class="lineNum">    1202 </span>            : void*
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 : DocAccessible::GetNativeWindow() const</span>
<span class="lineNum">    1204 </span>            : {
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :   if (!mPresShell)</span>
<span class="lineNum">    1206 </span>            :     return nullptr;
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   nsViewManager* vm = mPresShell-&gt;GetViewManager();</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   if (!vm)</span>
<span class="lineNum">    1210 </span>            :     return nullptr;
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :   nsCOMPtr&lt;nsIWidget&gt; widget;
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   vm-&gt;GetRootWidget(getter_AddRefs(widget));</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   if (widget)</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     return widget-&gt;GetNativeData(NS_NATIVE_WINDOW);</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            :   return nullptr;
<span class="lineNum">    1218 </span>            : }
<a name="1219"><span class="lineNum">    1219 </span>            : </a>
<span class="lineNum">    1220 </span>            : Accessible*
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 : DocAccessible::GetAccessibleByUniqueIDInSubtree(void* aUniqueID)</span>
<span class="lineNum">    1222 </span>            : {
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   Accessible* child = GetAccessibleByUniqueID(aUniqueID);</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :   if (child)</span>
<span class="lineNum">    1225 </span>            :     return child;
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :   uint32_t childDocCount = mChildDocuments.Length();</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   for (uint32_t childDocIdx= 0; childDocIdx &lt; childDocCount; childDocIdx++) {</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     DocAccessible* childDocument = mChildDocuments.ElementAt(childDocIdx);</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     child = childDocument-&gt;GetAccessibleByUniqueIDInSubtree(aUniqueID);</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     if (child)</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       return child;</span>
<span class="lineNum">    1233 </span>            :   }
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            :   return nullptr;
<span class="lineNum">    1236 </span>            : }
<a name="1237"><span class="lineNum">    1237 </span>            : </a>
<span class="lineNum">    1238 </span>            : Accessible*
<span class="lineNum">    1239 </span><span class="lineCov">          1 : DocAccessible::GetAccessibleOrContainer(nsINode* aNode) const</span>
<span class="lineNum">    1240 </span>            : {
<span class="lineNum">    1241 </span><span class="lineCov">          1 :   if (!aNode || !aNode-&gt;GetComposedDoc())</span>
<span class="lineNum">    1242 </span>            :     return nullptr;
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            :   nsINode* currNode = aNode;
<span class="lineNum">    1245 </span>            :   Accessible* accessible = nullptr;
<span class="lineNum">    1246 </span><span class="lineCov">          1 :   while (!(accessible = GetAccessible(currNode))) {</span>
<span class="lineNum">    1247 </span><span class="lineCov">          1 :     nsINode* parent = nullptr;</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :     // If this is a content node, try to get a flattened parent content node.
<span class="lineNum">    1250 </span>            :     // This will smartly skip from the shadow root to the host element,
<span class="lineNum">    1251 </span>            :     // over parentless document fragment
<span class="lineNum">    1252 </span><span class="lineCov">          1 :     if (currNode-&gt;IsContent())</span>
<span class="lineNum">    1253 </span><span class="lineCov">          1 :       parent = currNode-&gt;AsContent()-&gt;GetFlattenedTreeParent();</span>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            :     // Fallback to just get parent node, in case there is no parent content
<span class="lineNum">    1256 </span>            :     // node. Or current node is not a content node.
<span class="lineNum">    1257 </span><span class="lineCov">          1 :     if (!parent)</span>
<span class="lineNum">    1258 </span><span class="lineCov">          1 :       parent = currNode-&gt;GetParentNode();</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineCov">          1 :     if (!(currNode = parent)) break;</span>
<span class="lineNum">    1261 </span>            :   }
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span><span class="lineCov">          1 :   return accessible;</span>
<span class="lineNum">    1264 </span>            : }
<a name="1265"><span class="lineNum">    1265 </span>            : </a>
<span class="lineNum">    1266 </span>            : Accessible*
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 : DocAccessible::GetAccessibleOrDescendant(nsINode* aNode) const</span>
<span class="lineNum">    1268 </span>            : {
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   Accessible* acc = GetAccessible(aNode);</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   if (acc)</span>
<span class="lineNum">    1271 </span>            :     return acc;
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :   acc = GetContainerAccessible(aNode);</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :   if (acc) {</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     uint32_t childCnt = acc-&gt;ChildCount();</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :     for (uint32_t idx = 0; idx &lt; childCnt; idx++) {</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :       Accessible* child = acc-&gt;GetChildAt(idx);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :       for (nsIContent* elm = child-&gt;GetContent();</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :            elm &amp;&amp; elm != acc-&gt;GetContent();</span>
<span class="lineNum">    1280 </span>            :            elm = elm-&gt;GetFlattenedTreeParent()) {
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :         if (elm == aNode)</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :           return child;</span>
<span class="lineNum">    1283 </span>            :       }
<span class="lineNum">    1284 </span>            :     }
<span class="lineNum">    1285 </span>            :   }
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :   return nullptr;
<span class="lineNum">    1288 </span>            : }
<a name="1289"><span class="lineNum">    1289 </span>            : </a>
<span class="lineNum">    1290 </span>            : void
<span class="lineNum">    1291 </span><span class="lineCov">          1 : DocAccessible::BindToDocument(Accessible* aAccessible,</span>
<span class="lineNum">    1292 </span>            :                               const nsRoleMapEntry* aRoleMapEntry)
<span class="lineNum">    1293 </span>            : {
<span class="lineNum">    1294 </span>            :   // Put into DOM node cache.
<span class="lineNum">    1295 </span><span class="lineCov">          1 :   if (aAccessible-&gt;IsNodeMapEntry())</span>
<span class="lineNum">    1296 </span><span class="lineCov">          1 :     mNodeToAccessibleMap.Put(aAccessible-&gt;GetNode(), aAccessible);</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :   // Put into unique ID cache.
<span class="lineNum">    1299 </span><span class="lineCov">          1 :   mAccessibleCache.Put(aAccessible-&gt;UniqueID(), aAccessible);</span>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineCov">          1 :   aAccessible-&gt;SetRoleMapEntry(aRoleMapEntry);</span>
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span><span class="lineCov">          1 :   AddDependentIDsFor(aAccessible);</span>
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span><span class="lineCov">          1 :   if (aAccessible-&gt;HasOwnContent()) {</span>
<span class="lineNum">    1306 </span><span class="lineCov">          1 :     nsIContent* el = aAccessible-&gt;GetContent();</span>
<span class="lineNum">    1307 </span><span class="lineCov">          1 :     if (el-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::aria_owns)) {</span>
<span class="lineNum">    1308 </span><span class="lineCov">          1 :       mNotificationController-&gt;ScheduleRelocation(aAccessible);</span>
<span class="lineNum">    1309 </span>            :     }
<span class="lineNum">    1310 </span>            :   }
<span class="lineNum">    1311 </span><span class="lineCov">          1 : }</span>
<a name="1312"><span class="lineNum">    1312 </span>            : </a>
<span class="lineNum">    1313 </span>            : void
<span class="lineNum">    1314 </span><span class="lineCov">          1 : DocAccessible::UnbindFromDocument(Accessible* aAccessible)</span>
<span class="lineNum">    1315 </span>            : {
<span class="lineNum">    1316 </span>            :   NS_ASSERTION(mAccessibleCache.GetWeak(aAccessible-&gt;UniqueID()),
<span class="lineNum">    1317 </span>            :                &quot;Unbinding the unbound accessible!&quot;);
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :   // Fire focus event on accessible having DOM focus if active item was removed
<span class="lineNum">    1320 </span>            :   // from the tree.
<span class="lineNum">    1321 </span><span class="lineCov">          1 :   if (FocusMgr()-&gt;IsActiveItem(aAccessible)) {</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     FocusMgr()-&gt;ActiveItemChanged(nullptr);</span>
<span class="lineNum">    1323 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :           if (logging::IsEnabled(logging::eFocus))</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :             logging::ActiveItemChangeCausedBy(&quot;tree shutdown&quot;, aAccessible);</span>
<span class="lineNum">    1326 </span>            : #endif
<span class="lineNum">    1327 </span>            :   }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :   // Remove an accessible from node-to-accessible map if it exists there.
<span class="lineNum">    1330 </span><span class="lineCov">          1 :   if (aAccessible-&gt;IsNodeMapEntry() &amp;&amp;</span>
<span class="lineNum">    1331 </span><span class="lineCov">          1 :       mNodeToAccessibleMap.Get(aAccessible-&gt;GetNode()) == aAccessible)</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :     mNodeToAccessibleMap.Remove(aAccessible-&gt;GetNode());</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            :   // Update XPCOM part.
<span class="lineNum">    1335 </span><span class="lineCov">          1 :   xpcAccessibleDocument* xpcDoc = GetAccService()-&gt;GetCachedXPCDocument(this);</span>
<span class="lineNum">    1336 </span><span class="lineCov">          1 :   if (xpcDoc)</span>
<span class="lineNum">    1337 </span><span class="lineCov">          1 :     xpcDoc-&gt;NotifyOfShutdown(aAccessible);</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineCov">          1 :   void* uniqueID = aAccessible-&gt;UniqueID();</span>
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            :   NS_ASSERTION(!aAccessible-&gt;IsDefunct(), &quot;Shutdown the shutdown accessible!&quot;);
<span class="lineNum">    1342 </span><span class="lineCov">          1 :   aAccessible-&gt;Shutdown();</span>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span><span class="lineCov">          1 :   mAccessibleCache.Remove(uniqueID);</span>
<span class="lineNum">    1345 </span><span class="lineCov">          1 : }</span>
<a name="1346"><span class="lineNum">    1346 </span>            : </a>
<span class="lineNum">    1347 </span>            : void
<span class="lineNum">    1348 </span><span class="lineCov">          1 : DocAccessible::ContentInserted(nsIContent* aContainerNode,</span>
<span class="lineNum">    1349 </span>            :                                nsIContent* aStartChildNode,
<span class="lineNum">    1350 </span>            :                                nsIContent* aEndChildNode)
<span class="lineNum">    1351 </span>            : {
<span class="lineNum">    1352 </span>            :   // Ignore content insertions until we constructed accessible tree. Otherwise
<span class="lineNum">    1353 </span>            :   // schedule tree update on content insertion after layout.
<span class="lineNum">    1354 </span><span class="lineCov">          1 :   if (mNotificationController &amp;&amp; HasLoadState(eTreeConstructed)) {</span>
<span class="lineNum">    1355 </span>            :     // Update the whole tree of this document accessible when the container is
<span class="lineNum">    1356 </span>            :     // null (document element is inserted or removed).
<span class="lineNum">    1357 </span>            :     Accessible* container = aContainerNode ?
<span class="lineNum">    1358 </span><span class="lineCov">          1 :       AccessibleOrTrueContainer(aContainerNode) : this;</span>
<span class="lineNum">    1359 </span><span class="lineCov">          1 :     if (container) {</span>
<span class="lineNum">    1360 </span>            :       // Ignore notification if the container node is no longer in the DOM tree.
<span class="lineNum">    1361 </span>            :       mNotificationController-&gt;ScheduleContentInsertion(container,
<span class="lineNum">    1362 </span>            :                                                         aStartChildNode,
<span class="lineNum">    1363 </span><span class="lineCov">          1 :                                                         aEndChildNode);</span>
<span class="lineNum">    1364 </span>            :     }
<span class="lineNum">    1365 </span>            :   }
<span class="lineNum">    1366 </span><span class="lineCov">          1 : }</span>
<a name="1367"><span class="lineNum">    1367 </span>            : </a>
<span class="lineNum">    1368 </span>            : void
<span class="lineNum">    1369 </span><span class="lineCov">          1 : DocAccessible::RecreateAccessible(nsIContent* aContent)</span>
<span class="lineNum">    1370 </span>            : {
<span class="lineNum">    1371 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1372 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eTree)) {</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     logging::MsgBegin(&quot;TREE&quot;, &quot;accessible recreated&quot;);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     logging::Node(&quot;content&quot;, aContent);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     logging::MsgEnd();</span>
<span class="lineNum">    1376 </span>            :   }
<span class="lineNum">    1377 </span>            : #endif
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :   // XXX: we shouldn't recreate whole accessible subtree, instead we should
<span class="lineNum">    1380 </span>            :   // subclass hide and show events to handle them separately and implement their
<span class="lineNum">    1381 </span>            :   // coalescence with normal hide and show events. Note, in this case they
<span class="lineNum">    1382 </span>            :   // should be coalesced with normal show/hide events.
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineCov">          1 :   nsIContent* parent = aContent-&gt;GetFlattenedTreeParent();</span>
<span class="lineNum">    1385 </span><span class="lineCov">          1 :   ContentRemoved(parent, aContent);</span>
<span class="lineNum">    1386 </span><span class="lineCov">          1 :   ContentInserted(parent, aContent, aContent-&gt;GetNextSibling());</span>
<span class="lineNum">    1387 </span><span class="lineCov">          1 : }</span>
<a name="1388"><span class="lineNum">    1388 </span>            : </a>
<span class="lineNum">    1389 </span>            : void
<span class="lineNum">    1390 </span><span class="lineCov">          1 : DocAccessible::ProcessInvalidationList()</span>
<span class="lineNum">    1391 </span>            : {
<span class="lineNum">    1392 </span>            :   // Invalidate children of container accessible for each element in
<span class="lineNum">    1393 </span>            :   // invalidation list. Allow invalidation list insertions while container
<span class="lineNum">    1394 </span>            :   // children are recached.
<span class="lineNum">    1395 </span><span class="lineCov">          1 :   for (uint32_t idx = 0; idx &lt; mInvalidationList.Length(); idx++) {</span>
<span class="lineNum">    1396 </span><span class="lineCov">          1 :     nsIContent* content = mInvalidationList[idx];</span>
<span class="lineNum">    1397 </span><span class="lineCov">          1 :     if (!HasAccessible(content) &amp;&amp; content-&gt;HasID()) {</span>
<span class="lineNum">    1398 </span><span class="lineCov">          1 :       Accessible* container = GetContainerAccessible(content);</span>
<span class="lineNum">    1399 </span><span class="lineCov">          1 :       if (container) {</span>
<span class="lineNum">    1400 </span>            :         // Check if the node is a target of aria-owns, and if so, don't process
<span class="lineNum">    1401 </span>            :         // it here and let DoARIAOwnsRelocation process it.
<span class="lineNum">    1402 </span>            :         AttrRelProviderArray* list =
<span class="lineNum">    1403 </span><span class="lineCov">          1 :           mDependentIDsHash.Get(nsDependentAtomString(content-&gt;GetID()));</span>
<span class="lineNum">    1404 </span><span class="lineCov">          1 :         bool shouldProcess = !!list;</span>
<span class="lineNum">    1405 </span><span class="lineCov">          1 :         if (shouldProcess) {</span>
<span class="lineNum">    1406 </span><span class="lineCov">          1 :           for (uint32_t idx = 0; idx &lt; list-&gt;Length(); idx++) {</span>
<span class="lineNum">    1407 </span><span class="lineCov">          1 :             if (list-&gt;ElementAt(idx)-&gt;mRelAttr == nsGkAtoms::aria_owns) {</span>
<span class="lineNum">    1408 </span>            :               shouldProcess = false;
<span class="lineNum">    1409 </span>            :               break;
<span class="lineNum">    1410 </span>            :             }
<span class="lineNum">    1411 </span>            :           }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span><span class="lineCov">          1 :           if (shouldProcess) {</span>
<span class="lineNum">    1414 </span><span class="lineCov">          1 :             ProcessContentInserted(container, content);</span>
<span class="lineNum">    1415 </span>            :           }
<span class="lineNum">    1416 </span>            :         }
<span class="lineNum">    1417 </span>            :       }
<span class="lineNum">    1418 </span>            :     }
<span class="lineNum">    1419 </span>            :   }
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineCov">          1 :   mInvalidationList.Clear();</span>
<span class="lineNum">    1422 </span><span class="lineCov">          1 : }</span>
<a name="1423"><span class="lineNum">    1423 </span>            : </a>
<span class="lineNum">    1424 </span>            : Accessible*
<span class="lineNum">    1425 </span><span class="lineCov">          1 : DocAccessible::GetAccessibleEvenIfNotInMap(nsINode* aNode) const</span>
<span class="lineNum">    1426 </span>            : {
<span class="lineNum">    1427 </span><span class="lineCov">          1 : if (!aNode-&gt;IsContent() || !aNode-&gt;AsContent()-&gt;IsHTMLElement(nsGkAtoms::area))</span>
<span class="lineNum">    1428 </span><span class="lineCov">          1 :     return GetAccessible(aNode);</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :   // XXX Bug 135040, incorrect when multiple images use the same map.
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :   nsIFrame* frame = aNode-&gt;AsContent()-&gt;GetPrimaryFrame();</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :   nsImageFrame* imageFrame = do_QueryFrame(frame);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   if (imageFrame) {</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     Accessible* parent = GetAccessible(imageFrame-&gt;GetContent());</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     if (parent) {</span>
<span class="lineNum">    1436 </span>            :       Accessible* area =
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         parent-&gt;AsImageMap()-&gt;GetChildAccessibleFor(aNode);</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :       if (area)</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :         return area;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :       return nullptr;
<span class="lineNum">    1442 </span>            :     }
<span class="lineNum">    1443 </span>            :   }
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   return GetAccessible(aNode);</span>
<span class="lineNum">    1446 </span>            : }
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1449 </span>            : // Protected members
<a name="1450"><span class="lineNum">    1450 </span>            : </a>
<span class="lineNum">    1451 </span>            : void
<span class="lineNum">    1452 </span><span class="lineCov">          1 : DocAccessible::NotifyOfLoading(bool aIsReloading)</span>
<span class="lineNum">    1453 </span>            : {
<span class="lineNum">    1454 </span>            :   // Mark the document accessible as loading, if it stays alive then we'll mark
<span class="lineNum">    1455 </span>            :   // it as loaded when we receive proper notification.
<span class="lineNum">    1456 </span><span class="lineCov">          1 :   mLoadState &amp;= ~eDOMLoaded;</span>
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span><span class="lineCov">          1 :   if (!IsLoadEventTarget())</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span><span class="lineCov">          1 :   if (aIsReloading) {</span>
<span class="lineNum">    1462 </span>            :     // Fire reload and state busy events on existing document accessible while
<span class="lineNum">    1463 </span>            :     // event from user input flag can be calculated properly and accessible
<span class="lineNum">    1464 </span>            :     // is alive. When new document gets loaded then this one is destroyed.
<span class="lineNum">    1465 </span>            :     RefPtr&lt;AccEvent&gt; reloadEvent =
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :       new AccEvent(nsIAccessibleEvent::EVENT_DOCUMENT_RELOAD, this);</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :     nsEventShell::FireEvent(reloadEvent);</span>
<span class="lineNum">    1468 </span>            :   }
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            :   // Fire state busy change event. Use delayed event since we don't care
<span class="lineNum">    1471 </span>            :   // actually if event isn't delivered when the document goes away like a shot.
<span class="lineNum">    1472 </span>            :   RefPtr&lt;AccEvent&gt; stateEvent =
<span class="lineNum">    1473 </span><span class="lineCov">          1 :     new AccStateChangeEvent(this, states::BUSY, true);</span>
<span class="lineNum">    1474 </span><span class="lineCov">          1 :   FireDelayedEvent(stateEvent);</span>
<span class="lineNum">    1475 </span>            : }
<a name="1476"><span class="lineNum">    1476 </span>            : </a>
<span class="lineNum">    1477 </span>            : void
<span class="lineNum">    1478 </span><span class="lineCov">          1 : DocAccessible::DoInitialUpdate()</span>
<span class="lineNum">    1479 </span>            : {
<span class="lineNum">    1480 </span><span class="lineCov">          1 :   if (nsCoreUtils::IsTabDocument(mDocumentNode)) {</span>
<span class="lineNum">    1481 </span><span class="lineCov">          1 :     mDocFlags |= eTabDocument;</span>
<span class="lineNum">    1482 </span><span class="lineCov">          1 :     if (IPCAccessibilityActive()) {</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :       nsIDocShell* docShell = mDocumentNode-&gt;GetDocShell();</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :       if (RefPtr&lt;dom::TabChild&gt; tabChild = dom::TabChild::GetFrom(docShell)) {</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :         DocAccessibleChild* ipcDoc = new DocAccessibleChild(this, tabChild);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :         SetIPCDoc(ipcDoc);</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            : #if defined(XP_WIN)
<span class="lineNum">    1489 </span>            :         IAccessibleHolder holder(CreateHolderFromAccessible(this));
<span class="lineNum">    1490 </span>            :         int32_t childID = AccessibleWrap::GetChildIDFor(this);
<span class="lineNum">    1491 </span>            : #else
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         int32_t holder = 0, childID = 0;</span>
<span class="lineNum">    1493 </span>            : #endif
<span class="lineNum">    1494 </span>            :         tabChild-&gt;SendPDocAccessibleConstructor(ipcDoc, nullptr, 0, childID,
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :                                                 holder);</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1497 </span>            :     }
<span class="lineNum">    1498 </span>            :   }
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span><span class="lineCov">          1 :   mLoadState |= eTreeConstructed;</span>
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            :   // Set up a root element and ARIA role mapping.
<span class="lineNum">    1503 </span><span class="lineCov">          1 :   UpdateRootElIfNeeded();</span>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :   // Build initial tree.
<span class="lineNum">    1506 </span><span class="lineCov">          1 :   CacheChildrenInSubtree(this);</span>
<span class="lineNum">    1507 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1508 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eVerbose)) {</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :     logging::Tree(&quot;TREE&quot;, &quot;Initial subtree&quot;, this);</span>
<span class="lineNum">    1510 </span>            :   }
<span class="lineNum">    1511 </span>            : #endif
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            :   // Fire reorder event after the document tree is constructed. Note, since
<span class="lineNum">    1514 </span>            :   // this reorder event is processed by parent document then events targeted to
<span class="lineNum">    1515 </span>            :   // this document may be fired prior to this reorder event. If this is
<span class="lineNum">    1516 </span>            :   // a problem then consider to keep event processing per tab document.
<span class="lineNum">    1517 </span><span class="lineCov">          1 :   if (!IsRoot()) {</span>
<span class="lineNum">    1518 </span><span class="lineCov">          1 :     RefPtr&lt;AccReorderEvent&gt; reorderEvent = new AccReorderEvent(Parent());</span>
<span class="lineNum">    1519 </span><span class="lineCov">          1 :     ParentDocument()-&gt;FireDelayedEvent(reorderEvent);</span>
<span class="lineNum">    1520 </span>            :   }
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineCov">          1 :   TreeMutation mt(this);</span>
<span class="lineNum">    1523 </span><span class="lineCov">          1 :   uint32_t childCount = ChildCount();</span>
<span class="lineNum">    1524 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; childCount; i++) {</span>
<span class="lineNum">    1525 </span><span class="lineCov">          1 :     Accessible* child = GetChildAt(i);</span>
<span class="lineNum">    1526 </span><span class="lineCov">          1 :     mt.AfterInsertion(child);</span>
<span class="lineNum">    1527 </span>            :   }
<span class="lineNum">    1528 </span><span class="lineCov">          1 :   mt.Done();</span>
<span class="lineNum">    1529 </span><span class="lineCov">          1 : }</span>
<a name="1530"><span class="lineNum">    1530 </span>            : </a>
<span class="lineNum">    1531 </span>            : void
<span class="lineNum">    1532 </span><span class="lineCov">          1 : DocAccessible::ProcessLoad()</span>
<span class="lineNum">    1533 </span>            : {
<span class="lineNum">    1534 </span><span class="lineCov">          1 :   mLoadState |= eCompletelyLoaded;</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1537 </span><span class="lineCov">          1 :   if (logging::IsEnabled(logging::eDocLoad))</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     logging::DocCompleteLoad(this, IsLoadEventTarget());</span>
<span class="lineNum">    1539 </span>            : #endif
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            :   // Do not fire document complete/stop events for root chrome document
<span class="lineNum">    1542 </span>            :   // accessibles and for frame/iframe documents because
<span class="lineNum">    1543 </span>            :   // a) screen readers start working on focus event in the case of root chrome
<span class="lineNum">    1544 </span>            :   // documents
<span class="lineNum">    1545 </span>            :   // b) document load event on sub documents causes screen readers to act is if
<span class="lineNum">    1546 </span>            :   // entire page is reloaded.
<span class="lineNum">    1547 </span><span class="lineCov">          1 :   if (!IsLoadEventTarget())</span>
<span class="lineNum">    1548 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            :   // Fire complete/load stopped if the load event type is given.
<span class="lineNum">    1551 </span><span class="lineCov">          1 :   if (mLoadEventType) {</span>
<span class="lineNum">    1552 </span><span class="lineCov">          1 :     RefPtr&lt;AccEvent&gt; loadEvent = new AccEvent(mLoadEventType, this);</span>
<span class="lineNum">    1553 </span><span class="lineCov">          1 :     FireDelayedEvent(loadEvent);</span>
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span><span class="lineCov">          1 :     mLoadEventType = 0;</span>
<span class="lineNum">    1556 </span>            :   }
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :   // Fire busy state change event.
<span class="lineNum">    1559 </span>            :   RefPtr&lt;AccEvent&gt; stateEvent =
<span class="lineNum">    1560 </span><span class="lineCov">          1 :     new AccStateChangeEvent(this, states::BUSY, false);</span>
<span class="lineNum">    1561 </span><span class="lineCov">          1 :   FireDelayedEvent(stateEvent);</span>
<span class="lineNum">    1562 </span>            : }
<a name="1563"><span class="lineNum">    1563 </span>            : </a>
<span class="lineNum">    1564 </span>            : void
<span class="lineNum">    1565 </span><span class="lineCov">          1 : DocAccessible::AddDependentIDsFor(Accessible* aRelProvider, nsIAtom* aRelAttr)</span>
<span class="lineNum">    1566 </span>            : {
<span class="lineNum">    1567 </span><span class="lineCov">          1 :   dom::Element* relProviderEl = aRelProvider-&gt;Elm();</span>
<span class="lineNum">    1568 </span><span class="lineCov">          1 :   if (!relProviderEl)</span>
<span class="lineNum">    1569 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span><span class="lineCov">          1 :   for (uint32_t idx = 0; idx &lt; kRelationAttrsLen; idx++) {</span>
<span class="lineNum">    1572 </span><span class="lineCov">          1 :     nsIAtom* relAttr = *kRelationAttrs[idx];</span>
<span class="lineNum">    1573 </span><span class="lineCov">          1 :     if (aRelAttr &amp;&amp; aRelAttr != relAttr)</span>
<span class="lineNum">    1574 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span><span class="lineCov">          1 :     if (relAttr == nsGkAtoms::_for) {</span>
<span class="lineNum">    1577 </span><span class="lineCov">          1 :       if (!relProviderEl-&gt;IsAnyOfHTMLElements(nsGkAtoms::label,</span>
<span class="lineNum">    1578 </span><span class="lineCov">          1 :                                                nsGkAtoms::output))</span>
<span class="lineNum">    1579 </span>            :         continue;
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span><span class="lineCov">          1 :     } else if (relAttr == nsGkAtoms::control) {</span>
<span class="lineNum">    1582 </span><span class="lineCov">          1 :       if (!relProviderEl-&gt;IsAnyOfXULElements(nsGkAtoms::label,</span>
<span class="lineNum">    1583 </span><span class="lineCov">          1 :                                               nsGkAtoms::description))</span>
<span class="lineNum">    1584 </span>            :         continue;
<span class="lineNum">    1585 </span>            :     }
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span><span class="lineCov">          1 :     IDRefsIterator iter(this, relProviderEl, relAttr);</span>
<span class="lineNum">    1588 </span>            :     while (true) {
<span class="lineNum">    1589 </span><span class="lineCov">          1 :       const nsDependentSubstring id = iter.NextID();</span>
<span class="lineNum">    1590 </span><span class="lineCov">          1 :       if (id.IsEmpty())</span>
<span class="lineNum">    1591 </span>            :         break;
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineCov">          1 :       AttrRelProviderArray* providers = mDependentIDsHash.Get(id);</span>
<span class="lineNum">    1594 </span><span class="lineCov">          1 :       if (!providers) {</span>
<span class="lineNum">    1595 </span><span class="lineCov">          1 :         providers = new AttrRelProviderArray();</span>
<span class="lineNum">    1596 </span><span class="lineCov">          1 :         if (providers) {</span>
<span class="lineNum">    1597 </span><span class="lineCov">          1 :           mDependentIDsHash.Put(id, providers);</span>
<span class="lineNum">    1598 </span>            :         }
<span class="lineNum">    1599 </span>            :       }
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineCov">          1 :       if (providers) {</span>
<span class="lineNum">    1602 </span>            :         AttrRelProvider* provider =
<span class="lineNum">    1603 </span><span class="lineCov">          1 :           new AttrRelProvider(relAttr, relProviderEl);</span>
<span class="lineNum">    1604 </span><span class="lineCov">          1 :         if (provider) {</span>
<span class="lineNum">    1605 </span><span class="lineCov">          1 :           providers-&gt;AppendElement(provider);</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span>            :           // We've got here during the children caching. If the referenced
<span class="lineNum">    1608 </span>            :           // content is not accessible then store it to pend its container
<span class="lineNum">    1609 </span>            :           // children invalidation (this happens immediately after the caching
<span class="lineNum">    1610 </span>            :           // is finished).
<span class="lineNum">    1611 </span><span class="lineCov">          1 :           nsIContent* dependentContent = iter.GetElem(id);</span>
<span class="lineNum">    1612 </span><span class="lineCov">          1 :           if (dependentContent) {</span>
<span class="lineNum">    1613 </span><span class="lineCov">          1 :             if (!HasAccessible(dependentContent)) {</span>
<span class="lineNum">    1614 </span><span class="lineCov">          1 :               mInvalidationList.AppendElement(dependentContent);</span>
<span class="lineNum">    1615 </span>            :             }
<span class="lineNum">    1616 </span>            :           }
<span class="lineNum">    1617 </span>            :         }
<span class="lineNum">    1618 </span>            :       }
<span class="lineNum">    1619 </span>            :     }
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :     // If the relation attribute is given then we don't have anything else to
<span class="lineNum">    1622 </span>            :     // check.
<span class="lineNum">    1623 </span><span class="lineCov">          1 :     if (aRelAttr)</span>
<span class="lineNum">    1624 </span>            :       break;
<span class="lineNum">    1625 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            :   // Make sure to schedule the tree update if needed.
<span class="lineNum">    1628 </span><span class="lineCov">          1 :   mNotificationController-&gt;ScheduleProcessing();</span>
<span class="lineNum">    1629 </span>            : }
<a name="1630"><span class="lineNum">    1630 </span>            : </a>
<span class="lineNum">    1631 </span>            : void
<span class="lineNum">    1632 </span><span class="lineCov">          1 : DocAccessible::RemoveDependentIDsFor(Accessible* aRelProvider,</span>
<span class="lineNum">    1633 </span>            :                                      nsIAtom* aRelAttr)
<span class="lineNum">    1634 </span>            : {
<span class="lineNum">    1635 </span><span class="lineCov">          1 :   dom::Element* relProviderElm = aRelProvider-&gt;Elm();</span>
<span class="lineNum">    1636 </span><span class="lineCov">          1 :   if (!relProviderElm)</span>
<span class="lineNum">    1637 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineCov">          1 :   for (uint32_t idx = 0; idx &lt; kRelationAttrsLen; idx++) {</span>
<span class="lineNum">    1640 </span><span class="lineCov">          1 :     nsIAtom* relAttr = *kRelationAttrs[idx];</span>
<span class="lineNum">    1641 </span><span class="lineCov">          1 :     if (aRelAttr &amp;&amp; aRelAttr != *kRelationAttrs[idx])</span>
<span class="lineNum">    1642 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span><span class="lineCov">          1 :     IDRefsIterator iter(this, relProviderElm, relAttr);</span>
<span class="lineNum">    1645 </span>            :     while (true) {
<span class="lineNum">    1646 </span><span class="lineCov">          1 :       const nsDependentSubstring id = iter.NextID();</span>
<span class="lineNum">    1647 </span><span class="lineCov">          1 :       if (id.IsEmpty())</span>
<span class="lineNum">    1648 </span>            :         break;
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineCov">          1 :       AttrRelProviderArray* providers = mDependentIDsHash.Get(id);</span>
<span class="lineNum">    1651 </span><span class="lineCov">          1 :       if (providers) {</span>
<span class="lineNum">    1652 </span><span class="lineCov">          1 :         for (uint32_t jdx = 0; jdx &lt; providers-&gt;Length(); ) {</span>
<span class="lineNum">    1653 </span><span class="lineCov">          1 :           AttrRelProvider* provider = (*providers)[jdx];</span>
<span class="lineNum">    1654 </span><span class="lineCov">          1 :           if (provider-&gt;mRelAttr == relAttr &amp;&amp;</span>
<span class="lineNum">    1655 </span><span class="lineCov">          1 :               provider-&gt;mContent == relProviderElm)</span>
<span class="lineNum">    1656 </span><span class="lineCov">          1 :             providers-&gt;RemoveElement(provider);</span>
<span class="lineNum">    1657 </span>            :           else
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :             jdx++;</span>
<span class="lineNum">    1659 </span>            :         }
<span class="lineNum">    1660 </span><span class="lineCov">          1 :         if (providers-&gt;Length() == 0)</span>
<span class="lineNum">    1661 </span><span class="lineCov">          1 :           mDependentIDsHash.Remove(id);</span>
<span class="lineNum">    1662 </span>            :       }
<span class="lineNum">    1663 </span>            :     }
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            :     // If the relation attribute is given then we don't have anything else to
<span class="lineNum">    1666 </span>            :     // check.
<span class="lineNum">    1667 </span><span class="lineCov">          1 :     if (aRelAttr)</span>
<span class="lineNum">    1668 </span>            :       break;
<span class="lineNum">    1669 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1670 </span>            : }
<a name="1671"><span class="lineNum">    1671 </span>            : </a>
<span class="lineNum">    1672 </span>            : bool
<span class="lineNum">    1673 </span><span class="lineCov">          1 : DocAccessible::UpdateAccessibleOnAttrChange(dom::Element* aElement,</span>
<span class="lineNum">    1674 </span>            :                                             nsIAtom* aAttribute)
<span class="lineNum">    1675 </span>            : {
<span class="lineNum">    1676 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::role) {</span>
<span class="lineNum">    1677 </span>            :     // It is common for js libraries to set the role on the body element after
<span class="lineNum">    1678 </span>            :     // the document has loaded. In this case we just update the role map entry.
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     if (mContent == aElement) {</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :       SetRoleMapEntry(aria::GetRoleMap(aElement));</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :       if (mIPCDoc) {</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :         mIPCDoc-&gt;SendRoleChangedEvent(Role());</span>
<span class="lineNum">    1683 </span>            :       }
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            :       return true;
<span class="lineNum">    1686 </span>            :     }
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span>            :     // Recreate the accessible when role is changed because we might require a
<span class="lineNum">    1689 </span>            :     // different accessible class for the new role or the accessible may expose
<span class="lineNum">    1690 </span>            :     // a different sets of interfaces (COM restriction).
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :     RecreateAccessible(aElement);</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1694 </span>            :   }
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::href) {</span>
<span class="lineNum">    1697 </span>            :     // Not worth the expense to ensure which namespace these are in. It doesn't
<span class="lineNum">    1698 </span>            :     // kill use to recreate the accessible even if the attribute was used in
<span class="lineNum">    1699 </span>            :     // the wrong namespace or an element that doesn't support it.
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            :     // Make sure the accessible is recreated asynchronously to allow the content
<span class="lineNum">    1702 </span>            :     // to handle the attribute change.
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     RecreateAccessible(aElement);</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1705 </span>            :   }
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span><span class="lineCov">          1 :   if (aAttribute == nsGkAtoms::aria_multiselectable &amp;&amp;</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :       aElement-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::role)) {</span>
<span class="lineNum">    1709 </span>            :     // This affects whether the accessible supports SelectAccessible.
<span class="lineNum">    1710 </span>            :     // COM says we cannot change what interfaces are supported on-the-fly,
<span class="lineNum">    1711 </span>            :     // so invalidate this object. A new one will be created on demand.
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :     RecreateAccessible(aElement);</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1715 </span>            :   }
<span class="lineNum">    1716 </span>            : 
<span class="lineNum">    1717 </span>            :   return false;
<span class="lineNum">    1718 </span>            : }
<a name="1719"><span class="lineNum">    1719 </span>            : </a>
<span class="lineNum">    1720 </span>            : void
<span class="lineNum">    1721 </span><span class="lineCov">          1 : DocAccessible::UpdateRootElIfNeeded()</span>
<span class="lineNum">    1722 </span>            : {
<span class="lineNum">    1723 </span><span class="lineCov">          1 :   dom::Element* rootEl = mDocumentNode-&gt;GetBodyElement();</span>
<span class="lineNum">    1724 </span><span class="lineCov">          1 :   if (!rootEl) {</span>
<span class="lineNum">    1725 </span><span class="lineCov">          1 :     rootEl = mDocumentNode-&gt;GetRootElement();</span>
<span class="lineNum">    1726 </span>            :   }
<span class="lineNum">    1727 </span><span class="lineCov">          1 :   if (rootEl != mContent) {</span>
<span class="lineNum">    1728 </span><span class="lineCov">          1 :     mContent = rootEl;</span>
<span class="lineNum">    1729 </span><span class="lineCov">          1 :     SetRoleMapEntry(aria::GetRoleMap(rootEl));</span>
<span class="lineNum">    1730 </span><span class="lineCov">          1 :     if (mIPCDoc) {</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :       mIPCDoc-&gt;SendRoleChangedEvent(Role());</span>
<span class="lineNum">    1732 </span>            :     }
<span class="lineNum">    1733 </span>            :   }
<span class="lineNum">    1734 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            : /**
<span class="lineNum">    1737 </span>            :  * Content insertion helper.
<span class="lineNum">    1738 </span>            :  */
<span class="lineNum">    1739 </span>            : class InsertIterator final
<a name="1740"><span class="lineNum">    1740 </span>            : {</a>
<span class="lineNum">    1741 </span>            : public:
<span class="lineNum">    1742 </span><span class="lineCov">          1 :   InsertIterator(Accessible* aContext,</span>
<span class="lineNum">    1743 </span>            :                  const nsTArray&lt;nsCOMPtr&lt;nsIContent&gt; &gt;* aNodes) :
<span class="lineNum">    1744 </span>            :     mChild(nullptr), mChildBefore(nullptr), mWalker(aContext),
<span class="lineNum">    1745 </span><span class="lineCov">          1 :     mNodes(aNodes), mNodesIdx(0)</span>
<span class="lineNum">    1746 </span>            :   {
<span class="lineNum">    1747 </span>            :     MOZ_ASSERT(aContext, &quot;No context&quot;);
<span class="lineNum">    1748 </span>            :     MOZ_ASSERT(aNodes, &quot;No nodes to search for accessible elements&quot;);
<span class="lineNum">    1749 </span>            :     MOZ_COUNT_CTOR(InsertIterator);
<span class="lineNum">    1750 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1751 </span><span class="lineCov">          1 :   ~InsertIterator() { MOZ_COUNT_DTOR(InsertIterator); }</span>
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span><span class="lineCov">          1 :   Accessible* Context() const { return mWalker.Context(); }</span>
<span class="lineNum">    1754 </span>            :   Accessible* Child() const { return mChild; }
<span class="lineNum">    1755 </span>            :   Accessible* ChildBefore() const { return mChildBefore; }
<span class="lineNum">    1756 </span><span class="lineCov">          1 :   DocAccessible* Document() const { return mWalker.Document(); }</span>
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :   /**
<span class="lineNum">    1759 </span>            :    * Iterates to a next accessible within the inserted content.
<span class="lineNum">    1760 </span>            :    */
<span class="lineNum">    1761 </span>            :   bool Next();
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span>            :   void Rejected()
<span class="lineNum">    1764 </span>            :   {
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :     mChild = nullptr;</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :     mChildBefore = nullptr;</span>
<span class="lineNum">    1767 </span>            :   }
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            : private:
<span class="lineNum">    1770 </span>            :   Accessible* mChild;
<span class="lineNum">    1771 </span>            :   Accessible* mChildBefore;
<span class="lineNum">    1772 </span>            :   TreeWalker mWalker;
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            :   const nsTArray&lt;nsCOMPtr&lt;nsIContent&gt; &gt;* mNodes;
<span class="lineNum">    1775 </span>            :   uint32_t mNodesIdx;
<span class="lineNum">    1776 </span>            : };
<a name="1777"><span class="lineNum">    1777 </span>            : </a>
<span class="lineNum">    1778 </span>            : bool
<span class="lineNum">    1779 </span><span class="lineCov">          1 : InsertIterator::Next()</span>
<span class="lineNum">    1780 </span>            : {
<span class="lineNum">    1781 </span><span class="lineCov">          1 :   if (mNodesIdx &gt; 0) {</span>
<span class="lineNum">    1782 </span><span class="lineCov">          1 :     Accessible* nextChild = mWalker.Next();</span>
<span class="lineNum">    1783 </span><span class="lineCov">          1 :     if (nextChild) {</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :       mChildBefore = mChild;</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :       mChild = nextChild;</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1787 </span>            :     }
<span class="lineNum">    1788 </span>            :   }
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span><span class="lineCov">          1 :   while (mNodesIdx &lt; mNodes-&gt;Length()) {</span>
<span class="lineNum">    1791 </span>            :     // Ignore nodes that are not contained by the container anymore.
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :     // The container might be changed, for example, because of the subsequent
<span class="lineNum">    1794 </span>            :     // overlapping content insertion (i.e. other content was inserted between
<span class="lineNum">    1795 </span>            :     // this inserted content and its container or the content was reinserted
<span class="lineNum">    1796 </span>            :     // into different container of unrelated part of tree). To avoid a double
<span class="lineNum">    1797 </span>            :     // processing of the content insertion ignore this insertion notification.
<span class="lineNum">    1798 </span>            :     // Note, the inserted content might be not in tree at all at this point
<span class="lineNum">    1799 </span>            :     // what means there's no container. Ignore the insertion too.
<span class="lineNum">    1800 </span><span class="lineCov">          1 :     nsIContent* prevNode = mNodes-&gt;SafeElementAt(mNodesIdx - 1);</span>
<span class="lineNum">    1801 </span><span class="lineCov">          1 :     nsIContent* node = mNodes-&gt;ElementAt(mNodesIdx++);</span>
<span class="lineNum">    1802 </span><span class="lineCov">          1 :     Accessible* container = Document()-&gt;AccessibleOrTrueContainer(node);</span>
<span class="lineNum">    1803 </span><span class="lineCov">          1 :     if (container != Context()) {</span>
<span class="lineNum">    1804 </span>            :       continue;
<span class="lineNum">    1805 </span>            :     }
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            :     // HTML comboboxes have no-content list accessible as an intermediate
<span class="lineNum">    1808 </span>            :     // containing all options.
<span class="lineNum">    1809 </span><span class="lineCov">          1 :     if (container-&gt;IsHTMLCombobox()) {</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :       container = container-&gt;FirstChild();</span>
<span class="lineNum">    1811 </span>            :     }
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span><span class="lineCov">          1 :     if (!container-&gt;IsAcceptableChild(node)) {</span>
<span class="lineNum">    1814 </span>            :       continue;
<span class="lineNum">    1815 </span>            :     }
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1818 </span>            :     logging::TreeInfo(&quot;traversing an inserted node&quot;, logging::eVerbose,
<span class="lineNum">    1819 </span><span class="lineCov">          1 :                       &quot;container&quot;, container, &quot;node&quot;, node);</span>
<span class="lineNum">    1820 </span>            : #endif
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span>            :     // If inserted nodes are siblings then just move the walker next.
<span class="lineNum">    1823 </span><span class="lineCov">          1 :     if (mChild &amp;&amp; prevNode &amp;&amp; prevNode-&gt;GetNextSibling() == node) {</span>
<span class="lineNum">    1824 </span><span class="lineCov">          1 :       Accessible* nextChild = mWalker.Scope(node);</span>
<span class="lineNum">    1825 </span><span class="lineCov">          1 :       if (nextChild) {</span>
<span class="lineNum">    1826 </span><span class="lineCov">          1 :         mChildBefore = mChild;</span>
<span class="lineNum">    1827 </span><span class="lineCov">          1 :         mChild = nextChild;</span>
<span class="lineNum">    1828 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    1829 </span>            :       }
<span class="lineNum">    1830 </span>            :     }
<span class="lineNum">    1831 </span>            :     else {
<span class="lineNum">    1832 </span><span class="lineCov">          1 :       TreeWalker finder(container);</span>
<span class="lineNum">    1833 </span><span class="lineCov">          1 :       if (finder.Seek(node)) {</span>
<span class="lineNum">    1834 </span><span class="lineCov">          1 :         mChild = mWalker.Scope(node);</span>
<span class="lineNum">    1835 </span><span class="lineCov">          1 :         if (mChild) {</span>
<span class="lineNum">    1836 </span><span class="lineCov">          1 :           mChildBefore = finder.Prev();</span>
<span class="lineNum">    1837 </span><span class="lineCov">          1 :           return true;</span>
<span class="lineNum">    1838 </span>            :         }
<span class="lineNum">    1839 </span><span class="lineCov">          1 :       }</span>
<span class="lineNum">    1840 </span>            :     }
<span class="lineNum">    1841 </span>            :   }
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span>            :   return false;
<span class="lineNum">    1844 </span>            : }
<a name="1845"><span class="lineNum">    1845 </span>            : </a>
<span class="lineNum">    1846 </span>            : void
<span class="lineNum">    1847 </span><span class="lineCov">          1 : DocAccessible::ProcessContentInserted(Accessible* aContainer,</span>
<span class="lineNum">    1848 </span>            :                                       const nsTArray&lt;nsCOMPtr&lt;nsIContent&gt; &gt;* aNodes)
<span class="lineNum">    1849 </span>            : {
<span class="lineNum">    1850 </span>            :   // Process insertions if the container accessible is still in tree.
<span class="lineNum">    1851 </span><span class="lineCov">          1 :   if (!aContainer-&gt;IsInDocument()) {</span>
<span class="lineNum">    1852 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1853 </span>            :   }
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            :   // If new root content has been inserted then update it.
<span class="lineNum">    1856 </span><span class="lineCov">          1 :   if (aContainer == this) {</span>
<span class="lineNum">    1857 </span><span class="lineCov">          1 :     UpdateRootElIfNeeded();</span>
<span class="lineNum">    1858 </span>            :   }
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span><span class="lineCov">          1 :   InsertIterator iter(aContainer, aNodes);</span>
<span class="lineNum">    1861 </span><span class="lineCov">          1 :   if (!iter.Next()) {</span>
<span class="lineNum">    1862 </span>            :     return;
<span class="lineNum">    1863 </span>            :   }
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1866 </span>            :   logging::TreeInfo(&quot;children before insertion&quot;, logging::eVerbose,
<span class="lineNum">    1867 </span><span class="lineCov">          1 :                     aContainer);</span>
<span class="lineNum">    1868 </span>            : #endif
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span><span class="lineCov">          1 :   TreeMutation mt(aContainer);</span>
<span class="lineNum">    1871 </span><span class="lineCov">          1 :   do {</span>
<span class="lineNum">    1872 </span><span class="lineCov">          1 :     Accessible* parent = iter.Child()-&gt;Parent();</span>
<span class="lineNum">    1873 </span><span class="lineCov">          1 :     if (parent) {</span>
<span class="lineNum">    1874 </span><span class="lineCov">          1 :       if (parent != aContainer) {</span>
<span class="lineNum">    1875 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1876 </span>            :         logging::TreeInfo(&quot;stealing accessible&quot;, 0,
<span class="lineNum">    1877 </span>            :                           &quot;old parent&quot;, parent, &quot;new parent&quot;,
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :                           aContainer, &quot;child&quot;, iter.Child(), nullptr);</span>
<span class="lineNum">    1879 </span>            : #endif
<span class="lineNum">    1880 </span>            :         MOZ_ASSERT_UNREACHABLE(&quot;stealing accessible&quot;);
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1882 </span>            :       }
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1885 </span>            :       logging::TreeInfo(&quot;binding to same parent&quot;, logging::eVerbose,
<span class="lineNum">    1886 </span><span class="lineCov">          1 :                         &quot;parent&quot;, aContainer, &quot;child&quot;, iter.Child(), nullptr);</span>
<span class="lineNum">    1887 </span>            : #endif
<span class="lineNum">    1888 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    1889 </span>            :     }
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span><span class="lineCov">          1 :     if (aContainer-&gt;InsertAfter(iter.Child(), iter.ChildBefore())) {</span>
<span class="lineNum">    1892 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1893 </span>            :       logging::TreeInfo(&quot;accessible was inserted&quot;, 0,
<span class="lineNum">    1894 </span><span class="lineCov">          1 :                         &quot;container&quot;, aContainer, &quot;child&quot;, iter.Child(), nullptr);</span>
<span class="lineNum">    1895 </span>            : #endif
<span class="lineNum">    1896 </span>            : 
<span class="lineNum">    1897 </span><span class="lineCov">          1 :       CreateSubtree(iter.Child());</span>
<span class="lineNum">    1898 </span><span class="lineCov">          1 :       mt.AfterInsertion(iter.Child());</span>
<span class="lineNum">    1899 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    1900 </span>            :     }
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            :     MOZ_ASSERT_UNREACHABLE(&quot;accessible was rejected&quot;);
<span class="lineNum">    1903 </span>            :     iter.Rejected();
<span class="lineNum">    1904 </span>            :   } while (iter.Next());
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span><span class="lineCov">          1 :   mt.Done();</span>
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1909 </span>            :   logging::TreeInfo(&quot;children after insertion&quot;, logging::eVerbose,
<span class="lineNum">    1910 </span><span class="lineCov">          1 :                     aContainer);</span>
<span class="lineNum">    1911 </span>            : #endif
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineCov">          1 :   FireEventsOnInsertion(aContainer);</span>
<span class="lineNum">    1914 </span>            : }
<a name="1915"><span class="lineNum">    1915 </span>            : </a>
<span class="lineNum">    1916 </span>            : void
<span class="lineNum">    1917 </span><span class="lineCov">          1 : DocAccessible::ProcessContentInserted(Accessible* aContainer, nsIContent* aNode)</span>
<span class="lineNum">    1918 </span>            : {
<span class="lineNum">    1919 </span><span class="lineCov">          1 :   if (!aContainer-&gt;IsInDocument()) {</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1921 </span>            :   }
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1924 </span><span class="lineCov">          1 :   logging::TreeInfo(&quot;children before insertion&quot;, logging::eVerbose, aContainer);</span>
<span class="lineNum">    1925 </span>            : #endif
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1928 </span>            :   logging::TreeInfo(&quot;traversing an inserted node&quot;, logging::eVerbose,
<span class="lineNum">    1929 </span><span class="lineCov">          1 :                     &quot;container&quot;, aContainer, &quot;node&quot;, aNode);</span>
<span class="lineNum">    1930 </span>            : #endif
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span><span class="lineCov">          1 :   TreeWalker walker(aContainer);</span>
<span class="lineNum">    1933 </span><span class="lineCov">          1 :   if (aContainer-&gt;IsAcceptableChild(aNode) &amp;&amp; walker.Seek(aNode)) {</span>
<span class="lineNum">    1934 </span><span class="lineCov">          1 :     Accessible* child = GetAccessible(aNode);</span>
<span class="lineNum">    1935 </span><span class="lineCov">          1 :     if (!child) {</span>
<span class="lineNum">    1936 </span><span class="lineCov">          1 :       child = GetAccService()-&gt;CreateAccessible(aNode, aContainer);</span>
<span class="lineNum">    1937 </span>            :     }
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span><span class="lineCov">          1 :     if (child) {</span>
<span class="lineNum">    1940 </span><span class="lineCov">          1 :       TreeMutation mt(aContainer);</span>
<span class="lineNum">    1941 </span><span class="lineCov">          1 :       if (!aContainer-&gt;InsertAfter(child, walker.Prev())) {</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1943 </span>            :       }
<span class="lineNum">    1944 </span><span class="lineCov">          1 :       CreateSubtree(child);</span>
<span class="lineNum">    1945 </span><span class="lineCov">          1 :       mt.AfterInsertion(child);</span>
<span class="lineNum">    1946 </span><span class="lineCov">          1 :       mt.Done();</span>
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span><span class="lineCov">          1 :       FireEventsOnInsertion(aContainer);</span>
<span class="lineNum">    1949 </span>            :     }
<span class="lineNum">    1950 </span>            :   }
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1953 </span><span class="lineCov">          1 :   logging::TreeInfo(&quot;children after insertion&quot;, logging::eVerbose, aContainer);</span>
<span class="lineNum">    1954 </span>            : #endif
<span class="lineNum">    1955 </span>            : }
<a name="1956"><span class="lineNum">    1956 </span>            : </a>
<span class="lineNum">    1957 </span>            : void
<span class="lineNum">    1958 </span><span class="lineCov">          1 : DocAccessible::FireEventsOnInsertion(Accessible* aContainer)</span>
<span class="lineNum">    1959 </span>            : {
<span class="lineNum">    1960 </span>            :   // Check to see if change occurred inside an alert, and fire an EVENT_ALERT
<span class="lineNum">    1961 </span>            :   // if it did.
<span class="lineNum">    1962 </span><span class="lineCov">          1 :   if (aContainer-&gt;IsAlert() || aContainer-&gt;IsInsideAlert()) {</span>
<span class="lineNum">    1963 </span>            :     Accessible* ancestor = aContainer;
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :       if (ancestor-&gt;IsAlert()) {</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         FireDelayedEvent(nsIAccessibleEvent::EVENT_ALERT, ancestor);</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1968 </span>            :       }
<span class="lineNum">    1969 </span>            :     }
<span class="lineNum">    1970 </span>            :     while ((ancestor = ancestor-&gt;Parent()));
<span class="lineNum">    1971 </span>            :   }
<span class="lineNum">    1972 </span><span class="lineCov">          1 : }</span>
<a name="1973"><span class="lineNum">    1973 </span>            : </a>
<span class="lineNum">    1974 </span>            : void
<span class="lineNum">    1975 </span><span class="lineCov">          1 : DocAccessible::UpdateTreeOnRemoval(Accessible* aContainer, nsIContent* aChildNode)</span>
<span class="lineNum">    1976 </span>            : {
<span class="lineNum">    1977 </span>            :   // If child node is not accessible then look for its accessible children.
<span class="lineNum">    1978 </span><span class="lineCov">          1 :   Accessible* child = GetAccessible(aChildNode);</span>
<span class="lineNum">    1979 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    1980 </span>            :   logging::TreeInfo(&quot;process content removal&quot;, 0,
<span class="lineNum">    1981 </span><span class="lineCov">          1 :                     &quot;container&quot;, aContainer, &quot;child&quot;, aChildNode);</span>
<span class="lineNum">    1982 </span>            : #endif
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span><span class="lineCov">          1 :   TreeMutation mt(aContainer);</span>
<span class="lineNum">    1985 </span><span class="lineCov">          1 :   if (child) {</span>
<span class="lineNum">    1986 </span><span class="lineCov">          1 :     mt.BeforeRemoval(child);</span>
<span class="lineNum">    1987 </span>            :     MOZ_ASSERT(aContainer == child-&gt;Parent(), &quot;Wrong parent&quot;);
<span class="lineNum">    1988 </span><span class="lineCov">          1 :     aContainer-&gt;RemoveChild(child);</span>
<span class="lineNum">    1989 </span><span class="lineCov">          1 :     UncacheChildrenInSubtree(child);</span>
<span class="lineNum">    1990 </span><span class="lineCov">          1 :     mt.Done();</span>
<span class="lineNum">    1991 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1992 </span>            :   }
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span><span class="lineCov">          1 :   TreeWalker walker(aContainer, aChildNode, TreeWalker::eWalkCache);</span>
<span class="lineNum">    1995 </span><span class="lineCov">          1 :   while (Accessible* child = walker.Next()) {</span>
<span class="lineNum">    1996 </span><span class="lineCov">          1 :     mt.BeforeRemoval(child);</span>
<span class="lineNum">    1997 </span>            :     MOZ_ASSERT(aContainer == child-&gt;Parent(), &quot;Wrong parent&quot;);
<span class="lineNum">    1998 </span><span class="lineCov">          1 :     aContainer-&gt;RemoveChild(child);</span>
<span class="lineNum">    1999 </span><span class="lineCov">          1 :     UncacheChildrenInSubtree(child);</span>
<span class="lineNum">    2000 </span>            :   }
<span class="lineNum">    2001 </span><span class="lineCov">          1 :   mt.Done();</span>
<span class="lineNum">    2002 </span>            : }
<a name="2003"><span class="lineNum">    2003 </span>            : </a>
<span class="lineNum">    2004 </span>            : bool
<span class="lineNum">    2005 </span><span class="lineCov">          1 : DocAccessible::RelocateARIAOwnedIfNeeded(nsIContent* aElement)</span>
<span class="lineNum">    2006 </span>            : {
<span class="lineNum">    2007 </span><span class="lineCov">          1 :   if (!aElement-&gt;HasID())</span>
<span class="lineNum">    2008 </span>            :     return false;
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span>            :   AttrRelProviderArray* list =
<span class="lineNum">    2011 </span><span class="lineCov">          1 :     mDependentIDsHash.Get(nsDependentAtomString(aElement-&gt;GetID()));</span>
<span class="lineNum">    2012 </span><span class="lineCov">          1 :   if (list) {</span>
<span class="lineNum">    2013 </span><span class="lineCov">          1 :     for (uint32_t idx = 0; idx &lt; list-&gt;Length(); idx++) {</span>
<span class="lineNum">    2014 </span><span class="lineCov">          1 :       if (list-&gt;ElementAt(idx)-&gt;mRelAttr == nsGkAtoms::aria_owns) {</span>
<span class="lineNum">    2015 </span><span class="lineCov">          1 :         Accessible* owner = GetAccessible(list-&gt;ElementAt(idx)-&gt;mContent);</span>
<span class="lineNum">    2016 </span><span class="lineCov">          1 :         if (owner) {</span>
<span class="lineNum">    2017 </span><span class="lineCov">          1 :           mNotificationController-&gt;ScheduleRelocation(owner);</span>
<span class="lineNum">    2018 </span><span class="lineCov">          1 :           return true;</span>
<span class="lineNum">    2019 </span>            :         }
<span class="lineNum">    2020 </span>            :       }
<span class="lineNum">    2021 </span>            :     }
<span class="lineNum">    2022 </span>            :   }
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            :   return false;
<span class="lineNum">    2025 </span>            : }
<a name="2026"><span class="lineNum">    2026 </span>            : </a>
<span class="lineNum">    2027 </span>            : void
<span class="lineNum">    2028 </span><span class="lineCov">          1 : DocAccessible::ValidateARIAOwned()</span>
<span class="lineNum">    2029 </span>            : {
<span class="lineNum">    2030 </span><span class="lineCov">          1 :   for (auto it = mARIAOwnsHash.Iter(); !it.Done(); it.Next()) {</span>
<span class="lineNum">    2031 </span><span class="lineCov">          1 :     Accessible* owner = it.Key();</span>
<span class="lineNum">    2032 </span><span class="lineCov">          1 :     nsTArray&lt;RefPtr&lt;Accessible&gt; &gt;* children = it.UserData();</span>
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span>            :     // Owner is about to die, put children back if applicable.
<span class="lineNum">    2035 </span><span class="lineCov">          1 :     if (!mAccessibleCache.GetWeak(reinterpret_cast&lt;void*&gt;(owner)) ||</span>
<span class="lineNum">    2036 </span>            :         !owner-&gt;IsInDocument()) {
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :       PutChildrenBack(children, 0);</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :       it.Remove();</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    2040 </span>            :     }
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineCov">          1 :     for (uint32_t idx = 0; idx &lt; children-&gt;Length(); idx++) {</span>
<span class="lineNum">    2043 </span><span class="lineCov">          1 :       Accessible* child = children-&gt;ElementAt(idx);</span>
<span class="lineNum">    2044 </span><span class="lineCov">          1 :       if (!child-&gt;IsInDocument()) {</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :         children-&gt;RemoveElementAt(idx);</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :         idx--;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2048 </span>            :       }
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span>            :       NS_ASSERTION(child-&gt;Parent(), &quot;No parent for ARIA owned?&quot;);
<span class="lineNum">    2051 </span>            : 
<span class="lineNum">    2052 </span>            :       // If DOM node doesn't have a frame anymore then shutdown its accessible.
<span class="lineNum">    2053 </span><span class="lineCov">          1 :       if (child-&gt;Parent() &amp;&amp; !child-&gt;GetFrame()) {</span>
<span class="lineNum">    2054 </span><span class="lineCov">          1 :         UpdateTreeOnRemoval(child-&gt;Parent(), child-&gt;GetContent());</span>
<span class="lineNum">    2055 </span><span class="lineCov">          1 :         children-&gt;RemoveElementAt(idx);</span>
<span class="lineNum">    2056 </span><span class="lineCov">          1 :         idx--;</span>
<span class="lineNum">    2057 </span><span class="lineCov">          1 :         continue;</span>
<span class="lineNum">    2058 </span>            :       }
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            :       NS_ASSERTION(child-&gt;Parent() == owner,
<span class="lineNum">    2061 </span>            :                    &quot;Illigally stolen ARIA owned child!&quot;);
<span class="lineNum">    2062 </span>            :     }
<span class="lineNum">    2063 </span>            : 
<span class="lineNum">    2064 </span><span class="lineCov">          1 :     if (children-&gt;Length() == 0) {</span>
<span class="lineNum">    2065 </span><span class="lineCov">          1 :       it.Remove();</span>
<span class="lineNum">    2066 </span>            :     }
<span class="lineNum">    2067 </span>            :   }
<span class="lineNum">    2068 </span><span class="lineCov">          1 : }</span>
<a name="2069"><span class="lineNum">    2069 </span>            : </a>
<span class="lineNum">    2070 </span>            : void
<span class="lineNum">    2071 </span><span class="lineCov">          1 : DocAccessible::DoARIAOwnsRelocation(Accessible* aOwner)</span>
<span class="lineNum">    2072 </span>            : {
<span class="lineNum">    2073 </span><span class="lineCov">          1 :   nsTArray&lt;RefPtr&lt;Accessible&gt; &gt;* children = mARIAOwnsHash.LookupOrAdd(aOwner);</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span>            :   MOZ_ASSERT(aOwner, &quot;aOwner must be a valid pointer&quot;);
<span class="lineNum">    2076 </span>            :   MOZ_ASSERT(aOwner-&gt;Elm(), &quot;aOwner-&gt;Elm() must be a valid pointer&quot;);
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    2079 </span><span class="lineCov">          1 :   logging::TreeInfo(&quot;aria owns relocation&quot;, logging::eVerbose, aOwner);</span>
<span class="lineNum">    2080 </span>            : #endif
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span><span class="lineCov">          1 :   IDRefsIterator iter(this, aOwner-&gt;Elm(), nsGkAtoms::aria_owns);</span>
<span class="lineNum">    2083 </span><span class="lineCov">          1 :   uint32_t arrayIdx = 0, insertIdx = aOwner-&gt;ChildCount() - children-&gt;Length();</span>
<span class="lineNum">    2084 </span><span class="lineCov">          1 :   while (nsIContent* childEl = iter.NextElem()) {</span>
<span class="lineNum">    2085 </span><span class="lineCov">          1 :     Accessible* child = GetAccessible(childEl);</span>
<span class="lineNum">    2086 </span>            : 
<span class="lineNum">    2087 </span>            :     // Make an attempt to create an accessible if it wasn't created yet.
<span class="lineNum">    2088 </span><span class="lineCov">          1 :     if (!child) {</span>
<span class="lineNum">    2089 </span><span class="lineCov">          1 :       if (aOwner-&gt;IsAcceptableChild(childEl)) {</span>
<span class="lineNum">    2090 </span><span class="lineCov">          1 :         child = GetAccService()-&gt;CreateAccessible(childEl, aOwner);</span>
<span class="lineNum">    2091 </span><span class="lineCov">          1 :         if (child) {</span>
<span class="lineNum">    2092 </span><span class="lineCov">          1 :           TreeMutation imut(aOwner);</span>
<span class="lineNum">    2093 </span><span class="lineCov">          1 :           aOwner-&gt;InsertChildAt(insertIdx, child);</span>
<span class="lineNum">    2094 </span><span class="lineCov">          1 :           imut.AfterInsertion(child);</span>
<span class="lineNum">    2095 </span><span class="lineCov">          1 :           imut.Done();</span>
<span class="lineNum">    2096 </span>            : 
<span class="lineNum">    2097 </span><span class="lineCov">          1 :           child-&gt;SetRelocated(true);</span>
<span class="lineNum">    2098 </span><span class="lineCov">          1 :           children-&gt;InsertElementAt(arrayIdx, child);</span>
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            :           // Create subtree before adjusting the insertion index, since subtree
<span class="lineNum">    2101 </span>            :           // creation may alter children in the container.
<span class="lineNum">    2102 </span><span class="lineCov">          1 :           CreateSubtree(child);</span>
<span class="lineNum">    2103 </span><span class="lineCov">          1 :           FireEventsOnInsertion(aOwner);</span>
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span><span class="lineCov">          1 :           insertIdx = child-&gt;IndexInParent() + 1;</span>
<span class="lineNum">    2106 </span><span class="lineCov">          1 :           arrayIdx++;</span>
<span class="lineNum">    2107 </span>            :         }
<span class="lineNum">    2108 </span>            :       }
<span class="lineNum">    2109 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    2110 </span>            :     }
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    2113 </span>            :   logging::TreeInfo(&quot;aria owns traversal&quot;, logging::eVerbose,
<span class="lineNum">    2114 </span><span class="lineCov">          1 :                     &quot;candidate&quot;, child, nullptr);</span>
<span class="lineNum">    2115 </span>            : #endif
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span>            :     // Same child on same position, no change.
<span class="lineNum">    2118 </span><span class="lineCov">          1 :     if (child-&gt;Parent() == aOwner &amp;&amp;</span>
<span class="lineNum">    2119 </span><span class="lineCov">          1 :         child-&gt;IndexInParent() == static_cast&lt;int32_t&gt;(insertIdx)) {</span>
<span class="lineNum">    2120 </span>            :       NS_ASSERTION(child == children-&gt;ElementAt(arrayIdx), &quot;Not in sync!&quot;);
<span class="lineNum">    2121 </span><span class="lineCov">          1 :       insertIdx++; arrayIdx++;</span>
<span class="lineNum">    2122 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    2123 </span>            :     }
<span class="lineNum">    2124 </span>            : 
<span class="lineNum">    2125 </span>            :     NS_ASSERTION(children-&gt;SafeElementAt(arrayIdx) != child, &quot;Already in place!&quot;);
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span><span class="lineCov">          1 :     nsTArray&lt;RefPtr&lt;Accessible&gt; &gt;::index_type idx = children-&gt;IndexOf(child);</span>
<span class="lineNum">    2128 </span><span class="lineCov">          1 :     if (idx &lt; arrayIdx) {</span>
<span class="lineNum">    2129 </span>            :       continue; // ignore second entry of same ID
<span class="lineNum">    2130 </span>            :     }
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span>            :     // A new child is found, check for loops.
<span class="lineNum">    2133 </span><span class="lineCov">          1 :     if (child-&gt;Parent() != aOwner) {</span>
<span class="lineNum">    2134 </span>            :       Accessible* parent = aOwner;
<span class="lineNum">    2135 </span><span class="lineCov">          1 :       while (parent &amp;&amp; parent != child &amp;&amp; !parent-&gt;IsDoc()) {</span>
<span class="lineNum">    2136 </span><span class="lineCov">          1 :         parent = parent-&gt;Parent();</span>
<span class="lineNum">    2137 </span>            :       }
<span class="lineNum">    2138 </span>            :       // A referred child cannot be a parent of the owner.
<span class="lineNum">    2139 </span><span class="lineCov">          1 :       if (parent == child) {</span>
<span class="lineNum">    2140 </span>            :         continue;
<span class="lineNum">    2141 </span>            :       }
<span class="lineNum">    2142 </span>            :     }
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span><span class="lineCov">          1 :     if (MoveChild(child, aOwner, insertIdx)) {</span>
<span class="lineNum">    2145 </span><span class="lineCov">          1 :       child-&gt;SetRelocated(true);</span>
<span class="lineNum">    2146 </span><span class="lineCov">          1 :       children-&gt;InsertElementAt(arrayIdx, child);</span>
<span class="lineNum">    2147 </span><span class="lineCov">          1 :       arrayIdx++;</span>
<span class="lineNum">    2148 </span><span class="lineCov">          1 :       insertIdx = child-&gt;IndexInParent() + 1;</span>
<span class="lineNum">    2149 </span>            :     }
<span class="lineNum">    2150 </span>            :   }
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            :   // Put back children that are not seized anymore.
<span class="lineNum">    2153 </span><span class="lineCov">          1 :   PutChildrenBack(children, arrayIdx);</span>
<span class="lineNum">    2154 </span><span class="lineCov">          1 :   if (children-&gt;Length() == 0) {</span>
<span class="lineNum">    2155 </span><span class="lineCov">          1 :     mARIAOwnsHash.Remove(aOwner);</span>
<span class="lineNum">    2156 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    2157 </span><span class="lineCov">          1 : }</span>
<a name="2158"><span class="lineNum">    2158 </span>            : </a>
<span class="lineNum">    2159 </span>            : void
<span class="lineNum">    2160 </span><span class="lineCov">          1 : DocAccessible::PutChildrenBack(nsTArray&lt;RefPtr&lt;Accessible&gt; &gt;* aChildren,</span>
<span class="lineNum">    2161 </span>            :                                uint32_t aStartIdx)
<span class="lineNum">    2162 </span>            : {
<span class="lineNum">    2163 </span>            :   nsTArray&lt;RefPtr&lt;Accessible&gt; &gt; containers;
<span class="lineNum">    2164 </span><span class="lineCov">          1 :   for (auto idx = aStartIdx; idx &lt; aChildren-&gt;Length(); idx++) {</span>
<span class="lineNum">    2165 </span><span class="lineCov">          1 :     Accessible* child = aChildren-&gt;ElementAt(idx);</span>
<span class="lineNum">    2166 </span><span class="lineCov">          1 :     if (!child-&gt;IsInDocument()) {</span>
<span class="lineNum">    2167 </span>            :       continue;
<span class="lineNum">    2168 </span>            :     }
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span>            :     // Remove the child from the owner
<span class="lineNum">    2171 </span><span class="lineCov">          1 :     Accessible* owner = child-&gt;Parent();</span>
<span class="lineNum">    2172 </span><span class="lineCov">          1 :     if (!owner) {</span>
<span class="lineNum">    2173 </span>            :       NS_ERROR(&quot;Cannot put the child back. No parent, a broken tree.&quot;);
<span class="lineNum">    2174 </span>            :       continue;
<span class="lineNum">    2175 </span>            :     }
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    2178 </span>            :     logging::TreeInfo(&quot;aria owns put child back&quot;, 0,
<span class="lineNum">    2179 </span><span class="lineCov">          1 :                       &quot;old parent&quot;, owner, &quot;child&quot;, child, nullptr);</span>
<span class="lineNum">    2180 </span>            : #endif
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            :     // Unset relocated flag to find an insertion point for the child.
<span class="lineNum">    2183 </span><span class="lineCov">          1 :     child-&gt;SetRelocated(false);</span>
<span class="lineNum">    2184 </span>            : 
<span class="lineNum">    2185 </span><span class="lineCov">          1 :     int32_t idxInParent = -1;</span>
<span class="lineNum">    2186 </span><span class="lineCov">          1 :     Accessible* origContainer = GetContainerAccessible(child-&gt;GetContent());</span>
<span class="lineNum">    2187 </span><span class="lineCov">          1 :     if (origContainer) {</span>
<span class="lineNum">    2188 </span><span class="lineCov">          1 :       TreeWalker walker(origContainer);</span>
<span class="lineNum">    2189 </span><span class="lineCov">          1 :       if (walker.Seek(child-&gt;GetContent())) {</span>
<span class="lineNum">    2190 </span><span class="lineCov">          1 :         Accessible* prevChild = walker.Prev();</span>
<span class="lineNum">    2191 </span><span class="lineCov">          1 :         if (prevChild) {</span>
<span class="lineNum">    2192 </span><span class="lineCov">          1 :           idxInParent = prevChild-&gt;IndexInParent() + 1;</span>
<span class="lineNum">    2193 </span>            :           MOZ_ASSERT(origContainer == prevChild-&gt;Parent(), &quot;Broken tree&quot;);
<span class="lineNum">    2194 </span><span class="lineCov">          1 :           origContainer = prevChild-&gt;Parent();</span>
<span class="lineNum">    2195 </span>            :         }
<span class="lineNum">    2196 </span>            :         else {
<span class="lineNum">    2197 </span>            :           idxInParent = 0;
<span class="lineNum">    2198 </span>            :         }
<span class="lineNum">    2199 </span><span class="lineCov">          1 :       }</span>
<span class="lineNum">    2200 </span>            :     }
<span class="lineNum">    2201 </span><span class="lineCov">          1 :     MoveChild(child, origContainer, idxInParent);</span>
<span class="lineNum">    2202 </span>            :   }
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span><span class="lineCov">          1 :   aChildren-&gt;RemoveElementsAt(aStartIdx, aChildren-&gt;Length() - aStartIdx);</span>
<span class="lineNum">    2205 </span><span class="lineCov">          1 : }</span>
<a name="2206"><span class="lineNum">    2206 </span>            : </a>
<span class="lineNum">    2207 </span>            : bool
<span class="lineNum">    2208 </span><span class="lineCov">          1 : DocAccessible::MoveChild(Accessible* aChild, Accessible* aNewParent,</span>
<span class="lineNum">    2209 </span>            :                          int32_t aIdxInParent)
<span class="lineNum">    2210 </span>            : {
<span class="lineNum">    2211 </span>            :   MOZ_ASSERT(aChild, &quot;No child&quot;);
<span class="lineNum">    2212 </span>            :   MOZ_ASSERT(aChild-&gt;Parent(), &quot;No parent&quot;);
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span><span class="lineCov">          1 :   Accessible* curParent = aChild-&gt;Parent();</span>
<span class="lineNum">    2215 </span>            : 
<span class="lineNum">    2216 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    2217 </span>            :   logging::TreeInfo(&quot;move child&quot;, 0,
<span class="lineNum">    2218 </span>            :                     &quot;old parent&quot;, curParent, &quot;new parent&quot;, aNewParent,
<span class="lineNum">    2219 </span><span class="lineCov">          1 :                     &quot;child&quot;, aChild, nullptr);</span>
<span class="lineNum">    2220 </span>            : #endif
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            :   // If the child was taken from from an ARIA owns element.
<span class="lineNum">    2223 </span><span class="lineCov">          1 :   if (aChild-&gt;IsRelocated()) {</span>
<span class="lineNum">    2224 </span><span class="lineCov">          1 :     nsTArray&lt;RefPtr&lt;Accessible&gt; &gt;* children = mARIAOwnsHash.Get(curParent);</span>
<span class="lineNum">    2225 </span><span class="lineCov">          1 :     children-&gt;RemoveElement(aChild);</span>
<span class="lineNum">    2226 </span>            :   }
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineCov">          1 :   NotificationController::MoveGuard mguard(mNotificationController);</span>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span><span class="lineCov">          1 :   if (curParent == aNewParent) {</span>
<span class="lineNum">    2231 </span>            :     MOZ_ASSERT(aChild-&gt;IndexInParent() != aIdxInParent, &quot;No move case&quot;);
<span class="lineNum">    2232 </span><span class="lineCov">          1 :     curParent-&gt;MoveChild(aIdxInParent, aChild);</span>
<span class="lineNum">    2233 </span>            : 
<span class="lineNum">    2234 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    2235 </span>            :     logging::TreeInfo(&quot;move child: parent tree after&quot;,
<span class="lineNum">    2236 </span><span class="lineCov">          1 :                       logging::eVerbose, curParent);</span>
<span class="lineNum">    2237 </span>            : #endif
<span class="lineNum">    2238 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    2239 </span>            :   }
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineCov">          1 :   if (!aNewParent-&gt;IsAcceptableChild(aChild-&gt;GetContent())) {</span>
<span class="lineNum">    2242 </span>            :     return false;
<span class="lineNum">    2243 </span>            :   }
<span class="lineNum">    2244 </span>            : 
<span class="lineNum">    2245 </span>            :   MOZ_ASSERT(aIdxInParent &lt;= static_cast&lt;int32_t&gt;(aNewParent-&gt;ChildCount()),
<span class="lineNum">    2246 </span>            :              &quot;Wrong insertion point for a moving child&quot;);
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span>            :   // If the child cannot be re-inserted into the tree, then make sure to remove
<span class="lineNum">    2249 </span>            :   // it from its present parent and then shutdown it.
<span class="lineNum">    2250 </span><span class="lineCov">          1 :   bool hasInsertionPoint = (aIdxInParent != -1) ||</span>
<span class="lineNum">    2251 </span><span class="lineCov">          1 :     (aIdxInParent &lt;= static_cast&lt;int32_t&gt;(aNewParent-&gt;ChildCount()));</span>
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span><span class="lineCov">          1 :   TreeMutation rmut(curParent);</span>
<span class="lineNum">    2254 </span><span class="lineCov">          1 :   rmut.BeforeRemoval(aChild, hasInsertionPoint &amp;&amp; TreeMutation::kNoShutdown);</span>
<span class="lineNum">    2255 </span><span class="lineCov">          1 :   curParent-&gt;RemoveChild(aChild);</span>
<span class="lineNum">    2256 </span><span class="lineCov">          1 :   rmut.Done();</span>
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span>            :   // No insertion point for the child.
<span class="lineNum">    2259 </span><span class="lineCov">          1 :   if (!hasInsertionPoint) {</span>
<span class="lineNum">    2260 </span>            :     return true;
<span class="lineNum">    2261 </span>            :   }
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span><span class="lineCov">          1 :   TreeMutation imut(aNewParent);</span>
<span class="lineNum">    2264 </span><span class="lineCov">          1 :   aNewParent-&gt;InsertChildAt(aIdxInParent, aChild);</span>
<span class="lineNum">    2265 </span><span class="lineCov">          1 :   imut.AfterInsertion(aChild);</span>
<span class="lineNum">    2266 </span><span class="lineCov">          1 :   imut.Done();</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span>            : #ifdef A11Y_LOG
<span class="lineNum">    2269 </span>            :   logging::TreeInfo(&quot;move child: old parent tree after&quot;,
<span class="lineNum">    2270 </span><span class="lineCov">          1 :                     logging::eVerbose, curParent);</span>
<span class="lineNum">    2271 </span>            :   logging::TreeInfo(&quot;move child: new parent tree after&quot;,
<span class="lineNum">    2272 </span><span class="lineCov">          1 :                     logging::eVerbose, aNewParent);</span>
<span class="lineNum">    2273 </span>            : #endif
<span class="lineNum">    2274 </span>            : 
<span class="lineNum">    2275 </span><span class="lineCov">          1 :   return true;</span>
<span class="lineNum">    2276 </span>            : }
<span class="lineNum">    2277 </span>            : 
<a name="2278"><span class="lineNum">    2278 </span>            : </a>
<span class="lineNum">    2279 </span>            : void
<span class="lineNum">    2280 </span><span class="lineCov">          1 : DocAccessible::CacheChildrenInSubtree(Accessible* aRoot,</span>
<span class="lineNum">    2281 </span>            :                                       Accessible** aFocusedAcc)
<span class="lineNum">    2282 </span>            : {
<span class="lineNum">    2283 </span>            :   // If the accessible is focused then report a focus event after all related
<span class="lineNum">    2284 </span>            :   // mutation events.
<span class="lineNum">    2285 </span><span class="lineCov">          1 :   if (aFocusedAcc &amp;&amp; !*aFocusedAcc &amp;&amp;</span>
<span class="lineNum">    2286 </span><span class="lineCov">          1 :       FocusMgr()-&gt;HasDOMFocus(aRoot-&gt;GetContent()))</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :     *aFocusedAcc = aRoot;</span>
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span><span class="lineCov">          1 :   Accessible* root = aRoot-&gt;IsHTMLCombobox() ? aRoot-&gt;FirstChild() : aRoot;</span>
<span class="lineNum">    2290 </span><span class="lineCov">          1 :   if (root-&gt;KidsFromDOM()) {</span>
<span class="lineNum">    2291 </span><span class="lineCov">          1 :     TreeMutation mt(root, TreeMutation::kNoEvents);</span>
<span class="lineNum">    2292 </span><span class="lineCov">          1 :     TreeWalker walker(root);</span>
<span class="lineNum">    2293 </span><span class="lineCov">          1 :     while (Accessible* child = walker.Next()) {</span>
<span class="lineNum">    2294 </span><span class="lineCov">          1 :       if (child-&gt;IsBoundToParent()) {</span>
<span class="lineNum">    2295 </span><span class="lineCov">          1 :         MoveChild(child, root, root-&gt;ChildCount());</span>
<span class="lineNum">    2296 </span><span class="lineCov">          1 :         continue;</span>
<span class="lineNum">    2297 </span>            :       }
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span><span class="lineCov">          1 :       root-&gt;AppendChild(child);</span>
<span class="lineNum">    2300 </span><span class="lineCov">          1 :       mt.AfterInsertion(child);</span>
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span><span class="lineCov">          1 :       CacheChildrenInSubtree(child, aFocusedAcc);</span>
<span class="lineNum">    2303 </span>            :     }
<span class="lineNum">    2304 </span><span class="lineCov">          1 :     mt.Done();</span>
<span class="lineNum">    2305 </span>            :   }
<span class="lineNum">    2306 </span>            : 
<span class="lineNum">    2307 </span>            :   // Fire events for ARIA elements.
<span class="lineNum">    2308 </span><span class="lineCov">          1 :   if (!aRoot-&gt;HasARIARole()) {</span>
<span class="lineNum">    2309 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    2310 </span>            :   }
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            :   // XXX: we should delay document load complete event if the ARIA document
<span class="lineNum">    2313 </span>            :   // has aria-busy.
<span class="lineNum">    2314 </span><span class="lineCov">          1 :   roles::Role role = aRoot-&gt;ARIARole();</span>
<span class="lineNum">    2315 </span><span class="lineCov">          1 :   if (!aRoot-&gt;IsDoc() &amp;&amp; (role == roles::DIALOG || role == roles::DOCUMENT)) {</span>
<span class="lineNum">    2316 </span><span class="lineCov">          1 :     FireDelayedEvent(nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE, aRoot);</span>
<span class="lineNum">    2317 </span>            :   }
<span class="lineNum">    2318 </span>            : }
<a name="2319"><span class="lineNum">    2319 </span>            : </a>
<span class="lineNum">    2320 </span>            : void
<span class="lineNum">    2321 </span><span class="lineCov">          1 : DocAccessible::UncacheChildrenInSubtree(Accessible* aRoot)</span>
<span class="lineNum">    2322 </span>            : {
<span class="lineNum">    2323 </span><span class="lineCov">          1 :   aRoot-&gt;mStateFlags |= eIsNotInDocument;</span>
<span class="lineNum">    2324 </span><span class="lineCov">          1 :   RemoveDependentIDsFor(aRoot);</span>
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span><span class="lineCov">          1 :   uint32_t count = aRoot-&gt;ContentChildCount();</span>
<span class="lineNum">    2327 </span><span class="lineCov">          1 :   for (uint32_t idx = 0; idx &lt; count; idx++) {</span>
<span class="lineNum">    2328 </span><span class="lineCov">          1 :     Accessible* child = aRoot-&gt;ContentChildAt(idx);</span>
<span class="lineNum">    2329 </span>            : 
<span class="lineNum">    2330 </span>            :     // Removing this accessible from the document doesn't mean anything about
<span class="lineNum">    2331 </span>            :     // accessibles for subdocuments, so skip removing those from the tree.
<span class="lineNum">    2332 </span><span class="lineCov">          1 :     if (!child-&gt;IsDoc()) {</span>
<span class="lineNum">    2333 </span><span class="lineCov">          1 :       UncacheChildrenInSubtree(child);</span>
<span class="lineNum">    2334 </span>            :     }
<span class="lineNum">    2335 </span>            :   }
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span><span class="lineCov">          1 :   if (aRoot-&gt;IsNodeMapEntry() &amp;&amp;</span>
<span class="lineNum">    2338 </span><span class="lineCov">          1 :       mNodeToAccessibleMap.Get(aRoot-&gt;GetNode()) == aRoot)</span>
<span class="lineNum">    2339 </span><span class="lineCov">          1 :     mNodeToAccessibleMap.Remove(aRoot-&gt;GetNode());</span>
<span class="lineNum">    2340 </span><span class="lineCov">          1 : }</span>
<a name="2341"><span class="lineNum">    2341 </span>            : </a>
<span class="lineNum">    2342 </span>            : void
<span class="lineNum">    2343 </span><span class="lineCov">          1 : DocAccessible::ShutdownChildrenInSubtree(Accessible* aAccessible)</span>
<span class="lineNum">    2344 </span>            : {
<span class="lineNum">    2345 </span>            :   // Traverse through children and shutdown them before this accessible. When
<span class="lineNum">    2346 </span>            :   // child gets shutdown then it removes itself from children array of its
<span class="lineNum">    2347 </span>            :   //parent. Use jdx index to process the cases if child is not attached to the
<span class="lineNum">    2348 </span>            :   // parent and as result doesn't remove itself from its children.
<span class="lineNum">    2349 </span><span class="lineCov">          1 :   uint32_t count = aAccessible-&gt;ContentChildCount();</span>
<span class="lineNum">    2350 </span><span class="lineCov">          1 :   for (uint32_t idx = 0, jdx = 0; idx &lt; count; idx++) {</span>
<span class="lineNum">    2351 </span><span class="lineCov">          1 :     Accessible* child = aAccessible-&gt;ContentChildAt(jdx);</span>
<span class="lineNum">    2352 </span><span class="lineCov">          1 :     if (!child-&gt;IsBoundToParent()) {</span>
<span class="lineNum">    2353 </span>            :       NS_ERROR(&quot;Parent refers to a child, child doesn't refer to parent!&quot;);
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :       jdx++;</span>
<span class="lineNum">    2355 </span>            :     }
<span class="lineNum">    2356 </span>            : 
<span class="lineNum">    2357 </span>            :     // Don't cross document boundaries. The outerdoc shutdown takes care about
<span class="lineNum">    2358 </span>            :     // its subdocument.
<span class="lineNum">    2359 </span><span class="lineCov">          1 :     if (!child-&gt;IsDoc())</span>
<span class="lineNum">    2360 </span><span class="lineCov">          1 :       ShutdownChildrenInSubtree(child);</span>
<span class="lineNum">    2361 </span>            :   }
<span class="lineNum">    2362 </span>            : 
<span class="lineNum">    2363 </span><span class="lineCov">          1 :   UnbindFromDocument(aAccessible);</span>
<span class="lineNum">    2364 </span><span class="lineCov">          1 : }</span>
<a name="2365"><span class="lineNum">    2365 </span>            : </a>
<span class="lineNum">    2366 </span>            : bool
<span class="lineNum">    2367 </span><span class="lineCov">          1 : DocAccessible::IsLoadEventTarget() const</span>
<span class="lineNum">    2368 </span>            : {
<span class="lineNum">    2369 </span><span class="lineCov">          1 :   nsCOMPtr&lt;nsIDocShellTreeItem&gt; treeItem = mDocumentNode-&gt;GetDocShell();</span>
<span class="lineNum">    2370 </span>            :   NS_ASSERTION(treeItem, &quot;No document shell for document!&quot;);
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span>            :   nsCOMPtr&lt;nsIDocShellTreeItem&gt; parentTreeItem;
<span class="lineNum">    2373 </span><span class="lineCov">          1 :   treeItem-&gt;GetParent(getter_AddRefs(parentTreeItem));</span>
<span class="lineNum">    2374 </span>            : 
<span class="lineNum">    2375 </span>            :   // Not a root document.
<span class="lineNum">    2376 </span><span class="lineCov">          1 :   if (parentTreeItem) {</span>
<span class="lineNum">    2377 </span>            :     // Return true if it's either:
<span class="lineNum">    2378 </span>            :     // a) tab document;
<span class="lineNum">    2379 </span>            :     nsCOMPtr&lt;nsIDocShellTreeItem&gt; rootTreeItem;
<span class="lineNum">    2380 </span><span class="lineCov">          1 :     treeItem-&gt;GetRootTreeItem(getter_AddRefs(rootTreeItem));</span>
<span class="lineNum">    2381 </span><span class="lineCov">          1 :     if (parentTreeItem == rootTreeItem)</span>
<span class="lineNum">    2382 </span>            :       return true;
<span class="lineNum">    2383 </span>            : 
<span class="lineNum">    2384 </span>            :     // b) frame/iframe document and its parent document is not in loading state
<span class="lineNum">    2385 </span>            :     // Note: we can get notifications while document is loading (and thus
<span class="lineNum">    2386 </span>            :     // while there's no parent document yet).
<span class="lineNum">    2387 </span><span class="lineCov">          1 :     DocAccessible* parentDoc = ParentDocument();</span>
<span class="lineNum">    2388 </span><span class="lineCov">          1 :     return parentDoc &amp;&amp; parentDoc-&gt;HasLoadState(eCompletelyLoaded);</span>
<span class="lineNum">    2389 </span>            :   }
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span>            :   // It's content (not chrome) root document.
<span class="lineNum">    2392 </span><span class="lineCov">          1 :   return (treeItem-&gt;ItemType() == nsIDocShellTreeItem::typeContent);</span>
<span class="lineNum">    2393 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
