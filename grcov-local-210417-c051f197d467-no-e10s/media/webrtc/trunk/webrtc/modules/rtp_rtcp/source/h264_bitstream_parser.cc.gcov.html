<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/h264_bitstream_parser.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/rtp_rtcp/source</a> - h264_bitstream_parser.cc<span style="font-size: 80%;"> (source / <a href="h264_bitstream_parser.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">226</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : #include &quot;webrtc/modules/rtp_rtcp/source/h264_bitstream_parser.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;vector&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;webrtc/base/bitbuffer.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;webrtc/base/bytebuffer.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;webrtc/base/checks.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;webrtc/base/logging.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;webrtc/base/scoped_ptr.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : namespace webrtc {
<span class="lineNum">      21 </span>            : namespace {
<span class="lineNum">      22 </span>            : // The size of a NALU header {0 0 0 1}.
<span class="lineNum">      23 </span>            : static const size_t kNaluHeaderSize = 4;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : // The size of a NALU header plus the type byte.
<span class="lineNum">      26 </span>            : static const size_t kNaluHeaderAndTypeSize = kNaluHeaderSize + 1;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : // The NALU type.
<span class="lineNum">      29 </span>            : static const uint8_t kNaluSps = 0x7;
<span class="lineNum">      30 </span>            : static const uint8_t kNaluPps = 0x8;
<span class="lineNum">      31 </span>            : static const uint8_t kNaluIdr = 0x5;
<span class="lineNum">      32 </span>            : static const uint8_t kNaluTypeMask = 0x1F;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : static const uint8_t kSliceTypeP = 0x0;
<span class="lineNum">      35 </span>            : static const uint8_t kSliceTypeB = 0x1;
<span class="lineNum">      36 </span>            : static const uint8_t kSliceTypeSp = 0x3;
<a name="37"><span class="lineNum">      37 </span>            : </a>
<span class="lineNum">      38 </span>            : // Returns a vector of the NALU start sequences (0 0 0 1) in the given buffer.
<span class="lineNum">      39 </span><span class="lineNoCov">          0 : std::vector&lt;size_t&gt; FindNaluStartSequences(const uint8_t* buffer,</span>
<span class="lineNum">      40 </span>            :                                            size_t buffer_size) {
<span class="lineNum">      41 </span>            :   std::vector&lt;size_t&gt; sequences;
<span class="lineNum">      42 </span>            :   // This is sorta like Boyer-Moore, but with only the first optimization step:
<span class="lineNum">      43 </span>            :   // given a 4-byte sequence we're looking at, if the 4th byte isn't 1 or 0,
<span class="lineNum">      44 </span>            :   // skip ahead to the next 4-byte sequence. 0s and 1s are relatively rare, so
<span class="lineNum">      45 </span>            :   // this will skip the majority of reads/checks.
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   const uint8_t* end = buffer + buffer_size - 4;</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   for (const uint8_t* head = buffer; head &lt; end;) {</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :     if (head[3] &gt; 1) {</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :       head += 4;</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     } else if (head[3] == 1 &amp;&amp; head[2] == 0 &amp;&amp; head[1] == 0 &amp;&amp; head[0] == 0) {</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :       sequences.push_back(static_cast&lt;size_t&gt;(head - buffer));</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :       head += 4;</span>
<span class="lineNum">      53 </span>            :     } else {
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :       head++;</span>
<span class="lineNum">      55 </span>            :     }
<span class="lineNum">      56 </span>            :   }
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   return sequences;</span>
<span class="lineNum">      59 </span>            : }
<span class="lineNum">      60 </span>            : }  // namespace
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : // Parses RBSP from source bytes. Removes emulation bytes, but leaves the
<span class="lineNum">      63 </span>            : // rbsp_trailing_bits() in the stream, since none of the parsing reads all the
<span class="lineNum">      64 </span>            : // way to the end of a parsed RBSP sequence. When writing, that means the
<span class="lineNum">      65 </span>            : // rbsp_trailing_bits() should be preserved and don't need to be restored (i.e.
<span class="lineNum">      66 </span>            : // the rbsp_stop_one_bit, which is just a 1, then zero padded), and alignment
<span class="lineNum">      67 </span>            : // should &quot;just work&quot;.
<span class="lineNum">      68 </span>            : // TODO(pbos): Make parsing RBSP something that can be integrated into BitBuffer
<a name="69"><span class="lineNum">      69 </span>            : // so we don't have to copy the entire frames when only interested in the</a>
<span class="lineNum">      70 </span>            : // headers.
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : rtc::ByteBuffer* ParseRbsp(const uint8_t* bytes, size_t length) {</span>
<span class="lineNum">      72 </span>            :   // Copied from webrtc::H264SpsParser::Parse.
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   rtc::ByteBuffer* rbsp_buffer = new rtc::ByteBuffer;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; length;) {</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     if (length - i &gt;= 3 &amp;&amp; bytes[i] == 0 &amp;&amp; bytes[i + 1] == 0 &amp;&amp;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :         bytes[i + 2] == 3) {</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :       rbsp_buffer-&gt;WriteBytes(reinterpret_cast&lt;const char*&gt;(bytes) + i, 2);</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :       i += 3;</span>
<span class="lineNum">      79 </span>            :     } else {
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :       rbsp_buffer-&gt;WriteBytes(reinterpret_cast&lt;const char*&gt;(bytes) + i, 1);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :       i++;</span>
<span class="lineNum">      82 </span>            :     }
<span class="lineNum">      83 </span>            :   }
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   return rbsp_buffer;</span>
<span class="lineNum">      85 </span>            : }
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : #define RETURN_FALSE_ON_FAIL(x)       \
<span class="lineNum">      88 </span>            :   if (!(x)) {                         \
<span class="lineNum">      89 </span>            :     LOG_F(LS_ERROR) &lt;&lt; &quot;FAILED: &quot; #x; \
<span class="lineNum">      90 </span>            :     return false;                     \
<a name="91"><span class="lineNum">      91 </span>            :   }</a>
<span class="lineNum">      92 </span>            : 
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 : H264BitstreamParser::PpsState::PpsState() {}</span></a>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 : H264BitstreamParser::SpsState::SpsState() {}</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : // These functions are similar to webrtc::H264SpsParser::Parse, and based on the
<a name="98"><span class="lineNum">      98 </span>            : // same version of the H.264 standard. You can find it here:</a>
<span class="lineNum">      99 </span>            : // http://www.itu.int/rec/T-REC-H.264
<span class="lineNum">     100 </span><span class="lineNoCov">          0 : bool H264BitstreamParser::ParseSpsNalu(const uint8_t* sps, size_t length) {</span>
<span class="lineNum">     101 </span>            :   // Reset SPS state.
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   sps_ = SpsState();</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   sps_parsed_ = false;</span>
<span class="lineNum">     104 </span>            :   // Parse out the SPS RBSP. It should be small, so it's ok that we create a
<span class="lineNum">     105 </span>            :   // copy. We'll eventually write this back.
<span class="lineNum">     106 </span>            :   rtc::scoped_ptr&lt;rtc::ByteBuffer&gt; sps_rbsp(
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :       ParseRbsp(sps + kNaluHeaderAndTypeSize, length - kNaluHeaderAndTypeSize));</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   rtc::BitBuffer sps_parser(reinterpret_cast&lt;const uint8_t*&gt;(sps_rbsp-&gt;Data()),</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :                             sps_rbsp-&gt;Length());</span>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :   uint8_t byte_tmp;
<span class="lineNum">     112 </span>            :   uint32_t golomb_tmp;
<span class="lineNum">     113 </span>            :   uint32_t bits_tmp;
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :   // profile_idc: u(8).
<span class="lineNum">     116 </span>            :   uint8_t profile_idc;
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadUInt8(&amp;profile_idc));</span>
<span class="lineNum">     118 </span>            :   // constraint_set0_flag through constraint_set5_flag + reserved_zero_2bits
<span class="lineNum">     119 </span>            :   // 1 bit each for the flags + 2 bits = 8 bits = 1 byte.
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadUInt8(&amp;byte_tmp));</span>
<span class="lineNum">     121 </span>            :   // level_idc: u(8)
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadUInt8(&amp;byte_tmp));</span>
<span class="lineNum">     123 </span>            :   // seq_parameter_set_id: ue(v)
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   sps_.separate_colour_plane_flag = 0;</span>
<span class="lineNum">     126 </span>            :   // See if profile_idc has chroma format information.
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   if (profile_idc == 100 || profile_idc == 110 || profile_idc == 122 ||</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :       profile_idc == 244 || profile_idc == 44 || profile_idc == 83 ||</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :       profile_idc == 86 || profile_idc == 118 || profile_idc == 128 ||</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :       profile_idc == 138 || profile_idc == 139 || profile_idc == 134) {</span>
<span class="lineNum">     131 </span>            :     // chroma_format_idc: ue(v)
<span class="lineNum">     132 </span>            :     uint32_t chroma_format_idc;
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;chroma_format_idc));</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     if (chroma_format_idc == 3) {</span>
<span class="lineNum">     135 </span>            :       // separate_colour_plane_flag: u(1)
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     137 </span>            :           sps_parser.ReadBits(&amp;sps_.separate_colour_plane_flag, 1));
<span class="lineNum">     138 </span>            :     }
<span class="lineNum">     139 </span>            :     // bit_depth_luma_minus8: ue(v)
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     141 </span>            :     // bit_depth_chroma_minus8: ue(v)
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     143 </span>            :     // qpprime_y_zero_transform_bypass_flag: u(1)
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadBits(&amp;bits_tmp, 1));</span>
<span class="lineNum">     145 </span>            :     // seq_scaling_matrix_present_flag: u(1)
<span class="lineNum">     146 </span>            :     uint32_t seq_scaling_matrix_present_flag;
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     148 </span>            :         sps_parser.ReadBits(&amp;seq_scaling_matrix_present_flag, 1));
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     if (seq_scaling_matrix_present_flag) {</span>
<span class="lineNum">     150 </span>            :       // seq_scaling_list_present_flags. Either 8 or 12, depending on
<span class="lineNum">     151 </span>            :       // chroma_format_idc.
<span class="lineNum">     152 </span>            :       uint32_t seq_scaling_list_present_flags;
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :       if (chroma_format_idc != 3) {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     155 </span>            :             sps_parser.ReadBits(&amp;seq_scaling_list_present_flags, 8));
<span class="lineNum">     156 </span>            :       } else {
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     158 </span>            :             sps_parser.ReadBits(&amp;seq_scaling_list_present_flags, 12));
<span class="lineNum">     159 </span>            :       }
<span class="lineNum">     160 </span>            :       // TODO(pbos): Support parsing scaling lists if they're seen in practice.
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       RTC_CHECK(seq_scaling_list_present_flags == 0)</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;SPS contains scaling lists, which are unsupported.&quot;;</span>
<span class="lineNum">     163 </span>            :     }
<span class="lineNum">     164 </span>            :   }
<span class="lineNum">     165 </span>            :   // log2_max_frame_num_minus4: ue(v)
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     167 </span>            :       sps_parser.ReadExponentialGolomb(&amp;sps_.log2_max_frame_num_minus4));
<span class="lineNum">     168 </span>            :   // pic_order_cnt_type: ue(v)
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     170 </span>            :       sps_parser.ReadExponentialGolomb(&amp;sps_.pic_order_cnt_type));
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   if (sps_.pic_order_cnt_type == 0) {</span>
<span class="lineNum">     173 </span>            :     // log2_max_pic_order_cnt_lsb_minus4: ue(v)
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(</span>
<span class="lineNum">     175 </span>            :         &amp;sps_.log2_max_pic_order_cnt_lsb_minus4));
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   } else if (sps_.pic_order_cnt_type == 1) {</span>
<span class="lineNum">     177 </span>            :     // delta_pic_order_always_zero_flag: u(1)
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     179 </span>            :         sps_parser.ReadBits(&amp;sps_.delta_pic_order_always_zero_flag, 1));
<span class="lineNum">     180 </span>            :     // offset_for_non_ref_pic: se(v)
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     182 </span>            :     // offset_for_top_to_bottom_field: se(v)
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     184 </span>            :     uint32_t num_ref_frames_in_pic_order_cnt_cycle;
<span class="lineNum">     185 </span>            :     // num_ref_frames_in_pic_order_cnt_cycle: ue(v)
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(</span>
<span class="lineNum">     187 </span>            :         &amp;num_ref_frames_in_pic_order_cnt_cycle));
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; num_ref_frames_in_pic_order_cnt_cycle; i++) {</span>
<span class="lineNum">     189 </span>            :       // offset_for_ref_frame[i]: se(v)
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span>            :   }
<span class="lineNum">     193 </span>            :   // max_num_ref_frames: ue(v)
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     195 </span>            :   // gaps_in_frame_num_value_allowed_flag: u(1)
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadBits(&amp;bits_tmp, 1));</span>
<span class="lineNum">     197 </span>            :   // pic_width_in_mbs_minus1: ue(v)
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     199 </span>            :   // pic_height_in_map_units_minus1: ue(v)
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     201 </span>            :   // frame_mbs_only_flag: u(1)
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(sps_parser.ReadBits(&amp;sps_.frame_mbs_only_flag, 1));</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   sps_parsed_ = true;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="205"><span class="lineNum">     205 </span>            : }</a>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : bool H264BitstreamParser::ParsePpsNalu(const uint8_t* pps, size_t length) {</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   RTC_CHECK(sps_parsed_);</span>
<span class="lineNum">     209 </span>            :   // We're starting a new stream, so reset picture type rewriting values.
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   pps_ = PpsState();</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   pps_parsed_ = false;</span>
<span class="lineNum">     212 </span>            :   rtc::scoped_ptr&lt;rtc::ByteBuffer&gt; buffer(
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       ParseRbsp(pps + kNaluHeaderAndTypeSize, length - kNaluHeaderAndTypeSize));</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   rtc::BitBuffer parser(reinterpret_cast&lt;const uint8_t*&gt;(buffer-&gt;Data()),</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                         buffer-&gt;Length());</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   uint32_t bits_tmp;
<span class="lineNum">     218 </span>            :   uint32_t golomb_ignored;
<span class="lineNum">     219 </span>            :   // pic_parameter_set_id: ue(v)
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     221 </span>            :   // seq_parameter_set_id: ue(v)
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     223 </span>            :   // entropy_coding_mode_flag: u(1)
<span class="lineNum">     224 </span>            :   uint32_t entropy_coding_mode_flag;
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadBits(&amp;entropy_coding_mode_flag, 1));</span>
<span class="lineNum">     226 </span>            :   // TODO(pbos): Implement CABAC support if spotted in the wild.
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   RTC_CHECK(entropy_coding_mode_flag == 0)</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;Don't know how to parse CABAC streams.&quot;;</span>
<span class="lineNum">     229 </span>            :   // bottom_field_pic_order_in_frame_present_flag: u(1)
<span class="lineNum">     230 </span>            :   uint32_t bottom_field_pic_order_in_frame_present_flag;
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     232 </span>            :       parser.ReadBits(&amp;bottom_field_pic_order_in_frame_present_flag, 1));
<span class="lineNum">     233 </span>            :   pps_.bottom_field_pic_order_in_frame_present_flag =
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       bottom_field_pic_order_in_frame_present_flag != 0;</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   // num_slice_groups_minus1: ue(v)
<span class="lineNum">     237 </span>            :   uint32_t num_slice_groups_minus1;
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;num_slice_groups_minus1));</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   if (num_slice_groups_minus1 &gt; 0) {</span>
<span class="lineNum">     240 </span>            :     uint32_t slice_group_map_type;
<span class="lineNum">     241 </span>            :     // slice_group_map_type: ue(v)
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;slice_group_map_type));</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     if (slice_group_map_type == 0) {</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       for (uint32_t i_group = 0; i_group &lt;= num_slice_groups_minus1;</span>
<span class="lineNum">     245 </span>            :            ++i_group) {
<span class="lineNum">     246 </span>            :         // run_length_minus1[iGroup]: ue(v)
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     248 </span>            :       }
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     } else if (slice_group_map_type == 2) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :       for (uint32_t i_group = 0; i_group &lt;= num_slice_groups_minus1;</span>
<span class="lineNum">     251 </span>            :            ++i_group) {
<span class="lineNum">     252 </span>            :         // top_left[iGroup]: ue(v)
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     254 </span>            :         // bottom_right[iGroup]: ue(v)
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     256 </span>            :       }
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     } else if (slice_group_map_type == 3 || slice_group_map_type == 4 ||</span>
<span class="lineNum">     258 </span>            :                slice_group_map_type == 5) {
<span class="lineNum">     259 </span>            :       // slice_group_change_direction_flag: u(1)
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(parser.ReadBits(&amp;bits_tmp, 1));</span>
<span class="lineNum">     261 </span>            :       // slice_group_change_rate_minus1: ue(v)
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     } else if (slice_group_map_type == 6) {</span>
<span class="lineNum">     264 </span>            :       // pic_size_in_map_units_minus1: ue(v)
<span class="lineNum">     265 </span>            :       uint32_t pic_size_in_map_units_minus1;
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     267 </span>            :           parser.ReadExponentialGolomb(&amp;pic_size_in_map_units_minus1));
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :       uint32_t slice_group_id_bits = 0;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       uint32_t num_slice_groups = num_slice_groups_minus1 + 1;</span>
<span class="lineNum">     270 </span>            :       // If num_slice_groups is not a power of two an additional bit is required
<span class="lineNum">     271 </span>            :       // to account for the ceil() of log2() below.
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       if ((num_slice_groups &amp; (num_slice_groups - 1)) != 0)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         ++slice_group_id_bits;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       while (num_slice_groups &gt; 0) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         num_slice_groups &gt;&gt;= 1;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         ++slice_group_id_bits;</span>
<span class="lineNum">     277 </span>            :       }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; i &lt;= pic_size_in_map_units_minus1; i++) {</span>
<span class="lineNum">     279 </span>            :         // slice_group_id[i]: u(v)
<span class="lineNum">     280 </span>            :         // Represented by ceil(log2(num_slice_groups_minus1 + 1)) bits.
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(parser.ReadBits(&amp;bits_tmp, slice_group_id_bits));</span>
<span class="lineNum">     282 </span>            :       }
<span class="lineNum">     283 </span>            :     }
<span class="lineNum">     284 </span>            :   }
<span class="lineNum">     285 </span>            :   // num_ref_idx_l0_default_active_minus1: ue(v)
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     287 </span>            :   // num_ref_idx_l1_default_active_minus1: ue(v)
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     289 </span>            :   // weighted_pred_flag: u(1)
<span class="lineNum">     290 </span>            :   uint32_t weighted_pred_flag;
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadBits(&amp;weighted_pred_flag, 1));</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   pps_.weighted_pred_flag = weighted_pred_flag != 0;</span>
<span class="lineNum">     293 </span>            :   // weighted_bipred_idc: u(2)
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadBits(&amp;pps_.weighted_bipred_idc, 2));</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   // pic_init_qp_minus26: se(v)
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     298 </span>            :       parser.ReadSignedExponentialGolomb(&amp;pps_.pic_init_qp_minus26));
<span class="lineNum">     299 </span>            :   // pic_init_qs_minus26: se(v)
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     301 </span>            :   // chroma_qp_index_offset: se(v)
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadExponentialGolomb(&amp;golomb_ignored));</span>
<span class="lineNum">     303 </span>            :   // deblocking_filter_control_present_flag: u(1)
<span class="lineNum">     304 </span>            :   // constrained_intra_pred_flag: u(1)
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(parser.ReadBits(&amp;bits_tmp, 2));</span>
<span class="lineNum">     306 </span>            :   // redundant_pic_cnt_present_flag: u(1)
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     308 </span>            :       parser.ReadBits(&amp;pps_.redundant_pic_cnt_present_flag, 1));
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   pps_parsed_ = true;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="312"><span class="lineNum">     312 </span>            : }</a>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 : bool H264BitstreamParser::ParseNonParameterSetNalu(const uint8_t* source,</span>
<span class="lineNum">     315 </span>            :                                                    size_t source_length,
<span class="lineNum">     316 </span>            :                                                    uint8_t nalu_type) {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   RTC_CHECK(sps_parsed_);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   RTC_CHECK(pps_parsed_);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   last_slice_qp_delta_parsed_ = false;</span>
<span class="lineNum">     320 </span>            :   rtc::scoped_ptr&lt;rtc::ByteBuffer&gt; slice_rbsp(ParseRbsp(
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :       source + kNaluHeaderAndTypeSize, source_length - kNaluHeaderAndTypeSize));</span>
<span class="lineNum">     322 </span>            :   rtc::BitBuffer slice_reader(
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :       reinterpret_cast&lt;const uint8_t*&gt;(slice_rbsp-&gt;Data()),</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :       slice_rbsp-&gt;Length());</span>
<span class="lineNum">     325 </span>            :   // Check to see if this is an IDR slice, which has an extra field to parse
<span class="lineNum">     326 </span>            :   // out.
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   bool is_idr = (source[kNaluHeaderSize] &amp; 0x0F) == kNaluIdr;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   uint8_t nal_ref_idc = (source[kNaluHeaderSize] &amp; 0x60) &gt;&gt; 5;</span>
<span class="lineNum">     329 </span>            :   uint32_t golomb_tmp;
<span class="lineNum">     330 </span>            :   uint32_t bits_tmp;
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :   // first_mb_in_slice: ue(v)
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     334 </span>            :   // slice_type: ue(v)
<span class="lineNum">     335 </span>            :   uint32_t slice_type;
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;slice_type));</span>
<span class="lineNum">     337 </span>            :   // slice_type's 5..9 range is used to indicate that all slices of a picture
<span class="lineNum">     338 </span>            :   // have the same value of slice_type % 5, we don't care about that, so we map
<span class="lineNum">     339 </span>            :   // to the corresponding 0..4 range.
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   slice_type %= 5;</span>
<span class="lineNum">     341 </span>            :   // pic_parameter_set_id: ue(v)
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   if (sps_.separate_colour_plane_flag == 1) {</span>
<span class="lineNum">     344 </span>            :     // colour_plane_id
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 2));</span>
<span class="lineNum">     346 </span>            :   }
<span class="lineNum">     347 </span>            :   // frame_num: u(v)
<span class="lineNum">     348 </span>            :   // Represented by log2_max_frame_num_minus4 + 4 bits.
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     350 </span>            :       slice_reader.ReadBits(&amp;bits_tmp, sps_.log2_max_frame_num_minus4 + 4));
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   uint32_t field_pic_flag = 0;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   if (sps_.frame_mbs_only_flag == 0) {</span>
<span class="lineNum">     353 </span>            :     // field_pic_flag: u(1)
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadBits(&amp;field_pic_flag, 1));</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     if (field_pic_flag != 0) {</span>
<span class="lineNum">     356 </span>            :       // bottom_field_flag: u(1)
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1));</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span>            :   }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   if (is_idr) {</span>
<span class="lineNum">     361 </span>            :     // idr_pic_id: ue(v)
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     363 </span>            :   }
<span class="lineNum">     364 </span>            :   // pic_order_cnt_lsb: u(v)
<span class="lineNum">     365 </span>            :   // Represented by sps_.log2_max_pic_order_cnt_lsb_minus4 + 4 bits.
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   if (sps_.pic_order_cnt_type == 0) {</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadBits(</span>
<span class="lineNum">     368 </span>            :         &amp;bits_tmp, sps_.log2_max_pic_order_cnt_lsb_minus4 + 4));
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     if (pps_.bottom_field_pic_order_in_frame_present_flag &amp;&amp;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         field_pic_flag == 0) {</span>
<span class="lineNum">     371 </span>            :       // delta_pic_order_cnt_bottom: se(v)
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     373 </span>            :     }
<span class="lineNum">     374 </span>            :   }
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   if (sps_.pic_order_cnt_type == 1 &amp;&amp; !sps_.delta_pic_order_always_zero_flag) {</span>
<span class="lineNum">     376 </span>            :     // delta_pic_order_cnt[0]: se(v)
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     if (pps_.bottom_field_pic_order_in_frame_present_flag &amp;&amp; !field_pic_flag) {</span>
<span class="lineNum">     379 </span>            :       // delta_pic_order_cnt[1]: se(v)
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span>            :   }
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   if (pps_.redundant_pic_cnt_present_flag) {</span>
<span class="lineNum">     384 </span>            :     // redundant_pic_cnt: ue(v)
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     386 </span>            :   }
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   if (slice_type == kSliceTypeB) {</span>
<span class="lineNum">     388 </span>            :     // direct_spatial_mv_pred_flag: u(1)
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1));</span>
<span class="lineNum">     390 </span>            :   }
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   if (slice_type == kSliceTypeP || slice_type == kSliceTypeSp ||</span>
<span class="lineNum">     392 </span>            :       slice_type == kSliceTypeB) {
<span class="lineNum">     393 </span>            :     uint32_t num_ref_idx_active_override_flag;
<span class="lineNum">     394 </span>            :     // num_ref_idx_active_override_flag: u(1)
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     396 </span>            :         slice_reader.ReadBits(&amp;num_ref_idx_active_override_flag, 1));
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     if (num_ref_idx_active_override_flag != 0) {</span>
<span class="lineNum">     398 </span>            :       // num_ref_idx_l0_active_minus1: ue(v)
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       if (slice_type == kSliceTypeB) {</span>
<span class="lineNum">     401 </span>            :         // num_ref_idx_l1_active_minus1: ue(v)
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));</span>
<span class="lineNum">     403 </span>            :       }
<span class="lineNum">     404 </span>            :     }
<span class="lineNum">     405 </span>            :   }
<span class="lineNum">     406 </span>            :   // assume nal_unit_type != 20 &amp;&amp; nal_unit_type != 21:
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   RTC_CHECK_NE(nalu_type, 20);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   RTC_CHECK_NE(nalu_type, 21);</span>
<span class="lineNum">     409 </span>            :   // if (nal_unit_type == 20 || nal_unit_type == 21)
<span class="lineNum">     410 </span>            :   //   ref_pic_list_mvc_modification()
<span class="lineNum">     411 </span>            :   // else
<span class="lineNum">     412 </span>            :   {
<span class="lineNum">     413 </span>            :     // ref_pic_list_modification():
<span class="lineNum">     414 </span>            :     // |slice_type| checks here don't use named constants as they aren't named
<span class="lineNum">     415 </span>            :     // in the spec for this segment. Keeping them consistent makes it easier to
<span class="lineNum">     416 </span>            :     // verify that they are both the same.
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     if (slice_type % 5 != 2 &amp;&amp; slice_type % 5 != 4) {</span>
<span class="lineNum">     418 </span>            :       // ref_pic_list_modification_flag_l0: u(1)
<span class="lineNum">     419 </span>            :       uint32_t ref_pic_list_modification_flag_l0;
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     421 </span>            :           slice_reader.ReadBits(&amp;ref_pic_list_modification_flag_l0, 1));
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       if (ref_pic_list_modification_flag_l0) {</span>
<span class="lineNum">     423 </span>            :         uint32_t modification_of_pic_nums_idc;
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     425 </span>            :           // modification_of_pic_nums_idc: ue(v)
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :           RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(</span>
<span class="lineNum">     427 </span>            :               &amp;modification_of_pic_nums_idc));
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :           if (modification_of_pic_nums_idc == 0 ||</span>
<span class="lineNum">     429 </span>            :               modification_of_pic_nums_idc == 1) {
<span class="lineNum">     430 </span>            :             // abs_diff_pic_num_minus1: ue(v)
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     432 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :           } else if (modification_of_pic_nums_idc == 2) {</span>
<span class="lineNum">     434 </span>            :             // long_term_pic_num: ue(v)
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     436 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     437 </span>            :           }
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :         } while (modification_of_pic_nums_idc != 3);</span>
<span class="lineNum">     439 </span>            :       }
<span class="lineNum">     440 </span>            :     }
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     if (slice_type % 5 == 1) {</span>
<span class="lineNum">     442 </span>            :       // ref_pic_list_modification_flag_l1: u(1)
<span class="lineNum">     443 </span>            :       uint32_t ref_pic_list_modification_flag_l1;
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     445 </span>            :           slice_reader.ReadBits(&amp;ref_pic_list_modification_flag_l1, 1));
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       if (ref_pic_list_modification_flag_l1) {</span>
<span class="lineNum">     447 </span>            :         uint32_t modification_of_pic_nums_idc;
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     449 </span>            :           // modification_of_pic_nums_idc: ue(v)
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :           RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(</span>
<span class="lineNum">     451 </span>            :               &amp;modification_of_pic_nums_idc));
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :           if (modification_of_pic_nums_idc == 0 ||</span>
<span class="lineNum">     453 </span>            :               modification_of_pic_nums_idc == 1) {
<span class="lineNum">     454 </span>            :             // abs_diff_pic_num_minus1: ue(v)
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     456 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :           } else if (modification_of_pic_nums_idc == 2) {</span>
<span class="lineNum">     458 </span>            :             // long_term_pic_num: ue(v)
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     460 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     461 </span>            :           }
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :         } while (modification_of_pic_nums_idc != 3);</span>
<span class="lineNum">     463 </span>            :       }
<span class="lineNum">     464 </span>            :     }
<span class="lineNum">     465 </span>            :   }
<span class="lineNum">     466 </span>            :   // TODO(pbos): Do we need support for pred_weight_table()?
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   RTC_CHECK(!((pps_.weighted_pred_flag &amp;&amp;</span>
<span class="lineNum">     468 </span>            :                (slice_type == kSliceTypeP || slice_type == kSliceTypeSp)) ||
<span class="lineNum">     469 </span>            :               (pps_.weighted_bipred_idc != 0 &amp;&amp; slice_type == kSliceTypeB)))
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;Missing support for pred_weight_table().&quot;;</span>
<span class="lineNum">     471 </span>            :   // if ((weighted_pred_flag &amp;&amp; (slice_type == P || slice_type == SP)) ||
<span class="lineNum">     472 </span>            :   //    (weighted_bipred_idc == 1 &amp;&amp; slice_type == B)) {
<span class="lineNum">     473 </span>            :   //  pred_weight_table()
<span class="lineNum">     474 </span>            :   // }
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   if (nal_ref_idc != 0) {</span>
<span class="lineNum">     476 </span>            :     // dec_ref_pic_marking():
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     if (is_idr) {</span>
<span class="lineNum">     478 </span>            :       // no_output_of_prior_pics_flag: u(1)
<span class="lineNum">     479 </span>            :       // long_term_reference_flag: u(1)
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 2));</span>
<span class="lineNum">     481 </span>            :     } else {
<span class="lineNum">     482 </span>            :       // adaptive_ref_pic_marking_mode_flag: u(1)
<span class="lineNum">     483 </span>            :       uint32_t adaptive_ref_pic_marking_mode_flag;
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     485 </span>            :           slice_reader.ReadBits(&amp;adaptive_ref_pic_marking_mode_flag, 1));
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       if (adaptive_ref_pic_marking_mode_flag) {</span>
<span class="lineNum">     487 </span>            :         uint32_t memory_management_control_operation;
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     489 </span>            :           // memory_management_control_operation: ue(v)
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :           RETURN_FALSE_ON_FAIL(slice_reader.ReadExponentialGolomb(</span>
<span class="lineNum">     491 </span>            :               &amp;memory_management_control_operation));
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :           if (memory_management_control_operation == 1 ||</span>
<span class="lineNum">     493 </span>            :               memory_management_control_operation == 3) {
<span class="lineNum">     494 </span>            :             // difference_of_pic_nums_minus1: ue(v)
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     496 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     497 </span>            :           }
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :           if (memory_management_control_operation == 2) {</span>
<span class="lineNum">     499 </span>            :             // long_term_pic_num: ue(v)
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     501 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     502 </span>            :           }
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :           if (memory_management_control_operation == 3 ||</span>
<span class="lineNum">     504 </span>            :               memory_management_control_operation == 6) {
<span class="lineNum">     505 </span>            :             // long_term_frame_idx: ue(v)
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     507 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     508 </span>            :           }
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :           if (memory_management_control_operation == 4) {</span>
<span class="lineNum">     510 </span>            :             // max_long_term_frame_idx_plus1: ue(v)
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     512 </span>            :                 slice_reader.ReadExponentialGolomb(&amp;golomb_tmp));
<span class="lineNum">     513 </span>            :           }
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         } while (memory_management_control_operation != 0);</span>
<span class="lineNum">     515 </span>            :       }
<span class="lineNum">     516 </span>            :     }
<span class="lineNum">     517 </span>            :   }
<span class="lineNum">     518 </span>            :   // cabac not supported: entropy_coding_mode_flag == 0 asserted above.
<span class="lineNum">     519 </span>            :   // if (entropy_coding_mode_flag &amp;&amp; slice_type != I &amp;&amp; slice_type != SI)
<span class="lineNum">     520 </span>            :   //   cabac_init_idc
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   RETURN_FALSE_ON_FAIL(</span>
<span class="lineNum">     522 </span>            :       slice_reader.ReadSignedExponentialGolomb(&amp;last_slice_qp_delta_));
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   last_slice_qp_delta_parsed_ = true;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="525"><span class="lineNum">     525 </span>            : }</a>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 : void H264BitstreamParser::ParseSlice(const uint8_t* slice, size_t length) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   uint8_t nalu_type = slice[4] &amp; kNaluTypeMask;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   switch (nalu_type) {</span>
<span class="lineNum">     530 </span>            :     case kNaluSps:
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       RTC_CHECK(ParseSpsNalu(slice, length))</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;Failed to parse bitstream SPS.&quot;;</span>
<span class="lineNum">     533 </span>            :       break;
<span class="lineNum">     534 </span>            :     case kNaluPps:
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       RTC_CHECK(ParsePpsNalu(slice, length))</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;Failed to parse bitstream PPS.&quot;;</span>
<span class="lineNum">     537 </span>            :       break;
<span class="lineNum">     538 </span>            :     default:
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :       RTC_CHECK(ParseNonParameterSetNalu(slice, length, nalu_type))</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :           &lt;&lt; &quot;Failed to parse picture slice.&quot;;</span>
<span class="lineNum">     541 </span>            :       break;
<span class="lineNum">     542 </span>            :   }
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span><span class="lineNoCov">          0 : void H264BitstreamParser::ParseBitstream(const uint8_t* bitstream,</span>
<span class="lineNum">     546 </span>            :                                          size_t length) {
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   RTC_CHECK_GE(length, 4u);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   std::vector&lt;size_t&gt; slice_markers = FindNaluStartSequences(bitstream, length);</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   RTC_CHECK(!slice_markers.empty());</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; slice_markers.size() - 1; ++i) {</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     ParseSlice(bitstream + slice_markers[i],</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                slice_markers[i + 1] - slice_markers[i]);</span>
<span class="lineNum">     553 </span>            :   }
<span class="lineNum">     554 </span>            :   // Parse the last slice.
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   ParseSlice(bitstream + slice_markers.back(), length - slice_markers.back());</span>
<a name="556"><span class="lineNum">     556 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineNoCov">          0 : bool H264BitstreamParser::GetLastSliceQp(int* qp) const {</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   if (!last_slice_qp_delta_parsed_)</span>
<span class="lineNum">     560 </span>            :     return false;
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   *qp = 26 + pps_.pic_init_qp_minus26 + last_slice_qp_delta_;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     563 </span>            : }
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : }  // namespace webrtc
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
