<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/video_coding/qm_select.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/video_coding</a> - qm_select.cc<span style="font-size: 80%;"> (source / <a href="qm_select.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">492</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;webrtc/modules/video_coding/qm_select.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      14 </span>            : #ifdef ANDROID
<span class="lineNum">      15 </span>            : #include &lt;android/log.h&gt;
<span class="lineNum">      16 </span>            : #endif
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;webrtc/modules/include/module_common_types.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;webrtc/modules/video_coding/include/video_coding_defines.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;webrtc/modules/video_coding/internal_defines.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;webrtc/modules/video_coding/qm_select_data.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;webrtc/system_wrappers/include/trace.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : namespace webrtc {
<span class="lineNum">      25 </span>            : 
<a name="26"><span class="lineNum">      26 </span>            : // QM-METHOD class</a>
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span><span class="lineNoCov">          0 : VCMQmMethod::VCMQmMethod()</span>
<span class="lineNum">      29 </span>            :     : content_metrics_(NULL),
<span class="lineNum">      30 </span>            :       width_(0),
<span class="lineNum">      31 </span>            :       height_(0),
<span class="lineNum">      32 </span>            :       user_frame_rate_(0.0f),
<span class="lineNum">      33 </span>            :       native_width_(0),
<span class="lineNum">      34 </span>            :       native_height_(0),
<span class="lineNum">      35 </span>            :       native_frame_rate_(0.0f),
<span class="lineNum">      36 </span>            :       image_type_(kVGA),
<span class="lineNum">      37 </span>            :       framerate_level_(kFrameRateHigh),
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :       init_(false) {</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   ResetQM();</span>
<a name="40"><span class="lineNum">      40 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      41 </span>            : 
<a name="42"><span class="lineNum">      42 </span><span class="lineNoCov">          0 : VCMQmMethod::~VCMQmMethod() {}</span></a>
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineNoCov">          0 : void VCMQmMethod::ResetQM() {</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   aspect_ratio_ = 1.0f;</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   motion_.Reset();</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   spatial_.Reset();</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   content_class_ = 0;</span>
<a name="49"><span class="lineNum">      49 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span><span class="lineNoCov">          0 : uint8_t VCMQmMethod::ComputeContentClass() {</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   ComputeMotionNFD();</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   ComputeSpatial();</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   return content_class_ = 3 * motion_.level + spatial_.level;</span>
<a name="55"><span class="lineNum">      55 </span>            : }</a>
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span><span class="lineNoCov">          0 : void VCMQmMethod::UpdateContent(const VideoContentMetrics* contentMetrics) {</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   content_metrics_ = contentMetrics;</span>
<a name="59"><span class="lineNum">      59 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : void VCMQmMethod::ComputeMotionNFD() {</span>
<span class="lineNum">      62 </span>            : #if defined(WEBRTC_GONK)
<span class="lineNum">      63 </span>            :   motion_.value = (kHighMotionNfd + kLowMotionNfd)/2;
<span class="lineNum">      64 </span>            :   motion_.level = kDefault;
<span class="lineNum">      65 </span>            : #else
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   if (content_metrics_) {</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     motion_.value = content_metrics_-&gt;motion_magnitude;</span>
<span class="lineNum">      68 </span>            :   }
<span class="lineNum">      69 </span>            :   // Determine motion level.
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   if (motion_.value &lt; kLowMotionNfd) {</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     motion_.level = kLow;</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   } else if (motion_.value &gt; kHighMotionNfd) {</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     motion_.level = kHigh;</span>
<span class="lineNum">      74 </span>            :   } else {
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     motion_.level = kDefault;</span>
<span class="lineNum">      76 </span>            :   }
<span class="lineNum">      77 </span>            : #endif
<a name="78"><span class="lineNum">      78 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span><span class="lineNoCov">          0 : void VCMQmMethod::ComputeSpatial() {</span>
<span class="lineNum">      81 </span>            : #if defined(WEBRTC_GONK)
<span class="lineNum">      82 </span>            :   float scale2 = image_type_ &gt; kVGA ? kScaleTexture : 1.0;
<span class="lineNum">      83 </span>            :   spatial_.value = (kHighTexture + kLowTexture)*scale2/2;
<span class="lineNum">      84 </span>            :   spatial_.level = kDefault;
<span class="lineNum">      85 </span>            : #else
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   float spatial_err = 0.0;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   float spatial_err_h = 0.0;</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   float spatial_err_v = 0.0;</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   if (content_metrics_) {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     spatial_err = content_metrics_-&gt;spatial_pred_err;</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     spatial_err_h = content_metrics_-&gt;spatial_pred_err_h;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     spatial_err_v = content_metrics_-&gt;spatial_pred_err_v;</span>
<span class="lineNum">      93 </span>            :   }
<span class="lineNum">      94 </span>            :   // Spatial measure: take average of 3 prediction errors.
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   spatial_.value = (spatial_err + spatial_err_h + spatial_err_v) / 3.0f;</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   // Reduce thresholds for large scenes/higher pixel correlation.
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   float scale2 = image_type_ &gt; kVGA ? kScaleTexture : 1.0;</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   if (spatial_.value &gt; scale2 * kHighTexture) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     spatial_.level = kHigh;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   } else if (spatial_.value &lt; scale2 * kLowTexture) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     spatial_.level = kLow;</span>
<span class="lineNum">     104 </span>            :   } else {
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     spatial_.level = kDefault;</span>
<span class="lineNum">     106 </span>            :   }
<span class="lineNum">     107 </span>            : #endif
<a name="108"><span class="lineNum">     108 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineNoCov">          0 : ImageType VCMQmMethod::GetImageType(uint16_t width, uint16_t height) {</span>
<span class="lineNum">     111 </span>            :   // Get the image type for the encoder frame size.
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   uint32_t image_size = width * height;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   if (image_size == kSizeOfImageType[kQCIF]) {</span>
<span class="lineNum">     114 </span>            :     return kQCIF;
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kHCIF]) {</span>
<span class="lineNum">     116 </span>            :     return kHCIF;
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kQVGA]) {</span>
<span class="lineNum">     118 </span>            :     return kQVGA;
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kCIF]) {</span>
<span class="lineNum">     120 </span>            :     return kCIF;
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kHVGA]) {</span>
<span class="lineNum">     122 </span>            :     return kHVGA;
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kVGA]) {</span>
<span class="lineNum">     124 </span>            :     return kVGA;
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kQFULLHD]) {</span>
<span class="lineNum">     126 </span>            :     return kQFULLHD;
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kWHD]) {</span>
<span class="lineNum">     128 </span>            :     return kWHD;
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   } else if (image_size == kSizeOfImageType[kFULLHD]) {</span>
<span class="lineNum">     130 </span>            :     return kFULLHD;
<span class="lineNum">     131 </span>            :   } else {
<span class="lineNum">     132 </span>            :     // No exact match, find closet one.
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     return FindClosestImageType(width, height);</span>
<span class="lineNum">     134 </span>            :   }
<a name="135"><span class="lineNum">     135 </span>            : }</a>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineNoCov">          0 : ImageType VCMQmMethod::FindClosestImageType(uint16_t width, uint16_t height) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   float size = static_cast&lt;float&gt;(width * height);</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   float min = size;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   int isel = 0;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; kNumImageTypes; ++i) {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     float dist = fabs(size - kSizeOfImageType[i]);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     if (dist &lt; min) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :       min = dist;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       isel = i;</span>
<span class="lineNum">     146 </span>            :     }
<span class="lineNum">     147 </span>            :   }
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   return static_cast&lt;ImageType&gt;(isel);</span>
<a name="149"><span class="lineNum">     149 </span>            : }</a>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 : FrameRateLevelClass VCMQmMethod::FrameRateLevel(float avg_framerate) {</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   if (avg_framerate &lt;= kLowFrameRate) {</span>
<span class="lineNum">     153 </span>            :     return kFrameRateLow;
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   } else if (avg_framerate &lt;= kMiddleFrameRate) {</span>
<span class="lineNum">     155 </span>            :     return kFrameRateMiddle1;
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   } else if (avg_framerate &lt;= kHighFrameRate) {</span>
<span class="lineNum">     157 </span>            :     return kFrameRateMiddle2;
<span class="lineNum">     158 </span>            :   } else {
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     return kFrameRateHigh;</span>
<span class="lineNum">     160 </span>            :   }
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<a name="163"><span class="lineNum">     163 </span>            : // RESOLUTION CLASS</a>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 : VCMQmResolution::VCMQmResolution() : qm_(new VCMResolutionScale()) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   Reset();</span>
<a name="167"><span class="lineNum">     167 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 : VCMQmResolution::~VCMQmResolution() {</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   delete qm_;</span>
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineNoCov">          0 : void VCMQmResolution::ResetRates() {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   sum_target_rate_ = 0.0f;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   sum_incoming_framerate_ = 0.0f;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   sum_rate_MM_ = 0.0f;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   sum_rate_MM_sgn_ = 0.0f;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   sum_packet_loss_ = 0.0f;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   buffer_level_ = kInitBufferLevel * target_bitrate_;</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   frame_cnt_ = 0;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   frame_cnt_delta_ = 0;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   low_buffer_cnt_ = 0;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   update_rate_cnt_ = 0;</span>
<a name="184"><span class="lineNum">     184 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineNoCov">          0 : void VCMQmResolution::ResetDownSamplingState() {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   state_dec_factor_spatial_ = 1.0;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   state_dec_factor_temporal_ = 1.0;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; kDownActionHistorySize; i++) {</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     down_action_history_[i].spatial = kNoChangeSpatial;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     down_action_history_[i].temporal = kNoChangeTemporal;</span>
<span class="lineNum">     192 </span>            :   }
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 : void VCMQmResolution::Reset() {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   target_bitrate_ = 0.0f;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   incoming_framerate_ = 0.0f;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   buffer_level_ = 0.0f;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   per_frame_bandwidth_ = 0.0f;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   avg_target_rate_ = 0.0f;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   avg_incoming_framerate_ = 0.0f;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   avg_ratio_buffer_low_ = 0.0f;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   avg_rate_mismatch_ = 0.0f;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   avg_rate_mismatch_sgn_ = 0.0f;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   avg_packet_loss_ = 0.0f;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   encoder_state_ = kStableEncoding;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   num_layers_ = 1;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   ResetRates();</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   ResetDownSamplingState();</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   ResetQM();</span>
<a name="211"><span class="lineNum">     211 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : EncoderState VCMQmResolution::GetEncoderState() {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   return encoder_state_;</span>
<span class="lineNum">     215 </span>            : }
<span class="lineNum">     216 </span>            : 
<a name="217"><span class="lineNum">     217 </span>            : // Initialize state after re-initializing the encoder,</a>
<span class="lineNum">     218 </span>            : // i.e., after SetEncodingData() in mediaOpt.
<span class="lineNum">     219 </span><span class="lineNoCov">          0 : int VCMQmResolution::Initialize(float bitrate,</span>
<span class="lineNum">     220 </span>            :                                 float user_framerate,
<span class="lineNum">     221 </span>            :                                 uint16_t width,
<span class="lineNum">     222 </span>            :                                 uint16_t height,
<span class="lineNum">     223 </span>            :                                 int num_layers) {
<span class="lineNum">     224 </span>            :   WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     225 </span>            :                webrtc::kTraceVideoCoding,
<span class="lineNum">     226 </span>            :                -1,
<span class="lineNum">     227 </span>            :                &quot;qm_select.cc:initialize: %f %f %u %u&quot;,
<span class="lineNum">     228 </span>            :                bitrate, user_framerate, width, height);
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   if (user_framerate == 0.0f || width == 0 || height == 0) {</span>
<span class="lineNum">     231 </span>            :     return VCM_PARAMETER_ERROR;
<span class="lineNum">     232 </span>            :   }
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   Reset();</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   target_bitrate_ = bitrate;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   incoming_framerate_ = user_framerate;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   UpdateCodecParameters(user_framerate, width, height);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   native_width_ = width;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   native_height_ = height;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   native_frame_rate_ = user_framerate;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   num_layers_ = num_layers;</span>
<span class="lineNum">     241 </span>            :   // Initial buffer level.
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   buffer_level_ = kInitBufferLevel * target_bitrate_;</span>
<span class="lineNum">     243 </span>            :   // Per-frame bandwidth.
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   per_frame_bandwidth_ = target_bitrate_ / user_framerate;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   init_ = true;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   return VCM_OK;</span>
<a name="247"><span class="lineNum">     247 </span>            : }</a>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 : void VCMQmResolution::UpdateCodecParameters(float frame_rate,</span>
<span class="lineNum">     250 </span>            :                                             uint16_t width,
<span class="lineNum">     251 </span>            :                                             uint16_t height) {
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   width_ = width;</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   height_ = height;</span>
<span class="lineNum">     254 </span>            :   // |user_frame_rate| is the target frame rate for VPM frame dropper.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   user_frame_rate_ = frame_rate;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   image_type_ = GetImageType(width, height);</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 : }</span>
<a name="258"><span class="lineNum">     258 </span>            : </a>
<span class="lineNum">     259 </span>            : // Update rate data after every encoded frame.
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : void VCMQmResolution::UpdateEncodedSize(size_t encoded_size) {</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   frame_cnt_++;</span>
<span class="lineNum">     262 </span>            :   // Convert to Kbps.
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   float encoded_size_kbits = 8.0f * static_cast&lt;float&gt;(encoded_size) / 1000.0f;</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :   // Update the buffer level:
<span class="lineNum">     266 </span>            :   // Note this is not the actual encoder buffer level.
<span class="lineNum">     267 </span>            :   // |buffer_level_| is reset to an initial value after SelectResolution is
<span class="lineNum">     268 </span>            :   // called, and does not account for frame dropping by encoder or VCM.
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   buffer_level_ += per_frame_bandwidth_ - encoded_size_kbits;</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :   // Counter for occurrences of low buffer level:
<span class="lineNum">     272 </span>            :   // low/negative values means encoder is likely dropping frames.
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   if (buffer_level_ &lt;= kPercBufferThr * kInitBufferLevel * target_bitrate_) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     low_buffer_cnt_++;</span>
<span class="lineNum">     275 </span>            :   }
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : }</span>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<span class="lineNum">     278 </span>            : // Update various quantities after SetTargetRates in MediaOpt.
<span class="lineNum">     279 </span><span class="lineNoCov">          0 : void VCMQmResolution::UpdateRates(float target_bitrate,</span>
<span class="lineNum">     280 </span>            :                                   float encoder_sent_rate,
<span class="lineNum">     281 </span>            :                                   float incoming_framerate,
<span class="lineNum">     282 </span>            :                                   uint8_t packet_loss) {
<span class="lineNum">     283 </span>            :   // Sum the target bitrate: this is the encoder rate from previous update
<span class="lineNum">     284 </span>            :   // (~1sec), i.e, before the update for next ~1sec.
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   sum_target_rate_ += target_bitrate_;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   update_rate_cnt_++;</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   // Sum the received (from RTCP reports) packet loss rates.
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   sum_packet_loss_ += static_cast&lt;float&gt;(packet_loss / 255.0);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :   // Sum the sequence rate mismatch:
<span class="lineNum">     292 </span>            :   // Mismatch here is based on the difference between the target rate
<span class="lineNum">     293 </span>            :   // used (in previous ~1sec) and the average actual encoding rate measured
<span class="lineNum">     294 </span>            :   // at previous ~1sec.
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   float diff = target_bitrate_ - encoder_sent_rate;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   if (target_bitrate_ &gt; 0.0)</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     sum_rate_MM_ += fabs(diff) / target_bitrate_;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   int sgnDiff = diff &gt; 0 ? 1 : (diff &lt; 0 ? -1 : 0);</span>
<span class="lineNum">     299 </span>            :   // To check for consistent under(+)/over_shooting(-) of target rate.
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   sum_rate_MM_sgn_ += sgnDiff;</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :   // Update with the current new target and frame rate:
<span class="lineNum">     303 </span>            :   // these values are ones the encoder will use for the current/next ~1sec.
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   target_bitrate_ = target_bitrate;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   incoming_framerate_ = incoming_framerate;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   sum_incoming_framerate_ += incoming_framerate_;</span>
<span class="lineNum">     307 </span>            :   // Update the per_frame_bandwidth:
<span class="lineNum">     308 </span>            :   // this is the per_frame_bw for the current/next ~1sec.
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   per_frame_bandwidth_ = 0.0f;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   if (incoming_framerate_ &gt; 0.0f) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     per_frame_bandwidth_ = target_bitrate_ / incoming_framerate_;</span>
<span class="lineNum">     312 </span>            :   }
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : // Select the resolution factors: frame size and frame rate change (qm scales).
<span class="lineNum">     316 </span>            : // Selection is for going down in resolution, or for going back up
<span class="lineNum">     317 </span>            : // (if a previous down-sampling action was taken).
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : // In the current version the following constraints are imposed:
<span class="lineNum">     320 </span>            : // 1) We only allow for one action, either down or up, at a given time.
<span class="lineNum">     321 </span>            : // 2) The possible down-sampling actions are: spatial by 1/2x1/2, 3/4x3/4;
<span class="lineNum">     322 </span>            : //    temporal/frame rate reduction by 1/2 and 2/3.
<span class="lineNum">     323 </span>            : // 3) The action for going back up is the reverse of last (spatial or temporal)
<span class="lineNum">     324 </span>            : //    down-sampling action. The list of down-sampling actions from the
<span class="lineNum">     325 </span>            : //    Initialize() state are kept in |down_action_history_|.
<span class="lineNum">     326 </span>            : // 4) The total amount of down-sampling (spatial and/or temporal) from the
<span class="lineNum">     327 </span>            : //    Initialize() state (native resolution) is limited by various factors.
<a name="328"><span class="lineNum">     328 </span>            : // 5) If the codec can't handle arbitrary input resolutions, limit to %16==0</a>
<span class="lineNum">     329 </span>            : //    i.e. for h.264
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : int VCMQmResolution::SelectResolution(VCMResolutionScale** qm) {</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   if (!init_) {</span>
<span class="lineNum">     332 </span>            :     return VCM_UNINITIALIZED;
<span class="lineNum">     333 </span>            :   }
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   if (content_metrics_ == NULL) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     Reset();</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     *qm = qm_;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     return VCM_OK;</span>
<span class="lineNum">     338 </span>            :   }
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :   // Check conditions on down-sampling state.
<span class="lineNum">     341 </span>            :   assert(state_dec_factor_spatial_ &gt;= 1.0f);
<span class="lineNum">     342 </span>            :   assert(state_dec_factor_temporal_ &gt;= 1.0f);
<span class="lineNum">     343 </span>            :   assert(state_dec_factor_spatial_ &lt;= kMaxSpatialDown);
<span class="lineNum">     344 </span>            :   assert(state_dec_factor_temporal_ &lt;= kMaxTempDown);
<span class="lineNum">     345 </span>            :   assert(state_dec_factor_temporal_ * state_dec_factor_spatial_ &lt;=
<span class="lineNum">     346 </span>            :          kMaxTotalDown);
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   // Compute content class for selection.
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   content_class_ = ComputeContentClass();</span>
<span class="lineNum">     350 </span>            :   // Compute various rate quantities for selection.
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   ComputeRatesForSelection();</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :   // Get the encoder state.
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   ComputeEncoderState();</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :   // Default settings: no action.
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   SetDefaultAction();</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   *qm = qm_;</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :   // Check for going back up in resolution, if we have had some down-sampling
<span class="lineNum">     361 </span>            :   // relative to native state in Initialize().
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   if (down_action_history_[0].spatial != kNoChangeSpatial ||</span>
<span class="lineNum">     363 </span>            :       down_action_history_[0].temporal != kNoChangeTemporal) {
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     if (GoingUpResolution()) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       *qm = qm_;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :       return VCM_OK;</span>
<span class="lineNum">     367 </span>            :     }
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   // Check for going down in resolution.
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   if (GoingDownResolution()) {</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     *qm = qm_;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     return VCM_OK;</span>
<span class="lineNum">     374 </span>            :   }
<span class="lineNum">     375 </span>            :   return VCM_OK;
<a name="376"><span class="lineNum">     376 </span>            : }</a>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 : void VCMQmResolution::SetDefaultAction() {</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   qm_-&gt;codec_width = width_;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   qm_-&gt;codec_height = height_;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   qm_-&gt;frame_rate = user_frame_rate_;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   qm_-&gt;change_resolution_spatial = false;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   qm_-&gt;change_resolution_temporal = false;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   qm_-&gt;spatial_width_fact = 1.0f;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   qm_-&gt;spatial_height_fact = 1.0f;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   qm_-&gt;temporal_fact = 1.0f;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   action_.temporal = kNoChangeTemporal;</span>
<a name="389"><span class="lineNum">     389 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 : void VCMQmResolution::ComputeRatesForSelection() {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   avg_target_rate_ = 0.0f;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   avg_incoming_framerate_ = 0.0f;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   avg_ratio_buffer_low_ = 0.0f;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   avg_rate_mismatch_ = 0.0f;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   avg_rate_mismatch_sgn_ = 0.0f;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   avg_packet_loss_ = 0.0f;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   if (frame_cnt_ &gt; 0) {</span>
<span class="lineNum">     399 </span>            :     avg_ratio_buffer_low_ =
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         static_cast&lt;float&gt;(low_buffer_cnt_) / static_cast&lt;float&gt;(frame_cnt_);</span>
<span class="lineNum">     401 </span>            :   }
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   if (update_rate_cnt_ &gt; 0) {</span>
<span class="lineNum">     403 </span>            :     avg_rate_mismatch_ =
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         static_cast&lt;float&gt;(sum_rate_MM_) / static_cast&lt;float&gt;(update_rate_cnt_);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     avg_rate_mismatch_sgn_ = static_cast&lt;float&gt;(sum_rate_MM_sgn_) /</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                              static_cast&lt;float&gt;(update_rate_cnt_);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     avg_target_rate_ = static_cast&lt;float&gt;(sum_target_rate_) /</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                        static_cast&lt;float&gt;(update_rate_cnt_);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     avg_incoming_framerate_ = static_cast&lt;float&gt;(sum_incoming_framerate_) /</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                               static_cast&lt;float&gt;(update_rate_cnt_);</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     avg_packet_loss_ = static_cast&lt;float&gt;(sum_packet_loss_) /</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :                        static_cast&lt;float&gt;(update_rate_cnt_);</span>
<span class="lineNum">     413 </span>            :   }
<span class="lineNum">     414 </span>            :   // For selection we may want to weight some quantities more heavily
<span class="lineNum">     415 </span>            :   // with the current (i.e., next ~1sec) rate values.
<span class="lineNum">     416 </span>            :   avg_target_rate_ =
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       kWeightRate * avg_target_rate_ + (1.0 - kWeightRate) * target_bitrate_;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   avg_incoming_framerate_ = kWeightRate * avg_incoming_framerate_ +</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :                             (1.0 - kWeightRate) * incoming_framerate_;</span>
<span class="lineNum">     420 </span>            :   // Use base layer frame rate for temporal layers: this will favor spatial.
<span class="lineNum">     421 </span>            :   assert(num_layers_ &gt; 0);
<span class="lineNum">     422 </span>            :   framerate_level_ = FrameRateLevel(avg_incoming_framerate_ /
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                                     static_cast&lt;float&gt;(1 &lt;&lt; (num_layers_ - 1)));</span>
<a name="424"><span class="lineNum">     424 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : void VCMQmResolution::ComputeEncoderState() {</span>
<span class="lineNum">     427 </span>            :   // Default.
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   encoder_state_ = kStableEncoding;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   // Assign stressed state if:
<span class="lineNum">     431 </span>            :   // 1) occurrences of low buffer levels is high, or
<span class="lineNum">     432 </span>            :   // 2) rate mis-match is high, and consistent over-shooting by encoder.
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   if ((avg_ratio_buffer_low_ &gt; kMaxBufferLow) ||</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       ((avg_rate_mismatch_ &gt; kMaxRateMisMatch) &amp;&amp;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :        (avg_rate_mismatch_sgn_ &lt; -kRateOverShoot))) {</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     encoder_state_ = kStressedEncoding;</span>
<span class="lineNum">     437 </span>            :     WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     438 </span>            :                  webrtc::kTraceVideoCoding,
<span class="lineNum">     439 </span>            :                  -1,
<span class="lineNum">     440 </span>            :                  &quot;ComputeEncoderState==Stressed&quot;);
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     442 </span>            :   }
<span class="lineNum">     443 </span>            :   // Assign easy state if:
<span class="lineNum">     444 </span>            :   // 1) rate mis-match is high, and
<span class="lineNum">     445 </span>            :   // 2) consistent under-shooting by encoder.
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   if ((avg_rate_mismatch_ &gt; kMaxRateMisMatch) &amp;&amp;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       (avg_rate_mismatch_sgn_ &gt; kRateUnderShoot)) {</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     encoder_state_ = kEasyEncoding;</span>
<span class="lineNum">     449 </span>            :     WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     450 </span>            :                  webrtc::kTraceVideoCoding,
<span class="lineNum">     451 </span>            :                  -1,
<span class="lineNum">     452 </span>            :                  &quot;ComputeEncoderState==Easy&quot;);
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     454 </span>            :   }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     457 </span>            :                webrtc::kTraceVideoCoding,
<span class="lineNum">     458 </span>            :                -1,
<span class="lineNum">     459 </span>            :                &quot;ComputeEncoderState==Stable&quot;);
<a name="460"><span class="lineNum">     460 </span>            : }</a>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : bool VCMQmResolution::GoingUpResolution() {</span>
<span class="lineNum">     463 </span>            :   // We do not go up if we're already near max CPU load
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   if (loadstate_ == kLoadStressed) {</span>
<span class="lineNum">     465 </span>            :     return false;
<span class="lineNum">     466 </span>            :   }
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :   // For going up, we check for undoing the previous down-sampling action.
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   float fac_width = kFactorWidthSpatial[down_action_history_[0].spatial];</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   float fac_height = kFactorHeightSpatial[down_action_history_[0].spatial];</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   float fac_temp = kFactorTemporal[down_action_history_[0].temporal];</span>
<span class="lineNum">     473 </span>            :   // For going up spatially, we allow for going up by 3/4x3/4 at each stage.
<span class="lineNum">     474 </span>            :   // So if the last spatial action was 1/2x1/2 it would be undone in 2 stages.
<span class="lineNum">     475 </span>            :   // Modify the fac_width/height for this case.
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   if (down_action_history_[0].spatial == kOneQuarterSpatialUniform) {</span>
<span class="lineNum">     477 </span>            :     fac_width = kFactorWidthSpatial[kOneQuarterSpatialUniform] /
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                 kFactorWidthSpatial[kOneHalfSpatialUniform];</span>
<span class="lineNum">     479 </span>            :     fac_height = kFactorHeightSpatial[kOneQuarterSpatialUniform] /
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                  kFactorHeightSpatial[kOneHalfSpatialUniform];</span>
<span class="lineNum">     481 </span>            :   }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :   // Check if we should go up both spatially and temporally.
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   if (down_action_history_[0].spatial != kNoChangeSpatial &amp;&amp;</span>
<span class="lineNum">     485 </span>            :       down_action_history_[0].temporal != kNoChangeTemporal) {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     if (ConditionForGoingUp(fac_width, fac_height, fac_temp,</span>
<span class="lineNum">     487 </span>            :                             kTransRateScaleUpSpatialTemp)) {
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       action_.spatial = down_action_history_[0].spatial;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       action_.temporal = down_action_history_[0].temporal;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       UpdateDownsamplingState(kUpResolution);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">     492 </span>            :     }
<span class="lineNum">     493 </span>            :   }
<span class="lineNum">     494 </span>            :   // Check if we should go up either spatially or temporally.
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   bool selected_up_spatial = false;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   bool selected_up_temporal = false;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   if (down_action_history_[0].spatial != kNoChangeSpatial) {</span>
<span class="lineNum">     498 </span>            :     selected_up_spatial = ConditionForGoingUp(fac_width, fac_height, 1.0f,
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :                                               kTransRateScaleUpSpatial);</span>
<span class="lineNum">     500 </span>            :   }
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   if (down_action_history_[0].temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     502 </span>            :     selected_up_temporal =
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         ConditionForGoingUp(1.0f, 1.0f, fac_temp, kTransRateScaleUpTemp);</span>
<span class="lineNum">     504 </span>            :   }
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   if (selected_up_spatial &amp;&amp; !selected_up_temporal) {</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     action_.spatial = down_action_history_[0].spatial;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     UpdateDownsamplingState(kUpResolution);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   } else if (!selected_up_spatial &amp;&amp; selected_up_temporal) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     action_.temporal = down_action_history_[0].temporal;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     UpdateDownsamplingState(kUpResolution);</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   } else if (selected_up_spatial &amp;&amp; selected_up_temporal) {</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     PickSpatialOrTemporal();</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     UpdateDownsamplingState(kUpResolution);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     519 </span>            :   }
<span class="lineNum">     520 </span>            :   return false;
<a name="521"><span class="lineNum">     521 </span>            : }</a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : bool VCMQmResolution::ConditionForGoingUp(float fac_width,</span>
<span class="lineNum">     524 </span>            :                                           float fac_height,
<span class="lineNum">     525 </span>            :                                           float fac_temp,
<span class="lineNum">     526 </span>            :                                           float scale_fac) {
<span class="lineNum">     527 </span>            :   float estimated_transition_rate_up =
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       GetTransitionRate(fac_width, fac_height, fac_temp, scale_fac);</span>
<span class="lineNum">     529 </span>            :   // Go back up if:
<span class="lineNum">     530 </span>            :   // 1) target rate is above threshold and current encoder state is stable, or
<span class="lineNum">     531 </span>            :   // 2) encoder state is easy (encoder is significantly under-shooting target).
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   if (((avg_target_rate_ &gt; estimated_transition_rate_up) &amp;&amp;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :        (encoder_state_ == kStableEncoding)) ||</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       (encoder_state_ == kEasyEncoding)) {</span>
<span class="lineNum">     535 </span>            :     return true;
<span class="lineNum">     536 </span>            :   } else {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     538 </span>            :   }
<a name="539"><span class="lineNum">     539 </span>            : }</a>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span><span class="lineNoCov">          0 : bool VCMQmResolution::GoingDownResolution() {</span>
<span class="lineNum">     542 </span>            :   float estimated_transition_rate_down =
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       GetTransitionRate(1.0f, 1.0f, 1.0f, 1.0f);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   float max_rate = kFrameRateFac[framerate_level_] * kMaxRateQm[image_type_];</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     547 </span>            :                webrtc::kTraceVideoCoding,
<span class="lineNum">     548 </span>            :                -1,
<span class="lineNum">     549 </span>            :                &quot;state %d avg_target_rate %f estimated_trans_rate_down %f max %f&quot;,
<span class="lineNum">     550 </span>            :                loadstate_, avg_target_rate_, estimated_transition_rate_down, max_rate
<span class="lineNum">     551 </span>            :                );
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :   // Resolution reduction if:
<span class="lineNum">     554 </span>            :   // (1) target rate is below transition rate, or
<span class="lineNum">     555 </span>            :   // (2) encoder is in stressed state and target rate below a max threshold.
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (loadstate_ == kLoadStressed</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       || (avg_target_rate_ &lt; estimated_transition_rate_down)</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       || (encoder_state_ == kStressedEncoding &amp;&amp; avg_target_rate_ &lt; max_rate)) {</span>
<span class="lineNum">     559 </span>            :     // Get the down-sampling action: based on content class, and how low
<span class="lineNum">     560 </span>            :     // average target rate is relative to transition rate.
<span class="lineNum">     561 </span>            :     uint8_t spatial_fact =
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         kSpatialAction[content_class_ +</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                        9 * RateClass(estimated_transition_rate_down)];</span>
<span class="lineNum">     564 </span>            :     uint8_t temp_fact =
<span class="lineNum">     565 </span>            :         kTemporalAction[content_class_ +
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                         9 * RateClass(estimated_transition_rate_down)];</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     switch (spatial_fact) {</span>
<span class="lineNum">     569 </span>            :       case 4: {
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         action_.spatial = kOneQuarterSpatialUniform;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     572 </span>            :       }
<span class="lineNum">     573 </span>            :       case 2: {
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         action_.spatial = kOneHalfSpatialUniform;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     576 </span>            :       }
<span class="lineNum">     577 </span>            :       case 1: {
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     580 </span>            :       }
<span class="lineNum">     581 </span>            :       default: { assert(false); }
<span class="lineNum">     582 </span>            :     }
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     switch (temp_fact) {</span>
<span class="lineNum">     584 </span>            :       case 3: {
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :         action_.temporal = kTwoThirdsTemporal;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     587 </span>            :       }
<span class="lineNum">     588 </span>            :       case 2: {
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :         action_.temporal = kOneHalfTemporal;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     591 </span>            :       }
<span class="lineNum">     592 </span>            :       case 1: {
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :         action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     595 </span>            :       }
<span class="lineNum">     596 </span>            :       default: { assert(false); }
<span class="lineNum">     597 </span>            :     }
<span class="lineNum">     598 </span>            :     // Only allow for one action (spatial or temporal) at a given time.
<span class="lineNum">     599 </span>            :     assert(action_.temporal == kNoChangeTemporal ||
<span class="lineNum">     600 </span>            :            action_.spatial == kNoChangeSpatial);
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :     // CPU stressed but we did not get an action yet, likely because our
<span class="lineNum">     603 </span>            :     // bitrate is too high relative to the target.
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     if (loadstate_ == kLoadStressed</span>
<span class="lineNum">     605 </span>            :         &amp;&amp; action_.temporal == kNoChangeTemporal
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         &amp;&amp; action_.spatial == kNoChangeSpatial) {</span>
<span class="lineNum">     607 </span>            :       // If FPS is high, allow dropping it to 20 fps.
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       if (avg_incoming_framerate_ &gt;= 40) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         action_.temporal = kOneHalfTemporal;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       } else if (avg_incoming_framerate_ &gt;= 24) {</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         action_.temporal = kTwoThirdsTemporal;</span>
<span class="lineNum">     612 </span>            :       } else {
<span class="lineNum">     613 </span>            :         // Drop resolution in all other cases.
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         action_.spatial = kOneHalfSpatialUniform;</span>
<span class="lineNum">     615 </span>            :       }
<span class="lineNum">     616 </span>            :     }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :     // Adjust cases not captured in tables, mainly based on frame rate, and
<span class="lineNum">     619 </span>            :     // also check for odd frame sizes.
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     AdjustAction();</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :     // Update down-sampling state.
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     if (action_.spatial != kNoChangeSpatial ||</span>
<span class="lineNum">     624 </span>            :         action_.temporal != kNoChangeTemporal) {
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       UpdateDownsamplingState(kDownResolution);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            :   }
<span class="lineNum">     629 </span>            :   return false;
<a name="630"><span class="lineNum">     630 </span>            : }</a>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineNoCov">          0 : float VCMQmResolution::GetTransitionRate(float fac_width,</span>
<span class="lineNum">     633 </span>            :                                          float fac_height,
<span class="lineNum">     634 </span>            :                                          float fac_temp,
<span class="lineNum">     635 </span>            :                                          float scale_fac) {
<span class="lineNum">     636 </span>            :   ImageType image_type =
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       GetImageType(static_cast&lt;uint16_t&gt;(fac_width * width_),</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                    static_cast&lt;uint16_t&gt;(fac_height * height_));</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :   FrameRateLevelClass framerate_level =
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :       FrameRateLevel(fac_temp * avg_incoming_framerate_);</span>
<span class="lineNum">     642 </span>            :   // If we are checking for going up temporally, and this is the last
<span class="lineNum">     643 </span>            :   // temporal action, then use native frame rate.
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   if (down_action_history_[1].temporal == kNoChangeTemporal &amp;&amp;</span>
<span class="lineNum">     645 </span>            :       fac_temp &gt; 1.0f) {
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     framerate_level = FrameRateLevel(native_frame_rate_);</span>
<span class="lineNum">     647 </span>            :   }
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :   // The maximum allowed rate below which down-sampling is allowed:
<span class="lineNum">     650 </span>            :   // Nominal values based on image format (frame size and frame rate).
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :   float max_rate = kFrameRateFac[framerate_level] * kMaxRateQm[image_type];</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   uint8_t image_class = image_type &gt; kVGA ? 1 : 0;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   uint8_t table_index = image_class * 9 + content_class_;</span>
<span class="lineNum">     655 </span>            :   // Scale factor for down-sampling transition threshold:
<span class="lineNum">     656 </span>            :   // factor based on the content class and the image size.
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   float scaleTransRate = kScaleTransRateQm[table_index];</span>
<span class="lineNum">     658 </span>            :   // Threshold bitrate for resolution action.
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   return static_cast&lt;float&gt;(scale_fac * scaleTransRate * max_rate);</span>
<a name="660"><span class="lineNum">     660 </span>            : }</a>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 : void VCMQmResolution::UpdateDownsamplingState(UpDownAction up_down) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   if (up_down == kUpResolution) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_width_fact = 1.0f / kFactorWidthSpatial[action_.spatial];</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_height_fact = 1.0f / kFactorHeightSpatial[action_.spatial];</span>
<span class="lineNum">     666 </span>            :     // If last spatial action was 1/2x1/2, we undo it in two steps, so the
<span class="lineNum">     667 </span>            :     // spatial scale factor in this first step is modified as (4.0/3.0 / 2.0).
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     if (action_.spatial == kOneQuarterSpatialUniform) {</span>
<span class="lineNum">     669 </span>            :       qm_-&gt;spatial_width_fact = 1.0f *
<span class="lineNum">     670 </span>            :                                 kFactorWidthSpatial[kOneHalfSpatialUniform] /
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :                                 kFactorWidthSpatial[kOneQuarterSpatialUniform];</span>
<span class="lineNum">     672 </span>            :       qm_-&gt;spatial_height_fact =
<span class="lineNum">     673 </span>            :           1.0f * kFactorHeightSpatial[kOneHalfSpatialUniform] /
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :           kFactorHeightSpatial[kOneQuarterSpatialUniform];</span>
<span class="lineNum">     675 </span>            :     }
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     qm_-&gt;temporal_fact = 1.0f / kFactorTemporal[action_.temporal];</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     RemoveLastDownAction();</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :   } else if (up_down == kDownResolution) {</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     ConstrainAmountOfDownSampling();</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     ConvertSpatialFractionalToWhole();</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_width_fact = kFactorWidthSpatial[action_.spatial];</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_height_fact = kFactorHeightSpatial[action_.spatial];</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     qm_-&gt;temporal_fact = kFactorTemporal[action_.temporal];</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     InsertLatestDownAction();</span>
<span class="lineNum">     685 </span>            :   } else {
<span class="lineNum">     686 </span>            :     // This function should only be called if either the Up or Down action
<span class="lineNum">     687 </span>            :     // has been selected.
<span class="lineNum">     688 </span>            :     assert(false);
<span class="lineNum">     689 </span>            :   }
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   UpdateCodecResolution();</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   state_dec_factor_spatial_ = state_dec_factor_spatial_ *</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :                               qm_-&gt;spatial_width_fact *</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :                               qm_-&gt;spatial_height_fact;</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   state_dec_factor_temporal_ = state_dec_factor_temporal_ * qm_-&gt;temporal_fact;</span>
<a name="695"><span class="lineNum">     695 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineNoCov">          0 : void VCMQmResolution::UpdateCodecResolution() {</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   if (action_.spatial != kNoChangeSpatial) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     qm_-&gt;change_resolution_spatial = true;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     int old_width = qm_-&gt;codec_width;</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     int old_height = qm_-&gt;codec_height;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     qm_-&gt;codec_width = static_cast&lt;uint16_t&gt;((width_ /</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                                               qm_-&gt;spatial_width_fact) + 0.5f);</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     qm_-&gt;codec_height = static_cast&lt;uint16_t&gt;((height_ /</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                                                qm_-&gt;spatial_height_fact) + 0.5f);</span>
<span class="lineNum">     706 </span>            :     // Size should not exceed native sizes.
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     if (qm_-&gt;codec_width &gt; native_width_) {</span>
<span class="lineNum">     708 </span>            :       WEBRTC_TRACE(webrtc::kTraceError,
<span class="lineNum">     709 </span>            :                    webrtc::kTraceVideoCoding,
<span class="lineNum">     710 </span>            :                    -1,
<span class="lineNum">     711 </span>            :                    &quot;UpdateCodecResolution: *** Exceeds native width: [%d %d] %d %d (%f) =&gt; %d %d&quot;,
<span class="lineNum">     712 </span>            :                    native_width_, native_height_,
<span class="lineNum">     713 </span>            :                    old_width, old_height,
<span class="lineNum">     714 </span>            :                    qm_-&gt;spatial_width_fact,
<span class="lineNum">     715 </span>            :                    qm_-&gt;codec_width, qm_-&gt;codec_height
<span class="lineNum">     716 </span>            :                    );
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       qm_-&gt;codec_width = native_width_;</span>
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     if (qm_-&gt;codec_height &gt; native_height_) {</span>
<span class="lineNum">     720 </span>            :       WEBRTC_TRACE(webrtc::kTraceError,
<span class="lineNum">     721 </span>            :                    webrtc::kTraceVideoCoding,
<span class="lineNum">     722 </span>            :                    -1,
<span class="lineNum">     723 </span>            :                    &quot;UpdateCodecResolution: *** Exceeds native height: [%d %d] %d %d  (%f) =&gt; %d %d&quot;,
<span class="lineNum">     724 </span>            :                    native_width_, native_height_,
<span class="lineNum">     725 </span>            :                    old_width, old_height,
<span class="lineNum">     726 </span>            :                    qm_-&gt;spatial_height_fact,
<span class="lineNum">     727 </span>            :                    qm_-&gt;codec_width, qm_-&gt;codec_height
<span class="lineNum">     728 </span>            :                    );
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       qm_-&gt;codec_height = native_height_;</span>
<span class="lineNum">     730 </span>            :     }
<span class="lineNum">     731 </span>            :     WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     732 </span>            :                  webrtc::kTraceVideoCoding,
<span class="lineNum">     733 </span>            :                  -1,
<span class="lineNum">     734 </span>            :                  &quot;UpdateCodecResolution: [%d %d] %d %d =&gt; %d %d&quot;,
<span class="lineNum">     735 </span>            :                  native_width_, native_height_,
<span class="lineNum">     736 </span>            :                  old_width, old_height,
<span class="lineNum">     737 </span>            :                  qm_-&gt;codec_width, qm_-&gt;codec_height
<span class="lineNum">     738 </span>            :                  );
<span class="lineNum">     739 </span>            : #ifdef ANDROID
<span class="lineNum">     740 </span>            :     __android_log_print(ANDROID_LOG_INFO, &quot;WebRTC&quot;,
<span class="lineNum">     741 </span>            :                         &quot;UpdateCodecResolution: [%d %d] %d %d =&gt; %d %d&quot;,
<span class="lineNum">     742 </span>            :                         native_width_, native_height_,
<span class="lineNum">     743 </span>            :                         old_width, old_height,
<span class="lineNum">     744 </span>            :                         qm_-&gt;codec_width, qm_-&gt;codec_height);
<span class="lineNum">     745 </span>            : #endif
<span class="lineNum">     746 </span>            :   }
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   if (action_.temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     qm_-&gt;change_resolution_temporal = true;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     float old_rate = qm_-&gt;frame_rate;</span>
<span class="lineNum">     750 </span>            :     // Update the frame rate based on the average incoming frame rate.
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     qm_-&gt;frame_rate = avg_incoming_framerate_ / qm_-&gt;temporal_fact + 0.5f;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     if (down_action_history_[0].temporal == 0) {</span>
<span class="lineNum">     753 </span>            :       // When we undo the last temporal-down action, make sure we go back up
<span class="lineNum">     754 </span>            :       // to the native frame rate. Since the incoming frame rate may
<span class="lineNum">     755 </span>            :       // fluctuate over time, |avg_incoming_framerate_| scaled back up may
<span class="lineNum">     756 </span>            :       // be smaller than |native_frame rate_|.
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       qm_-&gt;frame_rate = native_frame_rate_;</span>
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span>            :     WEBRTC_TRACE(webrtc::kTraceDebug,
<span class="lineNum">     760 </span>            :                  webrtc::kTraceVideoCoding,
<span class="lineNum">     761 </span>            :                  -1,
<span class="lineNum">     762 </span>            :                  &quot;UpdateCodecResolution: [%f] %f fps =&gt; %f fps&quot;,
<span class="lineNum">     763 </span>            :                  native_frame_rate_,
<span class="lineNum">     764 </span>            :                  old_rate,
<span class="lineNum">     765 </span>            :                  qm_-&gt;frame_rate
<span class="lineNum">     766 </span>            :                  );
<span class="lineNum">     767 </span>            : #ifdef ANDROID
<span class="lineNum">     768 </span>            :     __android_log_print(ANDROID_LOG_INFO, &quot;WebRTC&quot;,
<span class="lineNum">     769 </span>            :                         &quot;UpdateCodecResolution: [%f] %f fps =&gt; %f fps&quot;,
<span class="lineNum">     770 </span>            :                         native_frame_rate_,
<span class="lineNum">     771 </span>            :                         old_rate,
<span class="lineNum">     772 </span>            :                         qm_-&gt;frame_rate);
<span class="lineNum">     773 </span>            : #endif
<span class="lineNum">     774 </span>            :   }
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineNoCov">          0 : uint8_t VCMQmResolution::RateClass(float transition_rate) {</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   return avg_target_rate_ &lt; (kFacLowRate * transition_rate)</span>
<span class="lineNum">     779 </span>            :              ? 0
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :              : (avg_target_rate_ &gt;= transition_rate ? 2 : 1);</span>
<span class="lineNum">     781 </span>            : }
<span class="lineNum">     782 </span>            : 
<a name="783"><span class="lineNum">     783 </span>            : // TODO(marpan): Would be better to capture these frame rate adjustments by</a>
<span class="lineNum">     784 </span>            : // extending the table data (qm_select_data.h).
<span class="lineNum">     785 </span><span class="lineNoCov">          0 : void VCMQmResolution::AdjustAction() {</span>
<span class="lineNum">     786 </span>            :   // If the spatial level is default state (neither low or high), motion level
<span class="lineNum">     787 </span>            :   // is not high, and spatial action was selected, switch to 2/3 frame rate
<span class="lineNum">     788 </span>            :   // reduction if the average incoming frame rate is high.
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   if (spatial_.level == kDefault &amp;&amp; motion_.level != kHigh &amp;&amp;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       action_.spatial != kNoChangeSpatial &amp;&amp;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :       framerate_level_ == kFrameRateHigh) {</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     action_.temporal = kTwoThirdsTemporal;</span>
<span class="lineNum">     794 </span>            :   }
<span class="lineNum">     795 </span>            :   // If both motion and spatial level are low, and temporal down action was
<span class="lineNum">     796 </span>            :   // selected, switch to spatial 3/4x3/4 if the frame rate is not above the
<span class="lineNum">     797 </span>            :   // lower middle level (|kFrameRateMiddle1|).
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   if (motion_.level == kLow &amp;&amp; spatial_.level == kLow &amp;&amp;</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :       framerate_level_ &lt;= kFrameRateMiddle1 &amp;&amp;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :       action_.temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     action_.spatial = kOneHalfSpatialUniform;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     803 </span>            :   }
<span class="lineNum">     804 </span>            :   // If spatial action is selected, and there has been too much spatial
<span class="lineNum">     805 </span>            :   // reduction already (i.e., 1/4), then switch to temporal action if the
<span class="lineNum">     806 </span>            :   // average frame rate is not low.
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   if (action_.spatial != kNoChangeSpatial &amp;&amp;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :       down_action_history_[0].spatial == kOneQuarterSpatialUniform &amp;&amp;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :       framerate_level_ != kFrameRateLow) {</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     action_.temporal = kTwoThirdsTemporal;</span>
<span class="lineNum">     812 </span>            :   }
<span class="lineNum">     813 </span>            :   // Never use temporal action if number of temporal layers is above 2.
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   if (num_layers_ &gt; 2) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     if (action_.temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       action_.spatial = kOneHalfSpatialUniform;</span>
<span class="lineNum">     817 </span>            :     }
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     819 </span>            :   }
<a name="820"><span class="lineNum">     820 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineNoCov">          0 : void VCMQmResolution::ConvertSpatialFractionalToWhole() {</span>
<span class="lineNum">     823 </span>            :   // If 3/4 spatial is selected, check if there has been another 3/4,
<span class="lineNum">     824 </span>            :   // and if so, combine them into 1/2. 1/2 scaling is more efficient than 9/16.
<span class="lineNum">     825 </span>            :   // Note we define 3/4x3/4 spatial as kOneHalfSpatialUniform.
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   if (action_.spatial == kOneHalfSpatialUniform) {</span>
<span class="lineNum">     827 </span>            :     bool found = false;
<span class="lineNum">     828 </span>            :     int isel = kDownActionHistorySize;
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; kDownActionHistorySize; ++i) {</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :       if (down_action_history_[i].spatial == kOneHalfSpatialUniform) {</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :         isel = i;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :         found = true;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     834 </span>            :       }
<span class="lineNum">     835 </span>            :     }
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     if (found) {</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :       action_.spatial = kOneQuarterSpatialUniform;</span>
<span class="lineNum">     838 </span>            :       state_dec_factor_spatial_ =
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :           state_dec_factor_spatial_ /</span>
<span class="lineNum">     840 </span>            :           (kFactorWidthSpatial[kOneHalfSpatialUniform] *
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :            kFactorHeightSpatial[kOneHalfSpatialUniform]);</span>
<span class="lineNum">     842 </span>            :       // Check if switching to 1/2x1/2 (=1/4) spatial is allowed.
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :       ConstrainAmountOfDownSampling();</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :       if (action_.spatial == kNoChangeSpatial) {</span>
<span class="lineNum">     845 </span>            :         // Not allowed. Go back to 3/4x3/4 spatial.
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :         action_.spatial = kOneHalfSpatialUniform;</span>
<span class="lineNum">     847 </span>            :         state_dec_factor_spatial_ =
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :             state_dec_factor_spatial_ *</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :             kFactorWidthSpatial[kOneHalfSpatialUniform] *</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :             kFactorHeightSpatial[kOneHalfSpatialUniform];</span>
<span class="lineNum">     851 </span>            :       } else {
<span class="lineNum">     852 </span>            :         // Switching is allowed. Remove 3/4x3/4 from the history, and update
<span class="lineNum">     853 </span>            :         // the frame size.
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :         for (int i = isel; i &lt; kDownActionHistorySize - 1; ++i) {</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :           down_action_history_[i].spatial = down_action_history_[i + 1].spatial;</span>
<span class="lineNum">     856 </span>            :         }
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :         width_ = width_ * kFactorWidthSpatial[kOneHalfSpatialUniform];</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :         height_ = height_ * kFactorHeightSpatial[kOneHalfSpatialUniform];</span>
<span class="lineNum">     859 </span>            :       }
<span class="lineNum">     860 </span>            :     }
<span class="lineNum">     861 </span>            :   }
<a name="862"><span class="lineNum">     862 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 : void VCMQmResolution::InsertLatestDownAction() {</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   if (action_.spatial != kNoChangeSpatial) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     for (int i = kDownActionHistorySize - 1; i &gt; 0; --i) {</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       down_action_history_[i].spatial = down_action_history_[i - 1].spatial;</span>
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     down_action_history_[0].spatial = action_.spatial;</span>
<span class="lineNum">     870 </span>            :   }
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   if (action_.temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     for (int i = kDownActionHistorySize - 1; i &gt; 0; --i) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       down_action_history_[i].temporal = down_action_history_[i - 1].temporal;</span>
<span class="lineNum">     874 </span>            :     }
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     down_action_history_[0].temporal = action_.temporal;</span>
<span class="lineNum">     876 </span>            :   }
<a name="877"><span class="lineNum">     877 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 : void VCMQmResolution::RemoveLastDownAction() {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   if (action_.spatial != kNoChangeSpatial) {</span>
<span class="lineNum">     881 </span>            :     // If the last spatial action was 1/2x1/2 we replace it with 3/4x3/4.
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     if (action_.spatial == kOneQuarterSpatialUniform) {</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :       down_action_history_[0].spatial = kOneHalfSpatialUniform;</span>
<span class="lineNum">     884 </span>            :     } else {
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; kDownActionHistorySize - 1; ++i) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         down_action_history_[i].spatial = down_action_history_[i + 1].spatial;</span>
<span class="lineNum">     887 </span>            :       }
<span class="lineNum">     888 </span>            :       down_action_history_[kDownActionHistorySize - 1].spatial =
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :           kNoChangeSpatial;</span>
<span class="lineNum">     890 </span>            :     }
<span class="lineNum">     891 </span>            :   }
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   if (action_.temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; kDownActionHistorySize - 1; ++i) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :       down_action_history_[i].temporal = down_action_history_[i + 1].temporal;</span>
<span class="lineNum">     895 </span>            :     }
<span class="lineNum">     896 </span>            :     down_action_history_[kDownActionHistorySize - 1].temporal =
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         kNoChangeTemporal;</span>
<span class="lineNum">     898 </span>            :   }
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span><span class="lineNoCov">          0 : void VCMQmResolution::ConstrainAmountOfDownSampling() {</span>
<span class="lineNum">     902 </span>            :   // Sanity checks on down-sampling selection:
<span class="lineNum">     903 </span>            :   // override the settings for too small image size and/or frame rate.
<span class="lineNum">     904 </span>            :   // Also check the limit on current down-sampling states.
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   float spatial_width_fact = kFactorWidthSpatial[action_.spatial];</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   float spatial_height_fact = kFactorHeightSpatial[action_.spatial];</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   float temporal_fact = kFactorTemporal[action_.temporal];</span>
<span class="lineNum">     909 </span>            :   float new_dec_factor_spatial =
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :       state_dec_factor_spatial_ * spatial_width_fact * spatial_height_fact;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   float new_dec_factor_temp = state_dec_factor_temporal_ * temporal_fact;</span>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :   // No spatial sampling if current frame size is too small, or if the
<span class="lineNum">     914 </span>            :   // amount of spatial down-sampling is above maximum spatial down-action.
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   if ((width_ * height_) &lt;= kMinImageSize ||</span>
<span class="lineNum">     916 </span>            :       new_dec_factor_spatial &gt; kMaxSpatialDown) {
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     new_dec_factor_spatial = state_dec_factor_spatial_;</span>
<span class="lineNum">     919 </span>            :   }
<span class="lineNum">     920 </span>            :   // No frame rate reduction if average frame rate is below some point, or if
<span class="lineNum">     921 </span>            :   // the amount of temporal down-sampling is above maximum temporal down-action.
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   if (avg_incoming_framerate_ &lt;= kMinFrameRate ||</span>
<span class="lineNum">     923 </span>            :       new_dec_factor_temp &gt; kMaxTempDown) {
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     new_dec_factor_temp = state_dec_factor_temporal_;</span>
<span class="lineNum">     926 </span>            :   }
<span class="lineNum">     927 </span>            :   // Check if the total (spatial-temporal) down-action is above maximum allowed,
<span class="lineNum">     928 </span>            :   // if so, disallow the current selected down-action.
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   if (new_dec_factor_spatial * new_dec_factor_temp &gt; kMaxTotalDown) {</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     if (action_.spatial != kNoChangeSpatial) {</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :       action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     } else if (action_.temporal != kNoChangeTemporal) {</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     934 </span>            :     } else {
<span class="lineNum">     935 </span>            :       // We only allow for one action (spatial or temporal) at a given time, so
<span class="lineNum">     936 </span>            :       // either spatial or temporal action is selected when this function is
<span class="lineNum">     937 </span>            :       // called. If the selected action is disallowed from one of the above
<span class="lineNum">     938 </span>            :       // 2 prior conditions (on spatial &amp; temporal max down-action), then this
<span class="lineNum">     939 </span>            :       // condition &quot;total down-action &gt; |kMaxTotalDown|&quot; would not be entered.
<span class="lineNum">     940 </span>            :       assert(false);
<span class="lineNum">     941 </span>            :     }
<span class="lineNum">     942 </span>            :   }
<a name="943"><span class="lineNum">     943 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineNoCov">          0 : void VCMQmResolution::PickSpatialOrTemporal() {</span>
<span class="lineNum">     946 </span>            :   // Pick the one that has had the most down-sampling thus far.
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   if (state_dec_factor_spatial_ &gt; state_dec_factor_temporal_) {</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     action_.spatial = down_action_history_[0].spatial;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     action_.temporal = kNoChangeTemporal;</span>
<span class="lineNum">     950 </span>            :   } else {
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     action_.spatial = kNoChangeSpatial;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     action_.temporal = down_action_history_[0].temporal;</span>
<span class="lineNum">     953 </span>            :   }
<span class="lineNum">     954 </span><span class="lineNoCov">          0 : }</span>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<span class="lineNum">     956 </span>            : // TODO(marpan): Update when we allow for directional spatial down-sampling.
<span class="lineNum">     957 </span><span class="lineNoCov">          0 : void VCMQmResolution::SelectSpatialDirectionMode(float transition_rate) {</span>
<span class="lineNum">     958 </span>            :   // Default is 4/3x4/3
<span class="lineNum">     959 </span>            :   // For bit rates well below transitional rate, we select 2x2.
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   if (avg_target_rate_ &lt; transition_rate * kRateRedSpatial2X2) {</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_width_fact = 2.0f;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_height_fact = 2.0f;</span>
<span class="lineNum">     963 </span>            :   }
<span class="lineNum">     964 </span>            :   // Otherwise check prediction errors and aspect ratio.
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   float spatial_err = 0.0f;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   float spatial_err_h = 0.0f;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   float spatial_err_v = 0.0f;</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   if (content_metrics_) {</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     spatial_err = content_metrics_-&gt;spatial_pred_err;</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     spatial_err_h = content_metrics_-&gt;spatial_pred_err_h;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     spatial_err_v = content_metrics_-&gt;spatial_pred_err_v;</span>
<span class="lineNum">     972 </span>            :   }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   // Favor 1x2 if aspect_ratio is 16:9.
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   if (aspect_ratio_ &gt;= 16.0f / 9.0f) {</span>
<span class="lineNum">     976 </span>            :     // Check if 1x2 has lowest prediction error.
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :     if (spatial_err_h &lt; spatial_err &amp;&amp; spatial_err_h &lt; spatial_err_v) {</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       qm_-&gt;spatial_width_fact = 2.0f;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :       qm_-&gt;spatial_height_fact = 1.0f;</span>
<span class="lineNum">     980 </span>            :     }
<span class="lineNum">     981 </span>            :   }
<span class="lineNum">     982 </span>            :   // Check for 4/3x4/3 selection: favor 2x2 over 1x2 and 2x1.
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   if (spatial_err &lt; spatial_err_h * (1.0f + kSpatialErr2x2VsHoriz) &amp;&amp;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       spatial_err &lt; spatial_err_v * (1.0f + kSpatialErr2X2VsVert)) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_width_fact = 4.0f / 3.0f;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_height_fact = 4.0f / 3.0f;</span>
<span class="lineNum">     987 </span>            :   }
<span class="lineNum">     988 </span>            :   // Check for 2x1 selection.
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   if (spatial_err_v &lt; spatial_err_h * (1.0f - kSpatialErrVertVsHoriz) &amp;&amp;</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :       spatial_err_v &lt; spatial_err * (1.0f - kSpatialErr2X2VsVert)) {</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_width_fact = 1.0f;</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     qm_-&gt;spatial_height_fact = 2.0f;</span>
<span class="lineNum">     993 </span>            :   }
<a name="994"><span class="lineNum">     994 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineNoCov">          0 : void VCMQmResolution::SetCPULoadState(CPULoadState state) {</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   loadstate_ = state;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     999 </span>            : 
<a name="1000"><span class="lineNum">    1000 </span>            : // ROBUSTNESS CLASS</a>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 : VCMQmRobustness::VCMQmRobustness() {</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   Reset();</span>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1005 </span>            : 
<a name="1006"><span class="lineNum">    1006 </span><span class="lineNoCov">          0 : VCMQmRobustness::~VCMQmRobustness() {}</span></a>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 : void VCMQmRobustness::Reset() {</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   prev_total_rate_ = 0.0f;</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   prev_rtt_time_ = 0;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   prev_packet_loss_ = 0;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   prev_code_rate_delta_ = 0;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   ResetQM();</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : // Adjust the FEC rate based on the content and the network state
<a name="1017"><span class="lineNum">    1017 </span>            : // (packet loss rate, total rate/bandwidth, round trip time).</a>
<span class="lineNum">    1018 </span>            : // Note that packetLoss here is the filtered loss value.
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 : float VCMQmRobustness::AdjustFecFactor(uint8_t code_rate_delta,</span>
<span class="lineNum">    1020 </span>            :                                        float total_rate,
<span class="lineNum">    1021 </span>            :                                        float framerate,
<span class="lineNum">    1022 </span>            :                                        int64_t rtt_time,
<span class="lineNum">    1023 </span>            :                                        uint8_t packet_loss) {
<span class="lineNum">    1024 </span>            :   // Default: no adjustment
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   float adjust_fec = 1.0f;</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   if (content_metrics_ == NULL) {</span>
<span class="lineNum">    1027 </span>            :     return adjust_fec;
<span class="lineNum">    1028 </span>            :   }
<span class="lineNum">    1029 </span>            :   // Compute class state of the content.
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   ComputeMotionNFD();</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   ComputeSpatial();</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :   // TODO(marpan): Set FEC adjustment factor.
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :   // Keep track of previous values of network state:
<span class="lineNum">    1036 </span>            :   // adjustment may be also based on pattern of changes in network state.
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   prev_total_rate_ = total_rate;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   prev_rtt_time_ = rtt_time;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   prev_packet_loss_ = packet_loss;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   prev_code_rate_delta_ = code_rate_delta;</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   return adjust_fec;</span>
<span class="lineNum">    1042 </span>            : }
<a name="1043"><span class="lineNum">    1043 </span>            : </a>
<span class="lineNum">    1044 </span>            : // Set the UEP (unequal-protection across packets) on/off for the FEC.
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 : bool VCMQmRobustness::SetUepProtection(uint8_t code_rate_delta,</span>
<span class="lineNum">    1046 </span>            :                                        float total_rate,
<span class="lineNum">    1047 </span>            :                                        uint8_t packet_loss,
<span class="lineNum">    1048 </span>            :                                        bool frame_type) {
<span class="lineNum">    1049 </span>            :   // Default.
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1051 </span>            : }
<span class="lineNum">    1052 </span>            : }  // namespace webrtc
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
