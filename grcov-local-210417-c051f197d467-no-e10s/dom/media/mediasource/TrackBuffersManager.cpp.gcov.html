<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - dom/media/mediasource/TrackBuffersManager.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">dom/media/mediasource</a> - TrackBuffersManager.cpp<span style="font-size: 80%;"> (source / <a href="TrackBuffersManager.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">915</td>
            <td class="headerCovTableEntry">1081</td>
            <td class="headerCovTableEntryMed">84.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">70</td>
            <td class="headerCovTableEntry">86</td>
            <td class="headerCovTableEntryMed">81.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;TrackBuffersManager.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;ContainerParser.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;MediaPrefs.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;MediaSourceDemuxer.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;MediaSourceUtils.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/SizePrintfMacros.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/StateMirroring.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;SourceBufferResource.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;SourceBuffer.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;WebMDemuxer.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;SourceBufferTask.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifdef MOZ_FMP4
<span class="lineNum">      21 </span>            : #include &quot;MP4Demuxer.h&quot;
<span class="lineNum">      22 </span>            : #endif
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &lt;limits&gt;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : extern mozilla::LogModule* GetMediaSourceLog();
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #define MSE_DEBUG(arg, ...) MOZ_LOG(GetMediaSourceLog(), mozilla::LogLevel::Debug, (&quot;TrackBuffersManager(%p:%s)::%s: &quot; arg, this, mType.OriginalString().Data(), __func__, ##__VA_ARGS__))
<a name="29"><span class="lineNum">      29 </span>            : #define MSE_DEBUGV(arg, ...) MOZ_LOG(GetMediaSourceLog(), mozilla::LogLevel::Verbose, (&quot;TrackBuffersManager(%p:%s)::%s: &quot; arg, this, mType.OriginalString().Data(), __func__, ##__VA_ARGS__))</a>
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span><span class="lineCov">          1 : mozilla::LogModule* GetMediaSourceSamplesLog()</span>
<span class="lineNum">      32 </span>            : {
<span class="lineNum">      33 </span>            :   static mozilla::LazyLogModule sLogModule(&quot;MediaSourceSamples&quot;);
<span class="lineNum">      34 </span><span class="lineCov">          1 :   return sLogModule;</span>
<span class="lineNum">      35 </span>            : }
<span class="lineNum">      36 </span>            : #define SAMPLE_DEBUG(arg, ...) MOZ_LOG(GetMediaSourceSamplesLog(), mozilla::LogLevel::Debug, (&quot;TrackBuffersManager(%p:%s)::%s: &quot; arg, this, mType.OriginalString().Data(), __func__, ##__VA_ARGS__))
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : namespace mozilla {
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : using dom::SourceBufferAppendMode;
<span class="lineNum">      41 </span>            : using media::TimeUnit;
<span class="lineNum">      42 </span>            : using media::TimeInterval;
<span class="lineNum">      43 </span>            : using media::TimeIntervals;
<span class="lineNum">      44 </span>            : typedef SourceBufferTask::AppendBufferResult AppendBufferResult;
<a name="45"><span class="lineNum">      45 </span>            : </a>
<span class="lineNum">      46 </span>            : static const char*
<span class="lineNum">      47 </span><span class="lineNoCov">          0 : AppendStateToStr(SourceBufferAttributes::AppendState aState)</span>
<span class="lineNum">      48 </span>            : {
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   switch (aState) {</span>
<span class="lineNum">      50 </span>            :     case SourceBufferAttributes::AppendState::WAITING_FOR_SEGMENT:
<span class="lineNum">      51 </span>            :       return &quot;WAITING_FOR_SEGMENT&quot;;
<span class="lineNum">      52 </span>            :     case SourceBufferAttributes::AppendState::PARSING_INIT_SEGMENT:
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :       return &quot;PARSING_INIT_SEGMENT&quot;;</span>
<span class="lineNum">      54 </span>            :     case SourceBufferAttributes::AppendState::PARSING_MEDIA_SEGMENT:
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :       return &quot;PARSING_MEDIA_SEGMENT&quot;;</span>
<span class="lineNum">      56 </span>            :     default:
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :       return &quot;IMPOSSIBLE&quot;;</span>
<span class="lineNum">      58 </span>            :   }
<span class="lineNum">      59 </span>            : }
<span class="lineNum">      60 </span>            : 
<a name="61"><span class="lineNum">      61 </span>            : static Atomic&lt;uint32_t&gt; sStreamSourceID(0u);</a>
<span class="lineNum">      62 </span>            : 
<a name="63"><span class="lineNum">      63 </span><span class="lineNoCov">          0 : class DispatchKeyNeededEvent : public Runnable {</span></a>
<span class="lineNum">      64 </span>            : public:
<span class="lineNum">      65 </span><span class="lineCov">          1 :   DispatchKeyNeededEvent(AbstractMediaDecoder* aDecoder,</span>
<span class="lineNum">      66 </span>            :                          nsTArray&lt;uint8_t&gt;&amp; aInitData,
<span class="lineNum">      67 </span>            :                          const nsString&amp; aInitDataType)
<span class="lineNum">      68 </span>            :     : mDecoder(aDecoder)
<span class="lineNum">      69 </span>            :     , mInitData(aInitData)
<span class="lineNum">      70 </span><span class="lineCov">          1 :     , mInitDataType(aInitDataType)</span>
<a name="71"><span class="lineNum">      71 </span>            :   {</a>
<span class="lineNum">      72 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   NS_IMETHOD Run() override {</span>
<span class="lineNum">      74 </span>            :     // Note: Null check the owner, as the decoder could have been shutdown
<span class="lineNum">      75 </span>            :     // since this event was dispatched.
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     MediaDecoderOwner* owner = mDecoder-&gt;GetOwner();</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     if (owner) {</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :       owner-&gt;DispatchEncrypted(mInitData, mInitDataType);</span>
<span class="lineNum">      79 </span>            :     }
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     mDecoder = nullptr;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">      82 </span>            :   }
<span class="lineNum">      83 </span>            : private:
<span class="lineNum">      84 </span>            :   RefPtr&lt;AbstractMediaDecoder&gt; mDecoder;
<span class="lineNum">      85 </span>            :   nsTArray&lt;uint8_t&gt; mInitData;
<span class="lineNum">      86 </span>            :   nsString mInitDataType;
<a name="87"><span class="lineNum">      87 </span>            : };</a>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineCov">          1 : TrackBuffersManager::TrackBuffersManager(MediaSourceDecoder* aParentDecoder,</span>
<span class="lineNum">      90 </span>            :                                          const MediaContainerType&amp; aType)
<span class="lineNum">      91 </span>            :   : mInputBuffer(new MediaByteBuffer)
<span class="lineNum">      92 </span>            :   , mBufferFull(false)
<span class="lineNum">      93 </span>            :   , mFirstInitializationSegmentReceived(false)
<span class="lineNum">      94 </span>            :   , mNewMediaSegmentStarted(false)
<span class="lineNum">      95 </span>            :   , mActiveTrack(false)
<span class="lineNum">      96 </span>            :   , mType(aType)
<span class="lineNum">      97 </span>            :   , mParser(ContainerParser::CreateForMIMEType(aType))
<span class="lineNum">      98 </span>            :   , mProcessedInput(0)
<span class="lineNum">      99 </span>            :   , mTaskQueue(aParentDecoder-&gt;GetDemuxer()-&gt;GetTaskQueue())
<span class="lineNum">     100 </span>            :   , mParentDecoder(new nsMainThreadPtrHolder&lt;MediaSourceDecoder&gt;(aParentDecoder, false /* strict */))
<span class="lineNum">     101 </span>            :   , mAbstractMainThread(aParentDecoder-&gt;AbstractMainThread())
<span class="lineNum">     102 </span>            :   , mEnded(false)
<span class="lineNum">     103 </span>            :   , mVideoEvictionThreshold(Preferences::GetUint(&quot;media.mediasource.eviction_threshold.video&quot;,
<span class="lineNum">     104 </span><span class="lineCov">          1 :                                                  100 * 1024 * 1024))</span>
<span class="lineNum">     105 </span>            :   , mAudioEvictionThreshold(Preferences::GetUint(&quot;media.mediasource.eviction_threshold.audio&quot;,
<span class="lineNum">     106 </span><span class="lineCov">          1 :                                                  20 * 1024 * 1024))</span>
<span class="lineNum">     107 </span>            :   , mEvictionState(EvictionState::NO_EVICTION_NEEDED)
<span class="lineNum">     108 </span><span class="lineCov">          1 :   , mMonitor(&quot;TrackBuffersManager&quot;)</span>
<span class="lineNum">     109 </span>            : {
<span class="lineNum">     110 </span>            :   MOZ_ASSERT(NS_IsMainThread(), &quot;Must be instanciated on the main thread&quot;);
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">          1 : TrackBuffersManager::~TrackBuffersManager()</span>
<span class="lineNum">     114 </span>            : {
<span class="lineNum">     115 </span><span class="lineCov">          1 :   ShutdownDemuxers();</span>
<span class="lineNum">     116 </span><span class="lineCov">          1 : }</span>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<span class="lineNum">     118 </span>            : RefPtr&lt;TrackBuffersManager::AppendPromise&gt;
<span class="lineNum">     119 </span><span class="lineCov">          1 : TrackBuffersManager::AppendData(MediaByteBuffer* aData,</span>
<span class="lineNum">     120 </span>            :                                 const SourceBufferAttributes&amp; aAttributes)
<span class="lineNum">     121 </span>            : {
<span class="lineNum">     122 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     123 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;Appending %&quot; PRIuSIZE &quot; bytes&quot;, aData-&gt;Length());</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineCov">          1 :   mEnded = false;</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :   return InvokeAsync&lt;RefPtr&lt;MediaByteBuffer&gt;, SourceBufferAttributes&amp;&amp;&gt;(
<span class="lineNum">     128 </span>            :            GetTaskQueue(), this, __func__,
<span class="lineNum">     129 </span><span class="lineCov">          1 :            &amp;TrackBuffersManager::DoAppendData, aData, aAttributes);</span>
<span class="lineNum">     130 </span>            : }
<a name="131"><span class="lineNum">     131 </span>            : </a>
<span class="lineNum">     132 </span>            : RefPtr&lt;TrackBuffersManager::AppendPromise&gt;
<span class="lineNum">     133 </span><span class="lineCov">          1 : TrackBuffersManager::DoAppendData(MediaByteBuffer* aData,</span>
<span class="lineNum">     134 </span>            :                                   const SourceBufferAttributes&amp; aAttributes)
<span class="lineNum">     135 </span>            : {
<span class="lineNum">     136 </span><span class="lineCov">          1 :   RefPtr&lt;AppendBufferTask&gt; task = new AppendBufferTask(aData, aAttributes);</span>
<span class="lineNum">     137 </span><span class="lineCov">          1 :   RefPtr&lt;AppendPromise&gt; p = task-&gt;mPromise.Ensure(__func__);</span>
<span class="lineNum">     138 </span><span class="lineCov">          1 :   QueueTask(task);</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">          1 :   return p;</span>
<span class="lineNum">     141 </span>            : }
<a name="142"><span class="lineNum">     142 </span>            : </a>
<span class="lineNum">     143 </span>            : void
<span class="lineNum">     144 </span><span class="lineCov">          1 : TrackBuffersManager::QueueTask(SourceBufferTask* aTask)</span>
<span class="lineNum">     145 </span>            : {
<span class="lineNum">     146 </span><span class="lineCov">          1 :   if (!OnTaskQueue()) {</span>
<span class="lineNum">     147 </span>            :     GetTaskQueue()-&gt;Dispatch(NewRunnableMethod&lt;RefPtr&lt;SourceBufferTask&gt;&gt;(
<span class="lineNum">     148 </span><span class="lineCov">          1 :       this, &amp;TrackBuffersManager::QueueTask, aTask));</span>
<span class="lineNum">     149 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     150 </span>            :   }
<span class="lineNum">     151 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     152 </span><span class="lineCov">          1 :   mQueue.Push(aTask);</span>
<span class="lineNum">     153 </span><span class="lineCov">          1 :   ProcessTasks();</span>
<span class="lineNum">     154 </span>            : }
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : void
<span class="lineNum">     157 </span><span class="lineCov">          1 : TrackBuffersManager::ProcessTasks()</span>
<span class="lineNum">     158 </span>            : {
<span class="lineNum">     159 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     160 </span>            :   typedef SourceBufferTask::Type Type;
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span><span class="lineCov">          1 :   if (mCurrentTask) {</span>
<span class="lineNum">     163 </span>            :     // Already have a task pending. ProcessTask will be scheduled once the
<span class="lineNum">     164 </span>            :     // current task complete.
<span class="lineNum">     165 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     166 </span>            :   }
<span class="lineNum">     167 </span><span class="lineCov">          1 :   RefPtr&lt;SourceBufferTask&gt; task = mQueue.Pop();</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :   if (!task) {</span>
<span class="lineNum">     169 </span>            :     // nothing to do.
<span class="lineNum">     170 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     171 </span>            :   }
<span class="lineNum">     172 </span><span class="lineCov">          1 :   switch (task-&gt;GetType()) {</span>
<span class="lineNum">     173 </span>            :     case Type::AppendBuffer:
<span class="lineNum">     174 </span><span class="lineCov">          1 :       mCurrentTask = task;</span>
<span class="lineNum">     175 </span><span class="lineCov">          1 :       if (!mInputBuffer) {</span>
<span class="lineNum">     176 </span><span class="lineCov">          1 :         mInputBuffer = task-&gt;As&lt;AppendBufferTask&gt;()-&gt;mBuffer;</span>
<span class="lineNum">     177 </span><span class="lineCov">          1 :       } else if (!mInputBuffer-&gt;AppendElements(*task-&gt;As&lt;AppendBufferTask&gt;()-&gt;mBuffer, fallible)) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         RejectAppend(NS_ERROR_OUT_OF_MEMORY, __func__);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     180 </span>            :       }
<span class="lineNum">     181 </span><span class="lineCov">          1 :       mSourceBufferAttributes =</span>
<span class="lineNum">     182 </span><span class="lineCov">          1 :         MakeUnique&lt;SourceBufferAttributes&gt;(task-&gt;As&lt;AppendBufferTask&gt;()-&gt;mAttributes);</span>
<span class="lineNum">     183 </span><span class="lineCov">          1 :       mAppendWindow =</span>
<span class="lineNum">     184 </span><span class="lineCov">          1 :         TimeInterval(TimeUnit::FromSeconds(mSourceBufferAttributes-&gt;GetAppendWindowStart()),</span>
<span class="lineNum">     185 </span><span class="lineCov">          1 :                      TimeUnit::FromSeconds(mSourceBufferAttributes-&gt;GetAppendWindowEnd()));</span>
<span class="lineNum">     186 </span><span class="lineCov">          1 :       ScheduleSegmentParserLoop();</span>
<span class="lineNum">     187 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">     188 </span>            :     case Type::RangeRemoval:
<span class="lineNum">     189 </span>            :     {
<span class="lineNum">     190 </span><span class="lineCov">          1 :       bool rv = CodedFrameRemoval(task-&gt;As&lt;RangeRemovalTask&gt;()-&gt;mRange);</span>
<span class="lineNum">     191 </span><span class="lineCov">          1 :       task-&gt;As&lt;RangeRemovalTask&gt;()-&gt;mPromise.Resolve(rv, __func__);</span>
<span class="lineNum">     192 </span>            :       break;
<span class="lineNum">     193 </span>            :     }
<span class="lineNum">     194 </span>            :     case Type::EvictData:
<span class="lineNum">     195 </span><span class="lineCov">          1 :       DoEvictData(task-&gt;As&lt;EvictDataTask&gt;()-&gt;mPlaybackTime,</span>
<span class="lineNum">     196 </span><span class="lineCov">          1 :                   task-&gt;As&lt;EvictDataTask&gt;()-&gt;mSizeToEvict);</span>
<span class="lineNum">     197 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">     198 </span>            :     case Type::Abort:
<span class="lineNum">     199 </span>            :       // not handled yet, and probably never.
<span class="lineNum">     200 </span>            :       break;
<span class="lineNum">     201 </span>            :     case Type::Reset:
<span class="lineNum">     202 </span><span class="lineCov">          1 :       CompleteResetParserState();</span>
<span class="lineNum">     203 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">     204 </span>            :     case Type::Detach:
<span class="lineNum">     205 </span><span class="lineCov">          1 :       mTaskQueue = nullptr;</span>
<span class="lineNum">     206 </span><span class="lineCov">          1 :       MOZ_DIAGNOSTIC_ASSERT(mQueue.Length() == 0,</span>
<span class="lineNum">     207 </span>            :                             &quot;Detach task must be the last&quot;);
<span class="lineNum">     208 </span>            :       return;
<span class="lineNum">     209 </span>            :     default:
<span class="lineNum">     210 </span>            :       NS_WARNING(&quot;Invalid Task&quot;);
<span class="lineNum">     211 </span>            :   }
<span class="lineNum">     212 </span><span class="lineCov">          1 :   GetTaskQueue()-&gt;Dispatch(NewRunnableMethod(this, &amp;TrackBuffersManager::ProcessTasks));</span>
<span class="lineNum">     213 </span>            : }
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : // The MSE spec requires that we abort the current SegmentParserLoop
<span class="lineNum">     216 </span>            : // which is then followed by a call to ResetParserState.
<span class="lineNum">     217 </span>            : // However due to our asynchronous design this causes inherent difficulties.
<span class="lineNum">     218 </span>            : // As the spec behaviour is non deterministic anyway, we instead process all
<a name="219"><span class="lineNum">     219 </span>            : // pending frames found in the input buffer.</a>
<span class="lineNum">     220 </span>            : void
<span class="lineNum">     221 </span><span class="lineCov">          1 : TrackBuffersManager::AbortAppendData()</span>
<span class="lineNum">     222 </span>            : {
<span class="lineNum">     223 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     224 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;&quot;);</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineCov">          1 :   QueueTask(new AbortTask());</span>
<span class="lineNum">     227 </span><span class="lineCov">          1 : }</span>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<span class="lineNum">     229 </span>            : void
<span class="lineNum">     230 </span><span class="lineCov">          1 : TrackBuffersManager::ResetParserState(SourceBufferAttributes&amp; aAttributes)</span>
<span class="lineNum">     231 </span>            : {
<span class="lineNum">     232 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     233 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;&quot;);</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   // Spec states:
<span class="lineNum">     236 </span>            :   // 1. If the append state equals PARSING_MEDIA_SEGMENT and the input buffer contains some complete coded frames, then run the coded frame processing algorithm until all of these complete coded frames have been processed.
<span class="lineNum">     237 </span>            :   // However, we will wait until all coded frames have been processed regardless
<span class="lineNum">     238 </span>            :   // of the value of append state.
<span class="lineNum">     239 </span><span class="lineCov">          1 :   QueueTask(new ResetTask());</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   // ResetParserState has some synchronous steps that much be performed now.
<span class="lineNum">     242 </span>            :   // The remaining steps will be performed once the ResetTask gets executed.
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   // 6. If the mode attribute equals &quot;sequence&quot;, then set the group start timestamp to the group end timestamp
<span class="lineNum">     245 </span><span class="lineCov">          1 :   if (aAttributes.GetAppendMode() == SourceBufferAppendMode::Sequence) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     aAttributes.SetGroupStartTimestamp(aAttributes.GetGroupEndTimestamp());</span>
<span class="lineNum">     247 </span>            :   }
<span class="lineNum">     248 </span>            :   // 8. Set append state to WAITING_FOR_SEGMENT.
<span class="lineNum">     249 </span><span class="lineCov">          1 :   aAttributes.SetAppendState(AppendState::WAITING_FOR_SEGMENT);</span>
<span class="lineNum">     250 </span><span class="lineCov">          1 : }</span>
<a name="251"><span class="lineNum">     251 </span>            : </a>
<span class="lineNum">     252 </span>            : RefPtr&lt;TrackBuffersManager::RangeRemovalPromise&gt;
<span class="lineNum">     253 </span><span class="lineCov">          1 : TrackBuffersManager::RangeRemoval(TimeUnit aStart, TimeUnit aEnd)</span>
<span class="lineNum">     254 </span>            : {
<span class="lineNum">     255 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     256 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;From %.2f to %.2f&quot;, aStart.ToSeconds(), aEnd.ToSeconds());</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineCov">          1 :   mEnded = false;</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :   return InvokeAsync(GetTaskQueue(), this, __func__,
<span class="lineNum">     261 </span>            :                      &amp;TrackBuffersManager::CodedFrameRemovalWithPromise,
<span class="lineNum">     262 </span><span class="lineCov">          1 :                      TimeInterval(aStart, aEnd));</span>
<span class="lineNum">     263 </span>            : }
<a name="264"><span class="lineNum">     264 </span>            : </a>
<span class="lineNum">     265 </span>            : TrackBuffersManager::EvictDataResult
<span class="lineNum">     266 </span><span class="lineCov">          1 : TrackBuffersManager::EvictData(const TimeUnit&amp; aPlaybackTime, int64_t aSize)</span>
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineCov">          1 :   if (aSize &gt; EvictionThreshold()) {</span>
<span class="lineNum">     271 </span>            :     // We're adding more data than we can hold.
<span class="lineNum">     272 </span>            :     return EvictDataResult::BUFFER_FULL;
<span class="lineNum">     273 </span>            :   }
<span class="lineNum">     274 </span><span class="lineCov">          1 :   const int64_t toEvict = GetSize() + aSize - EvictionThreshold();</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :   const uint32_t canEvict =
<span class="lineNum">     277 </span><span class="lineCov">          1 :     Evictable(HasVideo() ? TrackInfo::kVideoTrack : TrackInfo::kAudioTrack);</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;currentTime=%&quot; PRId64 &quot; buffered=%&quot; PRId64 &quot;kB, eviction threshold=%&quot; PRId64 &quot;kB, &quot;</span>
<span class="lineNum">     280 </span>            :             &quot;evict=%&quot; PRId64 &quot;kB canevict=%&quot; PRIu32 &quot;kB&quot;,
<span class="lineNum">     281 </span>            :             aPlaybackTime.ToMicroseconds(), GetSize() / 1024,
<span class="lineNum">     282 </span>            :             EvictionThreshold() / 1024, toEvict / 1024, canEvict / 1024);
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineCov">          1 :   if (toEvict &lt;= 0) {</span>
<span class="lineNum">     285 </span><span class="lineCov">          1 :     mEvictionState = EvictionState::NO_EVICTION_NEEDED;</span>
<span class="lineNum">     286 </span><span class="lineCov">          1 :     return EvictDataResult::NO_DATA_EVICTED;</span>
<span class="lineNum">     287 </span>            :   }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :   EvictDataResult result;
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">          1 :   if (mBufferFull &amp;&amp; mEvictionState == EvictionState::EVICTION_COMPLETED &amp;&amp;</span>
<span class="lineNum">     292 </span><span class="lineCov">          1 :       canEvict &lt; uint32_t(toEvict)) {</span>
<span class="lineNum">     293 </span>            :     // Our buffer is currently full. We will make another eviction attempt.
<span class="lineNum">     294 </span>            :     // However, the current appendBuffer will fail as we can't know ahead of
<span class="lineNum">     295 </span>            :     // time if the eviction will later succeed.
<span class="lineNum">     296 </span>            :     result = EvictDataResult::BUFFER_FULL;
<span class="lineNum">     297 </span>            :   } else {
<span class="lineNum">     298 </span><span class="lineCov">          1 :     mEvictionState = EvictionState::EVICTION_NEEDED;</span>
<span class="lineNum">     299 </span><span class="lineCov">          1 :     result = EvictDataResult::NO_DATA_EVICTED;</span>
<span class="lineNum">     300 </span>            :   }
<span class="lineNum">     301 </span><span class="lineCov">          1 :   MSE_DEBUG(</span>
<span class="lineNum">     302 </span>            :     &quot;Reached our size limit, schedule eviction of %&quot; PRId64 &quot; bytes (%s)&quot;, toEvict,
<span class="lineNum">     303 </span>            :     result == EvictDataResult::BUFFER_FULL ? &quot;buffer full&quot; : &quot;no data evicted&quot;);
<span class="lineNum">     304 </span><span class="lineCov">          1 :   QueueTask(new EvictDataTask(aPlaybackTime, toEvict));</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">     307 </span>            : }
<a name="308"><span class="lineNum">     308 </span>            : </a>
<span class="lineNum">     309 </span>            : TimeIntervals
<span class="lineNum">     310 </span><span class="lineCov">          1 : TrackBuffersManager::Buffered() const</span>
<span class="lineNum">     311 </span>            : {
<span class="lineNum">     312 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;&quot;);</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :   // http://w3c.github.io/media-source/index.html#widl-SourceBuffer-buffered
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">     317 </span>            :   nsTArray&lt;const TimeIntervals*&gt; tracks;
<span class="lineNum">     318 </span><span class="lineCov">          1 :   if (HasVideo()) {</span>
<span class="lineNum">     319 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mVideoBufferedRanges);</span>
<span class="lineNum">     320 </span>            :   }
<span class="lineNum">     321 </span><span class="lineCov">          1 :   if (HasAudio()) {</span>
<span class="lineNum">     322 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mAudioBufferedRanges);</span>
<span class="lineNum">     323 </span>            :   }
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :   // 2. Let highest end time be the largest track buffer ranges end time across all the track buffers managed by this SourceBuffer object.
<span class="lineNum">     326 </span><span class="lineCov">          1 :   TimeUnit highestEndTime = HighestEndTime(tracks);</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :   // 3. Let intersection ranges equal a TimeRange object containing a single range from 0 to highest end time.
<span class="lineNum">     329 </span><span class="lineCov">          1 :   TimeIntervals intersection{TimeInterval(TimeUnit::FromSeconds(0), highestEndTime)};</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :   // 4. For each track buffer managed by this SourceBuffer, run the following steps:
<span class="lineNum">     332 </span>            :   //   1. Let track ranges equal the track buffer ranges for the current track buffer.
<span class="lineNum">     333 </span><span class="lineCov">          1 :   for (const TimeIntervals* trackRanges : tracks) {</span>
<span class="lineNum">     334 </span>            :     // 2. If readyState is &quot;ended&quot;, then set the end time on the last range in track ranges to highest end time.
<span class="lineNum">     335 </span>            :     // 3. Let new intersection ranges equal the intersection between the intersection ranges and the track ranges.
<span class="lineNum">     336 </span><span class="lineCov">          1 :     if (mEnded) {</span>
<span class="lineNum">     337 </span><span class="lineCov">          1 :       TimeIntervals tR = *trackRanges;</span>
<span class="lineNum">     338 </span><span class="lineCov">          1 :       tR.Add(TimeInterval(tR.GetEnd(), highestEndTime));</span>
<span class="lineNum">     339 </span><span class="lineCov">          1 :       intersection.Intersection(tR);</span>
<span class="lineNum">     340 </span>            :     } else {
<span class="lineNum">     341 </span><span class="lineCov">          1 :       intersection.Intersection(*trackRanges);</span>
<span class="lineNum">     342 </span>            :     }
<span class="lineNum">     343 </span>            :   }
<span class="lineNum">     344 </span><span class="lineCov">          1 :   return intersection;</span>
<span class="lineNum">     345 </span>            : }
<a name="346"><span class="lineNum">     346 </span>            : </a>
<span class="lineNum">     347 </span>            : int64_t
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : TrackBuffersManager::GetSize() const</span>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span><span class="lineCov">          1 :   return mSizeSourceBuffer;</span>
<span class="lineNum">     351 </span>            : }
<a name="352"><span class="lineNum">     352 </span>            : </a>
<span class="lineNum">     353 </span>            : void
<span class="lineNum">     354 </span><span class="lineCov">          1 : TrackBuffersManager::Ended()</span>
<span class="lineNum">     355 </span>            : {
<span class="lineNum">     356 </span><span class="lineCov">          1 :   mEnded = true;</span>
<span class="lineNum">     357 </span><span class="lineCov">          1 : }</span>
<a name="358"><span class="lineNum">     358 </span>            : </a>
<span class="lineNum">     359 </span>            : void
<span class="lineNum">     360 </span><span class="lineCov">          1 : TrackBuffersManager::Detach()</span>
<span class="lineNum">     361 </span>            : {
<span class="lineNum">     362 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     363 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;&quot;);</span>
<span class="lineNum">     364 </span><span class="lineCov">          1 :   QueueTask(new DetachTask());</span>
<span class="lineNum">     365 </span><span class="lineCov">          1 : }</span>
<a name="366"><span class="lineNum">     366 </span>            : </a>
<span class="lineNum">     367 </span>            : void
<span class="lineNum">     368 </span><span class="lineCov">          1 : TrackBuffersManager::CompleteResetParserState()</span>
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     371 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;&quot;);</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :   // We shouldn't change mInputDemuxer while a demuxer init/reset request is
<span class="lineNum">     374 </span>            :   // being processed. See bug 1239983.
<span class="lineNum">     375 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(!mDemuxerInitRequest.Exists(), &quot;Previous AppendBuffer didn't complete&quot;);</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span><span class="lineCov">          1 :   for (auto&amp; track : GetTracksList()) {</span>
<span class="lineNum">     378 </span>            :     // 2. Unset the last decode timestamp on all track buffers.
<span class="lineNum">     379 </span>            :     // 3. Unset the last frame duration on all track buffers.
<span class="lineNum">     380 </span>            :     // 4. Unset the highest end timestamp on all track buffers.
<span class="lineNum">     381 </span>            :     // 5. Set the need random access point flag on all track buffers to true.
<span class="lineNum">     382 </span><span class="lineCov">          1 :     track-&gt;ResetAppendState();</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :     // if we have been aborted, we may have pending frames that we are going
<span class="lineNum">     385 </span>            :     // to discard now.
<span class="lineNum">     386 </span><span class="lineCov">          1 :     track-&gt;mQueuedSamples.Clear();</span>
<span class="lineNum">     387 </span>            :   }
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   // 7. Remove all bytes from the input buffer.
<span class="lineNum">     390 </span><span class="lineCov">          1 :   mInputBuffer = nullptr;</span>
<span class="lineNum">     391 </span><span class="lineCov">          1 :   if (mCurrentInputBuffer) {</span>
<span class="lineNum">     392 </span><span class="lineCov">          1 :     mCurrentInputBuffer-&gt;EvictAll();</span>
<span class="lineNum">     393 </span>            :     // The demuxer will be recreated during the next run of SegmentParserLoop.
<span class="lineNum">     394 </span>            :     // As such we don't need to notify it that data has been removed.
<span class="lineNum">     395 </span><span class="lineCov">          1 :     mCurrentInputBuffer = new SourceBufferResource(mType);</span>
<span class="lineNum">     396 </span>            :   }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   // We could be left with a demuxer in an unusable state. It needs to be
<span class="lineNum">     399 </span>            :   // recreated. We store in the InputBuffer an init segment which will be parsed
<span class="lineNum">     400 </span>            :   // during the next Segment Parser Loop and a new demuxer will be created and
<span class="lineNum">     401 </span>            :   // initialized.
<span class="lineNum">     402 </span><span class="lineCov">          1 :   if (mFirstInitializationSegmentReceived) {</span>
<span class="lineNum">     403 </span>            :     MOZ_ASSERT(mInitData &amp;&amp; mInitData-&gt;Length(), &quot;we must have an init segment&quot;);
<span class="lineNum">     404 </span>            :     // The aim here is really to destroy our current demuxer.
<span class="lineNum">     405 </span><span class="lineCov">          1 :     CreateDemuxerforMIMEType();</span>
<span class="lineNum">     406 </span>            :     // Recreate our input buffer. We can't directly assign the initData buffer
<span class="lineNum">     407 </span>            :     // to mInputBuffer as it will get modified in the Segment Parser Loop.
<span class="lineNum">     408 </span><span class="lineCov">          1 :     mInputBuffer = new MediaByteBuffer;</span>
<span class="lineNum">     409 </span><span class="lineCov">          1 :     mInputBuffer-&gt;AppendElements(*mInitData);</span>
<span class="lineNum">     410 </span>            :   }
<span class="lineNum">     411 </span><span class="lineCov">          1 :   RecreateParser(true);</span>
<span class="lineNum">     412 </span><span class="lineCov">          1 : }</span>
<a name="413"><span class="lineNum">     413 </span>            : </a>
<span class="lineNum">     414 </span>            : int64_t
<span class="lineNum">     415 </span><span class="lineCov">          1 : TrackBuffersManager::EvictionThreshold() const</span>
<span class="lineNum">     416 </span>            : {
<span class="lineNum">     417 </span><span class="lineCov">          1 :   if (HasVideo()) {</span>
<span class="lineNum">     418 </span><span class="lineCov">          1 :     return mVideoEvictionThreshold;</span>
<span class="lineNum">     419 </span>            :   }
<span class="lineNum">     420 </span><span class="lineCov">          1 :   return mAudioEvictionThreshold;</span>
<span class="lineNum">     421 </span>            : }
<a name="422"><span class="lineNum">     422 </span>            : </a>
<span class="lineNum">     423 </span>            : void
<span class="lineNum">     424 </span><span class="lineCov">          1 : TrackBuffersManager::DoEvictData(const TimeUnit&amp; aPlaybackTime,</span>
<span class="lineNum">     425 </span>            :                                  int64_t aSizeToEvict)
<span class="lineNum">     426 </span>            : {
<span class="lineNum">     427 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineCov">          1 :   mEvictionState = EvictionState::EVICTION_COMPLETED;</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   // Video is what takes the most space, only evict there if we have video.
<span class="lineNum">     432 </span><span class="lineCov">          1 :   auto&amp; track = HasVideo() ? mVideoTracks : mAudioTracks;</span>
<span class="lineNum">     433 </span><span class="lineCov">          1 :   const auto&amp; buffer = track.GetTrackBuffer();</span>
<span class="lineNum">     434 </span>            :   // Remove any data we've already played, or before the next sample to be
<span class="lineNum">     435 </span>            :   // demuxed whichever is lowest.
<span class="lineNum">     436 </span><span class="lineCov">          1 :   TimeUnit lowerLimit = std::min(track.mNextSampleTime, aPlaybackTime);</span>
<span class="lineNum">     437 </span><span class="lineCov">          1 :   uint32_t lastKeyFrameIndex = 0;</span>
<span class="lineNum">     438 </span><span class="lineCov">          1 :   int64_t toEvict = aSizeToEvict;</span>
<span class="lineNum">     439 </span><span class="lineCov">          1 :   int64_t partialEvict = 0;</span>
<span class="lineNum">     440 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; buffer.Length(); i++) {</span>
<span class="lineNum">     441 </span><span class="lineCov">          1 :     const auto&amp; frame = buffer[i];</span>
<span class="lineNum">     442 </span><span class="lineCov">          1 :     if (frame-&gt;mKeyframe) {</span>
<span class="lineNum">     443 </span><span class="lineCov">          1 :       lastKeyFrameIndex = i;</span>
<span class="lineNum">     444 </span><span class="lineCov">          1 :       toEvict -= partialEvict;</span>
<span class="lineNum">     445 </span><span class="lineCov">          1 :       if (toEvict &lt; 0) {</span>
<span class="lineNum">     446 </span>            :         break;
<span class="lineNum">     447 </span>            :       }
<span class="lineNum">     448 </span>            :       partialEvict = 0;
<span class="lineNum">     449 </span>            :     }
<span class="lineNum">     450 </span><span class="lineCov">          1 :     if (frame-&gt;GetEndTime() &gt;= lowerLimit) {</span>
<span class="lineNum">     451 </span>            :       break;
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span><span class="lineCov">          1 :     partialEvict += frame-&gt;ComputedSizeOfIncludingThis();</span>
<span class="lineNum">     454 </span>            :   }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineCov">          1 :   const int64_t finalSize = mSizeSourceBuffer - aSizeToEvict;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">          1 :   if (lastKeyFrameIndex &gt; 0) {</span>
<span class="lineNum">     459 </span><span class="lineCov">          1 :     MSE_DEBUG(&quot;Step1. Evicting %&quot; PRId64 &quot; bytes prior currentTime&quot;,</span>
<span class="lineNum">     460 </span>            :               aSizeToEvict - toEvict);
<span class="lineNum">     461 </span>            :     CodedFrameRemoval(
<span class="lineNum">     462 </span>            :       TimeInterval(TimeUnit::FromMicroseconds(0),
<span class="lineNum">     463 </span><span class="lineCov">          1 :                    TimeUnit::FromMicroseconds(buffer[lastKeyFrameIndex]-&gt;mTime - 1)));</span>
<span class="lineNum">     464 </span>            :   }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineCov">          1 :   if (mSizeSourceBuffer &lt;= finalSize) {</span>
<span class="lineNum">     467 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     468 </span>            :   }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">          1 :   toEvict = mSizeSourceBuffer - finalSize;</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :   // See if we can evict data into the future.
<span class="lineNum">     473 </span>            :   // We do not evict data from the currently used buffered interval.
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineCov">          1 :   TimeUnit currentPosition = std::max(aPlaybackTime, track.mNextSampleTime);</span>
<span class="lineNum">     476 </span><span class="lineCov">          1 :   TimeIntervals futureBuffered(TimeInterval(currentPosition, TimeUnit::FromInfinity()));</span>
<span class="lineNum">     477 </span><span class="lineCov">          1 :   futureBuffered.Intersection(track.mBufferedRanges);</span>
<span class="lineNum">     478 </span><span class="lineCov">          1 :   futureBuffered.SetFuzz(MediaSourceDemuxer::EOS_FUZZ / 2);</span>
<span class="lineNum">     479 </span><span class="lineCov">          1 :   if (futureBuffered.Length() &lt;= 1) {</span>
<span class="lineNum">     480 </span>            :     // We have one continuous segment ahead of us:
<span class="lineNum">     481 </span>            :     // nothing further can be evicted.
<span class="lineNum">     482 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     483 </span>            :   }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :   // Don't evict before the end of the current segment
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   TimeUnit upperLimit = futureBuffered[0].mEnd;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   uint32_t evictedFramesStartIndex = buffer.Length();</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   for (int32_t i = buffer.Length() - 1; i &gt;= 0; i--) {</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     const auto&amp; frame = buffer[i];</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     if (frame-&gt;mTime &lt;= upperLimit.ToMicroseconds() || toEvict &lt; 0) {</span>
<span class="lineNum">     491 </span>            :       // We've reached a frame that shouldn't be evicted -&gt; Evict after it -&gt; i+1.
<span class="lineNum">     492 </span>            :       // Or the previous loop reached the eviction threshold -&gt; Evict from it -&gt; i+1.
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       evictedFramesStartIndex = i + 1;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     495 </span>            :     }
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     toEvict -= frame-&gt;ComputedSizeOfIncludingThis();</span>
<span class="lineNum">     497 </span>            :   }
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   if (evictedFramesStartIndex &lt; buffer.Length()) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     MSE_DEBUG(&quot;Step2. Evicting %&quot; PRId64 &quot; bytes from trailing data&quot;,</span>
<span class="lineNum">     500 </span>            :               mSizeSourceBuffer - finalSize - toEvict);
<span class="lineNum">     501 </span>            :     CodedFrameRemoval(
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       TimeInterval(TimeUnit::FromMicroseconds(buffer[evictedFramesStartIndex]-&gt;mTime),</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                    TimeUnit::FromInfinity()));</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     505 </span>            : }
<a name="506"><span class="lineNum">     506 </span>            : </a>
<span class="lineNum">     507 </span>            : RefPtr&lt;TrackBuffersManager::RangeRemovalPromise&gt;
<span class="lineNum">     508 </span><span class="lineCov">          1 : TrackBuffersManager::CodedFrameRemovalWithPromise(TimeInterval aInterval)</span>
<span class="lineNum">     509 </span>            : {
<span class="lineNum">     510 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineCov">          1 :   RefPtr&lt;RangeRemovalTask&gt; task = new RangeRemovalTask(aInterval);</span>
<span class="lineNum">     513 </span><span class="lineCov">          1 :   RefPtr&lt;RangeRemovalPromise&gt; p = task-&gt;mPromise.Ensure(__func__);</span>
<span class="lineNum">     514 </span><span class="lineCov">          1 :   QueueTask(task);</span>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineCov">          1 :   return p;</span>
<span class="lineNum">     517 </span>            : }
<a name="518"><span class="lineNum">     518 </span>            : </a>
<span class="lineNum">     519 </span>            : bool
<span class="lineNum">     520 </span><span class="lineCov">          1 : TrackBuffersManager::CodedFrameRemoval(TimeInterval aInterval)</span>
<span class="lineNum">     521 </span>            : {
<span class="lineNum">     522 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     523 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;From %.2fs to %.2f&quot;,</span>
<span class="lineNum">     524 </span>            :             aInterval.mStart.ToSeconds(), aInterval.mEnd.ToSeconds());
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : #if DEBUG
<span class="lineNum">     527 </span>            :   if (HasVideo()) {
<span class="lineNum">     528 </span>            :     MSE_DEBUG(&quot;before video ranges=%s&quot;,
<span class="lineNum">     529 </span>            :               DumpTimeRanges(mVideoTracks.mBufferedRanges).get());
<span class="lineNum">     530 </span>            :   }
<span class="lineNum">     531 </span>            :   if (HasAudio()) {
<span class="lineNum">     532 </span>            :     MSE_DEBUG(&quot;before audio ranges=%s&quot;,
<span class="lineNum">     533 </span>            :               DumpTimeRanges(mAudioTracks.mBufferedRanges).get());
<span class="lineNum">     534 </span>            :   }
<span class="lineNum">     535 </span>            : #endif
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :   // 1. Let start be the starting presentation timestamp for the removal range.
<span class="lineNum">     538 </span><span class="lineCov">          1 :   TimeUnit start = aInterval.mStart;</span>
<span class="lineNum">     539 </span>            :   // 2. Let end be the end presentation timestamp for the removal range.
<span class="lineNum">     540 </span><span class="lineCov">          1 :   TimeUnit end = aInterval.mEnd;</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineCov">          1 :   bool dataRemoved = false;</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :   // 3. For each track buffer in this source buffer, run the following steps:
<span class="lineNum">     545 </span><span class="lineCov">          1 :   for (auto track : GetTracksList()) {</span>
<span class="lineNum">     546 </span><span class="lineCov">          1 :     MSE_DEBUGV(&quot;Processing %s track&quot;, track-&gt;mInfo-&gt;mMimeType.get());</span>
<span class="lineNum">     547 </span>            :     // 1. Let remove end timestamp be the current value of duration
<span class="lineNum">     548 </span>            :     // See bug: https://www.w3.org/Bugs/Public/show_bug.cgi?id=28727
<span class="lineNum">     549 </span>            :     // At worse we will remove all frames until the end, unless a key frame is
<span class="lineNum">     550 </span>            :     // found between the current interval's end and the trackbuffer's end.
<span class="lineNum">     551 </span><span class="lineCov">          1 :     TimeUnit removeEndTimestamp = track-&gt;mBufferedRanges.GetEnd();</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov">          1 :     if (start &gt; removeEndTimestamp) {</span>
<span class="lineNum">     554 </span>            :       // Nothing to remove.
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     556 </span>            :     }
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :     // 2. If this track buffer has a random access point timestamp that is greater than or equal to end,
<span class="lineNum">     559 </span>            :     // then update remove end timestamp to that random access point timestamp.
<span class="lineNum">     560 </span><span class="lineCov">          1 :     if (end &lt; track-&gt;mBufferedRanges.GetEnd()) {</span>
<span class="lineNum">     561 </span><span class="lineCov">          1 :       for (auto&amp; frame : track-&gt;GetTrackBuffer()) {</span>
<span class="lineNum">     562 </span><span class="lineCov">          1 :         if (frame-&gt;mKeyframe &amp;&amp; frame-&gt;mTime &gt;= end.ToMicroseconds()) {</span>
<span class="lineNum">     563 </span><span class="lineCov">          1 :           removeEndTimestamp = TimeUnit::FromMicroseconds(frame-&gt;mTime);</span>
<span class="lineNum">     564 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">     565 </span>            :         }
<span class="lineNum">     566 </span>            :       }
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :     // 3. Remove all media data, from this track buffer, that contain starting
<span class="lineNum">     570 </span>            :     // timestamps greater than or equal to start and less than the remove end timestamp.
<span class="lineNum">     571 </span>            :     // 4. Remove decoding dependencies of the coded frames removed in the previous step:
<span class="lineNum">     572 </span>            :     // Remove all coded frames between the coded frames removed in the previous step and the next random access point after those removed frames.
<span class="lineNum">     573 </span><span class="lineCov">          1 :     TimeIntervals removedInterval{TimeInterval(start, removeEndTimestamp)};</span>
<span class="lineNum">     574 </span><span class="lineCov">          1 :     RemoveFrames(removedInterval, *track, 0);</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :     // 5. If this object is in activeSourceBuffers, the current playback position
<span class="lineNum">     577 </span>            :     // is greater than or equal to start and less than the remove end timestamp,
<span class="lineNum">     578 </span>            :     // and HTMLMediaElement.readyState is greater than HAVE_METADATA, then set the
<span class="lineNum">     579 </span>            :     // HTMLMediaElement.readyState attribute to HAVE_METADATA and stall playback.
<span class="lineNum">     580 </span>            :     // This will be done by the MDSM during playback.
<span class="lineNum">     581 </span>            :     // TODO properly, so it works even if paused.
<span class="lineNum">     582 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov">          1 :   UpdateBufferedRanges();</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :   // Update our reported total size.
<span class="lineNum">     587 </span><span class="lineCov">          1 :   mSizeSourceBuffer = mVideoTracks.mSizeBuffer + mAudioTracks.mSizeBuffer;</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            :   // 4. If buffer full flag equals true and this object is ready to accept more bytes, then set the buffer full flag to false.
<span class="lineNum">     590 </span><span class="lineCov">          1 :   if (mBufferFull &amp;&amp; mSizeSourceBuffer &lt; EvictionThreshold()) {</span>
<span class="lineNum">     591 </span><span class="lineCov">          1 :     mBufferFull = false;</span>
<span class="lineNum">     592 </span>            :   }
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">          1 :   return dataRemoved;</span>
<span class="lineNum">     595 </span>            : }
<a name="596"><span class="lineNum">     596 </span>            : </a>
<span class="lineNum">     597 </span>            : void
<span class="lineNum">     598 </span><span class="lineCov">          1 : TrackBuffersManager::UpdateBufferedRanges()</span>
<span class="lineNum">     599 </span>            : {
<span class="lineNum">     600 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineCov">          1 :   mVideoBufferedRanges = mVideoTracks.mSanitizedBufferedRanges;</span>
<span class="lineNum">     603 </span><span class="lineCov">          1 :   mAudioBufferedRanges = mAudioTracks.mSanitizedBufferedRanges;</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : #if DEBUG
<span class="lineNum">     606 </span>            :   if (HasVideo()) {
<span class="lineNum">     607 </span>            :     MSE_DEBUG(&quot;after video ranges=%s&quot;,
<span class="lineNum">     608 </span>            :               DumpTimeRanges(mVideoTracks.mBufferedRanges).get());
<span class="lineNum">     609 </span>            :   }
<span class="lineNum">     610 </span>            :   if (HasAudio()) {
<span class="lineNum">     611 </span>            :     MSE_DEBUG(&quot;after audio ranges=%s&quot;,
<span class="lineNum">     612 </span>            :               DumpTimeRanges(mAudioTracks.mBufferedRanges).get());
<span class="lineNum">     613 </span>            :   }
<span class="lineNum">     614 </span>            : #endif
<span class="lineNum">     615 </span><span class="lineCov">          1 : }</span>
<a name="616"><span class="lineNum">     616 </span>            : </a>
<span class="lineNum">     617 </span>            : void
<span class="lineNum">     618 </span><span class="lineCov">          1 : TrackBuffersManager::SegmentParserLoop()</span>
<span class="lineNum">     619 </span>            : {
<span class="lineNum">     620 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :   while (true) {
<span class="lineNum">     623 </span>            :     // 1. If the input buffer is empty, then jump to the need more data step below.
<span class="lineNum">     624 </span><span class="lineCov">          1 :     if (!mInputBuffer || mInputBuffer-&gt;IsEmpty()) {</span>
<span class="lineNum">     625 </span><span class="lineCov">          1 :       NeedMoreData();</span>
<span class="lineNum">     626 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            :     // 2. If the input buffer contains bytes that violate the SourceBuffer
<span class="lineNum">     629 </span>            :     // byte stream format specification, then run the append error algorithm with
<span class="lineNum">     630 </span>            :     // the decode error parameter set to true and abort this algorithm.
<span class="lineNum">     631 </span>            :     // TODO
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :     // 3. Remove any bytes that the byte stream format specifications say must be
<span class="lineNum">     634 </span>            :     // ignored from the start of the input buffer.
<span class="lineNum">     635 </span>            :     // We do not remove bytes from our input buffer. Instead we enforce that
<span class="lineNum">     636 </span>            :     // our ContainerParser is able to skip over all data that is supposed to be
<span class="lineNum">     637 </span>            :     // ignored.
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :     // 4. If the append state equals WAITING_FOR_SEGMENT, then run the following
<span class="lineNum">     640 </span>            :     // steps:
<span class="lineNum">     641 </span><span class="lineCov">          1 :     if (mSourceBufferAttributes-&gt;GetAppendState() == AppendState::WAITING_FOR_SEGMENT) {</span>
<span class="lineNum">     642 </span><span class="lineCov">          1 :       MediaResult haveInitSegment = mParser-&gt;IsInitSegmentPresent(mInputBuffer);</span>
<span class="lineNum">     643 </span><span class="lineCov">          1 :       if (NS_SUCCEEDED(haveInitSegment)) {</span>
<span class="lineNum">     644 </span><span class="lineCov">          1 :         SetAppendState(AppendState::PARSING_INIT_SEGMENT);</span>
<span class="lineNum">     645 </span><span class="lineCov">          1 :         if (mFirstInitializationSegmentReceived) {</span>
<span class="lineNum">     646 </span>            :           // This is a new initialization segment. Obsolete the old one.
<span class="lineNum">     647 </span><span class="lineCov">          1 :           RecreateParser(false);</span>
<span class="lineNum">     648 </span>            :         }
<span class="lineNum">     649 </span>            :         continue;
<span class="lineNum">     650 </span>            :       }
<span class="lineNum">     651 </span>            :       MediaResult haveMediaSegment =
<span class="lineNum">     652 </span><span class="lineCov">          1 :         mParser-&gt;IsMediaSegmentPresent(mInputBuffer);</span>
<span class="lineNum">     653 </span><span class="lineCov">          1 :       if (NS_SUCCEEDED(haveMediaSegment)) {</span>
<span class="lineNum">     654 </span><span class="lineCov">          1 :         SetAppendState(AppendState::PARSING_MEDIA_SEGMENT);</span>
<span class="lineNum">     655 </span><span class="lineCov">          1 :         mNewMediaSegmentStarted = true;</span>
<span class="lineNum">     656 </span>            :         continue;
<span class="lineNum">     657 </span>            :       }
<span class="lineNum">     658 </span>            :       // We have neither an init segment nor a media segment.
<span class="lineNum">     659 </span>            :       // Check if it was invalid data.
<span class="lineNum">     660 </span><span class="lineCov">          1 :       if (haveInitSegment != NS_ERROR_NOT_AVAILABLE) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         MSE_DEBUG(&quot;Found invalid data.&quot;);</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         RejectAppend(haveInitSegment, __func__);</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     664 </span>            :       }
<span class="lineNum">     665 </span><span class="lineCov">          1 :       if (haveMediaSegment != NS_ERROR_NOT_AVAILABLE) {</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :         MSE_DEBUG(&quot;Found invalid data.&quot;);</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :         RejectAppend(haveMediaSegment, __func__);</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     669 </span>            :       }
<span class="lineNum">     670 </span><span class="lineCov">          1 :       MSE_DEBUG(&quot;Found incomplete data.&quot;);</span>
<span class="lineNum">     671 </span><span class="lineCov">          1 :       NeedMoreData();</span>
<span class="lineNum">     672 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :     int64_t start, end;
<span class="lineNum">     676 </span>            :     MediaResult newData =
<span class="lineNum">     677 </span><span class="lineCov">          1 :       mParser-&gt;ParseStartAndEndTimestamps(mInputBuffer, start, end);</span>
<span class="lineNum">     678 </span><span class="lineCov">          1 :     if (!NS_SUCCEEDED(newData) &amp;&amp; newData.Code() != NS_ERROR_NOT_AVAILABLE) {</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :       RejectAppend(newData, __func__);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     681 </span>            :     }
<span class="lineNum">     682 </span><span class="lineCov">          1 :     mProcessedInput += mInputBuffer-&gt;Length();</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :     // 5. If the append state equals PARSING_INIT_SEGMENT, then run the
<span class="lineNum">     685 </span>            :     // following steps:
<span class="lineNum">     686 </span><span class="lineCov">          1 :     if (mSourceBufferAttributes-&gt;GetAppendState() == AppendState::PARSING_INIT_SEGMENT) {</span>
<span class="lineNum">     687 </span><span class="lineCov">          1 :       if (mParser-&gt;InitSegmentRange().IsEmpty()) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         mInputBuffer = nullptr;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         NeedMoreData();</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     691 </span>            :       }
<span class="lineNum">     692 </span><span class="lineCov">          1 :       InitializationSegmentReceived();</span>
<span class="lineNum">     693 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     694 </span>            :     }
<span class="lineNum">     695 </span><span class="lineCov">          1 :     if (mSourceBufferAttributes-&gt;GetAppendState() == AppendState::PARSING_MEDIA_SEGMENT) {</span>
<span class="lineNum">     696 </span>            :       // 1. If the first initialization segment received flag is false, then run the append error algorithm with the decode error parameter set to true and abort this algorithm.
<span class="lineNum">     697 </span><span class="lineCov">          1 :       if (!mFirstInitializationSegmentReceived) {</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         RejectAppend(NS_ERROR_FAILURE, __func__);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     700 </span>            :       }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :       // We can't feed some demuxers (WebMDemuxer) with data that do not have
<span class="lineNum">     703 </span>            :       // monotonizally increasing timestamps. So we check if we have a
<span class="lineNum">     704 </span>            :       // discontinuity from the previous segment parsed.
<span class="lineNum">     705 </span>            :       // If so, recreate a new demuxer to ensure that the demuxer is only fed
<span class="lineNum">     706 </span>            :       // monotonically increasing data.
<span class="lineNum">     707 </span><span class="lineCov">          1 :       if (mNewMediaSegmentStarted) {</span>
<span class="lineNum">     708 </span><span class="lineCov">          1 :         if (NS_SUCCEEDED(newData) &amp;&amp; mLastParsedEndTime.isSome() &amp;&amp;</span>
<span class="lineNum">     709 </span><span class="lineCov">          1 :             start &lt; mLastParsedEndTime.ref().ToMicroseconds()) {</span>
<span class="lineNum">     710 </span><span class="lineCov">          1 :           MSE_DEBUG(&quot;Re-creating demuxer&quot;);</span>
<span class="lineNum">     711 </span><span class="lineCov">          1 :           ResetDemuxingState();</span>
<span class="lineNum">     712 </span><span class="lineCov">          1 :           return;</span>
<span class="lineNum">     713 </span>            :         }
<span class="lineNum">     714 </span><span class="lineCov">          1 :         if (NS_SUCCEEDED(newData) || !mParser-&gt;MediaSegmentRange().IsEmpty()) {</span>
<span class="lineNum">     715 </span><span class="lineCov">          1 :           if (mPendingInputBuffer) {</span>
<span class="lineNum">     716 </span>            :             // We now have a complete media segment header. We can resume parsing
<span class="lineNum">     717 </span>            :             // the data.
<span class="lineNum">     718 </span><span class="lineCov">          1 :             AppendDataToCurrentInputBuffer(mPendingInputBuffer);</span>
<span class="lineNum">     719 </span><span class="lineCov">          1 :             mPendingInputBuffer = nullptr;</span>
<span class="lineNum">     720 </span>            :           }
<span class="lineNum">     721 </span><span class="lineCov">          1 :           mNewMediaSegmentStarted = false;</span>
<span class="lineNum">     722 </span>            :         } else {
<span class="lineNum">     723 </span>            :           // We don't have any data to demux yet, stash aside the data.
<span class="lineNum">     724 </span>            :           // This also handles the case:
<span class="lineNum">     725 </span>            :           // 2. If the input buffer does not contain a complete media segment header yet, then jump to the need more data step below.
<span class="lineNum">     726 </span><span class="lineCov">          1 :           if (!mPendingInputBuffer) {</span>
<span class="lineNum">     727 </span><span class="lineCov">          1 :             mPendingInputBuffer = mInputBuffer;</span>
<span class="lineNum">     728 </span>            :           } else {
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :             mPendingInputBuffer-&gt;AppendElements(*mInputBuffer);</span>
<span class="lineNum">     730 </span>            :           }
<span class="lineNum">     731 </span><span class="lineCov">          1 :           mInputBuffer = nullptr;</span>
<span class="lineNum">     732 </span><span class="lineCov">          1 :           NeedMoreData();</span>
<span class="lineNum">     733 </span><span class="lineCov">          1 :           return;</span>
<span class="lineNum">     734 </span>            :         }
<span class="lineNum">     735 </span>            :       }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :       // 3. If the input buffer contains one or more complete coded frames, then run the coded frame processing algorithm.
<span class="lineNum">     738 </span><span class="lineCov">          1 :       RefPtr&lt;TrackBuffersManager&gt; self = this;</span>
<a name="739"><span class="lineNum">     739 </span>            :       CodedFrameProcessing()</a>
<span class="lineNum">     740 </span>            :         -&gt;Then(GetTaskQueue(), __func__,
<span class="lineNum">     741 </span><span class="lineCov">          1 :                [self] (bool aNeedMoreData) {</span>
<span class="lineNum">     742 </span><span class="lineCov">          1 :                  self-&gt;mProcessingRequest.Complete();</span>
<span class="lineNum">     743 </span><span class="lineCov">          1 :                  if (aNeedMoreData) {</span>
<span class="lineNum">     744 </span><span class="lineCov">          1 :                    self-&gt;NeedMoreData();</span>
<span class="lineNum">     745 </span>            :                  } else {
<span class="lineNum">     746 </span><span class="lineCov">          1 :                    self-&gt;ScheduleSegmentParserLoop();</span>
<a name="747"><span class="lineNum">     747 </span>            :                  }</a>
<span class="lineNum">     748 </span><span class="lineCov">          1 :                },</span>
<span class="lineNum">     749 </span><span class="lineCov">          1 :                [self] (const MediaResult&amp; aRejectValue) {</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :                  self-&gt;mProcessingRequest.Complete();</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :                  self-&gt;RejectAppend(aRejectValue, __func__);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :                })</span>
<span class="lineNum">     753 </span><span class="lineCov">          1 :         -&gt;Track(mProcessingRequest);</span>
<span class="lineNum">     754 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     755 </span>            :     }
<span class="lineNum">     756 </span>            :   }
<span class="lineNum">     757 </span>            : }
<a name="758"><span class="lineNum">     758 </span>            : </a>
<span class="lineNum">     759 </span>            : void
<span class="lineNum">     760 </span><span class="lineCov">          1 : TrackBuffersManager::NeedMoreData()</span>
<span class="lineNum">     761 </span>            : {
<span class="lineNum">     762 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;&quot;);</span>
<span class="lineNum">     763 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(mCurrentTask &amp;&amp; mCurrentTask-&gt;GetType() == SourceBufferTask::Type::AppendBuffer);</span>
<span class="lineNum">     764 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(mSourceBufferAttributes);</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineCov">          1 :   mCurrentTask-&gt;As&lt;AppendBufferTask&gt;()-&gt;mPromise.Resolve(</span>
<span class="lineNum">     767 </span>            :     SourceBufferTask::AppendBufferResult(mActiveTrack,
<span class="lineNum">     768 </span><span class="lineCov">          1 :                                          *mSourceBufferAttributes),</span>
<span class="lineNum">     769 </span><span class="lineCov">          1 :                                          __func__);</span>
<span class="lineNum">     770 </span><span class="lineCov">          1 :   mSourceBufferAttributes = nullptr;</span>
<span class="lineNum">     771 </span><span class="lineCov">          1 :   mCurrentTask = nullptr;</span>
<span class="lineNum">     772 </span><span class="lineCov">          1 :   ProcessTasks();</span>
<span class="lineNum">     773 </span><span class="lineCov">          1 : }</span>
<a name="774"><span class="lineNum">     774 </span>            : </a>
<span class="lineNum">     775 </span>            : void
<span class="lineNum">     776 </span><span class="lineNoCov">          0 : TrackBuffersManager::RejectAppend(const MediaResult&amp; aRejectValue, const char* aName)</span>
<span class="lineNum">     777 </span>            : {
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   MSE_DEBUG(&quot;rv=%&quot; PRIu32, static_cast&lt;uint32_t&gt;(aRejectValue.Code()));</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   MOZ_DIAGNOSTIC_ASSERT(mCurrentTask &amp;&amp; mCurrentTask-&gt;GetType() == SourceBufferTask::Type::AppendBuffer);</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   mCurrentTask-&gt;As&lt;AppendBufferTask&gt;()-&gt;mPromise.Reject(aRejectValue, __func__);</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :   mSourceBufferAttributes = nullptr;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   mCurrentTask = nullptr;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   ProcessTasks();</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 : }</span>
<a name="786"><span class="lineNum">     786 </span>            : </a>
<span class="lineNum">     787 </span>            : void
<span class="lineNum">     788 </span><span class="lineCov">          1 : TrackBuffersManager::ScheduleSegmentParserLoop()</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineCov">          1 :   GetTaskQueue()-&gt;Dispatch(NewRunnableMethod(this, &amp;TrackBuffersManager::SegmentParserLoop));</span>
<span class="lineNum">     791 </span><span class="lineCov">          1 : }</span>
<a name="792"><span class="lineNum">     792 </span>            : </a>
<span class="lineNum">     793 </span>            : void
<span class="lineNum">     794 </span><span class="lineCov">          1 : TrackBuffersManager::ShutdownDemuxers()</span>
<span class="lineNum">     795 </span>            : {
<span class="lineNum">     796 </span><span class="lineCov">          1 :   if (mVideoTracks.mDemuxer) {</span>
<span class="lineNum">     797 </span><span class="lineCov">          1 :     mVideoTracks.mDemuxer-&gt;BreakCycles();</span>
<span class="lineNum">     798 </span><span class="lineCov">          1 :     mVideoTracks.mDemuxer = nullptr;</span>
<span class="lineNum">     799 </span>            :   }
<span class="lineNum">     800 </span><span class="lineCov">          1 :   if (mAudioTracks.mDemuxer) {</span>
<span class="lineNum">     801 </span><span class="lineCov">          1 :     mAudioTracks.mDemuxer-&gt;BreakCycles();</span>
<span class="lineNum">     802 </span><span class="lineCov">          1 :     mAudioTracks.mDemuxer = nullptr;</span>
<span class="lineNum">     803 </span>            :   }
<span class="lineNum">     804 </span>            :   // We shouldn't change mInputDemuxer while a demuxer init/reset request is
<span class="lineNum">     805 </span>            :   // being processed. See bug 1239983.
<span class="lineNum">     806 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(!mDemuxerInitRequest.Exists());</span>
<span class="lineNum">     807 </span><span class="lineCov">          1 :   mInputDemuxer = nullptr;</span>
<span class="lineNum">     808 </span><span class="lineCov">          1 :   mLastParsedEndTime.reset();</span>
<span class="lineNum">     809 </span><span class="lineCov">          1 : }</span>
<a name="810"><span class="lineNum">     810 </span>            : </a>
<span class="lineNum">     811 </span>            : void
<span class="lineNum">     812 </span><span class="lineCov">          1 : TrackBuffersManager::CreateDemuxerforMIMEType()</span>
<span class="lineNum">     813 </span>            : {
<span class="lineNum">     814 </span><span class="lineCov">          1 :   ShutdownDemuxers();</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineCov">          1 :   if (mType.Type() == MEDIAMIMETYPE(&quot;video/webm&quot;) ||</span>
<span class="lineNum">     817 </span><span class="lineCov">          1 :       mType.Type() == MEDIAMIMETYPE(&quot;audio/webm&quot;)) {</span>
<span class="lineNum">     818 </span><span class="lineCov">          1 :     mInputDemuxer = new WebMDemuxer(mCurrentInputBuffer, true /* IsMediaSource*/ );</span>
<span class="lineNum">     819 </span>            :     return;
<span class="lineNum">     820 </span>            :   }
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            : #ifdef MOZ_FMP4
<span class="lineNum">     823 </span><span class="lineCov">          1 :   if (mType.Type() == MEDIAMIMETYPE(&quot;video/mp4&quot;)</span>
<span class="lineNum">     824 </span><span class="lineCov">          1 :       || mType.Type() == MEDIAMIMETYPE(&quot;audio/mp4&quot;)) {</span>
<span class="lineNum">     825 </span><span class="lineCov">          1 :     mInputDemuxer = new MP4Demuxer(mCurrentInputBuffer);</span>
<span class="lineNum">     826 </span>            :     return;
<span class="lineNum">     827 </span>            :   }
<span class="lineNum">     828 </span>            : #endif
<span class="lineNum">     829 </span>            :   NS_WARNING(&quot;Not supported (yet)&quot;);
<span class="lineNum">     830 </span>            :   return;
<span class="lineNum">     831 </span>            : }
<span class="lineNum">     832 </span>            : 
<a name="833"><span class="lineNum">     833 </span>            : // We reset the demuxer by creating a new one and initializing it.</a>
<span class="lineNum">     834 </span>            : void
<span class="lineNum">     835 </span><span class="lineCov">          1 : TrackBuffersManager::ResetDemuxingState()</span>
<span class="lineNum">     836 </span>            : {
<span class="lineNum">     837 </span>            :   MOZ_ASSERT(mParser &amp;&amp; mParser-&gt;HasInitData());
<span class="lineNum">     838 </span><span class="lineCov">          1 :   RecreateParser(true);</span>
<span class="lineNum">     839 </span><span class="lineCov">          1 :   mCurrentInputBuffer = new SourceBufferResource(mType);</span>
<span class="lineNum">     840 </span>            :   // The demuxer isn't initialized yet ; we don't want to notify it
<span class="lineNum">     841 </span>            :   // that data has been appended yet ; so we simply append the init segment
<span class="lineNum">     842 </span>            :   // to the resource.
<span class="lineNum">     843 </span><span class="lineCov">          1 :   mCurrentInputBuffer-&gt;AppendData(mParser-&gt;InitData());</span>
<span class="lineNum">     844 </span><span class="lineCov">          1 :   CreateDemuxerforMIMEType();</span>
<span class="lineNum">     845 </span><span class="lineCov">          1 :   if (!mInputDemuxer) {</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     RejectAppend(NS_ERROR_FAILURE, __func__);</span>
<span class="lineNum">     847 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     848 </span>            :   }
<span class="lineNum">     849 </span><span class="lineCov">          1 :   mInputDemuxer-&gt;Init()</span>
<span class="lineNum">     850 </span>            :     -&gt;Then(GetTaskQueue(), __func__,
<span class="lineNum">     851 </span>            :            this,
<span class="lineNum">     852 </span>            :            &amp;TrackBuffersManager::OnDemuxerResetDone,
<span class="lineNum">     853 </span>            :            &amp;TrackBuffersManager::OnDemuxerInitFailed)
<span class="lineNum">     854 </span><span class="lineCov">          1 :     -&gt;Track(mDemuxerInitRequest);</span>
<span class="lineNum">     855 </span>            : }
<a name="856"><span class="lineNum">     856 </span>            : </a>
<span class="lineNum">     857 </span>            : void
<span class="lineNum">     858 </span><span class="lineCov">          1 : TrackBuffersManager::OnDemuxerResetDone(const MediaResult&amp; aResult)</span>
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     861 </span><span class="lineCov">          1 :   mDemuxerInitRequest.Complete();</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">          1 :   if (NS_FAILED(aResult) &amp;&amp; MediaPrefs::MediaWarningsAsErrors()) {</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     RejectAppend(aResult, __func__);</span>
<span class="lineNum">     865 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     866 </span>            :   }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :   // mInputDemuxer shouldn't have been destroyed while a demuxer init/reset
<span class="lineNum">     869 </span>            :   // request was being processed. See bug 1239983.
<span class="lineNum">     870 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(mInputDemuxer);</span>
<span class="lineNum">     871 </span>            : 
<a name="872"><span class="lineNum">     872 </span><span class="lineCov">          1 :   if (aResult != NS_OK &amp;&amp; mParentDecoder) {</span></a>
<span class="lineNum">     873 </span><span class="lineCov">          1 :     RefPtr&lt;TrackBuffersManager&gt; self = this;</span>
<span class="lineNum">     874 </span><span class="lineCov">          1 :     mAbstractMainThread-&gt;Dispatch(NS_NewRunnableFunction([self, aResult] () {</span>
<span class="lineNum">     875 </span><span class="lineCov">          1 :       if (self-&gt;mParentDecoder &amp;&amp; self-&gt;mParentDecoder-&gt;GetOwner()) {</span>
<span class="lineNum">     876 </span><span class="lineCov">          1 :         self-&gt;mParentDecoder-&gt;GetOwner()-&gt;DecodeWarning(aResult);</span>
<span class="lineNum">     877 </span>            :       }
<span class="lineNum">     878 </span><span class="lineCov">          1 :     }));</span>
<span class="lineNum">     879 </span>            :   }
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :   // Recreate track demuxers.
<span class="lineNum">     882 </span><span class="lineCov">          1 :   uint32_t numVideos = mInputDemuxer-&gt;GetNumberTracks(TrackInfo::kVideoTrack);</span>
<span class="lineNum">     883 </span><span class="lineCov">          1 :   if (numVideos) {</span>
<span class="lineNum">     884 </span>            :     // We currently only handle the first video track.
<span class="lineNum">     885 </span><span class="lineCov">          1 :     mVideoTracks.mDemuxer =</span>
<span class="lineNum">     886 </span><span class="lineCov">          1 :       mInputDemuxer-&gt;GetTrackDemuxer(TrackInfo::kVideoTrack, 0);</span>
<span class="lineNum">     887 </span>            :     MOZ_ASSERT(mVideoTracks.mDemuxer);
<span class="lineNum">     888 </span>            :   }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">          1 :   uint32_t numAudios = mInputDemuxer-&gt;GetNumberTracks(TrackInfo::kAudioTrack);</span>
<span class="lineNum">     891 </span><span class="lineCov">          1 :   if (numAudios) {</span>
<span class="lineNum">     892 </span>            :     // We currently only handle the first audio track.
<span class="lineNum">     893 </span><span class="lineCov">          1 :     mAudioTracks.mDemuxer =</span>
<span class="lineNum">     894 </span><span class="lineCov">          1 :       mInputDemuxer-&gt;GetTrackDemuxer(TrackInfo::kAudioTrack, 0);</span>
<span class="lineNum">     895 </span>            :     MOZ_ASSERT(mAudioTracks.mDemuxer);
<span class="lineNum">     896 </span>            :   }
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">          1 :   if (mPendingInputBuffer) {</span>
<span class="lineNum">     899 </span>            :     // We had a partial media segment header stashed aside.
<span class="lineNum">     900 </span>            :     // Reparse its content so we can continue parsing the current input buffer.
<span class="lineNum">     901 </span>            :     int64_t start, end;
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     mParser-&gt;ParseStartAndEndTimestamps(mPendingInputBuffer, start, end);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     mProcessedInput += mPendingInputBuffer-&gt;Length();</span>
<span class="lineNum">     904 </span>            :   }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineCov">          1 :   SegmentParserLoop();</span>
<span class="lineNum">     907 </span>            : }
<a name="908"><span class="lineNum">     908 </span>            : </a>
<span class="lineNum">     909 </span>            : void
<span class="lineNum">     910 </span><span class="lineCov">          1 : TrackBuffersManager::AppendDataToCurrentInputBuffer(MediaByteBuffer* aData)</span>
<span class="lineNum">     911 </span>            : {
<span class="lineNum">     912 </span>            :   MOZ_ASSERT(mCurrentInputBuffer);
<span class="lineNum">     913 </span><span class="lineCov">          1 :   mCurrentInputBuffer-&gt;AppendData(aData);</span>
<span class="lineNum">     914 </span><span class="lineCov">          1 :   mInputDemuxer-&gt;NotifyDataArrived();</span>
<span class="lineNum">     915 </span><span class="lineCov">          1 : }</span>
<a name="916"><span class="lineNum">     916 </span>            : </a>
<span class="lineNum">     917 </span>            : void
<span class="lineNum">     918 </span><span class="lineCov">          1 : TrackBuffersManager::InitializationSegmentReceived()</span>
<span class="lineNum">     919 </span>            : {
<span class="lineNum">     920 </span>            :   MOZ_ASSERT(mParser-&gt;HasCompleteInitData());
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineCov">          1 :   int64_t endInit = mParser-&gt;InitSegmentRange().mEnd;</span>
<span class="lineNum">     923 </span><span class="lineCov">          1 :   if (mInputBuffer-&gt;Length() &gt; mProcessedInput ||</span>
<span class="lineNum">     924 </span><span class="lineCov">          1 :       int64_t(mProcessedInput - mInputBuffer-&gt;Length()) &gt; endInit) {</span>
<span class="lineNum">     925 </span>            :     // Something is not quite right with the data appended. Refuse it.
<span class="lineNum">     926 </span>            :     RejectAppend(MediaResult(NS_ERROR_FAILURE,
<span class="lineNum">     927 </span>            :                              &quot;Invalid state following initialization segment&quot;),
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :                  __func__);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     930 </span>            :   }
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineCov">          1 :   mCurrentInputBuffer = new SourceBufferResource(mType);</span>
<span class="lineNum">     933 </span>            :   // The demuxer isn't initialized yet ; we don't want to notify it
<span class="lineNum">     934 </span>            :   // that data has been appended yet ; so we simply append the init segment
<span class="lineNum">     935 </span>            :   // to the resource.
<span class="lineNum">     936 </span><span class="lineCov">          1 :   mCurrentInputBuffer-&gt;AppendData(mParser-&gt;InitData());</span>
<span class="lineNum">     937 </span><span class="lineCov">          1 :   uint32_t length = endInit - (mProcessedInput - mInputBuffer-&gt;Length());</span>
<span class="lineNum">     938 </span><span class="lineCov">          1 :   if (mInputBuffer-&gt;Length() == length) {</span>
<span class="lineNum">     939 </span><span class="lineCov">          1 :     mInputBuffer = nullptr;</span>
<span class="lineNum">     940 </span>            :   } else {
<span class="lineNum">     941 </span><span class="lineCov">          1 :     MOZ_RELEASE_ASSERT(length &lt;= mInputBuffer-&gt;Length());</span>
<span class="lineNum">     942 </span><span class="lineCov">          1 :     mInputBuffer-&gt;RemoveElementsAt(0, length);</span>
<span class="lineNum">     943 </span>            :   }
<span class="lineNum">     944 </span><span class="lineCov">          1 :   CreateDemuxerforMIMEType();</span>
<span class="lineNum">     945 </span><span class="lineCov">          1 :   if (!mInputDemuxer) {</span>
<span class="lineNum">     946 </span>            :     NS_WARNING(&quot;TODO type not supported&quot;);
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     RejectAppend(NS_ERROR_DOM_NOT_SUPPORTED_ERR, __func__);</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     949 </span>            :   }
<span class="lineNum">     950 </span><span class="lineCov">          1 :   mInputDemuxer-&gt;Init()</span>
<span class="lineNum">     951 </span>            :     -&gt;Then(GetTaskQueue(), __func__,
<span class="lineNum">     952 </span>            :            this,
<span class="lineNum">     953 </span>            :            &amp;TrackBuffersManager::OnDemuxerInitDone,
<span class="lineNum">     954 </span>            :            &amp;TrackBuffersManager::OnDemuxerInitFailed)
<span class="lineNum">     955 </span><span class="lineCov">          1 :     -&gt;Track(mDemuxerInitRequest);</span>
<span class="lineNum">     956 </span>            : }
<a name="957"><span class="lineNum">     957 </span>            : </a>
<span class="lineNum">     958 </span>            : void
<span class="lineNum">     959 </span><span class="lineCov">          1 : TrackBuffersManager::OnDemuxerInitDone(const MediaResult&amp; aResult)</span>
<span class="lineNum">     960 </span>            : {
<span class="lineNum">     961 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">     962 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(mInputDemuxer, &quot;mInputDemuxer has been destroyed&quot;);</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span><span class="lineCov">          1 :   mDemuxerInitRequest.Complete();</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineCov">          1 :   if (NS_FAILED(aResult) &amp;&amp; MediaPrefs::MediaWarningsAsErrors()) {</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     RejectAppend(aResult, __func__);</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     969 </span>            :   }
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span><span class="lineCov">          1 :   MediaInfo info;</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span><span class="lineCov">          1 :   uint32_t numVideos = mInputDemuxer-&gt;GetNumberTracks(TrackInfo::kVideoTrack);</span>
<span class="lineNum">     974 </span><span class="lineCov">          1 :   if (numVideos) {</span>
<span class="lineNum">     975 </span>            :     // We currently only handle the first video track.
<span class="lineNum">     976 </span><span class="lineCov">          1 :     mVideoTracks.mDemuxer =</span>
<span class="lineNum">     977 </span><span class="lineCov">          1 :       mInputDemuxer-&gt;GetTrackDemuxer(TrackInfo::kVideoTrack, 0);</span>
<span class="lineNum">     978 </span>            :     MOZ_ASSERT(mVideoTracks.mDemuxer);
<span class="lineNum">     979 </span><span class="lineCov">          1 :     info.mVideo = *mVideoTracks.mDemuxer-&gt;GetInfo()-&gt;GetAsVideoInfo();</span>
<span class="lineNum">     980 </span><span class="lineCov">          1 :     info.mVideo.mTrackId = 2;</span>
<span class="lineNum">     981 </span>            :   }
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineCov">          1 :   uint32_t numAudios = mInputDemuxer-&gt;GetNumberTracks(TrackInfo::kAudioTrack);</span>
<span class="lineNum">     984 </span><span class="lineCov">          1 :   if (numAudios) {</span>
<span class="lineNum">     985 </span>            :     // We currently only handle the first audio track.
<span class="lineNum">     986 </span><span class="lineCov">          1 :     mAudioTracks.mDemuxer =</span>
<span class="lineNum">     987 </span><span class="lineCov">          1 :       mInputDemuxer-&gt;GetTrackDemuxer(TrackInfo::kAudioTrack, 0);</span>
<span class="lineNum">     988 </span>            :     MOZ_ASSERT(mAudioTracks.mDemuxer);
<span class="lineNum">     989 </span><span class="lineCov">          1 :     info.mAudio = *mAudioTracks.mDemuxer-&gt;GetInfo()-&gt;GetAsAudioInfo();</span>
<span class="lineNum">     990 </span><span class="lineCov">          1 :     info.mAudio.mTrackId = 1;</span>
<span class="lineNum">     991 </span>            :   }
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineCov">          1 :   int64_t videoDuration = numVideos ? info.mVideo.mDuration.ToMicroseconds() : 0;</span>
<span class="lineNum">     994 </span><span class="lineCov">          1 :   int64_t audioDuration = numAudios ? info.mAudio.mDuration.ToMicroseconds() : 0;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">          1 :   int64_t duration = std::max(videoDuration, audioDuration);</span>
<span class="lineNum">     997 </span>            :   // 1. Update the duration attribute if it currently equals NaN.
<span class="lineNum">     998 </span>            :   // Those steps are performed by the MediaSourceDecoder::SetInitialDuration
<span class="lineNum">     999 </span><span class="lineCov">          1 :   mAbstractMainThread-&gt;Dispatch(NewRunnableMethod&lt;int64_t&gt;</span>
<span class="lineNum">    1000 </span><span class="lineCov">          1 :                                 (mParentDecoder.get(),</span>
<span class="lineNum">    1001 </span>            :                                 &amp;MediaSourceDecoder::SetInitialDuration,
<span class="lineNum">    1002 </span><span class="lineCov">          1 :                                 duration ? duration : -1));</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :   // 2. If the initialization segment has no audio, video, or text tracks, then
<span class="lineNum">    1005 </span>            :   // run the append error algorithm with the decode error parameter set to true
<span class="lineNum">    1006 </span>            :   // and abort these steps.
<span class="lineNum">    1007 </span><span class="lineCov">          1 :   if (!numVideos &amp;&amp; !numAudios) {</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     RejectAppend(NS_ERROR_FAILURE, __func__);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1010 </span>            :   }
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            :   // 3. If the first initialization segment received flag is true, then run the following steps:
<span class="lineNum">    1013 </span><span class="lineCov">          1 :   if (mFirstInitializationSegmentReceived) {</span>
<span class="lineNum">    1014 </span><span class="lineCov">          1 :     if (numVideos != mVideoTracks.mNumTracks ||</span>
<span class="lineNum">    1015 </span><span class="lineCov">          1 :         numAudios != mAudioTracks.mNumTracks ||</span>
<span class="lineNum">    1016 </span><span class="lineCov">          1 :         (numVideos &amp;&amp; info.mVideo.mMimeType != mVideoTracks.mInfo-&gt;mMimeType) ||</span>
<span class="lineNum">    1017 </span><span class="lineCov">          1 :         (numAudios &amp;&amp; info.mAudio.mMimeType != mAudioTracks.mInfo-&gt;mMimeType)) {</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :       RejectAppend(NS_ERROR_FAILURE, __func__);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1020 </span>            :     }
<span class="lineNum">    1021 </span>            :     // 1. If more than one track for a single type are present (ie 2 audio tracks),
<span class="lineNum">    1022 </span>            :     // then the Track IDs match the ones in the first initialization segment.
<span class="lineNum">    1023 </span>            :     // TODO
<span class="lineNum">    1024 </span>            :     // 2. Add the appropriate track descriptions from this initialization
<span class="lineNum">    1025 </span>            :     // segment to each of the track buffers.
<span class="lineNum">    1026 </span>            :     // TODO
<span class="lineNum">    1027 </span>            :     // 3. Set the need random access point flag on all track buffers to true.
<span class="lineNum">    1028 </span><span class="lineCov">          1 :     mVideoTracks.mNeedRandomAccessPoint = true;</span>
<span class="lineNum">    1029 </span><span class="lineCov">          1 :     mAudioTracks.mNeedRandomAccessPoint = true;</span>
<span class="lineNum">    1030 </span>            :   }
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            :   // 4. Let active track flag equal false.
<span class="lineNum">    1033 </span><span class="lineCov">          1 :   bool activeTrack = false;</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :   // Increase our stream id.
<span class="lineNum">    1036 </span><span class="lineCov">          1 :   uint32_t streamID = sStreamSourceID++;</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :   // 5. If the first initialization segment received flag is false, then run the following steps:
<span class="lineNum">    1039 </span><span class="lineCov">          1 :   if (!mFirstInitializationSegmentReceived) {</span>
<span class="lineNum">    1040 </span><span class="lineCov">          1 :     mAudioTracks.mNumTracks = numAudios;</span>
<span class="lineNum">    1041 </span>            :     // TODO:
<span class="lineNum">    1042 </span>            :     // 1. If the initialization segment contains tracks with codecs the user agent
<span class="lineNum">    1043 </span>            :     // does not support, then run the append error algorithm with the decode
<span class="lineNum">    1044 </span>            :     // error parameter set to true and abort these steps.
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            :     // 2. For each audio track in the initialization segment, run following steps:
<span class="lineNum">    1047 </span>            :     // for (uint32_t i = 0; i &lt; numAudios; i++) {
<span class="lineNum">    1048 </span><span class="lineCov">          1 :     if (numAudios) {</span>
<span class="lineNum">    1049 </span>            :       // 1. Let audio byte stream track ID be the Track ID for the current track being processed.
<span class="lineNum">    1050 </span>            :       // 2. Let audio language be a BCP 47 language tag for the language specified in the initialization segment for this track or an empty string if no language info is present.
<span class="lineNum">    1051 </span>            :       // 3. If audio language equals an empty string or the 'und' BCP 47 value, then run the default track language algorithm with byteStreamTrackID set to audio byte stream track ID and type set to &quot;audio&quot; and assign the value returned by the algorithm to audio language.
<span class="lineNum">    1052 </span>            :       // 4. Let audio label be a label specified in the initialization segment for this track or an empty string if no label info is present.
<span class="lineNum">    1053 </span>            :       // 5. If audio label equals an empty string, then run the default track label algorithm with byteStreamTrackID set to audio byte stream track ID and type set to &quot;audio&quot; and assign the value returned by the algorithm to audio label.
<span class="lineNum">    1054 </span>            :       // 6. Let audio kinds be an array of kind strings specified in the initialization segment for this track or an empty array if no kind information is provided.
<span class="lineNum">    1055 </span>            :       // 7. If audio kinds equals an empty array, then run the default track kinds algorithm with byteStreamTrackID set to audio byte stream track ID and type set to &quot;audio&quot; and assign the value returned by the algorithm to audio kinds.
<span class="lineNum">    1056 </span>            :       // 8. For each value in audio kinds, run the following steps:
<span class="lineNum">    1057 </span>            :       //   1. Let current audio kind equal the value from audio kinds for this iteration of the loop.
<span class="lineNum">    1058 </span>            :       //   2. Let new audio track be a new AudioTrack object.
<span class="lineNum">    1059 </span>            :       //   3. Generate a unique ID and assign it to the id property on new audio track.
<span class="lineNum">    1060 </span>            :       //   4. Assign audio language to the language property on new audio track.
<span class="lineNum">    1061 </span>            :       //   5. Assign audio label to the label property on new audio track.
<span class="lineNum">    1062 </span>            :       //   6. Assign current audio kind to the kind property on new audio track.
<span class="lineNum">    1063 </span>            :       //   7. If audioTracks.length equals 0, then run the following steps:
<span class="lineNum">    1064 </span>            :       //     1. Set the enabled property on new audio track to true.
<span class="lineNum">    1065 </span>            :       //     2. Set active track flag to true.
<span class="lineNum">    1066 </span><span class="lineCov">          1 :       activeTrack = true;</span>
<span class="lineNum">    1067 </span>            :       //   8. Add new audio track to the audioTracks attribute on this SourceBuffer object.
<span class="lineNum">    1068 </span>            :       //   9. Queue a task to fire a trusted event named addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent interface, at the AudioTrackList object referenced by the audioTracks attribute on this SourceBuffer object.
<span class="lineNum">    1069 </span>            :       //   10. Add new audio track to the audioTracks attribute on the HTMLMediaElement.
<span class="lineNum">    1070 </span>            :       //   11. Queue a task to fire a trusted event named addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent interface, at the AudioTrackList object referenced by the audioTracks attribute on the HTMLMediaElement.
<span class="lineNum">    1071 </span><span class="lineCov">          1 :       mAudioTracks.mBuffers.AppendElement(TrackBuffer());</span>
<span class="lineNum">    1072 </span>            :       // 10. Add the track description for this track to the track buffer.
<span class="lineNum">    1073 </span><span class="lineCov">          1 :       mAudioTracks.mInfo = new TrackInfoSharedPtr(info.mAudio, streamID);</span>
<span class="lineNum">    1074 </span><span class="lineCov">          1 :       mAudioTracks.mLastInfo = mAudioTracks.mInfo;</span>
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineCov">          1 :     mVideoTracks.mNumTracks = numVideos;</span>
<span class="lineNum">    1078 </span>            :     // 3. For each video track in the initialization segment, run following steps:
<span class="lineNum">    1079 </span>            :     // for (uint32_t i = 0; i &lt; numVideos; i++) {
<span class="lineNum">    1080 </span><span class="lineCov">          1 :     if (numVideos) {</span>
<span class="lineNum">    1081 </span>            :       // 1. Let video byte stream track ID be the Track ID for the current track being processed.
<span class="lineNum">    1082 </span>            :       // 2. Let video language be a BCP 47 language tag for the language specified in the initialization segment for this track or an empty string if no language info is present.
<span class="lineNum">    1083 </span>            :       // 3. If video language equals an empty string or the 'und' BCP 47 value, then run the default track language algorithm with byteStreamTrackID set to video byte stream track ID and type set to &quot;video&quot; and assign the value returned by the algorithm to video language.
<span class="lineNum">    1084 </span>            :       // 4. Let video label be a label specified in the initialization segment for this track or an empty string if no label info is present.
<span class="lineNum">    1085 </span>            :       // 5. If video label equals an empty string, then run the default track label algorithm with byteStreamTrackID set to video byte stream track ID and type set to &quot;video&quot; and assign the value returned by the algorithm to video label.
<span class="lineNum">    1086 </span>            :       // 6. Let video kinds be an array of kind strings specified in the initialization segment for this track or an empty array if no kind information is provided.
<span class="lineNum">    1087 </span>            :       // 7. If video kinds equals an empty array, then run the default track kinds algorithm with byteStreamTrackID set to video byte stream track ID and type set to &quot;video&quot; and assign the value returned by the algorithm to video kinds.
<span class="lineNum">    1088 </span>            :       // 8. For each value in video kinds, run the following steps:
<span class="lineNum">    1089 </span>            :       //   1. Let current video kind equal the value from video kinds for this iteration of the loop.
<span class="lineNum">    1090 </span>            :       //   2. Let new video track be a new VideoTrack object.
<span class="lineNum">    1091 </span>            :       //   3. Generate a unique ID and assign it to the id property on new video track.
<span class="lineNum">    1092 </span>            :       //   4. Assign video language to the language property on new video track.
<span class="lineNum">    1093 </span>            :       //   5. Assign video label to the label property on new video track.
<span class="lineNum">    1094 </span>            :       //   6. Assign current video kind to the kind property on new video track.
<span class="lineNum">    1095 </span>            :       //   7. If videoTracks.length equals 0, then run the following steps:
<span class="lineNum">    1096 </span>            :       //     1. Set the selected property on new video track to true.
<span class="lineNum">    1097 </span>            :       //     2. Set active track flag to true.
<span class="lineNum">    1098 </span><span class="lineCov">          1 :       activeTrack = true;</span>
<span class="lineNum">    1099 </span>            :       //   8. Add new video track to the videoTracks attribute on this SourceBuffer object.
<span class="lineNum">    1100 </span>            :       //   9. Queue a task to fire a trusted event named addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent interface, at the VideoTrackList object referenced by the videoTracks attribute on this SourceBuffer object.
<span class="lineNum">    1101 </span>            :       //   10. Add new video track to the videoTracks attribute on the HTMLMediaElement.
<span class="lineNum">    1102 </span>            :       //   11. Queue a task to fire a trusted event named addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent interface, at the VideoTrackList object referenced by the videoTracks attribute on the HTMLMediaElement.
<span class="lineNum">    1103 </span><span class="lineCov">          1 :       mVideoTracks.mBuffers.AppendElement(TrackBuffer());</span>
<span class="lineNum">    1104 </span>            :       // 10. Add the track description for this track to the track buffer.
<span class="lineNum">    1105 </span><span class="lineCov">          1 :       mVideoTracks.mInfo = new TrackInfoSharedPtr(info.mVideo, streamID);</span>
<span class="lineNum">    1106 </span><span class="lineCov">          1 :       mVideoTracks.mLastInfo = mVideoTracks.mInfo;</span>
<span class="lineNum">    1107 </span>            :     }
<span class="lineNum">    1108 </span>            :     // 4. For each text track in the initialization segment, run following steps:
<span class="lineNum">    1109 </span>            :     // 5. If active track flag equals true, then run the following steps:
<span class="lineNum">    1110 </span>            :     // This is handled by SourceBuffer once the promise is resolved.
<span class="lineNum">    1111 </span><span class="lineCov">          1 :     if (activeTrack) {</span>
<span class="lineNum">    1112 </span><span class="lineCov">          1 :       mActiveTrack = true;</span>
<span class="lineNum">    1113 </span>            :     }
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :     // 6. Set first initialization segment received flag to true.
<span class="lineNum">    1116 </span><span class="lineCov">          1 :     mFirstInitializationSegmentReceived = true;</span>
<span class="lineNum">    1117 </span>            :   } else {
<span class="lineNum">    1118 </span><span class="lineCov">          1 :     mAudioTracks.mLastInfo = new TrackInfoSharedPtr(info.mAudio, streamID);</span>
<span class="lineNum">    1119 </span><span class="lineCov">          1 :     mVideoTracks.mLastInfo = new TrackInfoSharedPtr(info.mVideo, streamID);</span>
<span class="lineNum">    1120 </span>            :   }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineCov">          1 :   UniquePtr&lt;EncryptionInfo&gt; crypto = mInputDemuxer-&gt;GetCrypto();</span>
<span class="lineNum">    1123 </span><span class="lineCov">          1 :   if (crypto &amp;&amp; crypto-&gt;IsEncrypted()) {</span>
<span class="lineNum">    1124 </span>            :     // Try and dispatch 'encrypted'. Won't go if ready state still HAVE_NOTHING.
<span class="lineNum">    1125 </span><span class="lineCov">          1 :     for (uint32_t i = 0; i &lt; crypto-&gt;mInitDatas.Length(); i++) {</span>
<span class="lineNum">    1126 </span>            :       nsCOMPtr&lt;nsIRunnable&gt; r =
<span class="lineNum">    1127 </span><span class="lineCov">          1 :         new DispatchKeyNeededEvent(mParentDecoder, crypto-&gt;mInitDatas[i].mInitData,</span>
<span class="lineNum">    1128 </span><span class="lineCov">          1 :                                    crypto-&gt;mInitDatas[i].mType);</span>
<span class="lineNum">    1129 </span><span class="lineCov">          1 :       mAbstractMainThread-&gt;Dispatch(r.forget());</span>
<span class="lineNum">    1130 </span>            :     }
<span class="lineNum">    1131 </span><span class="lineCov">          1 :     info.mCrypto = *crypto;</span>
<span class="lineNum">    1132 </span>            :     // We clear our crypto init data array, so the MediaFormatReader will
<span class="lineNum">    1133 </span>            :     // not emit an encrypted event for the same init data again.
<span class="lineNum">    1134 </span><span class="lineCov">          1 :     info.mCrypto.mInitDatas.Clear();</span>
<span class="lineNum">    1135 </span>            :   }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :   {
<span class="lineNum">    1138 </span><span class="lineCov">          1 :     MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    1139 </span><span class="lineCov">          1 :     mInfo = info;</span>
<span class="lineNum">    1140 </span>            :   }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :   // We now have a valid init data ; we can store it for later use.
<span class="lineNum">    1143 </span><span class="lineCov">          1 :   mInitData = mParser-&gt;InitData();</span>
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span>            :   // 3. Remove the initialization segment bytes from the beginning of the input buffer.
<span class="lineNum">    1146 </span>            :   // This step has already been done in InitializationSegmentReceived when we
<span class="lineNum">    1147 </span>            :   // transferred the content into mCurrentInputBuffer.
<span class="lineNum">    1148 </span><span class="lineCov">          1 :   mCurrentInputBuffer-&gt;EvictAll();</span>
<span class="lineNum">    1149 </span><span class="lineCov">          1 :   mInputDemuxer-&gt;NotifyDataRemoved();</span>
<span class="lineNum">    1150 </span><span class="lineCov">          1 :   RecreateParser(true);</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :   // 4. Set append state to WAITING_FOR_SEGMENT.
<span class="lineNum">    1153 </span><span class="lineCov">          1 :   SetAppendState(AppendState::WAITING_FOR_SEGMENT);</span>
<span class="lineNum">    1154 </span>            :   // 5. Jump to the loop top step above.
<span class="lineNum">    1155 </span><span class="lineCov">          1 :   ScheduleSegmentParserLoop();</span>
<span class="lineNum">    1156 </span>            : 
<a name="1157"><span class="lineNum">    1157 </span><span class="lineCov">          1 :   if (aResult != NS_OK &amp;&amp; mParentDecoder) {</span></a>
<span class="lineNum">    1158 </span><span class="lineCov">          1 :     RefPtr&lt;TrackBuffersManager&gt; self = this;</span>
<span class="lineNum">    1159 </span><span class="lineCov">          1 :     mAbstractMainThread-&gt;Dispatch(NS_NewRunnableFunction([self, aResult] () {</span>
<span class="lineNum">    1160 </span><span class="lineCov">          1 :       if (self-&gt;mParentDecoder &amp;&amp; self-&gt;mParentDecoder-&gt;GetOwner()) {</span>
<span class="lineNum">    1161 </span><span class="lineCov">          1 :         self-&gt;mParentDecoder-&gt;GetOwner()-&gt;DecodeWarning(aResult);</span>
<span class="lineNum">    1162 </span>            :       }
<span class="lineNum">    1163 </span><span class="lineCov">          1 :     }));</span>
<span class="lineNum">    1164 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1165 </span>            : }
<a name="1166"><span class="lineNum">    1166 </span>            : </a>
<span class="lineNum">    1167 </span>            : void
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 : TrackBuffersManager::OnDemuxerInitFailed(const MediaResult&amp; aError)</span>
<span class="lineNum">    1169 </span>            : {
<span class="lineNum">    1170 </span>            :   MOZ_ASSERT(aError != NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA);
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :   mDemuxerInitRequest.Complete();</span>
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   RejectAppend(aError, __func__);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 : }</span>
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<span class="lineNum">    1176 </span>            : RefPtr&lt;TrackBuffersManager::CodedFrameProcessingPromise&gt;
<span class="lineNum">    1177 </span><span class="lineCov">          1 : TrackBuffersManager::CodedFrameProcessing()</span>
<span class="lineNum">    1178 </span>            : {
<span class="lineNum">    1179 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1180 </span>            :   MOZ_ASSERT(mProcessingPromise.IsEmpty());
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span><span class="lineCov">          1 :   MediaByteRange mediaRange = mParser-&gt;MediaSegmentRange();</span>
<span class="lineNum">    1183 </span><span class="lineCov">          1 :   if (mediaRange.IsEmpty()) {</span>
<span class="lineNum">    1184 </span><span class="lineCov">          1 :     AppendDataToCurrentInputBuffer(mInputBuffer);</span>
<span class="lineNum">    1185 </span><span class="lineCov">          1 :     mInputBuffer = nullptr;</span>
<span class="lineNum">    1186 </span>            :   } else {
<span class="lineNum">    1187 </span>            :     MOZ_ASSERT(mProcessedInput &gt;= mInputBuffer-&gt;Length());
<span class="lineNum">    1188 </span><span class="lineCov">          1 :     if (int64_t(mProcessedInput - mInputBuffer-&gt;Length()) &gt; mediaRange.mEnd) {</span>
<span class="lineNum">    1189 </span>            :       // Something is not quite right with the data appended. Refuse it.
<span class="lineNum">    1190 </span>            :       // This would typically happen if the previous media segment was partial
<span class="lineNum">    1191 </span>            :       // yet a new complete media segment was added.
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :       return CodedFrameProcessingPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);</span>
<span class="lineNum">    1193 </span>            :     }
<span class="lineNum">    1194 </span>            :     // The mediaRange is offset by the init segment position previously added.
<span class="lineNum">    1195 </span>            :     uint32_t length =
<span class="lineNum">    1196 </span><span class="lineCov">          1 :       mediaRange.mEnd - (mProcessedInput - mInputBuffer-&gt;Length());</span>
<span class="lineNum">    1197 </span><span class="lineCov">          1 :     if (!length) {</span>
<span class="lineNum">    1198 </span>            :       // We've completed our earlier media segment and no new data is to be
<span class="lineNum">    1199 </span>            :       // processed. This happens with some containers that can't detect that a
<span class="lineNum">    1200 </span>            :       // media segment is ending until a new one starts.
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :       RefPtr&lt;CodedFrameProcessingPromise&gt; p = mProcessingPromise.Ensure(__func__);</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :       CompleteCodedFrameProcessing();</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :       return p;</span>
<span class="lineNum">    1204 </span>            :     }
<span class="lineNum">    1205 </span><span class="lineCov">          1 :     RefPtr&lt;MediaByteBuffer&gt; segment = new MediaByteBuffer;</span>
<span class="lineNum">    1206 </span><span class="lineCov">          1 :     if (!segment-&gt;AppendElements(mInputBuffer-&gt;Elements(), length, fallible)) {</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :       return CodedFrameProcessingPromise::CreateAndReject(NS_ERROR_OUT_OF_MEMORY, __func__);</span>
<span class="lineNum">    1208 </span>            :     }
<span class="lineNum">    1209 </span><span class="lineCov">          1 :     AppendDataToCurrentInputBuffer(segment);</span>
<span class="lineNum">    1210 </span><span class="lineCov">          1 :     mInputBuffer-&gt;RemoveElementsAt(0, length);</span>
<span class="lineNum">    1211 </span>            :   }
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span><span class="lineCov">          1 :   RefPtr&lt;CodedFrameProcessingPromise&gt; p = mProcessingPromise.Ensure(__func__);</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineCov">          1 :   DoDemuxVideo();</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineCov">          1 :   return p;</span>
<span class="lineNum">    1218 </span>            : }
<a name="1219"><span class="lineNum">    1219 </span>            : </a>
<span class="lineNum">    1220 </span>            : void
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 : TrackBuffersManager::OnDemuxFailed(TrackType aTrack,</span>
<span class="lineNum">    1222 </span>            :                                    const MediaResult&amp; aError)
<span class="lineNum">    1223 </span>            : {
<span class="lineNum">    1224 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   MSE_DEBUG(&quot;Failed to demux %s, failure:%&quot; PRIu32,</span>
<span class="lineNum">    1226 </span>            :             aTrack == TrackType::kVideoTrack ? &quot;video&quot; : &quot;audio&quot;,
<span class="lineNum">    1227 </span>            :             static_cast&lt;uint32_t&gt;(aError.Code()));
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   switch (aError.Code()) {</span>
<span class="lineNum">    1229 </span>            :     case NS_ERROR_DOM_MEDIA_END_OF_STREAM:
<span class="lineNum">    1230 </span>            :     case NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA:
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :       if (aTrack == TrackType::kVideoTrack) {</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         DoDemuxAudio();</span>
<span class="lineNum">    1233 </span>            :       } else {
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :         CompleteCodedFrameProcessing();</span>
<span class="lineNum">    1235 </span>            :       }
<span class="lineNum">    1236 </span>            :       break;
<span class="lineNum">    1237 </span>            :     default:
<span class="lineNum">    1238 </span>            :       RejectProcessing(aError, __func__);
<span class="lineNum">    1239 </span>            :       break;
<span class="lineNum">    1240 </span>            :   }
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 : }</span>
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<span class="lineNum">    1243 </span>            : void
<span class="lineNum">    1244 </span><span class="lineCov">          1 : TrackBuffersManager::DoDemuxVideo()</span>
<span class="lineNum">    1245 </span>            : {
<span class="lineNum">    1246 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1247 </span><span class="lineCov">          1 :   if (!HasVideo()) {</span>
<span class="lineNum">    1248 </span><span class="lineCov">          1 :     DoDemuxAudio();</span>
<span class="lineNum">    1249 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1250 </span>            :   }
<span class="lineNum">    1251 </span><span class="lineCov">          1 :   mVideoTracks.mDemuxer-&gt;GetSamples(-1)</span>
<span class="lineNum">    1252 </span>            :     -&gt;Then(GetTaskQueue(), __func__, this,
<span class="lineNum">    1253 </span>            :            &amp;TrackBuffersManager::OnVideoDemuxCompleted,
<span class="lineNum">    1254 </span>            :            &amp;TrackBuffersManager::OnVideoDemuxFailed)
<span class="lineNum">    1255 </span><span class="lineCov">          1 :     -&gt;Track(mVideoTracks.mDemuxRequest);</span>
<span class="lineNum">    1256 </span>            : }
<a name="1257"><span class="lineNum">    1257 </span>            : </a>
<span class="lineNum">    1258 </span>            : void
<span class="lineNum">    1259 </span><span class="lineCov">          1 : TrackBuffersManager::OnVideoDemuxCompleted(RefPtr&lt;MediaTrackDemuxer::SamplesHolder&gt; aSamples)</span>
<span class="lineNum">    1260 </span>            : {
<span class="lineNum">    1261 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1262 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;%&quot; PRIuSIZE &quot; video samples demuxed&quot;, aSamples-&gt;mSamples.Length());</span>
<span class="lineNum">    1263 </span><span class="lineCov">          1 :   mVideoTracks.mDemuxRequest.Complete();</span>
<span class="lineNum">    1264 </span><span class="lineCov">          1 :   mVideoTracks.mQueuedSamples.AppendElements(aSamples-&gt;mSamples);</span>
<span class="lineNum">    1265 </span><span class="lineCov">          1 :   DoDemuxAudio();</span>
<span class="lineNum">    1266 </span><span class="lineCov">          1 : }</span>
<a name="1267"><span class="lineNum">    1267 </span>            : </a>
<span class="lineNum">    1268 </span>            : void
<span class="lineNum">    1269 </span><span class="lineCov">          1 : TrackBuffersManager::DoDemuxAudio()</span>
<span class="lineNum">    1270 </span>            : {
<span class="lineNum">    1271 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1272 </span><span class="lineCov">          1 :   if (!HasAudio()) {</span>
<span class="lineNum">    1273 </span><span class="lineCov">          1 :     CompleteCodedFrameProcessing();</span>
<span class="lineNum">    1274 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1275 </span>            :   }
<span class="lineNum">    1276 </span><span class="lineCov">          1 :   mAudioTracks.mDemuxer-&gt;GetSamples(-1)</span>
<span class="lineNum">    1277 </span>            :     -&gt;Then(GetTaskQueue(), __func__, this,
<span class="lineNum">    1278 </span>            :            &amp;TrackBuffersManager::OnAudioDemuxCompleted,
<span class="lineNum">    1279 </span>            :            &amp;TrackBuffersManager::OnAudioDemuxFailed)
<span class="lineNum">    1280 </span><span class="lineCov">          1 :     -&gt;Track(mAudioTracks.mDemuxRequest);</span>
<span class="lineNum">    1281 </span>            : }
<a name="1282"><span class="lineNum">    1282 </span>            : </a>
<span class="lineNum">    1283 </span>            : void
<span class="lineNum">    1284 </span><span class="lineCov">          1 : TrackBuffersManager::OnAudioDemuxCompleted(RefPtr&lt;MediaTrackDemuxer::SamplesHolder&gt; aSamples)</span>
<span class="lineNum">    1285 </span>            : {
<span class="lineNum">    1286 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1287 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;%&quot; PRIuSIZE &quot; audio samples demuxed&quot;, aSamples-&gt;mSamples.Length());</span>
<span class="lineNum">    1288 </span><span class="lineCov">          1 :   mAudioTracks.mDemuxRequest.Complete();</span>
<span class="lineNum">    1289 </span><span class="lineCov">          1 :   mAudioTracks.mQueuedSamples.AppendElements(aSamples-&gt;mSamples);</span>
<span class="lineNum">    1290 </span><span class="lineCov">          1 :   CompleteCodedFrameProcessing();</span>
<span class="lineNum">    1291 </span><span class="lineCov">          1 : }</span>
<a name="1292"><span class="lineNum">    1292 </span>            : </a>
<span class="lineNum">    1293 </span>            : void
<span class="lineNum">    1294 </span><span class="lineCov">          1 : TrackBuffersManager::CompleteCodedFrameProcessing()</span>
<span class="lineNum">    1295 </span>            : {
<span class="lineNum">    1296 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :   // 1. For each coded frame in the media segment run the following steps:
<span class="lineNum">    1299 </span>            :   // Coded Frame Processing steps 1.1 to 1.21.
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineCov">          1 :   if (mSourceBufferAttributes-&gt;GetAppendMode() == SourceBufferAppendMode::Sequence &amp;&amp;</span>
<span class="lineNum">    1302 </span><span class="lineCov">          1 :       mVideoTracks.mQueuedSamples.Length() &amp;&amp; mAudioTracks.mQueuedSamples.Length()) {</span>
<span class="lineNum">    1303 </span>            :     // When we are in sequence mode, the order in which we process the frames is
<span class="lineNum">    1304 </span>            :     // important as it determines the future value of timestampOffset.
<span class="lineNum">    1305 </span>            :     // So we process the earliest sample first. See bug 1293576.
<span class="lineNum">    1306 </span>            :     TimeInterval videoInterval =
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :       PresentationInterval(mVideoTracks.mQueuedSamples);</span>
<span class="lineNum">    1308 </span>            :     TimeInterval audioInterval =
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :       PresentationInterval(mAudioTracks.mQueuedSamples);</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :     if (audioInterval.mStart &lt; videoInterval.mStart) {</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :       ProcessFrames(mAudioTracks.mQueuedSamples, mAudioTracks);</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       ProcessFrames(mVideoTracks.mQueuedSamples, mVideoTracks);</span>
<span class="lineNum">    1313 </span>            :     } else {
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :       ProcessFrames(mVideoTracks.mQueuedSamples, mVideoTracks);</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       ProcessFrames(mAudioTracks.mQueuedSamples, mAudioTracks);</span>
<span class="lineNum">    1316 </span>            :     }
<span class="lineNum">    1317 </span>            :   } else {
<span class="lineNum">    1318 </span><span class="lineCov">          1 :     ProcessFrames(mVideoTracks.mQueuedSamples, mVideoTracks);</span>
<span class="lineNum">    1319 </span><span class="lineCov">          1 :     ProcessFrames(mAudioTracks.mQueuedSamples, mAudioTracks);</span>
<span class="lineNum">    1320 </span>            :   }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            : #if defined(DEBUG)
<span class="lineNum">    1323 </span>            :   if (HasVideo()) {
<span class="lineNum">    1324 </span>            :     const auto&amp; track = mVideoTracks.GetTrackBuffer();
<span class="lineNum">    1325 </span>            :     MOZ_ASSERT(track.IsEmpty() || track[0]-&gt;mKeyframe);
<span class="lineNum">    1326 </span>            :     for (uint32_t i = 1; i &lt; track.Length(); i++) {
<span class="lineNum">    1327 </span>            :       MOZ_ASSERT((track[i-1]-&gt;mTrackInfo-&gt;GetID() == track[i]-&gt;mTrackInfo-&gt;GetID() &amp;&amp; track[i-1]-&gt;mTimecode &lt;= track[i]-&gt;mTimecode) ||
<span class="lineNum">    1328 </span>            :                  track[i]-&gt;mKeyframe);
<span class="lineNum">    1329 </span>            :     }
<span class="lineNum">    1330 </span>            :   }
<span class="lineNum">    1331 </span>            :   if (HasAudio()) {
<span class="lineNum">    1332 </span>            :     const auto&amp; track = mAudioTracks.GetTrackBuffer();
<span class="lineNum">    1333 </span>            :     MOZ_ASSERT(track.IsEmpty() || track[0]-&gt;mKeyframe);
<span class="lineNum">    1334 </span>            :     for (uint32_t i = 1; i &lt; track.Length(); i++) {
<span class="lineNum">    1335 </span>            :       MOZ_ASSERT((track[i-1]-&gt;mTrackInfo-&gt;GetID() == track[i]-&gt;mTrackInfo-&gt;GetID() &amp;&amp; track[i-1]-&gt;mTimecode &lt;= track[i]-&gt;mTimecode) ||
<span class="lineNum">    1336 </span>            :                  track[i]-&gt;mKeyframe);
<span class="lineNum">    1337 </span>            :     }
<span class="lineNum">    1338 </span>            :   }
<span class="lineNum">    1339 </span>            : #endif
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineCov">          1 :   mVideoTracks.mQueuedSamples.Clear();</span>
<span class="lineNum">    1342 </span><span class="lineCov">          1 :   mAudioTracks.mQueuedSamples.Clear();</span>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span><span class="lineCov">          1 :   UpdateBufferedRanges();</span>
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :   // Update our reported total size.
<span class="lineNum">    1347 </span><span class="lineCov">          1 :   mSizeSourceBuffer = mVideoTracks.mSizeBuffer + mAudioTracks.mSizeBuffer;</span>
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :   // Return to step 6.4 of Segment Parser Loop algorithm
<span class="lineNum">    1350 </span>            :   // 4. If this SourceBuffer is full and cannot accept more media data, then set the buffer full flag to true.
<span class="lineNum">    1351 </span><span class="lineCov">          1 :   if (mSizeSourceBuffer &gt;= EvictionThreshold()) {</span>
<span class="lineNum">    1352 </span><span class="lineCov">          1 :     mBufferFull = true;</span>
<span class="lineNum">    1353 </span>            :   }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            :   // 5. If the input buffer does not contain a complete media segment, then jump to the need more data step below.
<span class="lineNum">    1356 </span><span class="lineCov">          1 :   if (mParser-&gt;MediaSegmentRange().IsEmpty()) {</span>
<span class="lineNum">    1357 </span>            :     ResolveProcessing(true, __func__);
<span class="lineNum">    1358 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1359 </span>            :   }
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineCov">          1 :   mLastParsedEndTime = Some(std::max(mAudioTracks.mLastParsedEndTime,</span>
<span class="lineNum">    1362 </span><span class="lineCov">          1 :                                      mVideoTracks.mLastParsedEndTime));</span>
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :   // 6. Remove the media segment bytes from the beginning of the input buffer.
<span class="lineNum">    1365 </span>            :   // Clear our demuxer from any already processed data.
<span class="lineNum">    1366 </span><span class="lineCov">          1 :   int64_t safeToEvict = std::min(HasVideo()</span>
<span class="lineNum">    1367 </span><span class="lineCov">          1 :                                  ? mVideoTracks.mDemuxer-&gt;GetEvictionOffset(</span>
<span class="lineNum">    1368 </span><span class="lineCov">          1 :                                      mVideoTracks.mLastParsedEndTime)</span>
<span class="lineNum">    1369 </span>            :                                  : INT64_MAX,
<span class="lineNum">    1370 </span><span class="lineCov">          1 :                                  HasAudio()</span>
<span class="lineNum">    1371 </span><span class="lineCov">          1 :                                  ? mAudioTracks.mDemuxer-&gt;GetEvictionOffset(</span>
<span class="lineNum">    1372 </span><span class="lineCov">          1 :                                      mAudioTracks.mLastParsedEndTime)</span>
<span class="lineNum">    1373 </span><span class="lineCov">          1 :                                  : INT64_MAX);</span>
<span class="lineNum">    1374 </span>            :   ErrorResult rv;
<span class="lineNum">    1375 </span><span class="lineCov">          1 :   mCurrentInputBuffer-&gt;EvictBefore(safeToEvict, rv);</span>
<span class="lineNum">    1376 </span><span class="lineCov">          1 :   if (rv.Failed()) {</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     rv.SuppressException();</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :     RejectProcessing(NS_ERROR_OUT_OF_MEMORY, __func__);</span>
<span class="lineNum">    1379 </span>            :     return;
<span class="lineNum">    1380 </span>            :   }
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span><span class="lineCov">          1 :   mInputDemuxer-&gt;NotifyDataRemoved();</span>
<span class="lineNum">    1383 </span><span class="lineCov">          1 :   RecreateParser(true);</span>
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            :   // 7. Set append state to WAITING_FOR_SEGMENT.
<span class="lineNum">    1386 </span><span class="lineCov">          1 :   SetAppendState(AppendState::WAITING_FOR_SEGMENT);</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            :   // 8. Jump to the loop top step above.
<span class="lineNum">    1389 </span>            :   ResolveProcessing(false, __func__);
<span class="lineNum">    1390 </span>            : }
<a name="1391"><span class="lineNum">    1391 </span>            : </a>
<span class="lineNum">    1392 </span>            : void
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 : TrackBuffersManager::RejectProcessing(const MediaResult&amp; aRejectValue, const char* aName)</span>
<span class="lineNum">    1394 </span>            : {
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :   mProcessingPromise.RejectIfExists(aRejectValue, __func__);</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 : }</span>
<a name="1397"><span class="lineNum">    1397 </span>            : </a>
<span class="lineNum">    1398 </span>            : void
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 : TrackBuffersManager::ResolveProcessing(bool aResolveValue, const char* aName)</span>
<span class="lineNum">    1400 </span>            : {
<span class="lineNum">    1401 </span><span class="lineCov">          1 :   mProcessingPromise.ResolveIfExists(aResolveValue, __func__);</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 : }</span>
<a name="1403"><span class="lineNum">    1403 </span>            : </a>
<span class="lineNum">    1404 </span>            : void
<span class="lineNum">    1405 </span><span class="lineCov">          1 : TrackBuffersManager::CheckSequenceDiscontinuity(const TimeUnit&amp; aPresentationTime)</span>
<span class="lineNum">    1406 </span>            : {
<span class="lineNum">    1407 </span><span class="lineCov">          1 :   if (mSourceBufferAttributes-&gt;GetAppendMode() == SourceBufferAppendMode::Sequence &amp;&amp;</span>
<span class="lineNum">    1408 </span><span class="lineCov">          1 :       mSourceBufferAttributes-&gt;HaveGroupStartTimestamp()) {</span>
<span class="lineNum">    1409 </span>            :     mSourceBufferAttributes-&gt;SetTimestampOffset(
<span class="lineNum">    1410 </span><span class="lineCov">          1 :       mSourceBufferAttributes-&gt;GetGroupStartTimestamp() - aPresentationTime);</span>
<span class="lineNum">    1411 </span>            :     mSourceBufferAttributes-&gt;SetGroupEndTimestamp(
<span class="lineNum">    1412 </span><span class="lineCov">          1 :       mSourceBufferAttributes-&gt;GetGroupStartTimestamp());</span>
<span class="lineNum">    1413 </span><span class="lineCov">          1 :     mVideoTracks.mNeedRandomAccessPoint = true;</span>
<span class="lineNum">    1414 </span><span class="lineCov">          1 :     mAudioTracks.mNeedRandomAccessPoint = true;</span>
<span class="lineNum">    1415 </span><span class="lineCov">          1 :     mSourceBufferAttributes-&gt;ResetGroupStartTimestamp();</span>
<span class="lineNum">    1416 </span>            :   }
<span class="lineNum">    1417 </span><span class="lineCov">          1 : }</span>
<a name="1418"><span class="lineNum">    1418 </span>            : </a>
<span class="lineNum">    1419 </span>            : TimeInterval
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 : TrackBuffersManager::PresentationInterval(const TrackBuffer&amp; aSamples) const</span>
<span class="lineNum">    1421 </span>            : {
<span class="lineNum">    1422 </span>            :   TimeInterval presentationInterval =
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :     TimeInterval(TimeUnit::FromMicroseconds(aSamples[0]-&gt;mTime),</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                  aSamples[0]-&gt;GetEndTime());</span>
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   for (uint32_t i = 1; i &lt; aSamples.Length(); i++) {</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     auto&amp; sample = aSamples[i];</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     presentationInterval = presentationInterval.Span(</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :       TimeInterval(TimeUnit::FromMicroseconds(sample-&gt;mTime),</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :                    sample-&gt;GetEndTime()));</span>
<span class="lineNum">    1431 </span>            :   }
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :   return presentationInterval;</span>
<span class="lineNum">    1433 </span>            : }
<a name="1434"><span class="lineNum">    1434 </span>            : </a>
<span class="lineNum">    1435 </span>            : void
<span class="lineNum">    1436 </span><span class="lineCov">          1 : TrackBuffersManager::ProcessFrames(TrackBuffer&amp; aSamples, TrackData&amp; aTrackData)</span>
<span class="lineNum">    1437 </span>            : {
<span class="lineNum">    1438 </span><span class="lineCov">          1 :   if (!aSamples.Length()) {</span>
<span class="lineNum">    1439 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1440 </span>            :   }
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :   // 1. If generate timestamps flag equals true
<span class="lineNum">    1443 </span>            :   // Let presentation timestamp equal 0.
<span class="lineNum">    1444 </span>            :   // Otherwise
<span class="lineNum">    1445 </span>            :   // Let presentation timestamp be a double precision floating point representation of the coded frame's presentation timestamp in seconds.
<span class="lineNum">    1446 </span>            :   TimeUnit presentationTimestamp =
<span class="lineNum">    1447 </span><span class="lineCov">          1 :     mSourceBufferAttributes-&gt;mGenerateTimestamps</span>
<span class="lineNum">    1448 </span>            :     ? TimeUnit()
<span class="lineNum">    1449 </span><span class="lineCov">          1 :     : TimeUnit::FromMicroseconds(aSamples[0]-&gt;mTime);</span>
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :   // 3. If mode equals &quot;sequence&quot; and group start timestamp is set, then run the following steps:
<span class="lineNum">    1452 </span><span class="lineCov">          1 :   CheckSequenceDiscontinuity(presentationTimestamp);</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            :   // 5. Let track buffer equal the track buffer that the coded frame will be added to.
<span class="lineNum">    1455 </span><span class="lineCov">          1 :   auto&amp; trackBuffer = aTrackData;</span>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            :   // Some videos do not exactly start at 0, but instead a small negative value.
<span class="lineNum">    1458 </span>            :   // To avoid evicting the starting frame of those videos, we allow a leeway
<span class="lineNum">    1459 </span>            :   // of +- mLongestFrameDuration on the append window start.
<span class="lineNum">    1460 </span>            :   // We only apply the leeway with the default append window start of 0
<span class="lineNum">    1461 </span>            :   // otherwise do as per spec.
<span class="lineNum">    1462 </span>            :   TimeInterval targetWindow =
<span class="lineNum">    1463 </span><span class="lineCov">          1 :     mAppendWindow.mStart != TimeUnit::FromSeconds(0)</span>
<span class="lineNum">    1464 </span>            :     ? mAppendWindow
<span class="lineNum">    1465 </span>            :     : TimeInterval(mAppendWindow.mStart, mAppendWindow.mEnd,
<span class="lineNum">    1466 </span><span class="lineCov">          1 :                    trackBuffer.mLastFrameDuration.isSome()</span>
<span class="lineNum">    1467 </span>            :                    ? trackBuffer.mLongestFrameDuration
<span class="lineNum">    1468 </span><span class="lineCov">          1 :                    : aSamples[0]-&gt;mDuration);</span>
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineCov">          1 :   TimeIntervals samplesRange;</span>
<span class="lineNum">    1471 </span><span class="lineCov">          1 :   uint32_t sizeNewSamples = 0;</span>
<span class="lineNum">    1472 </span>            :   TrackBuffer samples; // array that will contain the frames to be added
<span class="lineNum">    1473 </span>            :                        // to our track buffer.
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            :   // We assume that no frames are contiguous within a media segment and as such
<span class="lineNum">    1476 </span>            :   // don't need to check for discontinuity except for the first frame and should
<span class="lineNum">    1477 </span>            :   // a frame be ignored due to the target window.
<span class="lineNum">    1478 </span><span class="lineCov">          1 :   bool needDiscontinuityCheck = true;</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :   // Highest presentation time seen in samples block.
<span class="lineNum">    1481 </span><span class="lineCov">          1 :   TimeUnit highestSampleTime;</span>
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">          1 :   if (aSamples.Length()) {</span>
<span class="lineNum">    1484 </span><span class="lineCov">          1 :     aTrackData.mLastParsedEndTime = TimeUnit();</span>
<span class="lineNum">    1485 </span>            :   }
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineCov">          1 :   for (auto&amp; sample : aSamples) {</span>
<span class="lineNum">    1488 </span><span class="lineCov">          1 :     SAMPLE_DEBUG(&quot;Processing %s frame(pts:%&quot; PRId64 &quot; end:%&quot; PRId64 &quot;, dts:%&quot; PRId64 &quot;, duration:%&quot; PRId64 &quot;, &quot;</span>
<span class="lineNum">    1489 </span>            :                &quot;kf:%d)&quot;,
<span class="lineNum">    1490 </span>            :                aTrackData.mInfo-&gt;mMimeType.get(),
<span class="lineNum">    1491 </span>            :                sample-&gt;mTime,
<span class="lineNum">    1492 </span>            :                sample-&gt;GetEndTime().ToMicroseconds(),
<span class="lineNum">    1493 </span>            :                sample-&gt;mTimecode,
<span class="lineNum">    1494 </span>            :                sample-&gt;mDuration.ToMicroseconds(),
<span class="lineNum">    1495 </span>            :                sample-&gt;mKeyframe);
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineCov">          1 :     const TimeUnit sampleEndTime = sample-&gt;GetEndTime();</span>
<span class="lineNum">    1498 </span><span class="lineCov">          1 :     if (sampleEndTime &gt; aTrackData.mLastParsedEndTime) {</span>
<span class="lineNum">    1499 </span><span class="lineCov">          1 :       aTrackData.mLastParsedEndTime = sampleEndTime;</span>
<span class="lineNum">    1500 </span>            :     }
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            :     // We perform step 10 right away as we can't do anything should a keyframe
<span class="lineNum">    1503 </span>            :     // be needed until we have one.
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :     // 10. If the need random access point flag on track buffer equals true, then run the following steps:
<span class="lineNum">    1506 </span><span class="lineCov">          1 :     if (trackBuffer.mNeedRandomAccessPoint) {</span>
<span class="lineNum">    1507 </span>            :       // 1. If the coded frame is not a random access point, then drop the coded frame and jump to the top of the loop to start processing the next coded frame.
<span class="lineNum">    1508 </span><span class="lineCov">          1 :       if (!sample-&gt;mKeyframe) {</span>
<span class="lineNum">    1509 </span><span class="lineCov">          1 :         continue;</span>
<span class="lineNum">    1510 </span>            :       }
<span class="lineNum">    1511 </span>            :       // 2. Set the need random access point flag on track buffer to false.
<span class="lineNum">    1512 </span><span class="lineCov">          1 :       trackBuffer.mNeedRandomAccessPoint = false;</span>
<span class="lineNum">    1513 </span>            :     }
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            :     // We perform step 1,2 and 4 at once:
<span class="lineNum">    1516 </span>            :     // 1. If generate timestamps flag equals true:
<span class="lineNum">    1517 </span>            :     //   Let presentation timestamp equal 0.
<span class="lineNum">    1518 </span>            :     //   Let decode timestamp equal 0.
<span class="lineNum">    1519 </span>            :     // Otherwise:
<span class="lineNum">    1520 </span>            :     //   Let presentation timestamp be a double precision floating point representation of the coded frame's presentation timestamp in seconds.
<span class="lineNum">    1521 </span>            :     //   Let decode timestamp be a double precision floating point representation of the coded frame's decode timestamp in seconds.
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span>            :     // 2. Let frame duration be a double precision floating point representation of the coded frame's duration in seconds.
<span class="lineNum">    1524 </span>            :     // Step 3 is performed earlier or when a discontinuity has been detected.
<span class="lineNum">    1525 </span>            :     // 4. If timestampOffset is not 0, then run the following steps:
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span><span class="lineCov">          1 :     TimeUnit sampleTime = TimeUnit::FromMicroseconds(sample-&gt;mTime);</span>
<span class="lineNum">    1528 </span><span class="lineCov">          1 :     TimeUnit sampleTimecode = TimeUnit::FromMicroseconds(sample-&gt;mTimecode);</span>
<span class="lineNum">    1529 </span><span class="lineCov">          1 :     TimeUnit sampleDuration = sample-&gt;mDuration;</span>
<span class="lineNum">    1530 </span><span class="lineCov">          1 :     TimeUnit timestampOffset = mSourceBufferAttributes-&gt;GetTimestampOffset();</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            :     TimeInterval sampleInterval =
<span class="lineNum">    1533 </span><span class="lineCov">          1 :       mSourceBufferAttributes-&gt;mGenerateTimestamps</span>
<span class="lineNum">    1534 </span><span class="lineCov">          1 :       ? TimeInterval(timestampOffset, timestampOffset + sampleDuration)</span>
<span class="lineNum">    1535 </span><span class="lineCov">          1 :       : TimeInterval(timestampOffset + sampleTime,</span>
<span class="lineNum">    1536 </span><span class="lineCov">          1 :                      timestampOffset + sampleTime + sampleDuration);</span>
<span class="lineNum">    1537 </span><span class="lineCov">          1 :     TimeUnit decodeTimestamp = mSourceBufferAttributes-&gt;mGenerateTimestamps</span>
<span class="lineNum">    1538 </span>            :                                ? timestampOffset
<span class="lineNum">    1539 </span><span class="lineCov">          1 :                                : timestampOffset + sampleTimecode;</span>
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            :     // 6. If last decode timestamp for track buffer is set and decode timestamp is less than last decode timestamp:
<span class="lineNum">    1542 </span>            :     // OR
<span class="lineNum">    1543 </span>            :     // If last decode timestamp for track buffer is set and the difference between decode timestamp and last decode timestamp is greater than 2 times last frame duration:
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineCov">          1 :     if (needDiscontinuityCheck &amp;&amp; trackBuffer.mLastDecodeTimestamp.isSome() &amp;&amp;</span>
<span class="lineNum">    1546 </span><span class="lineCov">          1 :         (decodeTimestamp &lt; trackBuffer.mLastDecodeTimestamp.ref() ||</span>
<span class="lineNum">    1547 </span><span class="lineCov">          1 :          (decodeTimestamp - trackBuffer.mLastDecodeTimestamp.ref()</span>
<span class="lineNum">    1548 </span><span class="lineCov">          1 :           &gt; trackBuffer.mLongestFrameDuration * 2))) {</span>
<span class="lineNum">    1549 </span><span class="lineCov">          1 :       MSE_DEBUG(&quot;Discontinuity detected.&quot;);</span>
<span class="lineNum">    1550 </span><span class="lineCov">          1 :       SourceBufferAppendMode appendMode = mSourceBufferAttributes-&gt;GetAppendMode();</span>
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            :       // 1a. If mode equals &quot;segments&quot;:
<span class="lineNum">    1553 </span><span class="lineCov">          1 :       if (appendMode == SourceBufferAppendMode::Segments) {</span>
<span class="lineNum">    1554 </span>            :         // Set group end timestamp to presentation timestamp.
<span class="lineNum">    1555 </span><span class="lineCov">          1 :         mSourceBufferAttributes-&gt;SetGroupEndTimestamp(sampleInterval.mStart);</span>
<span class="lineNum">    1556 </span>            :       }
<span class="lineNum">    1557 </span>            :       // 1b. If mode equals &quot;sequence&quot;:
<span class="lineNum">    1558 </span><span class="lineCov">          1 :       if (appendMode == SourceBufferAppendMode::Sequence) {</span>
<span class="lineNum">    1559 </span>            :         // Set group start timestamp equal to the group end timestamp.
<span class="lineNum">    1560 </span>            :         mSourceBufferAttributes-&gt;SetGroupStartTimestamp(
<span class="lineNum">    1561 </span><span class="lineCov">          1 :           mSourceBufferAttributes-&gt;GetGroupEndTimestamp());</span>
<span class="lineNum">    1562 </span>            :       }
<span class="lineNum">    1563 </span><span class="lineCov">          1 :       for (auto&amp; track : GetTracksList()) {</span>
<span class="lineNum">    1564 </span>            :         // 2. Unset the last decode timestamp on all track buffers.
<span class="lineNum">    1565 </span>            :         // 3. Unset the last frame duration on all track buffers.
<span class="lineNum">    1566 </span>            :         // 4. Unset the highest end timestamp on all track buffers.
<span class="lineNum">    1567 </span>            :         // 5. Set the need random access point flag on all track buffers to true.
<span class="lineNum">    1568 </span><span class="lineCov">          1 :         track-&gt;ResetAppendState();</span>
<span class="lineNum">    1569 </span>            :       }
<span class="lineNum">    1570 </span>            :       // 6. Jump to the Loop Top step above to restart processing of the current coded frame.
<span class="lineNum">    1571 </span>            :       // Rather that restarting the process for the frame, we run the first
<span class="lineNum">    1572 </span>            :       // steps again instead.
<span class="lineNum">    1573 </span>            :       // 3. If mode equals &quot;sequence&quot; and group start timestamp is set, then run the following steps:
<span class="lineNum">    1574 </span>            :       TimeUnit presentationTimestamp =
<span class="lineNum">    1575 </span><span class="lineCov">          1 :         mSourceBufferAttributes-&gt;mGenerateTimestamps ? TimeUnit() : sampleTime;</span>
<span class="lineNum">    1576 </span><span class="lineCov">          1 :       CheckSequenceDiscontinuity(presentationTimestamp);</span>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineCov">          1 :       if (!sample-&gt;mKeyframe) {</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1580 </span>            :       }
<span class="lineNum">    1581 </span><span class="lineCov">          1 :       if (appendMode == SourceBufferAppendMode::Sequence) {</span>
<span class="lineNum">    1582 </span>            :         // mSourceBufferAttributes-&gt;GetTimestampOffset() was modified during CheckSequenceDiscontinuity.
<span class="lineNum">    1583 </span>            :         // We need to update our variables.
<span class="lineNum">    1584 </span><span class="lineCov">          1 :         timestampOffset = mSourceBufferAttributes-&gt;GetTimestampOffset();</span>
<span class="lineNum">    1585 </span><span class="lineCov">          1 :         sampleInterval =</span>
<span class="lineNum">    1586 </span><span class="lineCov">          1 :           mSourceBufferAttributes-&gt;mGenerateTimestamps</span>
<span class="lineNum">    1587 </span><span class="lineCov">          1 :           ? TimeInterval(timestampOffset, timestampOffset + sampleDuration)</span>
<span class="lineNum">    1588 </span><span class="lineCov">          1 :           : TimeInterval(timestampOffset + sampleTime,</span>
<span class="lineNum">    1589 </span><span class="lineCov">          1 :                          timestampOffset + sampleTime + sampleDuration);</span>
<span class="lineNum">    1590 </span><span class="lineCov">          1 :         decodeTimestamp = mSourceBufferAttributes-&gt;mGenerateTimestamps</span>
<span class="lineNum">    1591 </span>            :                           ? timestampOffset
<span class="lineNum">    1592 </span><span class="lineCov">          1 :                           : timestampOffset + sampleTimecode;</span>
<span class="lineNum">    1593 </span>            :       }
<span class="lineNum">    1594 </span><span class="lineCov">          1 :       trackBuffer.mNeedRandomAccessPoint = false;</span>
<span class="lineNum">    1595 </span><span class="lineCov">          1 :       needDiscontinuityCheck = false;</span>
<span class="lineNum">    1596 </span>            :     }
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span>            :     // 7. Let frame end timestamp equal the sum of presentation timestamp and frame duration.
<span class="lineNum">    1599 </span>            :     // This is sampleInterval.mEnd
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            :     // 8. If presentation timestamp is less than appendWindowStart, then set the need random access point flag to true, drop the coded frame, and jump to the top of the loop to start processing the next coded frame.
<span class="lineNum">    1602 </span>            :     // 9. If frame end timestamp is greater than appendWindowEnd, then set the need random access point flag to true, drop the coded frame, and jump to the top of the loop to start processing the next coded frame.
<span class="lineNum">    1603 </span><span class="lineCov">          1 :     if (!targetWindow.ContainsWithStrictEnd(sampleInterval)) {</span>
<span class="lineNum">    1604 </span><span class="lineCov">          1 :       if (samples.Length()) {</span>
<span class="lineNum">    1605 </span>            :         // We are creating a discontinuity in the samples.
<span class="lineNum">    1606 </span>            :         // Insert the samples processed so far.
<span class="lineNum">    1607 </span><span class="lineCov">          1 :         InsertFrames(samples, samplesRange, trackBuffer);</span>
<span class="lineNum">    1608 </span><span class="lineCov">          1 :         samples.Clear();</span>
<span class="lineNum">    1609 </span><span class="lineCov">          1 :         samplesRange = TimeIntervals();</span>
<span class="lineNum">    1610 </span><span class="lineCov">          1 :         trackBuffer.mSizeBuffer += sizeNewSamples;</span>
<span class="lineNum">    1611 </span><span class="lineCov">          1 :         sizeNewSamples = 0;</span>
<span class="lineNum">    1612 </span><span class="lineCov">          1 :         UpdateHighestTimestamp(trackBuffer, highestSampleTime);</span>
<span class="lineNum">    1613 </span>            :       }
<span class="lineNum">    1614 </span><span class="lineCov">          1 :       trackBuffer.mNeedRandomAccessPoint = true;</span>
<span class="lineNum">    1615 </span><span class="lineCov">          1 :       needDiscontinuityCheck = true;</span>
<span class="lineNum">    1616 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    1617 </span>            :     }
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            :     samplesRange += sampleInterval;
<span class="lineNum">    1620 </span><span class="lineCov">          1 :     sizeNewSamples += sample-&gt;ComputedSizeOfIncludingThis();</span>
<span class="lineNum">    1621 </span><span class="lineCov">          1 :     sample-&gt;mTime = sampleInterval.mStart.ToMicroseconds();</span>
<span class="lineNum">    1622 </span><span class="lineCov">          1 :     sample-&gt;mTimecode = decodeTimestamp.ToMicroseconds();</span>
<span class="lineNum">    1623 </span><span class="lineCov">          1 :     sample-&gt;mTrackInfo = trackBuffer.mLastInfo;</span>
<span class="lineNum">    1624 </span><span class="lineCov">          1 :     samples.AppendElement(sample);</span>
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            :     // Steps 11,12,13,14, 15 and 16 will be done in one block in InsertFrames.
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            :     trackBuffer.mLongestFrameDuration =
<span class="lineNum">    1629 </span><span class="lineCov">          1 :       trackBuffer.mLastFrameDuration.isSome()</span>
<span class="lineNum">    1630 </span>            :       ? sample-&gt;mKeyframe
<span class="lineNum">    1631 </span>            :         ? sampleDuration
<span class="lineNum">    1632 </span><span class="lineCov">          1 :         : std::max(sampleDuration, trackBuffer.mLongestFrameDuration)</span>
<span class="lineNum">    1633 </span><span class="lineCov">          1 :       : sampleDuration;</span>
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            :     // 17. Set last decode timestamp for track buffer to decode timestamp.
<span class="lineNum">    1636 </span><span class="lineCov">          1 :     trackBuffer.mLastDecodeTimestamp = Some(decodeTimestamp);</span>
<span class="lineNum">    1637 </span>            :     // 18. Set last frame duration for track buffer to frame duration.
<span class="lineNum">    1638 </span><span class="lineCov">          1 :     trackBuffer.mLastFrameDuration = Some(sampleDuration);</span>
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            :     // 19. If highest end timestamp for track buffer is unset or frame end timestamp is greater than highest end timestamp, then set highest end timestamp for track buffer to frame end timestamp.
<span class="lineNum">    1641 </span><span class="lineCov">          1 :     if (trackBuffer.mHighestEndTimestamp.isNothing() ||</span>
<span class="lineNum">    1642 </span><span class="lineCov">          1 :         sampleInterval.mEnd &gt; trackBuffer.mHighestEndTimestamp.ref()) {</span>
<span class="lineNum">    1643 </span><span class="lineCov">          1 :       trackBuffer.mHighestEndTimestamp = Some(sampleInterval.mEnd);</span>
<span class="lineNum">    1644 </span>            :     }
<span class="lineNum">    1645 </span><span class="lineCov">          1 :     if (sampleInterval.mStart &gt; highestSampleTime) {</span>
<span class="lineNum">    1646 </span><span class="lineCov">          1 :       highestSampleTime = sampleInterval.mStart;</span>
<span class="lineNum">    1647 </span>            :     }
<span class="lineNum">    1648 </span>            :     // 20. If frame end timestamp is greater than group end timestamp, then set group end timestamp equal to frame end timestamp.
<span class="lineNum">    1649 </span><span class="lineCov">          1 :     if (sampleInterval.mEnd &gt; mSourceBufferAttributes-&gt;GetGroupEndTimestamp()) {</span>
<span class="lineNum">    1650 </span><span class="lineCov">          1 :       mSourceBufferAttributes-&gt;SetGroupEndTimestamp(sampleInterval.mEnd);</span>
<span class="lineNum">    1651 </span>            :     }
<span class="lineNum">    1652 </span>            :     // 21. If generate timestamps flag equals true, then set timestampOffset equal to frame end timestamp.
<span class="lineNum">    1653 </span><span class="lineCov">          1 :     if (mSourceBufferAttributes-&gt;mGenerateTimestamps) {</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :       mSourceBufferAttributes-&gt;SetTimestampOffset(sampleInterval.mEnd);</span>
<span class="lineNum">    1655 </span>            :     }
<span class="lineNum">    1656 </span>            :   }
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span><span class="lineCov">          1 :   if (samples.Length()) {</span>
<span class="lineNum">    1659 </span><span class="lineCov">          1 :     InsertFrames(samples, samplesRange, trackBuffer);</span>
<span class="lineNum">    1660 </span><span class="lineCov">          1 :     trackBuffer.mSizeBuffer += sizeNewSamples;</span>
<span class="lineNum">    1661 </span><span class="lineCov">          1 :     UpdateHighestTimestamp(trackBuffer, highestSampleTime);</span>
<span class="lineNum">    1662 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1663 </span>            : }
<a name="1664"><span class="lineNum">    1664 </span>            : </a>
<span class="lineNum">    1665 </span>            : bool
<span class="lineNum">    1666 </span><span class="lineCov">          1 : TrackBuffersManager::CheckNextInsertionIndex(TrackData&amp; aTrackData,</span>
<span class="lineNum">    1667 </span>            :                                              const TimeUnit&amp; aSampleTime)
<span class="lineNum">    1668 </span>            : {
<span class="lineNum">    1669 </span><span class="lineCov">          1 :   if (aTrackData.mNextInsertionIndex.isSome()) {</span>
<span class="lineNum">    1670 </span>            :     return true;
<span class="lineNum">    1671 </span>            :   }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineCov">          1 :   const TrackBuffer&amp; data = aTrackData.GetTrackBuffer();</span>
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineCov">          1 :   if (data.IsEmpty() || aSampleTime &lt; aTrackData.mBufferedRanges.GetStart()) {</span>
<span class="lineNum">    1676 </span><span class="lineCov">          1 :     aTrackData.mNextInsertionIndex = Some(0u);</span>
<span class="lineNum">    1677 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1678 </span>            :   }
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            :   // Find which discontinuity we should insert the frame before.
<span class="lineNum">    1681 </span><span class="lineCov">          1 :   TimeInterval target;</span>
<span class="lineNum">    1682 </span><span class="lineCov">          1 :   for (const auto&amp; interval : aTrackData.mBufferedRanges) {</span>
<span class="lineNum">    1683 </span><span class="lineCov">          1 :     if (aSampleTime &lt; interval.mStart) {</span>
<span class="lineNum">    1684 </span><span class="lineCov">          1 :       target = interval;</span>
<span class="lineNum">    1685 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    1686 </span>            :     }
<span class="lineNum">    1687 </span>            :   }
<span class="lineNum">    1688 </span><span class="lineCov">          1 :   if (target.IsEmpty()) {</span>
<span class="lineNum">    1689 </span>            :     // No target found, it will be added at the end of the track buffer.
<span class="lineNum">    1690 </span><span class="lineCov">          1 :     aTrackData.mNextInsertionIndex = Some(uint32_t(data.Length()));</span>
<span class="lineNum">    1691 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    1692 </span>            :   }
<span class="lineNum">    1693 </span>            :   // We now need to find the first frame of the searched interval.
<span class="lineNum">    1694 </span>            :   // We will insert our new frames right before.
<span class="lineNum">    1695 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; data.Length(); i++) {</span>
<span class="lineNum">    1696 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = data[i];</span>
<span class="lineNum">    1697 </span><span class="lineCov">          1 :     if (sample-&gt;mTime &gt;= target.mStart.ToMicroseconds() ||</span>
<span class="lineNum">    1698 </span><span class="lineCov">          1 :         sample-&gt;GetEndTime() &gt; target.mStart) {</span>
<span class="lineNum">    1699 </span><span class="lineCov">          1 :       aTrackData.mNextInsertionIndex = Some(i);</span>
<span class="lineNum">    1700 </span>            :       return true;
<span class="lineNum">    1701 </span>            :     }
<span class="lineNum">    1702 </span>            :   }
<span class="lineNum">    1703 </span>            :   NS_ASSERTION(false, &quot;Insertion Index Not Found&quot;);
<span class="lineNum">    1704 </span>            :   return false;
<span class="lineNum">    1705 </span>            : }
<a name="1706"><span class="lineNum">    1706 </span>            : </a>
<span class="lineNum">    1707 </span>            : void
<span class="lineNum">    1708 </span><span class="lineCov">          1 : TrackBuffersManager::InsertFrames(TrackBuffer&amp; aSamples,</span>
<span class="lineNum">    1709 </span>            :                                   const TimeIntervals&amp; aIntervals,
<span class="lineNum">    1710 </span>            :                                   TrackData&amp; aTrackData)
<span class="lineNum">    1711 </span>            : {
<span class="lineNum">    1712 </span>            :   // 5. Let track buffer equal the track buffer that the coded frame will be added to.
<span class="lineNum">    1713 </span><span class="lineCov">          1 :   auto&amp; trackBuffer = aTrackData;</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span><span class="lineCov">          1 :   MSE_DEBUGV(&quot;Processing %&quot; PRIuSIZE &quot; %s frames(start:%&quot; PRId64 &quot; end:%&quot; PRId64 &quot;)&quot;,</span>
<span class="lineNum">    1716 </span>            :              aSamples.Length(),
<span class="lineNum">    1717 </span>            :              aTrackData.mInfo-&gt;mMimeType.get(),
<span class="lineNum">    1718 </span>            :              aIntervals.GetStart().ToMicroseconds(),
<span class="lineNum">    1719 </span>            :              aIntervals.GetEnd().ToMicroseconds());
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :   // TODO: Handle splicing of audio (and text) frames.
<span class="lineNum">    1722 </span>            :   // 11. Let spliced audio frame be an unset variable for holding audio splice information
<span class="lineNum">    1723 </span>            :   // 12. Let spliced timed text frame be an unset variable for holding timed text splice information
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            :   // 13. If last decode timestamp for track buffer is unset and presentation timestamp falls within the presentation interval of a coded frame in track buffer,then run the following steps:
<span class="lineNum">    1726 </span>            :   // For now we only handle replacing existing frames with the new ones. So we
<span class="lineNum">    1727 </span>            :   // skip this step.
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :   // 14. Remove existing coded frames in track buffer:
<span class="lineNum">    1730 </span>            :   //   a) If highest end timestamp for track buffer is not set:
<span class="lineNum">    1731 </span>            :   //      Remove all coded frames from track buffer that have a presentation timestamp greater than or equal to presentation timestamp and less than frame end timestamp.
<span class="lineNum">    1732 </span>            :   //   b) If highest end timestamp for track buffer is set and less than or equal to presentation timestamp:
<span class="lineNum">    1733 </span>            :   //      Remove all coded frames from track buffer that have a presentation timestamp greater than or equal to highest end timestamp and less than frame end timestamp
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span>            :   // There is an ambiguity on how to remove frames, which was lodged with:
<span class="lineNum">    1736 </span>            :   // https://www.w3.org/Bugs/Public/show_bug.cgi?id=28710, implementing as per
<span class="lineNum">    1737 </span>            :   // bug description.
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span>            :   // 15. Remove decoding dependencies of the coded frames removed in the previous step:
<span class="lineNum">    1740 </span>            :   // Remove all coded frames between the coded frames removed in the previous step and the next random access point after those removed frames.
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span><span class="lineCov">          1 :   TimeIntervals intersection = trackBuffer.mBufferedRanges;</span>
<span class="lineNum">    1743 </span><span class="lineCov">          1 :   intersection.Intersection(aIntervals);</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span><span class="lineCov">          1 :   if (intersection.Length()) {</span>
<span class="lineNum">    1746 </span><span class="lineCov">          1 :     if (aSamples[0]-&gt;mKeyframe &amp;&amp;</span>
<span class="lineNum">    1747 </span><span class="lineCov">          1 :         (mType.Type() == MEDIAMIMETYPE(&quot;video/webm&quot;)</span>
<span class="lineNum">    1748 </span><span class="lineCov">          1 :          || mType.Type() == MEDIAMIMETYPE(&quot;audio/webm&quot;))) {</span>
<span class="lineNum">    1749 </span>            :       // We are starting a new GOP, we do not have to worry about breaking an
<span class="lineNum">    1750 </span>            :       // existing current coded frame group. Reset the next insertion index
<span class="lineNum">    1751 </span>            :       // so the search for when to start our frames removal can be exhaustive.
<span class="lineNum">    1752 </span>            :       // This is a workaround for bug 1276184 and only until either bug 1277733
<span class="lineNum">    1753 </span>            :       // or bug 1209386 is fixed.
<span class="lineNum">    1754 </span>            :       // With the webm container, we can't always properly determine the
<span class="lineNum">    1755 </span>            :       // duration of the last frame, which may cause the last frame of a cluster
<span class="lineNum">    1756 </span>            :       // to overlap the following frame.
<span class="lineNum">    1757 </span><span class="lineCov">          1 :       trackBuffer.mNextInsertionIndex.reset();</span>
<span class="lineNum">    1758 </span>            :     }
<span class="lineNum">    1759 </span>            :     uint32_t index =
<span class="lineNum">    1760 </span><span class="lineCov">          1 :       RemoveFrames(aIntervals, trackBuffer, trackBuffer.mNextInsertionIndex.refOr(0));</span>
<span class="lineNum">    1761 </span><span class="lineCov">          1 :     if (index) {</span>
<span class="lineNum">    1762 </span><span class="lineCov">          1 :       trackBuffer.mNextInsertionIndex = Some(index);</span>
<span class="lineNum">    1763 </span>            :     }
<span class="lineNum">    1764 </span>            :   }
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :   // 16. Add the coded frame with the presentation timestamp, decode timestamp, and frame duration to the track buffer.
<span class="lineNum">    1767 </span><span class="lineCov">          1 :   if (!CheckNextInsertionIndex(aTrackData,</span>
<span class="lineNum">    1768 </span><span class="lineCov">          1 :                                TimeUnit::FromMicroseconds(aSamples[0]-&gt;mTime))) {</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :     RejectProcessing(NS_ERROR_FAILURE, __func__);</span>
<span class="lineNum">    1770 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">    1771 </span>            :   }
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :   // Adjust our demuxing index if necessary.
<span class="lineNum">    1774 </span><span class="lineCov">          1 :   if (trackBuffer.mNextGetSampleIndex.isSome()) {</span>
<span class="lineNum">    1775 </span><span class="lineCov">          1 :     if (trackBuffer.mNextInsertionIndex.ref() == trackBuffer.mNextGetSampleIndex.ref() &amp;&amp;</span>
<span class="lineNum">    1776 </span><span class="lineCov">          1 :         aIntervals.GetEnd() &gt;= trackBuffer.mNextSampleTime) {</span>
<span class="lineNum">    1777 </span><span class="lineCov">          1 :       MSE_DEBUG(&quot;Next sample to be played got overwritten&quot;);</span>
<span class="lineNum">    1778 </span><span class="lineCov">          1 :       trackBuffer.mNextGetSampleIndex.reset();</span>
<span class="lineNum">    1779 </span><span class="lineCov">          1 :       ResetEvictionIndex(trackBuffer);</span>
<span class="lineNum">    1780 </span><span class="lineCov">          1 :     } else if (trackBuffer.mNextInsertionIndex.ref() &lt;= trackBuffer.mNextGetSampleIndex.ref()) {</span>
<span class="lineNum">    1781 </span><span class="lineCov">          1 :       trackBuffer.mNextGetSampleIndex.ref() += aSamples.Length();</span>
<span class="lineNum">    1782 </span>            :       // We could adjust the eviction index so that the new data gets added to
<span class="lineNum">    1783 </span>            :       // the evictable amount (as it is prior currentTime). However, considering
<span class="lineNum">    1784 </span>            :       // new data is being added prior the current playback, it's likely that
<span class="lineNum">    1785 </span>            :       // this data will be played next, and as such we probably don't want to
<span class="lineNum">    1786 </span>            :       // have it evicted too early. So instead reset the eviction index instead.
<span class="lineNum">    1787 </span><span class="lineCov">          1 :       ResetEvictionIndex(trackBuffer);</span>
<span class="lineNum">    1788 </span>            :     }
<span class="lineNum">    1789 </span>            :   }
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineCov">          1 :   TrackBuffer&amp; data = trackBuffer.GetTrackBuffer();</span>
<span class="lineNum">    1792 </span><span class="lineCov">          1 :   data.InsertElementsAt(trackBuffer.mNextInsertionIndex.ref(), aSamples);</span>
<span class="lineNum">    1793 </span><span class="lineCov">          1 :   trackBuffer.mNextInsertionIndex.ref() += aSamples.Length();</span>
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            :   // Update our buffered range with new sample interval.
<span class="lineNum">    1796 </span><span class="lineCov">          1 :   trackBuffer.mBufferedRanges += aIntervals;</span>
<span class="lineNum">    1797 </span>            :   // We allow a fuzz factor in our interval of half a frame length,
<span class="lineNum">    1798 </span>            :   // as fuzz is +/- value, giving an effective leeway of a full frame
<span class="lineNum">    1799 </span>            :   // length.
<span class="lineNum">    1800 </span><span class="lineCov">          1 :   if (aIntervals.Length()) {</span>
<span class="lineNum">    1801 </span><span class="lineCov">          1 :     TimeIntervals range(aIntervals);</span>
<span class="lineNum">    1802 </span><span class="lineCov">          1 :     range.SetFuzz(trackBuffer.mLongestFrameDuration / 2);</span>
<span class="lineNum">    1803 </span><span class="lineCov">          1 :     trackBuffer.mSanitizedBufferedRanges += range;</span>
<span class="lineNum">    1804 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1805 </span>            : }
<a name="1806"><span class="lineNum">    1806 </span>            : </a>
<span class="lineNum">    1807 </span>            : void
<span class="lineNum">    1808 </span><span class="lineCov">          1 : TrackBuffersManager::UpdateHighestTimestamp(TrackData&amp; aTrackData,</span>
<span class="lineNum">    1809 </span>            :                                             const media::TimeUnit&amp; aHighestTime)
<span class="lineNum">    1810 </span>            : {
<span class="lineNum">    1811 </span><span class="lineCov">          1 :   if (aHighestTime &gt; aTrackData.mHighestStartTimestamp) {</span>
<span class="lineNum">    1812 </span><span class="lineCov">          1 :     MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    1813 </span><span class="lineCov">          1 :     aTrackData.mHighestStartTimestamp = aHighestTime;</span>
<span class="lineNum">    1814 </span>            :   }
<span class="lineNum">    1815 </span><span class="lineCov">          1 : }</span>
<a name="1816"><span class="lineNum">    1816 </span>            : </a>
<span class="lineNum">    1817 </span>            : uint32_t
<span class="lineNum">    1818 </span><span class="lineCov">          1 : TrackBuffersManager::RemoveFrames(const TimeIntervals&amp; aIntervals,</span>
<span class="lineNum">    1819 </span>            :                                   TrackData&amp; aTrackData,
<span class="lineNum">    1820 </span>            :                                   uint32_t aStartIndex)
<span class="lineNum">    1821 </span>            : {
<span class="lineNum">    1822 </span><span class="lineCov">          1 :   TrackBuffer&amp; data = aTrackData.GetTrackBuffer();</span>
<span class="lineNum">    1823 </span>            :   Maybe&lt;uint32_t&gt; firstRemovedIndex;
<span class="lineNum">    1824 </span><span class="lineCov">          1 :   uint32_t lastRemovedIndex = 0;</span>
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span>            :   // We loop from aStartIndex to avoid removing frames that we inserted earlier
<span class="lineNum">    1827 </span>            :   // and part of the current coded frame group. This is allows to handle step
<span class="lineNum">    1828 </span>            :   // 14 of the coded frame processing algorithm without having to check the value
<span class="lineNum">    1829 </span>            :   // of highest end timestamp:
<span class="lineNum">    1830 </span>            :   // &quot;Remove existing coded frames in track buffer:
<span class="lineNum">    1831 </span>            :   //  If highest end timestamp for track buffer is not set:
<span class="lineNum">    1832 </span>            :   //   Remove all coded frames from track buffer that have a presentation timestamp greater than or equal to presentation timestamp and less than frame end timestamp.
<span class="lineNum">    1833 </span>            :   //  If highest end timestamp for track buffer is set and less than or equal to presentation timestamp:
<span class="lineNum">    1834 </span>            :   //   Remove all coded frames from track buffer that have a presentation timestamp greater than or equal to highest end timestamp and less than frame end timestamp&quot;
<span class="lineNum">    1835 </span><span class="lineCov">          1 :   TimeUnit intervalsEnd = aIntervals.GetEnd();</span>
<span class="lineNum">    1836 </span><span class="lineCov">          1 :   bool mayBreakLoop = false;</span>
<span class="lineNum">    1837 </span><span class="lineCov">          1 :   for (uint32_t i = aStartIndex; i &lt; data.Length(); i++) {</span>
<span class="lineNum">    1838 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt; sample = data[i];</span>
<span class="lineNum">    1839 </span>            :     TimeInterval sampleInterval =
<span class="lineNum">    1840 </span><span class="lineCov">          1 :       TimeInterval(TimeUnit::FromMicroseconds(sample-&gt;mTime),</span>
<span class="lineNum">    1841 </span><span class="lineCov">          1 :                    sample-&gt;GetEndTime());</span>
<span class="lineNum">    1842 </span><span class="lineCov">          1 :     if (aIntervals.Contains(sampleInterval)) {</span>
<span class="lineNum">    1843 </span><span class="lineCov">          1 :       if (firstRemovedIndex.isNothing()) {</span>
<span class="lineNum">    1844 </span><span class="lineCov">          1 :         firstRemovedIndex = Some(i);</span>
<span class="lineNum">    1845 </span>            :       }
<span class="lineNum">    1846 </span><span class="lineCov">          1 :       lastRemovedIndex = i;</span>
<span class="lineNum">    1847 </span><span class="lineCov">          1 :       mayBreakLoop = false;</span>
<span class="lineNum">    1848 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    1849 </span>            :     }
<span class="lineNum">    1850 </span><span class="lineCov">          1 :     if (sample-&gt;mKeyframe &amp;&amp; mayBreakLoop) {</span>
<span class="lineNum">    1851 </span>            :       break;
<span class="lineNum">    1852 </span>            :     }
<span class="lineNum">    1853 </span><span class="lineCov">          1 :     if (sampleInterval.mStart &gt; intervalsEnd) {</span>
<span class="lineNum">    1854 </span><span class="lineCov">          1 :       mayBreakLoop = true;</span>
<span class="lineNum">    1855 </span>            :     }
<span class="lineNum">    1856 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span><span class="lineCov">          1 :   if (firstRemovedIndex.isNothing()) {</span>
<span class="lineNum">    1859 </span>            :     return 0;
<span class="lineNum">    1860 </span>            :   }
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            :   // Remove decoding dependencies of the coded frames removed in the previous step:
<span class="lineNum">    1863 </span>            :   // Remove all coded frames between the coded frames removed in the previous step and the next random access point after those removed frames.
<span class="lineNum">    1864 </span><span class="lineCov">          1 :   for (uint32_t i = lastRemovedIndex + 1; i &lt; data.Length(); i++) {</span>
<span class="lineNum">    1865 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = data[i];</span>
<span class="lineNum">    1866 </span><span class="lineCov">          1 :     if (sample-&gt;mKeyframe) {</span>
<span class="lineNum">    1867 </span>            :       break;
<span class="lineNum">    1868 </span>            :     }
<span class="lineNum">    1869 </span><span class="lineCov">          1 :     lastRemovedIndex = i;</span>
<span class="lineNum">    1870 </span>            :   }
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineCov">          1 :   TimeUnit maxSampleDuration;</span>
<span class="lineNum">    1873 </span><span class="lineCov">          1 :   uint32_t sizeRemoved = 0;</span>
<span class="lineNum">    1874 </span><span class="lineCov">          1 :   TimeIntervals removedIntervals;</span>
<span class="lineNum">    1875 </span><span class="lineCov">          1 :   for (uint32_t i = firstRemovedIndex.ref(); i &lt;= lastRemovedIndex; i++) {</span>
<span class="lineNum">    1876 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt; sample = data[i];</span>
<span class="lineNum">    1877 </span>            :     TimeInterval sampleInterval =
<span class="lineNum">    1878 </span><span class="lineCov">          1 :       TimeInterval(TimeUnit::FromMicroseconds(sample-&gt;mTime),</span>
<span class="lineNum">    1879 </span><span class="lineCov">          1 :                    sample-&gt;GetEndTime());</span>
<span class="lineNum">    1880 </span>            :     removedIntervals += sampleInterval;
<span class="lineNum">    1881 </span><span class="lineCov">          1 :     if (sample-&gt;mDuration &gt; maxSampleDuration) {</span>
<span class="lineNum">    1882 </span><span class="lineCov">          1 :       maxSampleDuration = sample-&gt;mDuration;</span>
<span class="lineNum">    1883 </span>            :     }
<span class="lineNum">    1884 </span><span class="lineCov">          1 :     sizeRemoved += sample-&gt;ComputedSizeOfIncludingThis();</span>
<span class="lineNum">    1885 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">    1886 </span><span class="lineCov">          1 :   aTrackData.mSizeBuffer -= sizeRemoved;</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;Removing frames from:%u (frames:%u) ([%f, %f))&quot;,</span>
<span class="lineNum">    1889 </span>            :             firstRemovedIndex.ref(),
<span class="lineNum">    1890 </span>            :             lastRemovedIndex - firstRemovedIndex.ref() + 1,
<span class="lineNum">    1891 </span>            :             removedIntervals.GetStart().ToSeconds(),
<span class="lineNum">    1892 </span>            :             removedIntervals.GetEnd().ToSeconds());
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span><span class="lineCov">          1 :   if (aTrackData.mNextGetSampleIndex.isSome()) {</span>
<span class="lineNum">    1895 </span><span class="lineCov">          1 :     if (aTrackData.mNextGetSampleIndex.ref() &gt;= firstRemovedIndex.ref() &amp;&amp;</span>
<span class="lineNum">    1896 </span><span class="lineCov">          1 :         aTrackData.mNextGetSampleIndex.ref() &lt;= lastRemovedIndex) {</span>
<span class="lineNum">    1897 </span><span class="lineCov">          1 :       MSE_DEBUG(&quot;Next sample to be played got evicted&quot;);</span>
<span class="lineNum">    1898 </span><span class="lineCov">          1 :       aTrackData.mNextGetSampleIndex.reset();</span>
<span class="lineNum">    1899 </span><span class="lineCov">          1 :       ResetEvictionIndex(aTrackData);</span>
<span class="lineNum">    1900 </span><span class="lineCov">          1 :     } else if (aTrackData.mNextGetSampleIndex.ref() &gt; lastRemovedIndex) {</span>
<span class="lineNum">    1901 </span><span class="lineCov">          1 :       uint32_t samplesRemoved = lastRemovedIndex - firstRemovedIndex.ref() + 1;</span>
<span class="lineNum">    1902 </span><span class="lineCov">          1 :       aTrackData.mNextGetSampleIndex.ref() -= samplesRemoved;</span>
<span class="lineNum">    1903 </span><span class="lineCov">          1 :       if (aTrackData.mEvictionIndex.mLastIndex &gt; lastRemovedIndex) {</span>
<span class="lineNum">    1904 </span><span class="lineCov">          1 :         MOZ_DIAGNOSTIC_ASSERT(</span>
<span class="lineNum">    1905 </span>            :           aTrackData.mEvictionIndex.mLastIndex &gt;= samplesRemoved &amp;&amp;
<span class="lineNum">    1906 </span>            :           aTrackData.mEvictionIndex.mEvictable &gt;= sizeRemoved,
<span class="lineNum">    1907 </span>            :           &quot;Invalid eviction index&quot;);
<span class="lineNum">    1908 </span><span class="lineCov">          1 :         MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    1909 </span><span class="lineCov">          1 :         aTrackData.mEvictionIndex.mLastIndex -= samplesRemoved;</span>
<span class="lineNum">    1910 </span><span class="lineCov">          1 :         aTrackData.mEvictionIndex.mEvictable -= sizeRemoved;</span>
<span class="lineNum">    1911 </span>            :       } else {
<span class="lineNum">    1912 </span><span class="lineCov">          1 :         ResetEvictionIndex(aTrackData);</span>
<span class="lineNum">    1913 </span>            :       }
<span class="lineNum">    1914 </span>            :     }
<span class="lineNum">    1915 </span>            :   }
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span><span class="lineCov">          1 :   if (aTrackData.mNextInsertionIndex.isSome()) {</span>
<span class="lineNum">    1918 </span><span class="lineCov">          1 :     if (aTrackData.mNextInsertionIndex.ref() &gt; firstRemovedIndex.ref() &amp;&amp;</span>
<span class="lineNum">    1919 </span><span class="lineCov">          1 :         aTrackData.mNextInsertionIndex.ref() &lt;= lastRemovedIndex + 1) {</span>
<span class="lineNum">    1920 </span><span class="lineCov">          1 :       aTrackData.ResetAppendState();</span>
<span class="lineNum">    1921 </span><span class="lineCov">          1 :       MSE_DEBUG(&quot;NextInsertionIndex got reset.&quot;);</span>
<span class="lineNum">    1922 </span><span class="lineCov">          1 :     } else if (aTrackData.mNextInsertionIndex.ref() &gt; lastRemovedIndex + 1) {</span>
<span class="lineNum">    1923 </span><span class="lineCov">          1 :       aTrackData.mNextInsertionIndex.ref() -=</span>
<span class="lineNum">    1924 </span><span class="lineCov">          1 :         lastRemovedIndex - firstRemovedIndex.ref() + 1;</span>
<span class="lineNum">    1925 </span>            :     }
<span class="lineNum">    1926 </span>            :   }
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            :   // Update our buffered range to exclude the range just removed.
<span class="lineNum">    1929 </span><span class="lineCov">          1 :   aTrackData.mBufferedRanges -= removedIntervals;</span>
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span>            :   // Recalculate sanitized buffered ranges.
<span class="lineNum">    1932 </span><span class="lineCov">          1 :   aTrackData.mSanitizedBufferedRanges = aTrackData.mBufferedRanges;</span>
<span class="lineNum">    1933 </span><span class="lineCov">          1 :   aTrackData.mSanitizedBufferedRanges.SetFuzz(maxSampleDuration/2);</span>
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span>            :   data.RemoveElementsAt(firstRemovedIndex.ref(),
<span class="lineNum">    1936 </span><span class="lineCov">          1 :                         lastRemovedIndex - firstRemovedIndex.ref() + 1);</span>
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span><span class="lineCov">          1 :   if (aIntervals.GetEnd() &gt;= aTrackData.mHighestStartTimestamp) {</span>
<span class="lineNum">    1939 </span>            :     // The sample with the highest presentation time got removed.
<span class="lineNum">    1940 </span>            :     // Rescan the trackbuffer to determine the new one.
<span class="lineNum">    1941 </span><span class="lineCov">          1 :     int64_t highestStartTime = 0;</span>
<span class="lineNum">    1942 </span><span class="lineCov">          1 :     for (const auto&amp; sample : data) {</span>
<span class="lineNum">    1943 </span><span class="lineCov">          1 :       if (sample-&gt;mTime &gt; highestStartTime) {</span>
<span class="lineNum">    1944 </span><span class="lineCov">          1 :         highestStartTime = sample-&gt;mTime;</span>
<span class="lineNum">    1945 </span>            :       }
<span class="lineNum">    1946 </span>            :     }
<span class="lineNum">    1947 </span><span class="lineCov">          1 :     MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    1948 </span>            :     aTrackData.mHighestStartTimestamp =
<span class="lineNum">    1949 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(highestStartTime);</span>
<span class="lineNum">    1950 </span>            :   }
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineCov">          1 :   return firstRemovedIndex.ref();</span>
<span class="lineNum">    1953 </span>            : }
<a name="1954"><span class="lineNum">    1954 </span>            : </a>
<span class="lineNum">    1955 </span>            : void
<span class="lineNum">    1956 </span><span class="lineCov">          1 : TrackBuffersManager::RecreateParser(bool aReuseInitData)</span>
<span class="lineNum">    1957 </span>            : {
<span class="lineNum">    1958 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    1959 </span>            :   // Recreate our parser for only the data remaining. This is required
<span class="lineNum">    1960 </span>            :   // as it has parsed the entire InputBuffer provided.
<span class="lineNum">    1961 </span>            :   // Once the old TrackBuffer/MediaSource implementation is removed
<span class="lineNum">    1962 </span>            :   // we can optimize this part. TODO
<span class="lineNum">    1963 </span><span class="lineCov">          1 :   mParser = ContainerParser::CreateForMIMEType(mType);</span>
<span class="lineNum">    1964 </span><span class="lineCov">          1 :   if (aReuseInitData &amp;&amp; mInitData) {</span>
<span class="lineNum">    1965 </span>            :     int64_t start, end;
<span class="lineNum">    1966 </span><span class="lineCov">          1 :     mParser-&gt;ParseStartAndEndTimestamps(mInitData, start, end);</span>
<span class="lineNum">    1967 </span><span class="lineCov">          1 :     mProcessedInput = mInitData-&gt;Length();</span>
<span class="lineNum">    1968 </span>            :   } else {
<span class="lineNum">    1969 </span><span class="lineCov">          1 :     mProcessedInput = 0;</span>
<span class="lineNum">    1970 </span>            :   }
<span class="lineNum">    1971 </span><span class="lineCov">          1 : }</span>
<a name="1972"><span class="lineNum">    1972 </span>            : </a>
<span class="lineNum">    1973 </span>            : nsTArray&lt;TrackBuffersManager::TrackData*&gt;
<span class="lineNum">    1974 </span><span class="lineCov">          1 : TrackBuffersManager::GetTracksList()</span>
<span class="lineNum">    1975 </span>            : {
<span class="lineNum">    1976 </span>            :   nsTArray&lt;TrackData*&gt; tracks;
<span class="lineNum">    1977 </span><span class="lineCov">          1 :   if (HasVideo()) {</span>
<span class="lineNum">    1978 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mVideoTracks);</span>
<span class="lineNum">    1979 </span>            :   }
<span class="lineNum">    1980 </span><span class="lineCov">          1 :   if (HasAudio()) {</span>
<span class="lineNum">    1981 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mAudioTracks);</span>
<span class="lineNum">    1982 </span>            :   }
<span class="lineNum">    1983 </span><span class="lineCov">          1 :   return tracks;</span>
<span class="lineNum">    1984 </span>            : }
<a name="1985"><span class="lineNum">    1985 </span>            : </a>
<span class="lineNum">    1986 </span>            : nsTArray&lt;const TrackBuffersManager::TrackData*&gt;
<span class="lineNum">    1987 </span><span class="lineCov">          1 : TrackBuffersManager::GetTracksList() const</span>
<span class="lineNum">    1988 </span>            : {
<span class="lineNum">    1989 </span>            :   nsTArray&lt;const TrackData*&gt; tracks;
<span class="lineNum">    1990 </span><span class="lineCov">          1 :   if (HasVideo()) {</span>
<span class="lineNum">    1991 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mVideoTracks);</span>
<span class="lineNum">    1992 </span>            :   }
<span class="lineNum">    1993 </span><span class="lineCov">          1 :   if (HasAudio()) {</span>
<span class="lineNum">    1994 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mAudioTracks);</span>
<span class="lineNum">    1995 </span>            :   }
<span class="lineNum">    1996 </span><span class="lineCov">          1 :   return tracks;</span>
<span class="lineNum">    1997 </span>            : }
<a name="1998"><span class="lineNum">    1998 </span>            : </a>
<span class="lineNum">    1999 </span>            : void
<span class="lineNum">    2000 </span><span class="lineCov">          1 : TrackBuffersManager::SetAppendState(SourceBufferAttributes::AppendState aAppendState)</span>
<span class="lineNum">    2001 </span>            : {
<span class="lineNum">    2002 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;AppendState changed from %s to %s&quot;,</span>
<span class="lineNum">    2003 </span>            :             AppendStateToStr(mSourceBufferAttributes-&gt;GetAppendState()), AppendStateToStr(aAppendState));
<span class="lineNum">    2004 </span><span class="lineCov">          1 :   mSourceBufferAttributes-&gt;SetAppendState(aAppendState);</span>
<span class="lineNum">    2005 </span><span class="lineCov">          1 : }</span>
<a name="2006"><span class="lineNum">    2006 </span>            : </a>
<span class="lineNum">    2007 </span>            : MediaInfo
<span class="lineNum">    2008 </span><span class="lineCov">          1 : TrackBuffersManager::GetMetadata() const</span>
<span class="lineNum">    2009 </span>            : {
<span class="lineNum">    2010 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2011 </span><span class="lineCov">          1 :   return mInfo;</span>
<span class="lineNum">    2012 </span>            : }
<a name="2013"><span class="lineNum">    2013 </span>            : </a>
<span class="lineNum">    2014 </span>            : const TimeIntervals&amp;
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 : TrackBuffersManager::Buffered(TrackInfo::TrackType aTrack) const</span>
<span class="lineNum">    2016 </span>            : {
<span class="lineNum">    2017 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2018 </span><span class="lineCov">          1 :   return GetTracksData(aTrack).mBufferedRanges;</span>
<span class="lineNum">    2019 </span>            : }
<a name="2020"><span class="lineNum">    2020 </span>            : </a>
<span class="lineNum">    2021 </span>            : const media::TimeUnit&amp;
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 : TrackBuffersManager::HighestStartTime(TrackInfo::TrackType aTrack) const</span>
<span class="lineNum">    2023 </span>            : {
<span class="lineNum">    2024 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2025 </span><span class="lineCov">          1 :   return GetTracksData(aTrack).mHighestStartTimestamp;</span>
<span class="lineNum">    2026 </span>            : }
<a name="2027"><span class="lineNum">    2027 </span>            : </a>
<span class="lineNum">    2028 </span>            : TimeIntervals
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 : TrackBuffersManager::SafeBuffered(TrackInfo::TrackType aTrack) const</span>
<span class="lineNum">    2030 </span>            : {
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2032 </span>            :   return aTrack == TrackInfo::kVideoTrack
<span class="lineNum">    2033 </span>            :     ? mVideoBufferedRanges
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :     : mAudioBufferedRanges;</span>
<span class="lineNum">    2035 </span>            : }
<a name="2036"><span class="lineNum">    2036 </span>            : </a>
<span class="lineNum">    2037 </span>            : TimeUnit
<span class="lineNum">    2038 </span><span class="lineCov">          1 : TrackBuffersManager::HighestStartTime() const</span>
<span class="lineNum">    2039 </span>            : {
<span class="lineNum">    2040 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2041 </span><span class="lineCov">          1 :   TimeUnit highestStartTime;</span>
<span class="lineNum">    2042 </span><span class="lineCov">          1 :   for (auto&amp; track : GetTracksList()) {</span>
<span class="lineNum">    2043 </span>            :     highestStartTime =
<span class="lineNum">    2044 </span><span class="lineCov">          1 :       std::max(track-&gt;mHighestStartTimestamp, highestStartTime);</span>
<span class="lineNum">    2045 </span>            :   }
<span class="lineNum">    2046 </span><span class="lineCov">          1 :   return highestStartTime;</span>
<span class="lineNum">    2047 </span>            : }
<a name="2048"><span class="lineNum">    2048 </span>            : </a>
<span class="lineNum">    2049 </span>            : TimeUnit
<span class="lineNum">    2050 </span><span class="lineCov">          1 : TrackBuffersManager::HighestEndTime() const</span>
<span class="lineNum">    2051 </span>            : {
<span class="lineNum">    2052 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span>            :   nsTArray&lt;const TimeIntervals*&gt; tracks;
<span class="lineNum">    2055 </span><span class="lineCov">          1 :   if (HasVideo()) {</span>
<span class="lineNum">    2056 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mVideoBufferedRanges);</span>
<span class="lineNum">    2057 </span>            :   }
<span class="lineNum">    2058 </span><span class="lineCov">          1 :   if (HasAudio()) {</span>
<span class="lineNum">    2059 </span><span class="lineCov">          1 :     tracks.AppendElement(&amp;mAudioBufferedRanges);</span>
<span class="lineNum">    2060 </span>            :   }
<span class="lineNum">    2061 </span><span class="lineCov">          1 :   return HighestEndTime(tracks);</span>
<span class="lineNum">    2062 </span>            : }
<a name="2063"><span class="lineNum">    2063 </span>            : </a>
<span class="lineNum">    2064 </span>            : TimeUnit
<span class="lineNum">    2065 </span><span class="lineCov">          1 : TrackBuffersManager::HighestEndTime(</span>
<span class="lineNum">    2066 </span>            :   nsTArray&lt;const TimeIntervals*&gt;&amp; aTracks) const
<span class="lineNum">    2067 </span>            : {
<span class="lineNum">    2068 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineCov">          1 :   TimeUnit highestEndTime;</span>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineCov">          1 :   for (const auto&amp; trackRanges : aTracks) {</span>
<span class="lineNum">    2073 </span><span class="lineCov">          1 :     highestEndTime = std::max(trackRanges-&gt;GetEnd(), highestEndTime);</span>
<span class="lineNum">    2074 </span>            :   }
<span class="lineNum">    2075 </span><span class="lineCov">          1 :   return highestEndTime;</span>
<span class="lineNum">    2076 </span>            : }
<a name="2077"><span class="lineNum">    2077 </span>            : </a>
<span class="lineNum">    2078 </span>            : void
<span class="lineNum">    2079 </span><span class="lineCov">          1 : TrackBuffersManager::ResetEvictionIndex(TrackData&amp; aTrackData)</span>
<span class="lineNum">    2080 </span>            : {
<span class="lineNum">    2081 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2082 </span><span class="lineCov">          1 :   aTrackData.mEvictionIndex.Reset();</span>
<span class="lineNum">    2083 </span><span class="lineCov">          1 : }</span>
<a name="2084"><span class="lineNum">    2084 </span>            : </a>
<span class="lineNum">    2085 </span>            : void
<span class="lineNum">    2086 </span><span class="lineCov">          1 : TrackBuffersManager::UpdateEvictionIndex(TrackData&amp; aTrackData,</span>
<span class="lineNum">    2087 </span>            :                                          uint32_t currentIndex)
<span class="lineNum">    2088 </span>            : {
<span class="lineNum">    2089 </span><span class="lineCov">          1 :   uint32_t evictable = 0;</span>
<span class="lineNum">    2090 </span><span class="lineCov">          1 :   TrackBuffer&amp; data = aTrackData.GetTrackBuffer();</span>
<span class="lineNum">    2091 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(currentIndex &gt;= aTrackData.mEvictionIndex.mLastIndex,</span>
<span class="lineNum">    2092 </span>            :                         &quot;Invalid call&quot;);
<span class="lineNum">    2093 </span><span class="lineCov">          1 :   MOZ_DIAGNOSTIC_ASSERT(currentIndex == data.Length() ||</span>
<span class="lineNum">    2094 </span>            :                         data[currentIndex]-&gt;mKeyframe,&quot;Must stop at keyframe&quot;);
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span><span class="lineCov">          1 :   for (uint32_t i = aTrackData.mEvictionIndex.mLastIndex; i &lt; currentIndex;</span>
<span class="lineNum">    2097 </span>            :        i++) {
<span class="lineNum">    2098 </span><span class="lineCov">          1 :     evictable += data[i]-&gt;ComputedSizeOfIncludingThis();</span>
<span class="lineNum">    2099 </span>            :   }
<span class="lineNum">    2100 </span><span class="lineCov">          1 :   aTrackData.mEvictionIndex.mLastIndex = currentIndex;</span>
<span class="lineNum">    2101 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2102 </span><span class="lineCov">          1 :   aTrackData.mEvictionIndex.mEvictable += evictable;</span>
<span class="lineNum">    2103 </span><span class="lineCov">          1 : }</span>
<a name="2104"><span class="lineNum">    2104 </span>            : </a>
<span class="lineNum">    2105 </span>            : const TrackBuffersManager::TrackBuffer&amp;
<span class="lineNum">    2106 </span><span class="lineCov">          1 : TrackBuffersManager::GetTrackBuffer(TrackInfo::TrackType aTrack) const</span>
<span class="lineNum">    2107 </span>            : {
<span class="lineNum">    2108 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2109 </span><span class="lineCov">          1 :   return GetTracksData(aTrack).GetTrackBuffer();</span>
<a name="2110"><span class="lineNum">    2110 </span>            : }</a>
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span><span class="lineCov">          1 : uint32_t TrackBuffersManager::FindSampleIndex(const TrackBuffer&amp; aTrackBuffer,</span>
<span class="lineNum">    2113 </span>            :                                               const TimeInterval&amp; aInterval)
<span class="lineNum">    2114 </span>            : {
<span class="lineNum">    2115 </span><span class="lineCov">          1 :   TimeUnit target = aInterval.mStart - aInterval.mFuzz;</span>
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; aTrackBuffer.Length(); i++) {</span>
<span class="lineNum">    2118 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = aTrackBuffer[i];</span>
<span class="lineNum">    2119 </span><span class="lineCov">          1 :     if (sample-&gt;mTime &gt;= target.ToMicroseconds() ||</span>
<span class="lineNum">    2120 </span><span class="lineCov">          1 :         sample-&gt;GetEndTime() &gt; target) {</span>
<span class="lineNum">    2121 </span><span class="lineCov">          1 :       return i;</span>
<span class="lineNum">    2122 </span>            :     }
<span class="lineNum">    2123 </span>            :   }
<span class="lineNum">    2124 </span>            :   NS_ASSERTION(false, &quot;FindSampleIndex called with invalid arguments&quot;);
<span class="lineNum">    2125 </span>            : 
<span class="lineNum">    2126 </span>            :   return 0;
<span class="lineNum">    2127 </span>            : }
<a name="2128"><span class="lineNum">    2128 </span>            : </a>
<span class="lineNum">    2129 </span>            : TimeUnit
<span class="lineNum">    2130 </span><span class="lineCov">          1 : TrackBuffersManager::Seek(TrackInfo::TrackType aTrack,</span>
<span class="lineNum">    2131 </span>            :                           const TimeUnit&amp; aTime,
<span class="lineNum">    2132 </span>            :                           const TimeUnit&amp; aFuzz)
<span class="lineNum">    2133 </span>            : {
<span class="lineNum">    2134 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2135 </span><span class="lineCov">          1 :   auto&amp; trackBuffer = GetTracksData(aTrack);</span>
<span class="lineNum">    2136 </span><span class="lineCov">          1 :   const TrackBuffersManager::TrackBuffer&amp; track = GetTrackBuffer(aTrack);</span>
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span><span class="lineCov">          1 :   if (!track.Length()) {</span>
<span class="lineNum">    2139 </span>            :     // This a reset. It will be followed by another valid seek.
<span class="lineNum">    2140 </span><span class="lineCov">          1 :     trackBuffer.mNextGetSampleIndex = Some(uint32_t(0));</span>
<span class="lineNum">    2141 </span><span class="lineCov">          1 :     trackBuffer.mNextSampleTimecode = TimeUnit();</span>
<span class="lineNum">    2142 </span><span class="lineCov">          1 :     trackBuffer.mNextSampleTime = TimeUnit();</span>
<span class="lineNum">    2143 </span><span class="lineCov">          1 :     ResetEvictionIndex(trackBuffer);</span>
<span class="lineNum">    2144 </span><span class="lineCov">          1 :     return TimeUnit();</span>
<span class="lineNum">    2145 </span>            :   }
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineCov">          1 :   uint32_t i = 0;</span>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span><span class="lineCov">          1 :   if (aTime != TimeUnit()) {</span>
<span class="lineNum">    2150 </span>            :     // Determine the interval of samples we're attempting to seek to.
<span class="lineNum">    2151 </span><span class="lineCov">          1 :     TimeIntervals buffered = trackBuffer.mBufferedRanges;</span>
<span class="lineNum">    2152 </span>            :     // Fuzz factor is +/- aFuzz; as we want to only eliminate gaps
<span class="lineNum">    2153 </span>            :     // that are less than aFuzz wide, we set a fuzz factor aFuzz/2.
<span class="lineNum">    2154 </span><span class="lineCov">          1 :     buffered.SetFuzz(aFuzz / 2);</span>
<span class="lineNum">    2155 </span><span class="lineCov">          1 :     TimeIntervals::IndexType index = buffered.Find(aTime);</span>
<span class="lineNum">    2156 </span>            :     MOZ_ASSERT(index != TimeIntervals::NoIndex,
<span class="lineNum">    2157 </span>            :                &quot;We shouldn't be called if aTime isn't buffered&quot;);
<span class="lineNum">    2158 </span><span class="lineCov">          1 :     TimeInterval target = buffered[index];</span>
<span class="lineNum">    2159 </span><span class="lineCov">          1 :     target.mFuzz = aFuzz;</span>
<span class="lineNum">    2160 </span><span class="lineCov">          1 :     i = FindSampleIndex(track, target);</span>
<span class="lineNum">    2161 </span>            :   }
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span>            :   Maybe&lt;TimeUnit&gt; lastKeyFrameTime;
<span class="lineNum">    2164 </span><span class="lineCov">          1 :   TimeUnit lastKeyFrameTimecode;</span>
<span class="lineNum">    2165 </span><span class="lineCov">          1 :   uint32_t lastKeyFrameIndex = 0;</span>
<span class="lineNum">    2166 </span><span class="lineCov">          1 :   for (; i &lt; track.Length(); i++) {</span>
<span class="lineNum">    2167 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = track[i];</span>
<span class="lineNum">    2168 </span><span class="lineCov">          1 :     TimeUnit sampleTime = TimeUnit::FromMicroseconds(sample-&gt;mTime);</span>
<span class="lineNum">    2169 </span><span class="lineCov">          1 :     if (sampleTime &gt; aTime &amp;&amp; lastKeyFrameTime.isSome()) {</span>
<span class="lineNum">    2170 </span>            :       break;
<span class="lineNum">    2171 </span>            :     }
<span class="lineNum">    2172 </span><span class="lineCov">          1 :     if (sample-&gt;mKeyframe) {</span>
<span class="lineNum">    2173 </span><span class="lineCov">          1 :       lastKeyFrameTimecode = TimeUnit::FromMicroseconds(sample-&gt;mTimecode);</span>
<span class="lineNum">    2174 </span><span class="lineCov">          1 :       lastKeyFrameTime = Some(sampleTime);</span>
<span class="lineNum">    2175 </span><span class="lineCov">          1 :       lastKeyFrameIndex = i;</span>
<span class="lineNum">    2176 </span>            :     }
<span class="lineNum">    2177 </span><span class="lineCov">          1 :     if (sampleTime == aTime ||</span>
<span class="lineNum">    2178 </span><span class="lineCov">          1 :         (sampleTime &gt; aTime &amp;&amp; lastKeyFrameTime.isSome())) {</span>
<span class="lineNum">    2179 </span>            :       break;
<span class="lineNum">    2180 </span>            :     }
<span class="lineNum">    2181 </span>            :   }
<span class="lineNum">    2182 </span><span class="lineCov">          1 :   MSE_DEBUG(&quot;Keyframe %s found at %&quot; PRId64 &quot; @ %u&quot;,</span>
<span class="lineNum">    2183 </span>            :             lastKeyFrameTime.isSome() ? &quot;&quot; : &quot;not&quot;,
<span class="lineNum">    2184 </span>            :             lastKeyFrameTime.refOr(TimeUnit()).ToMicroseconds(),
<span class="lineNum">    2185 </span>            :             lastKeyFrameIndex);
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span><span class="lineCov">          1 :   trackBuffer.mNextGetSampleIndex = Some(lastKeyFrameIndex);</span>
<span class="lineNum">    2188 </span><span class="lineCov">          1 :   trackBuffer.mNextSampleTimecode = lastKeyFrameTimecode;</span>
<span class="lineNum">    2189 </span><span class="lineCov">          1 :   trackBuffer.mNextSampleTime = lastKeyFrameTime.refOr(TimeUnit());</span>
<span class="lineNum">    2190 </span><span class="lineCov">          1 :   ResetEvictionIndex(trackBuffer);</span>
<span class="lineNum">    2191 </span><span class="lineCov">          1 :   UpdateEvictionIndex(trackBuffer, lastKeyFrameIndex);</span>
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span><span class="lineCov">          1 :   return lastKeyFrameTime.refOr(TimeUnit());</span>
<span class="lineNum">    2194 </span>            : }
<a name="2195"><span class="lineNum">    2195 </span>            : </a>
<span class="lineNum">    2196 </span>            : uint32_t
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 : TrackBuffersManager::SkipToNextRandomAccessPoint(TrackInfo::TrackType aTrack,</span>
<span class="lineNum">    2198 </span>            :                                                  const TimeUnit&amp; aTimeThreadshold,
<span class="lineNum">    2199 </span>            :                                                  const media::TimeUnit&amp; aFuzz,
<span class="lineNum">    2200 </span>            :                                                  bool&amp; aFound)
<span class="lineNum">    2201 </span>            : {
<span class="lineNum">    2202 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :   uint32_t parsed = 0;</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :   auto&amp; trackData = GetTracksData(aTrack);</span>
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :   const TrackBuffer&amp; track = GetTrackBuffer(aTrack);</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :   aFound = false;</span>
<span class="lineNum">    2207 </span>            : 
<span class="lineNum">    2208 </span>            :   // SkipToNextRandomAccessPoint can only be called if aTimeThreadshold is known
<span class="lineNum">    2209 </span>            :   // to be buffered.
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span>            :   // So first determine the current position in the track buffer if necessary.
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :   if (trackData.mNextGetSampleIndex.isNothing()) {</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :     if (trackData.mNextSampleTimecode == TimeUnit()) {</span>
<span class="lineNum">    2214 </span>            :       // First demux, get first sample.
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :       trackData.mNextGetSampleIndex = Some(0u);</span>
<span class="lineNum">    2216 </span>            :     } else {
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :       int32_t pos = FindCurrentPosition(aTrack, aFuzz);</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :       if (pos &lt; 0) {</span>
<span class="lineNum">    2219 </span>            :         return 0;
<span class="lineNum">    2220 </span>            :       }
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :       trackData.mNextGetSampleIndex = Some(uint32_t(pos));</span>
<span class="lineNum">    2222 </span>            :     }
<span class="lineNum">    2223 </span>            :   }
<span class="lineNum">    2224 </span>            : 
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :   TimeUnit nextSampleTimecode = trackData.mNextSampleTimecode;</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :   TimeUnit nextSampleTime = trackData.mNextSampleTime;</span>
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :   uint32_t i = trackData.mNextGetSampleIndex.ref();</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :   int32_t originalPos = i;</span>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :   for (; i &lt; track.Length(); i++) {</span>
<span class="lineNum">    2231 </span>            :     const MediaRawData* sample =
<span class="lineNum">    2232 </span>            :       GetSample(aTrack,
<span class="lineNum">    2233 </span>            :                 i,
<span class="lineNum">    2234 </span>            :                 nextSampleTimecode,
<span class="lineNum">    2235 </span>            :                 nextSampleTime,
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :                 aFuzz);</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :     if (!sample) {</span>
<span class="lineNum">    2238 </span>            :       break;
<span class="lineNum">    2239 </span>            :     }
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :     if (sample-&gt;mKeyframe &amp;&amp;</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :         sample-&gt;mTime &gt;= aTimeThreadshold.ToMicroseconds()) {</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :       aFound = true;</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2244 </span>            :     }
<span class="lineNum">    2245 </span>            :     nextSampleTimecode =
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode) + sample-&gt;mDuration;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :     nextSampleTime = sample-&gt;GetEndTime();</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :     parsed++;</span>
<span class="lineNum">    2249 </span>            :   }
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :   // Adjust the next demux time and index so that the next call to
<span class="lineNum">    2252 </span>            :   // SkipToNextRandomAccessPoint will not count again the parsed sample as
<span class="lineNum">    2253 </span>            :   // skipped.
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :   if (aFound) {</span>
<span class="lineNum">    2255 </span>            :     trackData.mNextSampleTimecode =
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :        TimeUnit::FromMicroseconds(track[i]-&gt;mTimecode);</span>
<span class="lineNum">    2257 </span>            :     trackData.mNextSampleTime =
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :        TimeUnit::FromMicroseconds(track[i]-&gt;mTime);</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :     trackData.mNextGetSampleIndex = Some(i);</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :   } else if (i &gt; 0) {</span>
<span class="lineNum">    2261 </span>            :     // Go back to the previous keyframe or the original position so the next
<span class="lineNum">    2262 </span>            :     // demux can succeed and be decoded.
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     for (int j = i - 1; j &gt;= originalPos; j--) {</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :       const RefPtr&lt;MediaRawData&gt;&amp; sample = track[j];</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :       if (sample-&gt;mKeyframe) {</span>
<span class="lineNum">    2266 </span>            :         trackData.mNextSampleTimecode =
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :           TimeUnit::FromMicroseconds(sample-&gt;mTimecode);</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         trackData.mNextSampleTime = TimeUnit::FromMicroseconds(sample-&gt;mTime);</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :         trackData.mNextGetSampleIndex = Some(uint32_t(j));</span>
<span class="lineNum">    2270 </span>            :         // We are unable to skip to a keyframe past aTimeThreshold, however
<span class="lineNum">    2271 </span>            :         // we are speeding up decoding by dropping the unplayable frames.
<span class="lineNum">    2272 </span>            :         // So we can mark aFound as true.
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         aFound = true;</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2275 </span>            :       }
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :       parsed--;</span>
<span class="lineNum">    2277 </span>            :     }
<span class="lineNum">    2278 </span>            :   }
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :   if (aFound) {</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :     UpdateEvictionIndex(trackData, trackData.mNextGetSampleIndex.ref());</span>
<span class="lineNum">    2282 </span>            :   }
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :   return parsed;</span>
<span class="lineNum">    2285 </span>            : }
<a name="2286"><span class="lineNum">    2286 </span>            : </a>
<span class="lineNum">    2287 </span>            : const MediaRawData*
<span class="lineNum">    2288 </span><span class="lineCov">          1 : TrackBuffersManager::GetSample(TrackInfo::TrackType aTrack,</span>
<span class="lineNum">    2289 </span>            :                                uint32_t aIndex,
<span class="lineNum">    2290 </span>            :                                const TimeUnit&amp; aExpectedDts,
<span class="lineNum">    2291 </span>            :                                const TimeUnit&amp; aExpectedPts,
<span class="lineNum">    2292 </span>            :                                const TimeUnit&amp; aFuzz)
<span class="lineNum">    2293 </span>            : {
<span class="lineNum">    2294 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2295 </span><span class="lineCov">          1 :   const TrackBuffer&amp; track = GetTrackBuffer(aTrack);</span>
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span><span class="lineCov">          1 :   if (aIndex &gt;= track.Length()) {</span>
<span class="lineNum">    2298 </span>            :     // reached the end.
<span class="lineNum">    2299 </span>            :     return nullptr;
<span class="lineNum">    2300 </span>            :   }
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span><span class="lineCov">          1 :   const RefPtr&lt;MediaRawData&gt;&amp; sample = track[aIndex];</span>
<span class="lineNum">    2303 </span><span class="lineCov">          1 :   if (!aIndex || sample-&gt;mTimecode &lt;= (aExpectedDts + aFuzz).ToMicroseconds() ||</span>
<span class="lineNum">    2304 </span><span class="lineCov">          1 :       sample-&gt;mTime &lt;= (aExpectedPts + aFuzz).ToMicroseconds()) {</span>
<span class="lineNum">    2305 </span><span class="lineCov">          1 :     return sample;</span>
<span class="lineNum">    2306 </span>            :   }
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span>            :   // Gap is too big. End of Stream or Waiting for Data.
<span class="lineNum">    2309 </span>            :   // TODO, check that we have continuous data based on the sanitized buffered
<span class="lineNum">    2310 </span>            :   // range instead.
<span class="lineNum">    2311 </span>            :   return nullptr;
<span class="lineNum">    2312 </span>            : }
<a name="2313"><span class="lineNum">    2313 </span>            : </a>
<span class="lineNum">    2314 </span>            : already_AddRefed&lt;MediaRawData&gt;
<span class="lineNum">    2315 </span><span class="lineCov">          1 : TrackBuffersManager::GetSample(TrackInfo::TrackType aTrack,</span>
<span class="lineNum">    2316 </span>            :                                const TimeUnit&amp; aFuzz,
<span class="lineNum">    2317 </span>            :                                MediaResult&amp; aResult)
<span class="lineNum">    2318 </span>            : {
<span class="lineNum">    2319 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2320 </span><span class="lineCov">          1 :   auto&amp; trackData = GetTracksData(aTrack);</span>
<span class="lineNum">    2321 </span><span class="lineCov">          1 :   const TrackBuffer&amp; track = GetTrackBuffer(aTrack);</span>
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span><span class="lineCov">          1 :   aResult = NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA;</span>
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span><span class="lineCov">          1 :   if (!track.Length()) {</span>
<span class="lineNum">    2326 </span><span class="lineCov">          1 :     aResult = NS_ERROR_DOM_MEDIA_END_OF_STREAM;</span>
<span class="lineNum">    2327 </span><span class="lineCov">          1 :     return nullptr;</span>
<span class="lineNum">    2328 </span>            :   }
<span class="lineNum">    2329 </span>            : 
<span class="lineNum">    2330 </span><span class="lineCov">          1 :   if (trackData.mNextGetSampleIndex.isNothing() &amp;&amp;</span>
<span class="lineNum">    2331 </span><span class="lineCov">          1 :       trackData.mNextSampleTimecode == TimeUnit()) {</span>
<span class="lineNum">    2332 </span>            :     // First demux, get first sample.
<span class="lineNum">    2333 </span><span class="lineCov">          1 :     trackData.mNextGetSampleIndex = Some(0u);</span>
<span class="lineNum">    2334 </span>            :   }
<span class="lineNum">    2335 </span>            : 
<span class="lineNum">    2336 </span><span class="lineCov">          1 :   if (trackData.mNextGetSampleIndex.isSome()) {</span>
<span class="lineNum">    2337 </span><span class="lineCov">          1 :     if (trackData.mNextGetSampleIndex.ref() &gt;= track.Length()) {</span>
<span class="lineNum">    2338 </span><span class="lineCov">          1 :       aResult = NS_ERROR_DOM_MEDIA_END_OF_STREAM;</span>
<span class="lineNum">    2339 </span><span class="lineCov">          1 :       return nullptr;</span>
<span class="lineNum">    2340 </span>            :     }
<span class="lineNum">    2341 </span>            :     const MediaRawData* sample =
<span class="lineNum">    2342 </span>            :       GetSample(aTrack,
<span class="lineNum">    2343 </span><span class="lineCov">          1 :                 trackData.mNextGetSampleIndex.ref(),</span>
<span class="lineNum">    2344 </span>            :                 trackData.mNextSampleTimecode,
<span class="lineNum">    2345 </span>            :                 trackData.mNextSampleTime,
<span class="lineNum">    2346 </span><span class="lineCov">          1 :                 aFuzz);</span>
<span class="lineNum">    2347 </span><span class="lineCov">          1 :     if (!sample) {</span>
<span class="lineNum">    2348 </span><span class="lineCov">          1 :       return nullptr;</span>
<span class="lineNum">    2349 </span>            :     }
<span class="lineNum">    2350 </span>            : 
<span class="lineNum">    2351 </span><span class="lineCov">          1 :     RefPtr&lt;MediaRawData&gt; p = sample-&gt;Clone();</span>
<span class="lineNum">    2352 </span><span class="lineCov">          1 :     if (!p) {</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :       aResult = MediaResult(NS_ERROR_OUT_OF_MEMORY, __func__);</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    2355 </span>            :     }
<span class="lineNum">    2356 </span><span class="lineCov">          1 :     if (p-&gt;mKeyframe) {</span>
<span class="lineNum">    2357 </span><span class="lineCov">          1 :       UpdateEvictionIndex(trackData, trackData.mNextGetSampleIndex.ref());</span>
<span class="lineNum">    2358 </span>            :     }
<span class="lineNum">    2359 </span><span class="lineCov">          1 :     trackData.mNextGetSampleIndex.ref()++;</span>
<span class="lineNum">    2360 </span>            :     // Estimate decode timestamp and timestamp of the next sample.
<span class="lineNum">    2361 </span>            :     TimeUnit nextSampleTimecode =
<span class="lineNum">    2362 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode) + sample-&gt;mDuration;</span>
<span class="lineNum">    2363 </span><span class="lineCov">          1 :     TimeUnit nextSampleTime = sample-&gt;GetEndTime();</span>
<span class="lineNum">    2364 </span>            :     const MediaRawData* nextSample =
<span class="lineNum">    2365 </span>            :       GetSample(aTrack,
<span class="lineNum">    2366 </span><span class="lineCov">          1 :                 trackData.mNextGetSampleIndex.ref(),</span>
<span class="lineNum">    2367 </span>            :                 nextSampleTimecode,
<span class="lineNum">    2368 </span>            :                 nextSampleTime,
<span class="lineNum">    2369 </span><span class="lineCov">          1 :                 aFuzz);</span>
<span class="lineNum">    2370 </span><span class="lineCov">          1 :     if (nextSample) {</span>
<span class="lineNum">    2371 </span>            :       // We have a valid next sample, can use exact values.
<span class="lineNum">    2372 </span>            :       trackData.mNextSampleTimecode =
<span class="lineNum">    2373 </span><span class="lineCov">          1 :         TimeUnit::FromMicroseconds(nextSample-&gt;mTimecode);</span>
<span class="lineNum">    2374 </span>            :       trackData.mNextSampleTime =
<span class="lineNum">    2375 </span><span class="lineCov">          1 :         TimeUnit::FromMicroseconds(nextSample-&gt;mTime);</span>
<span class="lineNum">    2376 </span>            :     } else {
<span class="lineNum">    2377 </span>            :       // Next sample isn't available yet. Use estimates.
<span class="lineNum">    2378 </span><span class="lineCov">          1 :       trackData.mNextSampleTimecode = nextSampleTimecode;</span>
<span class="lineNum">    2379 </span><span class="lineCov">          1 :       trackData.mNextSampleTime = nextSampleTime;</span>
<span class="lineNum">    2380 </span>            :     }
<span class="lineNum">    2381 </span><span class="lineCov">          1 :     aResult = NS_OK;</span>
<span class="lineNum">    2382 </span><span class="lineCov">          1 :     return p.forget();</span>
<span class="lineNum">    2383 </span>            :   }
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineCov">          1 :   if (trackData.mNextSampleTimecode &gt;</span>
<span class="lineNum">    2386 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(track.LastElement()-&gt;mTimecode)</span>
<span class="lineNum">    2387 </span><span class="lineCov">          1 :        + track.LastElement()-&gt;mDuration) {</span>
<span class="lineNum">    2388 </span>            :     // The next element is past our last sample. We're done.
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :     trackData.mNextGetSampleIndex = Some(uint32_t(track.Length()));</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :     aResult = NS_ERROR_DOM_MEDIA_END_OF_STREAM;</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2392 </span>            :   }
<span class="lineNum">    2393 </span>            : 
<span class="lineNum">    2394 </span>            :   // Our previous index has been overwritten, attempt to find the new one.
<span class="lineNum">    2395 </span><span class="lineCov">          1 :   int32_t pos = FindCurrentPosition(aTrack, aFuzz);</span>
<span class="lineNum">    2396 </span><span class="lineCov">          1 :   if (pos &lt; 0) {</span>
<span class="lineNum">    2397 </span><span class="lineCov">          1 :     MSE_DEBUG(&quot;Couldn't find sample (pts:%&quot; PRId64 &quot; dts:%&quot; PRId64 &quot;)&quot;,</span>
<span class="lineNum">    2398 </span>            :               trackData.mNextSampleTime.ToMicroseconds(),
<span class="lineNum">    2399 </span>            :               trackData.mNextSampleTimecode.ToMicroseconds());
<span class="lineNum">    2400 </span><span class="lineCov">          1 :     return nullptr;</span>
<span class="lineNum">    2401 </span>            :   }
<span class="lineNum">    2402 </span>            : 
<span class="lineNum">    2403 </span><span class="lineCov">          1 :   const RefPtr&lt;MediaRawData&gt;&amp; sample = track[pos];</span>
<span class="lineNum">    2404 </span><span class="lineCov">          1 :   RefPtr&lt;MediaRawData&gt; p = sample-&gt;Clone();</span>
<span class="lineNum">    2405 </span><span class="lineCov">          1 :   if (!p) {</span>
<span class="lineNum">    2406 </span>            :     // OOM
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :     aResult = MediaResult(NS_ERROR_OUT_OF_MEMORY, __func__);</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2409 </span>            :   }
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span>            :   // Find the previous keyframe to calculate the evictable amount.
<span class="lineNum">    2412 </span>            :   int32_t i = pos;
<span class="lineNum">    2413 </span><span class="lineCov">          1 :   for (; !track[i]-&gt;mKeyframe; i--) {</span>
<span class="lineNum">    2414 </span>            :   }
<span class="lineNum">    2415 </span><span class="lineCov">          1 :   UpdateEvictionIndex(trackData, i);</span>
<span class="lineNum">    2416 </span>            : 
<span class="lineNum">    2417 </span><span class="lineCov">          1 :   trackData.mNextGetSampleIndex = Some(uint32_t(pos)+1);</span>
<span class="lineNum">    2418 </span>            :   trackData.mNextSampleTimecode =
<span class="lineNum">    2419 </span><span class="lineCov">          1 :     TimeUnit::FromMicroseconds(sample-&gt;mTimecode) + sample-&gt;mDuration;</span>
<span class="lineNum">    2420 </span><span class="lineCov">          1 :   trackData.mNextSampleTime = sample-&gt;GetEndTime();</span>
<span class="lineNum">    2421 </span><span class="lineCov">          1 :   aResult = NS_OK;</span>
<span class="lineNum">    2422 </span><span class="lineCov">          1 :   return p.forget();</span>
<span class="lineNum">    2423 </span>            : }
<a name="2424"><span class="lineNum">    2424 </span>            : </a>
<span class="lineNum">    2425 </span>            : int32_t
<span class="lineNum">    2426 </span><span class="lineCov">          1 : TrackBuffersManager::FindCurrentPosition(TrackInfo::TrackType aTrack,</span>
<span class="lineNum">    2427 </span>            :                                          const TimeUnit&amp; aFuzz) const
<span class="lineNum">    2428 </span>            : {
<span class="lineNum">    2429 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2430 </span><span class="lineCov">          1 :   auto&amp; trackData = GetTracksData(aTrack);</span>
<span class="lineNum">    2431 </span><span class="lineCov">          1 :   const TrackBuffer&amp; track = GetTrackBuffer(aTrack);</span>
<span class="lineNum">    2432 </span>            : 
<span class="lineNum">    2433 </span>            :   // Perform an exact search first.
<span class="lineNum">    2434 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; track.Length(); i++) {</span>
<span class="lineNum">    2435 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = track[i];</span>
<span class="lineNum">    2436 </span>            :     TimeInterval sampleInterval{
<span class="lineNum">    2437 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode),</span>
<span class="lineNum">    2438 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode) + sample-&gt;mDuration};</span>
<span class="lineNum">    2439 </span>            : 
<span class="lineNum">    2440 </span><span class="lineCov">          1 :     if (sampleInterval.ContainsStrict(trackData.mNextSampleTimecode)) {</span>
<span class="lineNum">    2441 </span><span class="lineCov">          1 :       return i;</span>
<span class="lineNum">    2442 </span>            :     }
<span class="lineNum">    2443 </span><span class="lineCov">          1 :     if (sampleInterval.mStart &gt; trackData.mNextSampleTimecode) {</span>
<span class="lineNum">    2444 </span>            :       // Samples are ordered by timecode. There's no need to search
<span class="lineNum">    2445 </span>            :       // any further.
<span class="lineNum">    2446 </span>            :       break;
<span class="lineNum">    2447 </span>            :     }
<span class="lineNum">    2448 </span>            :   }
<span class="lineNum">    2449 </span>            : 
<span class="lineNum">    2450 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; track.Length(); i++) {</span>
<span class="lineNum">    2451 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = track[i];</span>
<span class="lineNum">    2452 </span>            :     TimeInterval sampleInterval{
<span class="lineNum">    2453 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode),</span>
<span class="lineNum">    2454 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode) + sample-&gt;mDuration,</span>
<span class="lineNum">    2455 </span><span class="lineCov">          1 :       aFuzz};</span>
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span><span class="lineCov">          1 :     if (sampleInterval.ContainsWithStrictEnd(trackData.mNextSampleTimecode)) {</span>
<span class="lineNum">    2458 </span><span class="lineCov">          1 :       return i;</span>
<span class="lineNum">    2459 </span>            :     }
<span class="lineNum">    2460 </span><span class="lineCov">          1 :     if (sampleInterval.mStart - aFuzz &gt; trackData.mNextSampleTimecode) {</span>
<span class="lineNum">    2461 </span>            :       // Samples are ordered by timecode. There's no need to search
<span class="lineNum">    2462 </span>            :       // any further.
<span class="lineNum">    2463 </span>            :       break;
<span class="lineNum">    2464 </span>            :     }
<span class="lineNum">    2465 </span>            :   }
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span>            :   // We couldn't find our sample by decode timestamp. Attempt to find it using
<span class="lineNum">    2468 </span>            :   // presentation timestamp. There will likely be small jerkiness.
<span class="lineNum">    2469 </span><span class="lineCov">          1 :   for (uint32_t i = 0; i &lt; track.Length(); i++) {</span>
<span class="lineNum">    2470 </span><span class="lineCov">          1 :     const RefPtr&lt;MediaRawData&gt;&amp; sample = track[i];</span>
<span class="lineNum">    2471 </span>            :     TimeInterval sampleInterval{
<span class="lineNum">    2472 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTime),</span>
<span class="lineNum">    2473 </span><span class="lineCov">          1 :       sample-&gt;GetEndTime(),</span>
<span class="lineNum">    2474 </span><span class="lineCov">          1 :       aFuzz};</span>
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span><span class="lineCov">          1 :     if (sampleInterval.ContainsWithStrictEnd(trackData.mNextSampleTimecode)) {</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :       return i;</span>
<span class="lineNum">    2478 </span>            :     }
<span class="lineNum">    2479 </span>            :   }
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span>            :   // Still not found.
<span class="lineNum">    2482 </span>            :   return -1;
<span class="lineNum">    2483 </span>            : }
<a name="2484"><span class="lineNum">    2484 </span>            : </a>
<span class="lineNum">    2485 </span>            : uint32_t
<span class="lineNum">    2486 </span><span class="lineCov">          1 : TrackBuffersManager::Evictable(TrackInfo::TrackType aTrack) const</span>
<span class="lineNum">    2487 </span>            : {
<span class="lineNum">    2488 </span><span class="lineCov">          1 :   MonitorAutoLock mon(mMonitor);</span>
<span class="lineNum">    2489 </span><span class="lineCov">          1 :   return GetTracksData(aTrack).mEvictionIndex.mEvictable;</span>
<span class="lineNum">    2490 </span>            : }
<a name="2491"><span class="lineNum">    2491 </span>            : </a>
<span class="lineNum">    2492 </span>            : TimeUnit
<span class="lineNum">    2493 </span><span class="lineCov">          1 : TrackBuffersManager::GetNextRandomAccessPoint(TrackInfo::TrackType aTrack,</span>
<span class="lineNum">    2494 </span>            :                                               const TimeUnit&amp; aFuzz)
<span class="lineNum">    2495 </span>            : {
<span class="lineNum">    2496 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2497 </span><span class="lineCov">          1 :   auto&amp; trackData = GetTracksData(aTrack);</span>
<span class="lineNum">    2498 </span>            :   MOZ_ASSERT(trackData.mNextGetSampleIndex.isSome());
<span class="lineNum">    2499 </span><span class="lineCov">          1 :   const TrackBuffersManager::TrackBuffer&amp; track = GetTrackBuffer(aTrack);</span>
<span class="lineNum">    2500 </span>            : 
<span class="lineNum">    2501 </span><span class="lineCov">          1 :   uint32_t i = trackData.mNextGetSampleIndex.ref();</span>
<span class="lineNum">    2502 </span><span class="lineCov">          1 :   TimeUnit nextSampleTimecode = trackData.mNextSampleTimecode;</span>
<span class="lineNum">    2503 </span><span class="lineCov">          1 :   TimeUnit nextSampleTime = trackData.mNextSampleTime;</span>
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span><span class="lineCov">          1 :   for (; i &lt; track.Length(); i++) {</span>
<span class="lineNum">    2506 </span>            :     const MediaRawData* sample =
<span class="lineNum">    2507 </span><span class="lineCov">          1 :       GetSample(aTrack, i, nextSampleTimecode, nextSampleTime, aFuzz);</span>
<span class="lineNum">    2508 </span><span class="lineCov">          1 :     if (!sample) {</span>
<span class="lineNum">    2509 </span>            :       break;
<span class="lineNum">    2510 </span>            :     }
<span class="lineNum">    2511 </span><span class="lineCov">          1 :     if (sample-&gt;mKeyframe) {</span>
<span class="lineNum">    2512 </span><span class="lineCov">          1 :       return TimeUnit::FromMicroseconds(sample-&gt;mTime);</span>
<span class="lineNum">    2513 </span>            :     }
<span class="lineNum">    2514 </span>            :     nextSampleTimecode =
<span class="lineNum">    2515 </span><span class="lineCov">          1 :       TimeUnit::FromMicroseconds(sample-&gt;mTimecode) + sample-&gt;mDuration;</span>
<span class="lineNum">    2516 </span><span class="lineCov">          1 :     nextSampleTime = sample-&gt;GetEndTime();</span>
<span class="lineNum">    2517 </span>            :   }
<span class="lineNum">    2518 </span>            :   return TimeUnit::FromInfinity();
<span class="lineNum">    2519 </span>            : }
<a name="2520"><span class="lineNum">    2520 </span>            : </a>
<span class="lineNum">    2521 </span>            : void
<span class="lineNum">    2522 </span><span class="lineCov">          1 : TrackBuffersManager::TrackData::AddSizeOfResources(MediaSourceDecoder::ResourceSizes* aSizes) const</span>
<span class="lineNum">    2523 </span>            : {
<span class="lineNum">    2524 </span><span class="lineCov">          1 :   for (const TrackBuffer&amp; buffer : mBuffers) {</span>
<span class="lineNum">    2525 </span><span class="lineCov">          1 :     for (const MediaRawData* data : buffer) {</span>
<span class="lineNum">    2526 </span><span class="lineCov">          1 :       aSizes-&gt;mByteSize += data-&gt;SizeOfIncludingThis(aSizes-&gt;mMallocSizeOf);</span>
<span class="lineNum">    2527 </span>            :     }
<span class="lineNum">    2528 </span>            :   }
<span class="lineNum">    2529 </span><span class="lineCov">          1 : }</span>
<a name="2530"><span class="lineNum">    2530 </span>            : </a>
<span class="lineNum">    2531 </span>            : void
<span class="lineNum">    2532 </span><span class="lineCov">          1 : TrackBuffersManager::AddSizeOfResources(MediaSourceDecoder::ResourceSizes* aSizes) const</span>
<span class="lineNum">    2533 </span>            : {
<span class="lineNum">    2534 </span>            :   MOZ_ASSERT(OnTaskQueue());
<span class="lineNum">    2535 </span><span class="lineCov">          1 :   mVideoTracks.AddSizeOfResources(aSizes);</span>
<span class="lineNum">    2536 </span><span class="lineCov">          1 :   mAudioTracks.AddSizeOfResources(aSizes);</span>
<span class="lineNum">    2537 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span>            : } // namespace mozilla
<span class="lineNum">    2540 </span>            : #undef MSE_DEBUG
<span class="lineNum">    2541 </span>            : #undef MSE_DEBUGV
<span class="lineNum">    2542 </span>            : #undef SAMPLE_DEBUG
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
