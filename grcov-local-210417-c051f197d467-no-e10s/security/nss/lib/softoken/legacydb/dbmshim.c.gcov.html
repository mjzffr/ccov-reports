<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/nss/lib/softoken/legacydb/dbmshim.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">security/nss/lib/softoken/legacydb</a> - dbmshim.c<span style="font-size: 80%;"> (source / <a href="dbmshim.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">87</td>
            <td class="headerCovTableEntry">204</td>
            <td class="headerCovTableEntryLo">42.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryLo">50.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public</a>
<span class="lineNum">       2 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       3 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : /*
<span class="lineNum">       6 </span>            :  * Berkeley DB 1.85 Shim code to handle blobs.
<span class="lineNum">       7 </span>            :  */
<span class="lineNum">       8 </span>            : #include &quot;mcom_db.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;secitem.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nssb64.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;blapi.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;secerr.h&quot;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;lgdb.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /*
<span class="lineNum">      17 </span>            :  *   Blob block:
<span class="lineNum">      18 </span>            :  *   Byte 0   CERTDB Version           -+                       -+
<span class="lineNum">      19 </span>            :  *   Byte 1   certDBEntryTypeBlob       |  BLOB_HEAD_LEN         |
<span class="lineNum">      20 </span>            :  *   Byte 2   flags (always '0');       |                        |
<span class="lineNum">      21 </span>            :  *   Byte 3   reserved (always '0');   -+                        |
<span class="lineNum">      22 </span>            :  *   Byte 4   LSB length                | &lt;--BLOB_LENGTH_START   | BLOB_BUF_LEN
<span class="lineNum">      23 </span>            :  *   Byte 5       .                     |                        |
<span class="lineNum">      24 </span>            :  *   Byte 6       .                     | BLOB_LENGTH_LEN        |
<span class="lineNum">      25 </span>            :  *   Byte 7   MSB length                |                        |
<span class="lineNum">      26 </span>            :  *   Byte 8   blob_filename   -+       -+  &lt;-- BLOB_NAME_START   |
<span class="lineNum">      27 </span>            :  *   Byte 9       .            | BLOB_NAME_LEN                   |
<span class="lineNum">      28 </span>            :  *     .          .            |                                 |
<span class="lineNum">      29 </span>            :  *   Byte 37      .           -+                                -+
<span class="lineNum">      30 </span>            :  */
<span class="lineNum">      31 </span>            : #define DBS_BLOCK_SIZE (16 * 1024)                   /* 16 k */
<span class="lineNum">      32 </span>            : #define DBS_MAX_ENTRY_SIZE (DBS_BLOCK_SIZE - (2048)) /* 14 k */
<span class="lineNum">      33 </span>            : #define DBS_CACHE_SIZE DBS_BLOCK_SIZE * 8
<span class="lineNum">      34 </span>            : #define ROUNDDIV(x, y) (x + (y - 1)) / y
<span class="lineNum">      35 </span>            : #define BLOB_HEAD_LEN 4
<span class="lineNum">      36 </span>            : #define BLOB_LENGTH_START BLOB_HEAD_LEN
<span class="lineNum">      37 </span>            : #define BLOB_LENGTH_LEN 4
<span class="lineNum">      38 </span>            : #define BLOB_NAME_START BLOB_LENGTH_START + BLOB_LENGTH_LEN
<span class="lineNum">      39 </span>            : #define BLOB_NAME_LEN 1 + ROUNDDIV(SHA1_LENGTH, 3) * 4 + 1
<span class="lineNum">      40 </span>            : #define BLOB_BUF_LEN BLOB_HEAD_LEN + BLOB_LENGTH_LEN + BLOB_NAME_LEN
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /* a Shim data structure. This data structure has a db built into it. */
<span class="lineNum">      43 </span>            : typedef struct DBSStr DBS;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : struct DBSStr {
<span class="lineNum">      46 </span>            :     DB db;
<span class="lineNum">      47 </span>            :     char *blobdir;
<span class="lineNum">      48 </span>            :     int mode;
<span class="lineNum">      49 </span>            :     PRBool readOnly;
<span class="lineNum">      50 </span>            :     char staticBlobArea[BLOB_BUF_LEN];
<span class="lineNum">      51 </span>            : };
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : /*
<span class="lineNum">      54 </span>            :  * return true if the Datablock contains a blobtype
<a name="55"><span class="lineNum">      55 </span>            :  */</a>
<span class="lineNum">      56 </span>            : static PRBool
<span class="lineNum">      57 </span><span class="lineCov">          1 : dbs_IsBlob(DBT *blobData)</span>
<span class="lineNum">      58 </span>            : {
<span class="lineNum">      59 </span><span class="lineCov">          1 :     unsigned char *addr = (unsigned char *)blobData-&gt;data;</span>
<span class="lineNum">      60 </span><span class="lineCov">          1 :     if (blobData-&gt;size &lt; BLOB_BUF_LEN) {</span>
<span class="lineNum">      61 </span>            :         return PR_FALSE;
<span class="lineNum">      62 </span>            :     }
<span class="lineNum">      63 </span><span class="lineCov">          1 :     return addr &amp;&amp; ((certDBEntryType)addr[1] == certDBEntryTypeBlob);</span>
<span class="lineNum">      64 </span>            : }
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : /*
<span class="lineNum">      67 </span>            :  * extract the filename in the blob of the real data set.
<span class="lineNum">      68 </span>            :  * This value is not malloced (does not need to be freed by the caller.
<span class="lineNum">      69 </span>            :  */
<span class="lineNum">      70 </span>            : static const char *
<span class="lineNum">      71 </span>            : dbs_getBlobFileName(DBT *blobData)
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     char *addr = (char *)blobData-&gt;data;</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     return &amp;addr[BLOB_NAME_START];</span>
<span class="lineNum">      76 </span>            : }
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /*
<span class="lineNum">      79 </span>            :  * extract the size of the actual blob from the blob record
<a name="80"><span class="lineNum">      80 </span>            :  */</a>
<span class="lineNum">      81 </span>            : static PRUint32
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : dbs_getBlobSize(DBT *blobData)</span>
<span class="lineNum">      83 </span>            : {
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     unsigned char *addr = (unsigned char *)blobData-&gt;data;</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     return (PRUint32)(addr[BLOB_LENGTH_START + 3] &lt;&lt; 24) |</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :            (addr[BLOB_LENGTH_START + 2] &lt;&lt; 16) |</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :            (addr[BLOB_LENGTH_START + 1] &lt;&lt; 8) |</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :            addr[BLOB_LENGTH_START];</span>
<span class="lineNum">      90 </span>            : }
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : /* We are using base64 data for the filename, but base64 data can include a
<span class="lineNum">      93 </span>            :  * '/' which is interpreted as a path separator on  many platforms. Replace it
<span class="lineNum">      94 </span>            :  * with an inocuous '-'. We don't need to convert back because we never actual
<span class="lineNum">      95 </span>            :  * decode the filename.
<span class="lineNum">      96 </span>            :  */
<a name="97"><span class="lineNum">      97 </span>            : </a>
<span class="lineNum">      98 </span>            : static void
<span class="lineNum">      99 </span><span class="lineNoCov">          0 : dbs_replaceSlash(char *cp, int len)</span>
<span class="lineNum">     100 </span>            : {
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     while (len--) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         if (*cp == '/')</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :             *cp = '-';</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :         cp++;</span>
<span class="lineNum">     105 </span>            :     }
<span class="lineNum">     106 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : /*
<span class="lineNum">     109 </span>            :  * create a blob record from a key, data and return it in blobData.
<span class="lineNum">     110 </span>            :  * NOTE: The data element is static data (keeping with the dbm model).
<a name="111"><span class="lineNum">     111 </span>            :  */</a>
<span class="lineNum">     112 </span>            : static void
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : dbs_mkBlob(DBS *dbsp, const DBT *key, const DBT *data, DBT *blobData)</span>
<span class="lineNum">     114 </span>            : {
<span class="lineNum">     115 </span>            :     unsigned char sha1_data[SHA1_LENGTH];
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     char *b = dbsp-&gt;staticBlobArea;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     PRUint32 length = data-&gt;size;</span>
<span class="lineNum">     118 </span>            :     SECItem sha1Item;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     b[0] = CERT_DB_FILE_VERSION;      /* certdb version number */</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     b[1] = (char)certDBEntryTypeBlob; /* type */</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     b[2] = 0;                         /* flags */</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     b[3] = 0;                         /* reserved */</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     b[BLOB_LENGTH_START] = length &amp; 0xff;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     b[BLOB_LENGTH_START + 1] = (length &gt;&gt; 8) &amp; 0xff;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     b[BLOB_LENGTH_START + 2] = (length &gt;&gt; 16) &amp; 0xff;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     b[BLOB_LENGTH_START + 3] = (length &gt;&gt; 24) &amp; 0xff;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     sha1Item.data = sha1_data;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     sha1Item.len = SHA1_LENGTH;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     SHA1_HashBuf(sha1_data, key-&gt;data, key-&gt;size);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     b[BLOB_NAME_START] = 'b'; /* Make sure we start with a alpha */</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     NSSBase64_EncodeItem(NULL, &amp;b[BLOB_NAME_START + 1], BLOB_NAME_LEN - 1, &amp;sha1Item);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     b[BLOB_BUF_LEN - 1] = 0;</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     dbs_replaceSlash(&amp;b[BLOB_NAME_START + 1], BLOB_NAME_LEN - 1);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     blobData-&gt;data = b;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     blobData-&gt;size = BLOB_BUF_LEN;</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     138 </span>            : }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : /*
<span class="lineNum">     141 </span>            :  * construct a path to the actual blob. The string returned must be
<span class="lineNum">     142 </span>            :  * freed by the caller with PR_smprintf_free.
<span class="lineNum">     143 </span>            :  *
<span class="lineNum">     144 </span>            :  * Note: this file does lots of consistancy checks on the DBT. The
<span class="lineNum">     145 </span>            :  * routines that call this depend on these checks, so they don't worry
<span class="lineNum">     146 </span>            :  * about them (success of this routine implies a good blobdata record).
<a name="147"><span class="lineNum">     147 </span>            :  */</a>
<span class="lineNum">     148 </span>            : static char *
<span class="lineNum">     149 </span><span class="lineNoCov">          0 : dbs_getBlobFilePath(char *blobdir, DBT *blobData)</span>
<span class="lineNum">     150 </span>            : {
<span class="lineNum">     151 </span>            :     const char *name;
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     if (blobdir == NULL) {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         PR_SetError(SEC_ERROR_BAD_DATABASE, 0);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     156 </span>            :     }
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     if (!dbs_IsBlob(blobData)) {</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         PR_SetError(SEC_ERROR_BAD_DATABASE, 0);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     name = dbs_getBlobFileName(blobData);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     if (!name || *name == 0) {</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :         PR_SetError(SEC_ERROR_BAD_DATABASE, 0);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     return PR_smprintf(&quot;%s&quot; PATH_SEPARATOR &quot;%s&quot;, blobdir, name);</span>
<span class="lineNum">     167 </span>            : }
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : /*
<span class="lineNum">     170 </span>            :  * Delete a blob file pointed to by the blob record.
<a name="171"><span class="lineNum">     171 </span>            :  */</a>
<span class="lineNum">     172 </span>            : static void
<span class="lineNum">     173 </span><span class="lineNoCov">          0 : dbs_removeBlob(DBS *dbsp, DBT *blobData)</span>
<span class="lineNum">     174 </span>            : {
<span class="lineNum">     175 </span>            :     char *file;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     file = dbs_getBlobFilePath(dbsp-&gt;blobdir, blobData);</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     if (!file) {</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     180 </span>            :     }
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     PR_Delete(file);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     PR_smprintf_free(file);</span>
<span class="lineNum">     183 </span>            : }
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /*
<span class="lineNum">     186 </span>            :  * Directory modes are slightly different, the 'x' bit needs to be on to
<span class="lineNum">     187 </span>            :  * access them. Copy all the read bits to 'x' bits
<span class="lineNum">     188 </span>            :  */
<span class="lineNum">     189 </span>            : static int
<span class="lineNum">     190 </span>            : dbs_DirMode(int mode)
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     int x_bits = (mode &gt;&gt; 2) &amp; 0111;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     return mode | x_bits;</span>
<span class="lineNum">     194 </span>            : }
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : /*
<span class="lineNum">     197 </span>            :  * write a data blob to it's file. blobdData is the blob record that will be
<span class="lineNum">     198 </span>            :  * stored in the database. data is the actual data to go out on disk.
<a name="199"><span class="lineNum">     199 </span>            :  */</a>
<span class="lineNum">     200 </span>            : static int
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : dbs_writeBlob(DBS *dbsp, int mode, DBT *blobData, const DBT *data)</span>
<span class="lineNum">     202 </span>            : {
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     char *file = NULL;</span>
<span class="lineNum">     204 </span>            :     PRFileDesc *filed;
<span class="lineNum">     205 </span>            :     PRStatus status;
<span class="lineNum">     206 </span>            :     int len;
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     int error = 0;</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     file = dbs_getBlobFilePath(dbsp-&gt;blobdir, blobData);</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     if (!file) {</span>
<span class="lineNum">     211 </span>            :         goto loser;
<span class="lineNum">     212 </span>            :     }
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     if (PR_Access(dbsp-&gt;blobdir, PR_ACCESS_EXISTS) != PR_SUCCESS) {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         status = PR_MkDir(dbsp-&gt;blobdir, dbs_DirMode(mode));</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         if (status != PR_SUCCESS) {</span>
<span class="lineNum">     216 </span>            :             goto loser;
<span class="lineNum">     217 </span>            :         }
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     filed = PR_OpenFile(file, PR_CREATE_FILE | PR_TRUNCATE | PR_WRONLY, mode);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     if (filed == NULL) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         error = PR_GetError();</span>
<span class="lineNum">     222 </span>            :         goto loser;
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     len = PR_Write(filed, data-&gt;data, data-&gt;size);</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     error = PR_GetError();</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     PR_Close(filed);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     if (len &lt; (int)data-&gt;size) {</span>
<span class="lineNum">     228 </span>            :         goto loser;
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     PR_smprintf_free(file);</span>
<span class="lineNum">     231 </span>            :     return 0;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : loser:
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     if (file) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         PR_Delete(file);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         PR_smprintf_free(file);</span>
<span class="lineNum">     237 </span>            :     }
<span class="lineNum">     238 </span>            :     /* don't let close or delete reset the error */
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     PR_SetError(error, 0);</span>
<span class="lineNum">     240 </span>            :     return -1;
<span class="lineNum">     241 </span>            : }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : /*
<span class="lineNum">     244 </span>            :  * platforms that cannot map the file need to read it into a temp buffer.
<a name="245"><span class="lineNum">     245 </span>            :  */</a>
<span class="lineNum">     246 </span>            : static unsigned char *
<span class="lineNum">     247 </span><span class="lineNoCov">          0 : dbs_EmulateMap(PRFileDesc *filed, int len)</span>
<span class="lineNum">     248 </span>            : {
<span class="lineNum">     249 </span>            :     unsigned char *addr;
<span class="lineNum">     250 </span>            :     PRInt32 dataRead;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     addr = PORT_Alloc(len);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     if (addr == NULL) {</span>
<span class="lineNum">     254 </span>            :         return NULL;
<span class="lineNum">     255 </span>            :     }
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     dataRead = PR_Read(filed, addr, len);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     if (dataRead != len) {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :         PORT_Free(addr);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         if (dataRead &gt; 0) {</span>
<span class="lineNum">     261 </span>            :             /* PR_Read didn't set an error, we need to */
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :             PR_SetError(SEC_ERROR_BAD_DATABASE, 0);</span>
<span class="lineNum">     263 </span>            :         }
<span class="lineNum">     264 </span>            :         return NULL;
<span class="lineNum">     265 </span>            :     }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :     return addr;
<span class="lineNum">     268 </span>            : }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : /*
<span class="lineNum">     271 </span>            :  * pull a database record off the disk
<span class="lineNum">     272 </span>            :  * data points to the blob record on input and the real record (if we could
<span class="lineNum">     273 </span>            :  * read it) on output. if there is an error data is not modified.
<a name="274"><span class="lineNum">     274 </span>            :  */</a>
<span class="lineNum">     275 </span>            : static int
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : dbs_readBlob(DBS *dbsp, DBT *data)</span>
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     char *file = NULL;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     PRFileDesc *filed = NULL;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     unsigned char *addr = NULL;</span>
<span class="lineNum">     281 </span>            :     int error;
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     int len = -1;</span>
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     file = dbs_getBlobFilePath(dbsp-&gt;blobdir, data);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if (!file) {</span>
<span class="lineNum">     286 </span>            :         goto loser;
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     filed = PR_OpenFile(file, PR_RDONLY, 0);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     PR_smprintf_free(file);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     file = NULL;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if (filed == NULL) {</span>
<span class="lineNum">     292 </span>            :         goto loser;
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     len = dbs_getBlobSize(data);</span>
<span class="lineNum">     296 </span>            :     /* Bug 1323150
<span class="lineNum">     297 </span>            :      * PR_MemMap fails on Windows for larger certificates.
<span class="lineNum">     298 </span>            :      * https://msdn.microsoft.com/en-us/library/windows/desktop/aa366761(v=vs.85).aspx
<span class="lineNum">     299 </span>            :      * Let's always use the emulated map, i.e. read the file.
<span class="lineNum">     300 </span>            :      */
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     addr = dbs_EmulateMap(filed, len);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     if (addr == NULL) {</span>
<span class="lineNum">     303 </span>            :         goto loser;
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     PR_Close(filed);</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     data-&gt;data = addr;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     data-&gt;size = len;</span>
<span class="lineNum">     309 </span>            :     return 0;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : loser:
<span class="lineNum">     312 </span>            :     /* preserve the error code */
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     error = PR_GetError();</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     if (filed) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         PR_Close(filed);</span>
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     PR_SetError(error, 0);</span>
<span class="lineNum">     318 </span>            :     return -1;
<span class="lineNum">     319 </span>            : }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : /*
<span class="lineNum">     322 </span>            :  * actual DBM shims
<a name="323"><span class="lineNum">     323 </span>            :  */</a>
<span class="lineNum">     324 </span>            : static int
<span class="lineNum">     325 </span><span class="lineCov">          1 : dbs_get(const DB *dbs, const DBT *key, DBT *data, unsigned int flags)</span>
<span class="lineNum">     326 </span>            : {
<span class="lineNum">     327 </span>            :     int ret;
<span class="lineNum">     328 </span><span class="lineCov">          1 :     DBS *dbsp = (DBS *)dbs;</span>
<span class="lineNum">     329 </span><span class="lineCov">          1 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineCov">          1 :     ret = (*db-&gt;get)(db, key, data, flags);</span>
<span class="lineNum">     332 </span><span class="lineCov">          1 :     if ((ret == 0) &amp;&amp; dbs_IsBlob(data)) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         ret = dbs_readBlob(dbsp, data);</span>
<span class="lineNum">     334 </span>            :     }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineCov">          1 :     return (ret);</span>
<span class="lineNum">     337 </span>            : }
<a name="338"><span class="lineNum">     338 </span>            : </a>
<span class="lineNum">     339 </span>            : static int
<span class="lineNum">     340 </span><span class="lineCov">          1 : dbs_put(const DB *dbs, DBT *key, const DBT *data, unsigned int flags)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span>            :     DBT blob;
<span class="lineNum">     343 </span><span class="lineCov">          1 :     int ret = 0;</span>
<span class="lineNum">     344 </span><span class="lineCov">          1 :     DBS *dbsp = (DBS *)dbs;</span>
<span class="lineNum">     345 </span><span class="lineCov">          1 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     /* If the db is readonly, just pass the data down to rdb and let it fail */
<span class="lineNum">     348 </span><span class="lineCov">          1 :     if (!dbsp-&gt;readOnly) {</span>
<span class="lineNum">     349 </span>            :         DBT oldData;
<span class="lineNum">     350 </span>            :         int ret1;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :         /* make sure the current record is deleted if it's a blob */
<span class="lineNum">     353 </span><span class="lineCov">          1 :         ret1 = (*db-&gt;get)(db, key, &amp;oldData, 0);</span>
<span class="lineNum">     354 </span><span class="lineCov">          1 :         if ((ret1 == 0) &amp;&amp; flags == R_NOOVERWRITE) {</span>
<span class="lineNum">     355 </span>            :             /* let DBM return the error to maintain consistancy */
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             return (*db-&gt;put)(db, key, data, flags);</span>
<span class="lineNum">     357 </span>            :         }
<span class="lineNum">     358 </span><span class="lineCov">          1 :         if ((ret1 == 0) &amp;&amp; dbs_IsBlob(&amp;oldData)) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             dbs_removeBlob(dbsp, &amp;oldData);</span>
<span class="lineNum">     360 </span>            :         }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineCov">          1 :         if (data-&gt;size &gt; DBS_MAX_ENTRY_SIZE) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :             dbs_mkBlob(dbsp, key, data, &amp;blob);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             ret = dbs_writeBlob(dbsp, dbsp-&gt;mode, &amp;blob, data);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :             data = &amp;blob;</span>
<span class="lineNum">     366 </span>            :         }
<span class="lineNum">     367 </span>            :     }
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineCov">          1 :     if (ret == 0) {</span>
<span class="lineNum">     370 </span><span class="lineCov">          1 :         ret = (*db-&gt;put)(db, key, data, flags);</span>
<span class="lineNum">     371 </span>            :     }
<span class="lineNum">     372 </span><span class="lineCov">          1 :     return (ret);</span>
<span class="lineNum">     373 </span>            : }
<a name="374"><span class="lineNum">     374 </span>            : </a>
<span class="lineNum">     375 </span>            : static int
<span class="lineNum">     376 </span><span class="lineCov">          1 : dbs_sync(const DB *dbs, unsigned int flags)</span>
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span><span class="lineCov">          1 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     379 </span><span class="lineCov">          1 :     return (*db-&gt;sync)(db, flags);</span>
<span class="lineNum">     380 </span>            : }
<a name="381"><span class="lineNum">     381 </span>            : </a>
<span class="lineNum">     382 </span>            : static int
<span class="lineNum">     383 </span><span class="lineCov">          1 : dbs_del(const DB *dbs, const DBT *key, unsigned int flags)</span>
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span>            :     int ret;
<span class="lineNum">     386 </span><span class="lineCov">          1 :     DBS *dbsp = (DBS *)dbs;</span>
<span class="lineNum">     387 </span><span class="lineCov">          1 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">          1 :     if (!dbsp-&gt;readOnly) {</span>
<span class="lineNum">     390 </span>            :         DBT oldData;
<span class="lineNum">     391 </span><span class="lineCov">          1 :         ret = (*db-&gt;get)(db, key, &amp;oldData, 0);</span>
<span class="lineNum">     392 </span><span class="lineCov">          1 :         if ((ret == 0) &amp;&amp; dbs_IsBlob(&amp;oldData)) {</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             dbs_removeBlob(dbsp, &amp;oldData);</span>
<span class="lineNum">     394 </span>            :         }
<span class="lineNum">     395 </span>            :     }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineCov">          1 :     return (*db-&gt;del)(db, key, flags);</span>
<span class="lineNum">     398 </span>            : }
<a name="399"><span class="lineNum">     399 </span>            : </a>
<span class="lineNum">     400 </span>            : static int
<span class="lineNum">     401 </span><span class="lineCov">          1 : dbs_seq(const DB *dbs, DBT *key, DBT *data, unsigned int flags)</span>
<span class="lineNum">     402 </span>            : {
<span class="lineNum">     403 </span>            :     int ret;
<span class="lineNum">     404 </span><span class="lineCov">          1 :     DBS *dbsp = (DBS *)dbs;</span>
<span class="lineNum">     405 </span><span class="lineCov">          1 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">          1 :     ret = (*db-&gt;seq)(db, key, data, flags);</span>
<span class="lineNum">     408 </span><span class="lineCov">          1 :     if ((ret == 0) &amp;&amp; dbs_IsBlob(data)) {</span>
<span class="lineNum">     409 </span>            :         /* don't return a blob read as an error so traversals keep going */
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         (void)dbs_readBlob(dbsp, data);</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineCov">          1 :     return (ret);</span>
<span class="lineNum">     414 </span>            : }
<a name="415"><span class="lineNum">     415 </span>            : </a>
<span class="lineNum">     416 </span>            : static int
<span class="lineNum">     417 </span><span class="lineCov">          1 : dbs_close(DB *dbs)</span>
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span><span class="lineCov">          1 :     DBS *dbsp = (DBS *)dbs;</span>
<span class="lineNum">     420 </span><span class="lineCov">          1 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     421 </span>            :     int ret;
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineCov">          1 :     ret = (*db-&gt;close)(db);</span>
<span class="lineNum">     424 </span><span class="lineCov">          1 :     PORT_Free(dbsp-&gt;blobdir);</span>
<span class="lineNum">     425 </span><span class="lineCov">          1 :     PORT_Free(dbsp);</span>
<span class="lineNum">     426 </span><span class="lineCov">          1 :     return ret;</span>
<span class="lineNum">     427 </span>            : }
<a name="428"><span class="lineNum">     428 </span>            : </a>
<span class="lineNum">     429 </span>            : static int
<span class="lineNum">     430 </span><span class="lineNoCov">          0 : dbs_fd(const DB *dbs)</span>
<span class="lineNum">     431 </span>            : {
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     DB *db = (DB *)dbs-&gt;internal;</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     return (*db-&gt;fd)(db);</span>
<span class="lineNum">     435 </span>            : }
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : /*
<span class="lineNum">     438 </span>            :  * the naming convention we use is
<span class="lineNum">     439 </span>            :  * change the .xxx into .dir. (for nss it's always .db);
<span class="lineNum">     440 </span>            :  * if no .extension exists or is equal to .dir, add a .dir
<span class="lineNum">     441 </span>            :  * the returned data must be freed.
<span class="lineNum">     442 </span>            :  */
<a name="443"><span class="lineNum">     443 </span>            : #define DIRSUFFIX &quot;.dir&quot;</a>
<span class="lineNum">     444 </span>            : static char *
<span class="lineNum">     445 </span><span class="lineCov">          1 : dbs_mkBlobDirName(const char *dbname)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineCov">          1 :     int dbname_len = PORT_Strlen(dbname);</span>
<span class="lineNum">     448 </span><span class="lineCov">          1 :     int dbname_end = dbname_len;</span>
<span class="lineNum">     449 </span>            :     const char *cp;
<span class="lineNum">     450 </span><span class="lineCov">          1 :     char *blobDir = NULL;</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :     /* scan back from the end looking for either a directory separator, a '.',
<span class="lineNum">     453 </span>            :      * or the end of the string. NOTE: Windows should check for both separators
<span class="lineNum">     454 </span>            :      * here. For now this is safe because we know NSS always uses a '.'
<span class="lineNum">     455 </span>            :      */
<span class="lineNum">     456 </span><span class="lineCov">          1 :     for (cp = &amp;dbname[dbname_len];</span>
<span class="lineNum">     457 </span><span class="lineCov">          1 :          (cp &gt; dbname) &amp;&amp; (*cp != '.') &amp;&amp; (*cp != *PATH_SEPARATOR);</span>
<span class="lineNum">     458 </span><span class="lineCov">          1 :          cp--)</span>
<span class="lineNum">     459 </span>            :         /* Empty */;
<span class="lineNum">     460 </span><span class="lineCov">          1 :     if (*cp == '.') {</span>
<span class="lineNum">     461 </span><span class="lineCov">          1 :         dbname_end = cp - dbname;</span>
<span class="lineNum">     462 </span><span class="lineCov">          1 :         if (PORT_Strcmp(cp, DIRSUFFIX) == 0) {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             dbname_end = dbname_len;</span>
<span class="lineNum">     464 </span>            :         }
<span class="lineNum">     465 </span>            :     }
<span class="lineNum">     466 </span><span class="lineCov">          1 :     blobDir = PORT_ZAlloc(dbname_end + sizeof(DIRSUFFIX));</span>
<span class="lineNum">     467 </span><span class="lineCov">          1 :     if (blobDir == NULL) {</span>
<span class="lineNum">     468 </span>            :         return NULL;
<span class="lineNum">     469 </span>            :     }
<span class="lineNum">     470 </span><span class="lineCov">          1 :     PORT_Memcpy(blobDir, dbname, dbname_end);</span>
<span class="lineNum">     471 </span><span class="lineCov">          1 :     PORT_Memcpy(&amp;blobDir[dbname_end], DIRSUFFIX, sizeof(DIRSUFFIX));</span>
<span class="lineNum">     472 </span><span class="lineCov">          1 :     return blobDir;</span>
<span class="lineNum">     473 </span>            : }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : #define DBM_DEFAULT 0
<span class="lineNum">     476 </span>            : static const HASHINFO dbs_hashInfo = {
<span class="lineNum">     477 </span>            :     DBS_BLOCK_SIZE, /* bucket size, must be greater than = to
<span class="lineNum">     478 </span>            :                                      * or maximum entry size (+ header)
<span class="lineNum">     479 </span>            :                                      * we allow before blobing */
<span class="lineNum">     480 </span>            :     DBM_DEFAULT,    /* Fill Factor */
<span class="lineNum">     481 </span>            :     DBM_DEFAULT,    /* number of elements */
<span class="lineNum">     482 </span>            :     DBS_CACHE_SIZE, /* cache size */
<span class="lineNum">     483 </span>            :     DBM_DEFAULT,    /* hash function */
<span class="lineNum">     484 </span>            :     DBM_DEFAULT,    /* byte order */
<span class="lineNum">     485 </span>            : };
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            : /*
<span class="lineNum">     488 </span>            :  * the open function. NOTE: this is the only exposed function in this file.
<span class="lineNum">     489 </span>            :  * everything else is called through the function table pointer.
<a name="490"><span class="lineNum">     490 </span>            :  */</a>
<span class="lineNum">     491 </span>            : DB *
<span class="lineNum">     492 </span><span class="lineCov">          1 : dbsopen(const char *dbname, int flags, int mode, DBTYPE type,</span>
<span class="lineNum">     493 </span>            :         const void *userData)
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineCov">          1 :     DB *db = NULL, *dbs = NULL;</span>
<span class="lineNum">     496 </span><span class="lineCov">          1 :     DBS *dbsp = NULL;</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :     /* NOTE: we are overriding userData with dbs_hashInfo. since all known
<span class="lineNum">     499 </span>            :      * callers pass 0, this is ok, otherwise we should merge the two */
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineCov">          1 :     dbsp = (DBS *)PORT_ZAlloc(sizeof(DBS));</span>
<span class="lineNum">     502 </span><span class="lineCov">          1 :     if (!dbsp) {</span>
<span class="lineNum">     503 </span>            :         return NULL;
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span><span class="lineCov">          1 :     dbs = &amp;dbsp-&gt;db;</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">          1 :     dbsp-&gt;blobdir = dbs_mkBlobDirName(dbname);</span>
<span class="lineNum">     508 </span><span class="lineCov">          1 :     if (dbsp-&gt;blobdir == NULL) {</span>
<span class="lineNum">     509 </span>            :         goto loser;
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span><span class="lineCov">          1 :     dbsp-&gt;mode = mode;</span>
<span class="lineNum">     512 </span><span class="lineCov">          1 :     dbsp-&gt;readOnly = (PRBool)(flags == NO_RDONLY);</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     /* the real dbm call */
<span class="lineNum">     515 </span><span class="lineCov">          1 :     db = dbopen(dbname, flags, mode, type, &amp;dbs_hashInfo);</span>
<span class="lineNum">     516 </span><span class="lineCov">          1 :     if (db == NULL) {</span>
<span class="lineNum">     517 </span>            :         goto loser;
<span class="lineNum">     518 </span>            :     }
<span class="lineNum">     519 </span><span class="lineCov">          1 :     dbs-&gt;internal = (void *)db;</span>
<span class="lineNum">     520 </span><span class="lineCov">          1 :     dbs-&gt;type = type;</span>
<span class="lineNum">     521 </span><span class="lineCov">          1 :     dbs-&gt;close = dbs_close;</span>
<span class="lineNum">     522 </span><span class="lineCov">          1 :     dbs-&gt;get = dbs_get;</span>
<span class="lineNum">     523 </span><span class="lineCov">          1 :     dbs-&gt;del = dbs_del;</span>
<span class="lineNum">     524 </span><span class="lineCov">          1 :     dbs-&gt;put = dbs_put;</span>
<span class="lineNum">     525 </span><span class="lineCov">          1 :     dbs-&gt;seq = dbs_seq;</span>
<span class="lineNum">     526 </span><span class="lineCov">          1 :     dbs-&gt;sync = dbs_sync;</span>
<span class="lineNum">     527 </span><span class="lineCov">          1 :     dbs-&gt;fd = dbs_fd;</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineCov">          1 :     return dbs;</span>
<span class="lineNum">     530 </span>            : loser:
<span class="lineNum">     531 </span><span class="lineCov">          1 :     if (db) {</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         (*db-&gt;close)(db);</span>
<span class="lineNum">     533 </span>            :     }
<span class="lineNum">     534 </span><span class="lineCov">          1 :     if (dbsp-&gt;blobdir) {</span>
<span class="lineNum">     535 </span><span class="lineCov">          1 :         PORT_Free(dbsp-&gt;blobdir);</span>
<span class="lineNum">     536 </span>            :     }
<span class="lineNum">     537 </span><span class="lineCov">          1 :     PORT_Free(dbsp);</span>
<span class="lineNum">     538 </span><span class="lineCov">          1 :     return NULL;</span>
<span class="lineNum">     539 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
