<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/sandbox/linux/Sandbox.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">security/sandbox/linux</a> - Sandbox.cpp<span style="font-size: 80%;"> (source / <a href="Sandbox.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntry">215</td>
            <td class="headerCovTableEntryLo">7.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">20.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
<span class="lineNum">       5 </span>            :  * You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;Sandbox.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;LinuxCapabilities.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;LinuxSched.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;SandboxBrokerClient.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;SandboxChroot.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;SandboxFilter.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;SandboxInternal.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;SandboxLogging.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;SandboxReporterClient.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;SandboxUtil.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &lt;dirent.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;linux/futex.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;pthread.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;sys/prctl.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;sys/ptrace.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;sys/syscall.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;mozilla/Atomics.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;mozilla/SandboxInfo.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;mozilla/Unused.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;sandbox/linux/bpf_dsl/codegen.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;sandbox/linux/bpf_dsl/dump_bpf.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;sandbox/linux/bpf_dsl/policy.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;sandbox/linux/bpf_dsl/policy_compiler.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;sandbox/linux/bpf_dsl/seccomp_macros.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;sandbox/linux/seccomp-bpf/trap.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;sandbox/linux/system_headers/linux_filter.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;sandbox/linux/system_headers/linux_seccomp.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;sandbox/linux/system_headers/linux_syscalls.h&quot;
<span class="lineNum">      48 </span>            : #if defined(ANDROID)
<span class="lineNum">      49 </span>            : #include &quot;sandbox/linux/system_headers/linux_ucontext.h&quot;
<span class="lineNum">      50 </span>            : #endif
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #ifdef MOZ_ASAN
<span class="lineNum">      53 </span>            : // Copy libsanitizer declarations to avoid depending on ASAN headers.
<span class="lineNum">      54 </span>            : // See also bug 1081242 comment #4.
<span class="lineNum">      55 </span>            : extern &quot;C&quot; {
<span class="lineNum">      56 </span>            : namespace __sanitizer {
<span class="lineNum">      57 </span>            : // Win64 uses long long, but this is Linux.
<span class="lineNum">      58 </span>            : typedef signed long sptr;
<span class="lineNum">      59 </span>            : } // namespace __sanitizer
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : typedef struct {
<span class="lineNum">      62 </span>            :   int coverage_sandboxed;
<span class="lineNum">      63 </span>            :   __sanitizer::sptr coverage_fd;
<span class="lineNum">      64 </span>            :   unsigned int coverage_max_block_size;
<span class="lineNum">      65 </span>            : } __sanitizer_sandbox_arguments;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : MOZ_IMPORT_API void
<span class="lineNum">      68 </span>            : __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);
<span class="lineNum">      69 </span>            : } // extern &quot;C&quot;
<span class="lineNum">      70 </span>            : #endif // MOZ_ASAN
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : // Signal number used to enable seccomp on each thread.
<span class="lineNum">      73 </span>            : int gSeccompTsyncBroadcastSignum = 0;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : namespace mozilla {
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : static bool gSandboxCrashOnError = false;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : // This is initialized by SandboxSetCrashFunc().
<span class="lineNum">      80 </span>            : SandboxCrashFunc gSandboxCrashFunc;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : #ifdef MOZ_GMP_SANDBOX
<span class="lineNum">      83 </span>            : // For media plugins, we can start the sandbox before we dlopen the
<span class="lineNum">      84 </span>            : // module, so we have to pre-open the file and simulate the sandboxed
<span class="lineNum">      85 </span>            : // open().
<span class="lineNum">      86 </span>            : static SandboxOpenedFile gMediaPluginFile;
<span class="lineNum">      87 </span>            : #endif
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineCov">          1 : static Maybe&lt;SandboxReporterClient&gt; gSandboxReporterClient;</span>
<span class="lineNum">      90 </span><span class="lineCov">          1 : static UniquePtr&lt;SandboxChroot&gt; gChrootHelper;</span>
<span class="lineNum">      91 </span>            : static void (*gChromiumSigSysHandler)(int, siginfo_t*, void*);
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : // Test whether a ucontext, interpreted as the state after a syscall,
<span class="lineNum">      94 </span>            : // indicates the given error.  See also sandbox::Syscall::PutValueInUcontext.
<span class="lineNum">      95 </span>            : static bool
<span class="lineNum">      96 </span>            : ContextIsError(const ucontext_t *aContext, int aError)
<span class="lineNum">      97 </span>            : {
<span class="lineNum">      98 </span>            :   // Avoid integer promotion warnings.  (The unary addition makes
<span class="lineNum">      99 </span>            :   // the decltype not evaluate to a reference type.)
<span class="lineNum">     100 </span>            :   typedef decltype(+SECCOMP_RESULT(aContext)) reg_t;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : #ifdef __mips__
<span class="lineNum">     103 </span>            :   return SECCOMP_PARM4(aContext) != 0
<span class="lineNum">     104 </span>            :     &amp;&amp; SECCOMP_RESULT(aContext) == static_cast&lt;reg_t&gt;(aError);
<span class="lineNum">     105 </span>            : #else
<span class="lineNum">     106 </span>            :   return SECCOMP_RESULT(aContext) == static_cast&lt;reg_t&gt;(-aError);
<span class="lineNum">     107 </span>            : #endif
<span class="lineNum">     108 </span>            : }
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : /**
<span class="lineNum">     111 </span>            :  * This is the SIGSYS handler function.  It delegates to the Chromium
<span class="lineNum">     112 </span>            :  * TrapRegistry handler (see InstallSigSysHandler, below) and, if the
<span class="lineNum">     113 </span>            :  * trap handler installed by the policy would fail with ENOSYS,
<span class="lineNum">     114 </span>            :  * crashes the process.  This allows unintentional policy failures to
<span class="lineNum">     115 </span>            :  * be reported as crash dumps and fixed.  It also logs information
<span class="lineNum">     116 </span>            :  * about the failed system call.
<span class="lineNum">     117 </span>            :  *
<span class="lineNum">     118 </span>            :  * Note that this could be invoked in parallel on multiple threads and
<span class="lineNum">     119 </span>            :  * that it could be in async signal context (e.g., intercepting an
<span class="lineNum">     120 </span>            :  * open() called from an async signal handler).
<a name="121"><span class="lineNum">     121 </span>            :  */</a>
<span class="lineNum">     122 </span>            : static void
<span class="lineNum">     123 </span><span class="lineNoCov">          0 : SigSysHandler(int nr, siginfo_t *info, void *void_context)</span>
<span class="lineNum">     124 </span>            : {
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   ucontext_t *ctx = static_cast&lt;ucontext_t*&gt;(void_context);</span>
<span class="lineNum">     126 </span>            :   // This shouldn't ever be null, but the Chromium handler checks for
<span class="lineNum">     127 </span>            :   // that and refrains from crashing, so let's not crash release builds:
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   MOZ_DIAGNOSTIC_ASSERT(ctx);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   if (!ctx) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     131 </span>            :   }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :   // Save a copy of the context before invoking the trap handler,
<span class="lineNum">     134 </span>            :   // which will overwrite one or more registers with the return value.
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   ucontext_t savedCtx = *ctx;</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   gChromiumSigSysHandler(nr, info, ctx);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   if (!ContextIsError(ctx, ENOSYS)) {</span>
<span class="lineNum">     139 </span>            :     return;
<span class="lineNum">     140 </span>            :   }
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   SandboxReport report = gSandboxReporterClient-&gt;MakeReportAndSend(&amp;savedCtx);</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :   // TODO, someday when this is enabled on MIPS: include the two extra
<span class="lineNum">     145 </span>            :   // args in the error message.
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   SANDBOX_LOG_ERROR(&quot;seccomp sandbox violation: pid %d, tid %d, syscall %d,&quot;</span>
<span class="lineNum">     147 </span>            :                     &quot; args %d %d %d %d %d %d.%s&quot;,
<span class="lineNum">     148 </span>            :                     report.mPid, report.mTid, report.mSyscall,
<span class="lineNum">     149 </span>            :                     report.mArgs[0], report.mArgs[1], report.mArgs[2],
<span class="lineNum">     150 </span>            :                     report.mArgs[3], report.mArgs[4], report.mArgs[5],
<span class="lineNum">     151 </span>            :                     gSandboxCrashOnError ? &quot;  Killing process.&quot; : &quot;&quot;);
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   if (gSandboxCrashOnError) {</span>
<span class="lineNum">     154 </span>            :     // Bug 1017393: record syscall number somewhere useful.
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     info-&gt;si_addr = reinterpret_cast&lt;void*&gt;(report.mSyscall);</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     gSandboxCrashFunc(nr, info, &amp;savedCtx);</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     _exit(127);</span>
<span class="lineNum">     159 </span>            :   }
<span class="lineNum">     160 </span>            : }
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            : /**
<span class="lineNum">     163 </span>            :  * This function installs the SIGSYS handler.  This is slightly
<span class="lineNum">     164 </span>            :  * complicated because we want to use Chromium's handler to dispatch
<span class="lineNum">     165 </span>            :  * to specific trap handlers defined in the policy, but we also need
<span class="lineNum">     166 </span>            :  * the full original signal context to give to Breakpad for crash
<span class="lineNum">     167 </span>            :  * dumps.  So we install Chromium's handler first, then retrieve its
<span class="lineNum">     168 </span>            :  * address so our replacement can delegate to it.
<a name="169"><span class="lineNum">     169 </span>            :  */</a>
<span class="lineNum">     170 </span>            : static void
<span class="lineNum">     171 </span><span class="lineNoCov">          0 : InstallSigSysHandler(void)</span>
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span>            :   struct sigaction act;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   // Ensure that the Chromium handler is installed.
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   Unused &lt;&lt; sandbox::Trap::Registry();</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :   // If the signal handling state isn't as expected, crash now instead
<span class="lineNum">     179 </span>            :   // of crashing later (and more confusingly) when SIGSYS happens.
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   if (sigaction(SIGSYS, nullptr, &amp;act) != 0) {</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Couldn't read old SIGSYS disposition&quot;);</span>
<span class="lineNum">     183 </span>            :   }
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   if ((act.sa_flags &amp; SA_SIGINFO) != SA_SIGINFO) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;SIGSYS not already set to a siginfo handler?&quot;);</span>
<span class="lineNum">     186 </span>            :   }
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   MOZ_RELEASE_ASSERT(act.sa_sigaction);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   gChromiumSigSysHandler = act.sa_sigaction;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   act.sa_sigaction = SigSysHandler;</span>
<span class="lineNum">     190 </span>            :   // Currently, SA_NODEFER should already be set by the Chromium code,
<span class="lineNum">     191 </span>            :   // but it's harmless to ensure that it's set:
<span class="lineNum">     192 </span>            :   MOZ_ASSERT(act.sa_flags &amp; SA_NODEFER);
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   act.sa_flags |= SA_NODEFER;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   if (sigaction(SIGSYS, &amp;act, nullptr) &lt; 0) {</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Couldn't change SIGSYS disposition&quot;);</span>
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : /**
<span class="lineNum">     200 </span>            :  * This function installs the syscall filter, a.k.a. seccomp.  The
<span class="lineNum">     201 </span>            :  * aUseTSync flag indicates whether this should apply to all threads
<span class="lineNum">     202 </span>            :  * in the process -- which will fail if the kernel doesn't support
<span class="lineNum">     203 </span>            :  * that -- or only the current thread.
<span class="lineNum">     204 </span>            :  *
<span class="lineNum">     205 </span>            :  * SECCOMP_MODE_FILTER is the &quot;bpf&quot; mode of seccomp which allows
<span class="lineNum">     206 </span>            :  * to pass a bpf program (in our case, it contains a syscall
<span class="lineNum">     207 </span>            :  * whitelist).
<span class="lineNum">     208 </span>            :  *
<span class="lineNum">     209 </span>            :  * PR_SET_NO_NEW_PRIVS ensures that it is impossible to grant more
<span class="lineNum">     210 </span>            :  * syscalls to the process beyond this point (even after fork()), and
<span class="lineNum">     211 </span>            :  * prevents gaining capabilities (e.g., by exec'ing a setuid root
<span class="lineNum">     212 </span>            :  * program).  The kernel won't allow seccomp-bpf without doing this,
<span class="lineNum">     213 </span>            :  * because otherwise it could be used for privilege escalation attacks.
<span class="lineNum">     214 </span>            :  *
<span class="lineNum">     215 </span>            :  * Returns false if the filter was already installed (see the
<span class="lineNum">     216 </span>            :  * PR_SET_NO_NEW_PRIVS rule in SandboxFilter.cpp).  Crashes on any
<span class="lineNum">     217 </span>            :  * other error condition.
<span class="lineNum">     218 </span>            :  *
<span class="lineNum">     219 </span>            :  * @see SandboxInfo
<span class="lineNum">     220 </span>            :  * @see BroadcastSetThreadSandbox
<a name="221"><span class="lineNum">     221 </span>            :  */</a>
<span class="lineNum">     222 </span>            : static bool MOZ_MUST_USE
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : InstallSyscallFilter(const sock_fprog *aProg, bool aUseTSync)</span>
<span class="lineNum">     224 </span>            : {
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     if (!aUseTSync &amp;&amp; errno == ETXTBSY) {</span>
<span class="lineNum">     227 </span>            :       return false;
<span class="lineNum">     228 </span>            :     }
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;prctl(PR_SET_NO_NEW_PRIVS) failed: %s&quot;, strerror(errno));</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;prctl(PR_SET_NO_NEW_PRIVS)&quot;);</span>
<span class="lineNum">     231 </span>            :   }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   if (aUseTSync) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     if (syscall(__NR_seccomp, SECCOMP_SET_MODE_FILTER,</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :                 SECCOMP_FILTER_FLAG_TSYNC, aProg) != 0) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;thread-synchronized seccomp failed: %s&quot;,</span>
<span class="lineNum">     237 </span>            :                         strerror(errno));
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER)&quot;);</span>
<span class="lineNum">     239 </span>            :     }
<span class="lineNum">     240 </span>            :   } else {
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, (unsigned long)aProg, 0, 0)) {</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER) failed: %s&quot;,</span>
<span class="lineNum">     243 </span>            :                         strerror(errno));
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;seccomp+tsync failed, but kernel supports tsync&quot;);</span>
<span class="lineNum">     245 </span>            :     }
<span class="lineNum">     246 </span>            :   }
<span class="lineNum">     247 </span>            :   return true;
<span class="lineNum">     248 </span>            : }
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : // Use signals for permissions that need to be set per-thread.
<span class="lineNum">     251 </span>            : // The communication channel from the signal handler back to the main thread.
<span class="lineNum">     252 </span>            : static mozilla::Atomic&lt;int&gt; gSetSandboxDone;
<span class="lineNum">     253 </span>            : // Pass the filter itself through a global.
<span class="lineNum">     254 </span>            : const sock_fprog* gSetSandboxFilter;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : // We have to dynamically allocate the signal number; see bug 1038900.
<span class="lineNum">     257 </span>            : // This function returns the first realtime signal currently set to
<span class="lineNum">     258 </span>            : // default handling (i.e., not in use), or 0 if none could be found.
<span class="lineNum">     259 </span>            : //
<span class="lineNum">     260 </span>            : // WARNING: if this function or anything similar to it (including in
<span class="lineNum">     261 </span>            : // external libraries) is used on multiple threads concurrently, there
<a name="262"><span class="lineNum">     262 </span>            : // will be a race condition.</a>
<span class="lineNum">     263 </span>            : static int
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : FindFreeSignalNumber()</span>
<span class="lineNum">     265 </span>            : {
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   for (int signum = SIGRTMAX; signum &gt;= SIGRTMIN; --signum) {</span>
<span class="lineNum">     267 </span>            :     struct sigaction sa;
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     if (sigaction(signum, nullptr, &amp;sa) == 0 &amp;&amp;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         (sa.sa_flags &amp; SA_SIGINFO) == 0 &amp;&amp;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         sa.sa_handler == SIG_DFL) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       return signum;</span>
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span>            :   }
<span class="lineNum">     275 </span>            :   return 0;
<span class="lineNum">     276 </span>            : }
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            : // Returns true if sandboxing was enabled, or false if sandboxing
<a name="279"><span class="lineNum">     279 </span>            : // already was enabled.  Crashes if sandboxing could not be enabled.</a>
<span class="lineNum">     280 </span>            : static bool
<span class="lineNum">     281 </span><span class="lineNoCov">          0 : SetThreadSandbox()</span>
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   return InstallSyscallFilter(gSetSandboxFilter, false);</span>
<span class="lineNum">     284 </span>            : }
<a name="285"><span class="lineNum">     285 </span>            : </a>
<span class="lineNum">     286 </span>            : static void
<span class="lineNum">     287 </span><span class="lineNoCov">          0 : SetThreadSandboxHandler(int signum)</span>
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :   // The non-zero number sent back to the main thread indicates
<span class="lineNum">     290 </span>            :   // whether action was taken.
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   if (SetThreadSandbox()) {</span>
<span class="lineNum">     292 </span>            :     gSetSandboxDone = 2;
<span class="lineNum">     293 </span>            :   } else {
<span class="lineNum">     294 </span>            :     gSetSandboxDone = 1;
<span class="lineNum">     295 </span>            :   }
<span class="lineNum">     296 </span>            :   // Wake up the main thread.  See the FUTEX_WAIT call, below, for an
<span class="lineNum">     297 </span>            :   // explanation.
<span class="lineNum">     298 </span>            :   syscall(__NR_futex, reinterpret_cast&lt;int*&gt;(&amp;gSetSandboxDone),
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :           FUTEX_WAKE, 1);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 : }</span>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<span class="lineNum">     302 </span>            : static void
<span class="lineNum">     303 </span><span class="lineNoCov">          0 : EnterChroot()</span>
<span class="lineNum">     304 </span>            : {
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   if (gChrootHelper) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     gChrootHelper-&gt;Invoke();</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     gChrootHelper = nullptr;</span>
<span class="lineNum">     308 </span>            :   }
<span class="lineNum">     309 </span><span class="lineNoCov">          0 : }</span>
<a name="310"><span class="lineNum">     310 </span>            : </a>
<span class="lineNum">     311 </span>            : static void
<span class="lineNum">     312 </span><span class="lineNoCov">          0 : BroadcastSetThreadSandbox(const sock_fprog* aFilter)</span>
<span class="lineNum">     313 </span>            : {
<span class="lineNum">     314 </span>            :   pid_t pid, tid, myTid;
<span class="lineNum">     315 </span>            :   DIR *taskdp;
<span class="lineNum">     316 </span>            :   struct dirent *de;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   // This function does not own *aFilter, so this global needs to
<span class="lineNum">     319 </span>            :   // always be zeroed before returning.
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   gSetSandboxFilter = aFilter;</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :   static_assert(sizeof(mozilla::Atomic&lt;int&gt;) == sizeof(int),
<span class="lineNum">     323 </span>            :                 &quot;mozilla::Atomic&lt;int&gt; isn't represented by an int&quot;);
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   pid = getpid();</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   myTid = syscall(__NR_gettid);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   taskdp = opendir(&quot;/proc/self/task&quot;);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   if (taskdp == nullptr) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;opendir /proc/self/task: %s\n&quot;, strerror(errno));</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     MOZ_CRASH();</span>
<span class="lineNum">     330 </span>            :   }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   EnterChroot();</span>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   // In case this races with a not-yet-deprivileged thread cloning
<span class="lineNum">     335 </span>            :   // itself, repeat iterating over all threads until we find none
<span class="lineNum">     336 </span>            :   // that are still privileged.
<span class="lineNum">     337 </span>            :   bool sandboxProgress;
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     sandboxProgress = false;</span>
<span class="lineNum">     340 </span>            :     // For each thread...
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     while ((de = readdir(taskdp))) {</span>
<span class="lineNum">     342 </span>            :       char *endptr;
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       tid = strtol(de-&gt;d_name, &amp;endptr, 10);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :       if (*endptr != '\0' || tid &lt;= 0) {</span>
<span class="lineNum">     345 </span>            :         // Not a task ID.
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     347 </span>            :       }
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       if (tid == myTid) {</span>
<span class="lineNum">     349 </span>            :         // Drop this thread's privileges last, below, so we can
<span class="lineNum">     350 </span>            :         // continue to signal other threads.
<span class="lineNum">     351 </span>            :         continue;
<span class="lineNum">     352 </span>            :       }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       MOZ_RELEASE_ASSERT(gSeccompTsyncBroadcastSignum != 0);</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :       // Reset the futex cell and signal.
<span class="lineNum">     357 </span>            :       gSetSandboxDone = 0;
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       if (syscall(__NR_tgkill, pid, tid, gSeccompTsyncBroadcastSignum) != 0) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         if (errno == ESRCH) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :           SANDBOX_LOG_ERROR(&quot;Thread %d unexpectedly exited.&quot;, tid);</span>
<span class="lineNum">     361 </span>            :           // Rescan threads, in case it forked before exiting.
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :           sandboxProgress = true;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">     364 </span>            :         }
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         SANDBOX_LOG_ERROR(&quot;tgkill(%d,%d): %s\n&quot;, pid, tid, strerror(errno));</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         MOZ_CRASH();</span>
<span class="lineNum">     367 </span>            :       }
<span class="lineNum">     368 </span>            :       // It's unlikely, but if the thread somehow manages to exit
<span class="lineNum">     369 </span>            :       // after receiving the signal but before entering the signal
<span class="lineNum">     370 </span>            :       // handler, we need to avoid blocking forever.
<span class="lineNum">     371 </span>            :       //
<span class="lineNum">     372 </span>            :       // Using futex directly lets the signal handler send the wakeup
<span class="lineNum">     373 </span>            :       // from an async signal handler (pthread mutex/condvar calls
<span class="lineNum">     374 </span>            :       // aren't allowed), and to use a relative timeout that isn't
<span class="lineNum">     375 </span>            :       // affected by changes to the system clock (not possible with
<span class="lineNum">     376 </span>            :       // POSIX semaphores).
<span class="lineNum">     377 </span>            :       //
<span class="lineNum">     378 </span>            :       // If a thread doesn't respond within a reasonable amount of
<span class="lineNum">     379 </span>            :       // time, but still exists, we crash -- the alternative is either
<span class="lineNum">     380 </span>            :       // blocking forever or silently losing security, and it
<span class="lineNum">     381 </span>            :       // shouldn't actually happen.
<span class="lineNum">     382 </span>            :       static const int crashDelay = 10; // seconds
<span class="lineNum">     383 </span>            :       struct timespec timeLimit;
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       clock_gettime(CLOCK_MONOTONIC, &amp;timeLimit);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       timeLimit.tv_sec += crashDelay;</span>
<span class="lineNum">     386 </span>            :       while (true) {
<span class="lineNum">     387 </span>            :         static const struct timespec futexTimeout = { 0, 10*1000*1000 }; // 10ms
<span class="lineNum">     388 </span>            :         // Atomically: if gSetSandboxDone == 0, then sleep.
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         if (syscall(__NR_futex, reinterpret_cast&lt;int*&gt;(&amp;gSetSandboxDone),</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                   FUTEX_WAIT, 0, &amp;futexTimeout) != 0) {</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :           if (errno != EWOULDBLOCK &amp;&amp; errno != ETIMEDOUT &amp;&amp; errno != EINTR) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :             SANDBOX_LOG_ERROR(&quot;FUTEX_WAIT: %s\n&quot;, strerror(errno));</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             MOZ_CRASH();</span>
<span class="lineNum">     394 </span>            :           }
<span class="lineNum">     395 </span>            :         }
<span class="lineNum">     396 </span>            :         // Did the handler finish?
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         if (gSetSandboxDone &gt; 0) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :           if (gSetSandboxDone == 2) {</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :             sandboxProgress = true;</span>
<span class="lineNum">     400 </span>            :           }
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     402 </span>            :         }
<span class="lineNum">     403 </span>            :         // Has the thread ceased to exist?
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         if (syscall(__NR_tgkill, pid, tid, 0) != 0) {</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :           if (errno == ESRCH) {</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :             SANDBOX_LOG_ERROR(&quot;Thread %d unexpectedly exited.&quot;, tid);</span>
<span class="lineNum">     407 </span>            :           }
<span class="lineNum">     408 </span>            :           // Rescan threads, in case it forked before exiting.
<span class="lineNum">     409 </span>            :           // Also, if it somehow failed in a way that wasn't ESRCH,
<span class="lineNum">     410 </span>            :           // and still exists, that will be handled on the next pass.
<span class="lineNum">     411 </span>            :           sandboxProgress = true;
<span class="lineNum">     412 </span>            :           break;
<span class="lineNum">     413 </span>            :         }
<span class="lineNum">     414 </span>            :         struct timespec now;
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         clock_gettime(CLOCK_MONOTONIC, &amp;now);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         if (now.tv_sec &gt; timeLimit.tv_sec ||</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :             (now.tv_sec == timeLimit.tv_sec &amp;&amp;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :              now.tv_nsec &gt; timeLimit.tv_nsec)) {</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :           SANDBOX_LOG_ERROR(&quot;Thread %d unresponsive for %d seconds.&quot;</span>
<span class="lineNum">     420 </span>            :                             &quot;  Killing process.&quot;,
<span class="lineNum">     421 </span>            :                             tid, crashDelay);
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :           MOZ_CRASH();</span>
<span class="lineNum">     423 </span>            :         }
<span class="lineNum">     424 </span>            :       }
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     rewinddir(taskdp);</span>
<span class="lineNum">     427 </span>            :   } while (sandboxProgress);
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :   void (*oldHandler)(int);
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   oldHandler = signal(gSeccompTsyncBroadcastSignum, SIG_DFL);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   gSeccompTsyncBroadcastSignum = 0;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   if (oldHandler != SetThreadSandboxHandler) {</span>
<span class="lineNum">     433 </span>            :     // See the comment on FindFreeSignalNumber about race conditions.
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;handler for signal %d was changed to %p!&quot;,</span>
<span class="lineNum">     435 </span>            :                       gSeccompTsyncBroadcastSignum, oldHandler);
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     MOZ_CRASH();</span>
<span class="lineNum">     437 </span>            :   }
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   Unused &lt;&lt; closedir(taskdp);</span>
<span class="lineNum">     439 </span>            :   // And now, deprivilege the main thread:
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   SetThreadSandbox();</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   gSetSandboxFilter = nullptr;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : }</span>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<span class="lineNum">     444 </span>            : static void
<span class="lineNum">     445 </span><span class="lineNoCov">          0 : ApplySandboxWithTSync(sock_fprog* aFilter)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   EnterChroot();</span>
<span class="lineNum">     448 </span>            :   // At this point we're committed to using tsync, because the signal
<span class="lineNum">     449 </span>            :   // broadcast workaround needs to access procfs.  (Unless chroot
<span class="lineNum">     450 </span>            :   // isn't used... but this failure shouldn't happen in the first
<span class="lineNum">     451 </span>            :   // place, so let's not make extra special cases for it.)
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   if (!InstallSyscallFilter(aFilter, true)) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     MOZ_CRASH();</span>
<span class="lineNum">     454 </span>            :   }
<span class="lineNum">     455 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     456 </span>            : 
<a name="457"><span class="lineNum">     457 </span>            : // Common code for sandbox startup.</a>
<span class="lineNum">     458 </span>            : static void
<span class="lineNum">     459 </span><span class="lineNoCov">          0 : SetCurrentProcessSandbox(UniquePtr&lt;sandbox::bpf_dsl::Policy&gt; aPolicy)</span>
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span>            :   MOZ_ASSERT(gSandboxCrashFunc);
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   MOZ_RELEASE_ASSERT(gSandboxReporterClient.isSome());</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   // Note: PolicyCompiler borrows the policy and registry for its
<span class="lineNum">     465 </span>            :   // lifetime, but does not take ownership of them.
<span class="lineNum">     466 </span>            :   sandbox::bpf_dsl::PolicyCompiler compiler(aPolicy.get(),
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                                             sandbox::Trap::Registry());</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   sandbox::CodeGen::Program program = compiler.Compile();</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   if (SandboxInfo::Get().Test(SandboxInfo::kVerbose)) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     sandbox::bpf_dsl::DumpBPF::PrintProgram(program);</span>
<span class="lineNum">     471 </span>            :   }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   InstallSigSysHandler();</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : #ifdef MOZ_ASAN
<span class="lineNum">     476 </span>            :   __sanitizer_sandbox_arguments asanArgs;
<span class="lineNum">     477 </span>            :   asanArgs.coverage_sandboxed = 1;
<span class="lineNum">     478 </span>            :   asanArgs.coverage_fd = -1;
<span class="lineNum">     479 </span>            :   asanArgs.coverage_max_block_size = 0;
<span class="lineNum">     480 </span>            :   __sanitizer_sandbox_on_notify(&amp;asanArgs);
<span class="lineNum">     481 </span>            : #endif
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :   // The syscall takes a C-style array, so copy the vector into one.
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   size_t programLen = program.size();</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   UniquePtr&lt;sock_filter[]&gt; flatProgram(new sock_filter[programLen]);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   for (auto i = program.begin(); i != program.end(); ++i) {</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     flatProgram[i - program.begin()] = *i;</span>
<span class="lineNum">     488 </span>            :   }
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :   sock_fprog fprog;
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   fprog.filter = flatProgram.get();</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   fprog.len = static_cast&lt;unsigned short&gt;(programLen);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   MOZ_RELEASE_ASSERT(static_cast&lt;size_t&gt;(fprog.len) == programLen);</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   const SandboxInfo info = SandboxInfo::Get();</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   if (info.Test(SandboxInfo::kHasSeccompTSync)) {</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     if (info.Test(SandboxInfo::kVerbose)) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;using seccomp tsync&quot;);</span>
<span class="lineNum">     499 </span>            :     }
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     ApplySandboxWithTSync(&amp;fprog);</span>
<span class="lineNum">     501 </span>            :   } else {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     if (info.Test(SandboxInfo::kVerbose)) {</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;no tsync support; using signal broadcast&quot;);</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     BroadcastSetThreadSandbox(&amp;fprog);</span>
<span class="lineNum">     506 </span>            :   }
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   MOZ_RELEASE_ASSERT(!gChrootHelper, &quot;forgot to chroot&quot;);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 : }</span>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<span class="lineNum">     510 </span>            : void
<span class="lineNum">     511 </span><span class="lineCov">          1 : SandboxEarlyInit(GeckoProcessType aType)</span>
<span class="lineNum">     512 </span>            : {
<span class="lineNum">     513 </span><span class="lineCov">          1 :   const SandboxInfo info = SandboxInfo::Get();</span>
<span class="lineNum">     514 </span><span class="lineCov">          1 :   if (info.Test(SandboxInfo::kUnexpectedThreads)) {</span>
<span class="lineNum">     515 </span>            :     return;
<span class="lineNum">     516 </span>            :   }
<span class="lineNum">     517 </span><span class="lineCov">          1 :   MOZ_RELEASE_ASSERT(IsSingleThreaded());</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :   // Set gSandboxCrashOnError if appropriate.  This doesn't need to
<span class="lineNum">     520 </span>            :   // happen this early, but for now it's here so that I don't need to
<span class="lineNum">     521 </span>            :   // add NSPR dependencies for PR_GetEnv.
<span class="lineNum">     522 </span>            :   //
<span class="lineNum">     523 </span>            :   // This also means that users with &quot;unexpected threads&quot; setups won't
<span class="lineNum">     524 </span>            :   // crash even on nightly.
<span class="lineNum">     525 </span>            : #ifdef NIGHTLY_BUILD
<span class="lineNum">     526 </span><span class="lineCov">          1 :   gSandboxCrashOnError = true;</span>
<span class="lineNum">     527 </span>            : #endif
<span class="lineNum">     528 </span><span class="lineCov">          1 :   if (const char* envVar = getenv(&quot;MOZ_SANDBOX_CRASH_ON_ERROR&quot;)) {</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     if (envVar[0]) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       gSandboxCrashOnError = envVar[0] != '0';</span>
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            :   }
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   // Which kinds of resource isolation (of those that need to be set
<span class="lineNum">     535 </span>            :   // up at this point) can be used by this process?
<span class="lineNum">     536 </span><span class="lineCov">          1 :   bool canChroot = false;</span>
<span class="lineNum">     537 </span><span class="lineCov">          1 :   bool canUnshareNet = false;</span>
<span class="lineNum">     538 </span><span class="lineCov">          1 :   bool canUnshareIPC = false;</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineCov">          1 :   switch (aType) {</span>
<span class="lineNum">     541 </span>            :   case GeckoProcessType_Default:
<span class="lineNum">     542 </span>            :     MOZ_ASSERT(false, &quot;SandboxEarlyInit in parent process&quot;);
<span class="lineNum">     543 </span>            :     return;
<span class="lineNum">     544 </span>            : #ifdef MOZ_GMP_SANDBOX
<span class="lineNum">     545 </span>            :   case GeckoProcessType_GMPlugin:
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     if (!info.Test(SandboxInfo::kEnabledForMedia)) {</span>
<span class="lineNum">     547 </span>            :       break;
<span class="lineNum">     548 </span>            :     }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     canUnshareNet = true;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     canUnshareIPC = true;</span>
<span class="lineNum">     551 </span>            :     // Need seccomp-bpf to intercept open().
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     canChroot = info.Test(SandboxInfo::kHasSeccompBPF);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     554 </span>            : #endif
<span class="lineNum">     555 </span>            :     // In the future, content processes will be able to use some of
<span class="lineNum">     556 </span>            :     // these.
<span class="lineNum">     557 </span>            :   default:
<span class="lineNum">     558 </span>            :     // Other cases intentionally left blank.
<span class="lineNum">     559 </span>            :     break;
<span class="lineNum">     560 </span>            :   }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :   // If TSYNC is not supported, set up signal handler
<span class="lineNum">     563 </span>            :   // used to enable seccomp on each thread.
<span class="lineNum">     564 </span><span class="lineCov">          1 :   if (!info.Test(SandboxInfo::kHasSeccompTSync)) {</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     gSeccompTsyncBroadcastSignum = FindFreeSignalNumber();</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     if (gSeccompTsyncBroadcastSignum == 0) {</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;No available signal numbers!&quot;);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :       MOZ_CRASH();</span>
<span class="lineNum">     569 </span>            :     }
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :     void (*oldHandler)(int);
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     oldHandler = signal(gSeccompTsyncBroadcastSignum, SetThreadSandboxHandler);</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :     if (oldHandler != SIG_DFL) {</span>
<span class="lineNum">     574 </span>            :       // See the comment on FindFreeSignalNumber about race conditions.
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;signal %d in use by handler %p!\n&quot;,</span>
<span class="lineNum">     576 </span>            :         gSeccompTsyncBroadcastSignum, oldHandler);
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       MOZ_CRASH();</span>
<span class="lineNum">     578 </span>            :     }
<span class="lineNum">     579 </span>            :   }
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            :   // If there's nothing to do, then we're done.
<span class="lineNum">     582 </span><span class="lineCov">          1 :   if (!canChroot &amp;&amp; !canUnshareNet &amp;&amp; !canUnshareIPC) {</span>
<span class="lineNum">     583 </span>            :     return;
<span class="lineNum">     584 </span>            :   }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :   {
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     LinuxCapabilities existingCaps;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     if (existingCaps.GetCurrent() &amp;&amp; existingCaps.AnyEffective()) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;PLEASE DO NOT RUN THIS AS ROOT.  Strange things may&quot;</span>
<span class="lineNum">     590 </span>            :                         &quot; happen when capabilities are dropped.&quot;);
<span class="lineNum">     591 </span>            :     }
<span class="lineNum">     592 </span>            :   }
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :   // If capabilities can't be gained, then nothing can be done.
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   if (!info.Test(SandboxInfo::kHasUserNamespaces)) {</span>
<span class="lineNum">     596 </span>            :     // Drop any existing capabilities; unsharing the user namespace
<span class="lineNum">     597 </span>            :     // would implicitly drop them, so if we're running in a broken
<span class="lineNum">     598 </span>            :     // configuration where that would matter (e.g., running as root
<span class="lineNum">     599 </span>            :     // from a non-root-owned mode-0700 directory) this means it will
<span class="lineNum">     600 </span>            :     // break the same way on all kernels and be easier to troubleshoot.
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     LinuxCapabilities().SetCurrent();</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     603 </span>            :   }
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   // The failure cases for the various unshares, and setting up the
<span class="lineNum">     606 </span>            :   // chroot helper, don't strictly need to be fatal -- but they also
<span class="lineNum">     607 </span>            :   // shouldn't fail on any reasonable system, so let's take the small
<span class="lineNum">     608 </span>            :   // risk of breakage over the small risk of quietly providing less
<span class="lineNum">     609 </span>            :   // security than we expect.  (Unlike in SandboxInfo, this is in the
<span class="lineNum">     610 </span>            :   // child process, so crashing here isn't as severe a response to the
<span class="lineNum">     611 </span>            :   // unexpected.)
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   if (!UnshareUserNamespace()) {</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;unshare(CLONE_NEWUSER): %s&quot;, strerror(errno));</span>
<span class="lineNum">     614 </span>            :     // If CanCreateUserNamespace (SandboxInfo.cpp) returns true, then
<span class="lineNum">     615 </span>            :     // the unshare shouldn't have failed.
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;unshare(CLONE_NEWUSER)&quot;);</span>
<span class="lineNum">     617 </span>            :   }
<span class="lineNum">     618 </span>            :   // No early returns after this point!  We need to drop the
<span class="lineNum">     619 </span>            :   // capabilities that were gained by unsharing the user namesapce.
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   if (canUnshareIPC &amp;&amp; syscall(__NR_unshare, CLONE_NEWIPC) != 0) {</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;unshare(CLONE_NEWIPC): %s&quot;, strerror(errno));</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;unshare(CLONE_NEWIPC)&quot;);</span>
<span class="lineNum">     624 </span>            :   }
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   if (canUnshareNet &amp;&amp; syscall(__NR_unshare, CLONE_NEWNET) != 0) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;unshare(CLONE_NEWNET): %s&quot;, strerror(errno));</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;unshare(CLONE_NEWNET)&quot;);</span>
<span class="lineNum">     629 </span>            :   }
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   if (canChroot) {</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     gChrootHelper = MakeUnique&lt;SandboxChroot&gt;();</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     if (!gChrootHelper-&gt;Prepare()) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;failed to set up chroot helper&quot;);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;SandboxChroot::Prepare&quot;);</span>
<span class="lineNum">     636 </span>            :     }
<span class="lineNum">     637 </span>            :   }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :   if (!LinuxCapabilities().SetCurrent()) {</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;dropping capabilities: %s&quot;, strerror(errno));</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;can't drop capabilities&quot;);</span>
<span class="lineNum">     642 </span>            :   }
<span class="lineNum">     643 </span>            : }
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : #ifdef MOZ_CONTENT_SANDBOX
<span class="lineNum">     646 </span>            : /**
<span class="lineNum">     647 </span>            :  * Starts the seccomp sandbox for a content process.  Should be called
<span class="lineNum">     648 </span>            :  * only once, and before any potentially harmful content is loaded.
<span class="lineNum">     649 </span>            :  *
<span class="lineNum">     650 </span>            :  * Will normally make the process exit on failure.
<a name="651"><span class="lineNum">     651 </span>            : */</a>
<span class="lineNum">     652 </span>            : bool
<span class="lineNum">     653 </span><span class="lineNoCov">          0 : SetContentProcessSandbox(int aBrokerFd, std::vector&lt;int&gt;&amp; aSyscallWhitelist)</span>
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   if (!SandboxInfo::Get().Test(SandboxInfo::kEnabledForContent)) {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     if (aBrokerFd &gt;= 0) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :       close(aBrokerFd);</span>
<span class="lineNum">     658 </span>            :     }
<span class="lineNum">     659 </span>            :     return false;
<span class="lineNum">     660 </span>            :   }
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   gSandboxReporterClient.emplace(SandboxReport::ProcType::CONTENT);</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :   // This needs to live until the process exits.
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   static Maybe&lt;SandboxBrokerClient&gt; sBroker;</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :   if (aBrokerFd &gt;= 0) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     sBroker.emplace(aBrokerFd);</span>
<span class="lineNum">     668 </span>            :   }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :   SetCurrentProcessSandbox(GetContentSandboxPolicy(sBroker.ptrOr(nullptr),
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :                                                    aSyscallWhitelist));</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     673 </span>            : }
<span class="lineNum">     674 </span>            : #endif // MOZ_CONTENT_SANDBOX
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : #ifdef MOZ_GMP_SANDBOX
<span class="lineNum">     677 </span>            : /**
<span class="lineNum">     678 </span>            :  * Starts the seccomp sandbox for a media plugin process.  Should be
<span class="lineNum">     679 </span>            :  * called only once, and before any potentially harmful content is
<span class="lineNum">     680 </span>            :  * loaded -- including the plugin itself, if it's considered untrusted.
<span class="lineNum">     681 </span>            :  *
<span class="lineNum">     682 </span>            :  * The file indicated by aFilePath, if non-null, can be open()ed
<span class="lineNum">     683 </span>            :  * read-only, once, after the sandbox starts; it should be the .so
<span class="lineNum">     684 </span>            :  * file implementing the not-yet-loaded plugin.
<span class="lineNum">     685 </span>            :  *
<span class="lineNum">     686 </span>            :  * Will normally make the process exit on failure.
<a name="687"><span class="lineNum">     687 </span>            : */</a>
<span class="lineNum">     688 </span>            : void
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : SetMediaPluginSandbox(const char *aFilePath)</span>
<span class="lineNum">     690 </span>            : {
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   if (!SandboxInfo::Get().Test(SandboxInfo::kEnabledForMedia)) {</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     693 </span>            :   }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :   gSandboxReporterClient.emplace(SandboxReport::ProcType::MEDIA_PLUGIN);</span>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :   MOZ_ASSERT(!gMediaPluginFile.mPath);
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   if (aFilePath) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     gMediaPluginFile.mPath = strdup(aFilePath);</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     gMediaPluginFile.mFd = open(aFilePath, O_RDONLY | O_CLOEXEC);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     if (gMediaPluginFile.mFd == -1) {</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;failed to open plugin file %s: %s&quot;,</span>
<span class="lineNum">     703 </span>            :                         aFilePath, strerror(errno));
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       MOZ_CRASH();</span>
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span>            :   } else {
<span class="lineNum">     707 </span>            :     gMediaPluginFile.mFd = -1;
<span class="lineNum">     708 </span>            :   }
<span class="lineNum">     709 </span>            :   // Finally, start the sandbox.
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   SetCurrentProcessSandbox(GetMediaSandboxPolicy(&amp;gMediaPluginFile));</span>
<span class="lineNum">     711 </span>            : }
<a name="712"><span class="lineNum">     712 </span>            : #endif // MOZ_GMP_SANDBOX</a>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">          1 : } // namespace mozilla</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
