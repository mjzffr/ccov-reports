<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/sandbox/linux/SandboxFilter.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">security/sandbox/linux</a> - SandboxFilter.cpp<span style="font-size: 80%;"> (source / <a href="SandboxFilter.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">278</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
<span class="lineNum">       5 </span>            :  * You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;SandboxFilter.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;SandboxFilterUtil.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;SandboxBrokerClient.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;SandboxInfo.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;SandboxInternal.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;SandboxLogging.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;linux/ipc.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;linux/net.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;linux/prctl.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;linux/sched.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;sys/mman.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;sys/socket.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;sys/syscall.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;vector&gt;
<span class="lineNum">      29 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &quot;sandbox/linux/bpf_dsl/bpf_dsl.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;sandbox/linux/system_headers/linux_seccomp.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;sandbox/linux/system_headers/linux_syscalls.h&quot;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : using namespace sandbox::bpf_dsl;
<span class="lineNum">      36 </span>            : #define CASES SANDBOX_BPF_DSL_CASES
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : // Fill in defines in case of old headers.
<span class="lineNum">      39 </span>            : // (Warning: these are wrong on PA-RISC.)
<span class="lineNum">      40 </span>            : #ifndef MADV_NOHUGEPAGE
<span class="lineNum">      41 </span>            : #define MADV_NOHUGEPAGE 15
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : #ifndef MADV_DONTDUMP
<span class="lineNum">      44 </span>            : #define MADV_DONTDUMP 16
<span class="lineNum">      45 </span>            : #endif
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : // Added in Linux 4.5; see bug 1303813.
<span class="lineNum">      48 </span>            : #ifndef MADV_FREE
<span class="lineNum">      49 </span>            : #define MADV_FREE 8
<span class="lineNum">      50 </span>            : #endif
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #ifndef PR_SET_PTRACER
<span class="lineNum">      53 </span>            : #define PR_SET_PTRACER 0x59616d61
<span class="lineNum">      54 </span>            : #endif
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : // To avoid visual confusion between &quot;ifdef ANDROID&quot; and &quot;ifndef ANDROID&quot;:
<span class="lineNum">      57 </span>            : #ifndef ANDROID
<span class="lineNum">      58 </span>            : #define DESKTOP
<span class="lineNum">      59 </span>            : #endif
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : // This file defines the seccomp-bpf system call filter policies.
<span class="lineNum">      62 </span>            : // See also SandboxFilterUtil.h, for the CASES_FOR_* macros and
<span class="lineNum">      63 </span>            : // SandboxFilterBase::Evaluate{Socket,Ipc}Call.
<span class="lineNum">      64 </span>            : //
<span class="lineNum">      65 </span>            : // One important difference from how Chromium bpf_dsl filters are
<span class="lineNum">      66 </span>            : // normally interpreted: returning -ENOSYS from a Trap() handler
<span class="lineNum">      67 </span>            : // indicates an unexpected system call; SigSysHandler() in Sandbox.cpp
<span class="lineNum">      68 </span>            : // will detect this, request a crash dump, and terminate the process.
<span class="lineNum">      69 </span>            : // This does not apply to using Error(ENOSYS) in the policy, so that
<span class="lineNum">      70 </span>            : // can be used if returning an actual ENOSYS is needed.
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : namespace mozilla {
<span class="lineNum">      73 </span>            : 
<a name="74"><span class="lineNum">      74 </span>            : // This class whitelists everything used by the sandbox itself, by the</a>
<span class="lineNum">      75 </span>            : // core IPC code, by the crash reporter, or other core code.
<span class="lineNum">      76 </span><span class="lineNoCov">          0 : class SandboxPolicyCommon : public SandboxPolicyBase</span>
<span class="lineNum">      77 </span>            : {
<span class="lineNum">      78 </span>            : protected:
<a name="79"><span class="lineNum">      79 </span>            :   typedef const sandbox::arch_seccomp_data&amp; ArgsRef;</a>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   static intptr_t BlockedSyscallTrap(ArgsRef aArgs, void *aux) {</span>
<span class="lineNum">      82 </span>            :     MOZ_ASSERT(!aux);
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     return -ENOSYS;</span>
<span class="lineNum">      84 </span>            :   }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : private:
<span class="lineNum">      87 </span>            : #if defined(ANDROID) &amp;&amp; ANDROID_VERSION &lt; 16
<span class="lineNum">      88 </span>            :   // Bug 1093893: Translate tkill to tgkill for pthread_kill; fixed in
<span class="lineNum">      89 </span>            :   // bionic commit 10c8ce59a (in JB and up; API level 16 = Android 4.1).
<span class="lineNum">      90 </span>            :   static intptr_t TKillCompatTrap(const sandbox::arch_seccomp_data&amp; aArgs,
<span class="lineNum">      91 </span>            :                                   void *aux)
<span class="lineNum">      92 </span>            :   {
<span class="lineNum">      93 </span>            :     return syscall(__NR_tgkill, getpid(), aArgs.args[0], aArgs.args[1]);
<span class="lineNum">      94 </span>            :   }
<a name="95"><span class="lineNum">      95 </span>            : #endif</a>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   static intptr_t SetNoNewPrivsTrap(ArgsRef&amp; aArgs, void* aux) {</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     if (gSetSandboxFilter == nullptr) {</span>
<span class="lineNum">      99 </span>            :       // Called after BroadcastSetThreadSandbox finished, therefore
<span class="lineNum">     100 </span>            :       // not our doing and not expected.
<span class="lineNum">     101 </span>            :       return BlockedSyscallTrap(aArgs, nullptr);
<span class="lineNum">     102 </span>            :     }
<span class="lineNum">     103 </span>            :     // Signal that the filter is already in place.
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     return -ETXTBSY;</span>
<span class="lineNum">     105 </span>            :   }
<a name="106"><span class="lineNum">     106 </span>            : </a>
<span class="lineNum">     107 </span>            : public:
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   virtual ResultExpr InvalidSyscall() const override {</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     return Trap(BlockedSyscallTrap, nullptr);</span>
<a name="110"><span class="lineNum">     110 </span>            :   }</a>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   virtual ResultExpr ClonePolicy(ResultExpr failPolicy) const {</span>
<span class="lineNum">     113 </span>            :     // Allow use for simple thread creation (pthread_create) only.
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :     // WARNING: s390 and cris pass the flags in the second arg -- see
<span class="lineNum">     116 </span>            :     // CLONE_BACKWARDS2 in arch/Kconfig in the kernel source -- but we
<span class="lineNum">     117 </span>            :     // don't support seccomp-bpf on those archs yet.
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     Arg&lt;int&gt; flags(0);</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :     // The glibc source hasn't changed the thread creation clone flags
<span class="lineNum">     121 </span>            :     // since 2004, so this *should* be safe to hard-code.  Bionic's
<span class="lineNum">     122 </span>            :     // value has changed a few times, and has converged on the same one
<span class="lineNum">     123 </span>            :     // as glibc; allow any of them.
<span class="lineNum">     124 </span>            :     static const int flags_common = CLONE_VM | CLONE_FS | CLONE_FILES |
<span class="lineNum">     125 </span>            :       CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM;
<span class="lineNum">     126 </span>            :     static const int flags_modern = flags_common | CLONE_SETTLS |
<span class="lineNum">     127 </span>            :       CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID;
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :     // Can't use CASES here because its decltype magic infers const
<span class="lineNum">     130 </span>            :     // int instead of regular int and bizarre voluminous errors issue
<span class="lineNum">     131 </span>            :     // forth from the depths of the standard library implementation.
<span class="lineNum">     132 </span>            :     return Switch(flags)
<span class="lineNum">     133 </span>            : #ifdef ANDROID
<span class="lineNum">     134 </span>            :       .Case(flags_common | CLONE_DETACHED, Allow()) // &lt;= JB 4.2
<span class="lineNum">     135 </span>            :       .Case(flags_common, Allow()) // JB 4.3 or KK 4.4
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            :       .Case(flags_modern, Allow()) // Android L or glibc
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :       .Default(failPolicy);</span>
<a name="139"><span class="lineNum">     139 </span>            :   }</a>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   virtual ResultExpr PrctlPolicy() const {</span>
<span class="lineNum">     142 </span>            :     // Note: this will probably need PR_SET_VMA if/when it's used on
<span class="lineNum">     143 </span>            :     // Android without being overridden by an allow-all policy, and
<span class="lineNum">     144 </span>            :     // the constant will need to be defined locally.
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     Arg&lt;int&gt; op(0);</span>
<span class="lineNum">     146 </span>            :     return Switch(op)
<span class="lineNum">     147 </span>            :       .CASES((PR_GET_SECCOMP, // BroadcastSetThreadSandbox, etc.
<span class="lineNum">     148 </span>            :               PR_SET_NAME,    // Thread creation
<span class="lineNum">     149 </span>            :               PR_SET_DUMPABLE, // Crash reporting
<span class="lineNum">     150 </span>            :               PR_SET_PTRACER), // Debug-mode crash handling
<span class="lineNum">     151 </span>            :              Allow())
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :       .Default(InvalidSyscall());</span>
<a name="153"><span class="lineNum">     153 </span>            :   }</a>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   virtual Maybe&lt;ResultExpr&gt; EvaluateSocketCall(int aCall) const override {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     switch (aCall) {</span>
<span class="lineNum">     157 </span>            :     case SYS_RECVMSG:
<span class="lineNum">     158 </span>            :     case SYS_SENDMSG:
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       return Some(Allow());</span>
<span class="lineNum">     160 </span>            :     default:
<span class="lineNum">     161 </span>            :       return Nothing();
<span class="lineNum">     162 </span>            :     }
<a name="163"><span class="lineNum">     163 </span>            :   }</a>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   virtual ResultExpr EvaluateSyscall(int sysno) const override {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     switch (sysno) {</span>
<span class="lineNum">     167 </span>            :       // Timekeeping
<span class="lineNum">     168 </span>            :     case __NR_clock_gettime: {
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       Arg&lt;clockid_t&gt; clk_id(0);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :       return If(clk_id == CLOCK_MONOTONIC, Allow())</span>
<span class="lineNum">     171 </span>            : #ifdef CLOCK_MONOTONIC_COARSE
<span class="lineNum">     172 </span>            :         // Used by SandboxReporter, among other things.
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :         .ElseIf(clk_id == CLOCK_MONOTONIC_COARSE, Allow())</span>
<span class="lineNum">     174 </span>            : #endif
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         .ElseIf(clk_id == CLOCK_PROCESS_CPUTIME_ID, Allow())</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         .ElseIf(clk_id == CLOCK_REALTIME, Allow())</span>
<span class="lineNum">     177 </span>            : #ifdef CLOCK_REALTIME_COARSE
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         .ElseIf(clk_id == CLOCK_REALTIME_COARSE, Allow())</span>
<span class="lineNum">     179 </span>            : #endif
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         .ElseIf(clk_id == CLOCK_THREAD_CPUTIME_ID, Allow())</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         .Else(InvalidSyscall());</span>
<span class="lineNum">     182 </span>            :     }
<span class="lineNum">     183 </span>            :     case __NR_gettimeofday:
<span class="lineNum">     184 </span>            : #ifdef __NR_time
<span class="lineNum">     185 </span>            :     case __NR_time:
<span class="lineNum">     186 </span>            : #endif
<span class="lineNum">     187 </span>            :     case __NR_nanosleep:
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :       // Thread synchronization
<span class="lineNum">     191 </span>            :     case __NR_futex:
<span class="lineNum">     192 </span>            :       // FIXME: This could be more restrictive....
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :       // Asynchronous I/O
<span class="lineNum">     196 </span>            :     case __NR_epoll_wait:
<span class="lineNum">     197 </span>            :     case __NR_epoll_pwait:
<span class="lineNum">     198 </span>            :     case __NR_epoll_ctl:
<span class="lineNum">     199 </span>            :     case __NR_ppoll:
<span class="lineNum">     200 </span>            :     case __NR_poll:
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :       // Used when requesting a crash dump.
<span class="lineNum">     204 </span>            :     case __NR_pipe:
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :       // Metadata of opened files
<span class="lineNum">     208 </span>            :     CASES_FOR_fstat:
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :       // Simple I/O
<span class="lineNum">     212 </span>            :     case __NR_write:
<span class="lineNum">     213 </span>            :     case __NR_read:
<span class="lineNum">     214 </span>            :     case __NR_readv:
<span class="lineNum">     215 </span>            :     case __NR_writev: // see SandboxLogging.cpp
<span class="lineNum">     216 </span>            :     CASES_FOR_lseek:
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :       // Memory mapping
<span class="lineNum">     220 </span>            :     CASES_FOR_mmap:
<span class="lineNum">     221 </span>            :     case __NR_munmap:
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :       // Signal handling
<span class="lineNum">     225 </span>            : #if defined(ANDROID) || defined(MOZ_ASAN)
<span class="lineNum">     226 </span>            :     case __NR_sigaltstack:
<span class="lineNum">     227 </span>            : #endif
<span class="lineNum">     228 </span>            :     CASES_FOR_sigreturn:
<span class="lineNum">     229 </span>            :     CASES_FOR_sigprocmask:
<span class="lineNum">     230 </span>            :     CASES_FOR_sigaction:
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :       // Send signals within the process (raise(), profiling, etc.)
<span class="lineNum">     234 </span>            :     case __NR_tgkill: {
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       Arg&lt;pid_t&gt; tgid(0);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :       return If(tgid == getpid(), Allow())</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         .Else(InvalidSyscall());</span>
<span class="lineNum">     238 </span>            :     }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : #if defined(ANDROID) &amp;&amp; ANDROID_VERSION &lt; 16
<span class="lineNum">     241 </span>            :       // Polyfill with tgkill; see above.
<span class="lineNum">     242 </span>            :     case __NR_tkill:
<span class="lineNum">     243 </span>            :       return Trap(TKillCompatTrap, nullptr);
<span class="lineNum">     244 </span>            : #endif
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :       // Yield
<span class="lineNum">     247 </span>            :     case __NR_sched_yield:
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :       // Thread creation.
<span class="lineNum">     251 </span>            :     case __NR_clone:
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       return ClonePolicy(InvalidSyscall());</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :       // More thread creation.
<span class="lineNum">     255 </span>            : #ifdef __NR_set_robust_list
<span class="lineNum">     256 </span>            :     case __NR_set_robust_list:
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     258 </span>            : #endif
<span class="lineNum">     259 </span>            : #ifdef ANDROID
<span class="lineNum">     260 </span>            :     case __NR_set_tid_address:
<span class="lineNum">     261 </span>            :       return Allow();
<span class="lineNum">     262 </span>            : #endif
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :       // prctl
<span class="lineNum">     265 </span>            :     case __NR_prctl: {
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :       if (SandboxInfo::Get().Test(SandboxInfo::kHasSeccompTSync)) {</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         return PrctlPolicy();</span>
<span class="lineNum">     268 </span>            :       }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       Arg&lt;int&gt; option(0);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       return If(option == PR_SET_NO_NEW_PRIVS,</span>
<span class="lineNum">     272 </span>            :                 Trap(SetNoNewPrivsTrap, nullptr))
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         .Else(PrctlPolicy());</span>
<span class="lineNum">     274 </span>            :     }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :       // NSPR can call this when creating a thread, but it will accept a
<span class="lineNum">     277 </span>            :       // polite &quot;no&quot;.
<span class="lineNum">     278 </span>            :     case __NR_getpriority:
<span class="lineNum">     279 </span>            :       // But if thread creation races with sandbox startup, that call
<span class="lineNum">     280 </span>            :       // could succeed, and then we get one of these:
<span class="lineNum">     281 </span>            :     case __NR_setpriority:
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :       return Error(EACCES);</span>
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :       // Stack bounds are obtained via pthread_getattr_np, which calls
<span class="lineNum">     285 </span>            :       // this but doesn't actually need it:
<span class="lineNum">     286 </span>            :     case __NR_sched_getaffinity:
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       return Error(ENOSYS);</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :       // Read own pid/tid.
<span class="lineNum">     290 </span>            :     case __NR_getpid:
<span class="lineNum">     291 </span>            :     case __NR_gettid:
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :       // Discard capabilities
<span class="lineNum">     295 </span>            :     case __NR_close:
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :       // Machine-dependent stuff
<span class="lineNum">     299 </span>            : #ifdef __arm__
<span class="lineNum">     300 </span>            :     case __ARM_NR_breakpoint:
<span class="lineNum">     301 </span>            :     case __ARM_NR_cacheflush:
<span class="lineNum">     302 </span>            :     case __ARM_NR_usr26: // FIXME: do we actually need this?
<span class="lineNum">     303 </span>            :     case __ARM_NR_usr32:
<span class="lineNum">     304 </span>            :     case __ARM_NR_set_tls:
<span class="lineNum">     305 </span>            :       return Allow();
<span class="lineNum">     306 </span>            : #endif
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :       // Needed when being debugged:
<span class="lineNum">     309 </span>            :     case __NR_restart_syscall:
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :       // Terminate threads or the process
<span class="lineNum">     313 </span>            :     case __NR_exit:
<span class="lineNum">     314 </span>            :     case __NR_exit_group:
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : #ifdef MOZ_ASAN
<span class="lineNum">     318 </span>            :       // ASAN's error reporter wants to know if stderr is a tty.
<span class="lineNum">     319 </span>            :     case __NR_ioctl: {
<span class="lineNum">     320 </span>            :       Arg&lt;int&gt; fd(0);
<span class="lineNum">     321 </span>            :       return If(fd == STDERR_FILENO, Allow())
<span class="lineNum">     322 </span>            :         .Else(InvalidSyscall());
<span class="lineNum">     323 </span>            :     }
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :       // ...and before compiler-rt r209773, it will call readlink on
<span class="lineNum">     326 </span>            :       // /proc/self/exe and use the cached value only if that fails:
<span class="lineNum">     327 </span>            :     case __NR_readlink:
<span class="lineNum">     328 </span>            :     case __NR_readlinkat:
<span class="lineNum">     329 </span>            :       return Error(ENOENT);
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :       // ...and if it found an external symbolizer, it will try to run it:
<span class="lineNum">     332 </span>            :       // (See also bug 1081242 comment #7.)
<span class="lineNum">     333 </span>            :     CASES_FOR_stat:
<span class="lineNum">     334 </span>            :       return Error(ENOENT);
<span class="lineNum">     335 </span>            : #endif
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :     default:
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       return SandboxPolicyBase::EvaluateSyscall(sysno);</span>
<span class="lineNum">     339 </span>            :     }
<span class="lineNum">     340 </span>            :   }
<span class="lineNum">     341 </span>            : };
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : // The process-type-specific syscall rules start here:
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : #ifdef MOZ_CONTENT_SANDBOX
<span class="lineNum">     346 </span>            : // The seccomp-bpf filter for content processes is not a true sandbox
<span class="lineNum">     347 </span>            : // on its own; its purpose is attack surface reduction and syscall
<span class="lineNum">     348 </span>            : // interception in support of a semantic sandboxing layer.  On B2G
<span class="lineNum">     349 </span>            : // this is the Android process permission model; on desktop,
<span class="lineNum">     350 </span>            : // namespaces and chroot() will be used.
<span class="lineNum">     351 </span>            : class ContentSandboxPolicy : public SandboxPolicyCommon {
<span class="lineNum">     352 </span>            : private:
<span class="lineNum">     353 </span>            :   SandboxBrokerClient* mBroker;
<span class="lineNum">     354 </span>            :   std::vector&lt;int&gt; mSyscallWhitelist;
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :   // Trap handlers for filesystem brokering.
<a name="357"><span class="lineNum">     357 </span>            :   // (The amount of code duplication here could be improved....)</a>
<span class="lineNum">     358 </span>            : #ifdef __NR_open
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   static intptr_t OpenTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     auto flags = static_cast&lt;int&gt;(aArgs.args[1]);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     return broker-&gt;Open(path, flags);</span>
<span class="lineNum">     364 </span>            :   }
<a name="365"><span class="lineNum">     365 </span>            : #endif</a>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   static intptr_t OpenAtTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     auto fd = static_cast&lt;int&gt;(aArgs.args[0]);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     auto flags = static_cast&lt;int&gt;(aArgs.args[2]);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     if (fd != AT_FDCWD &amp;&amp; path[0] != '/') {</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;unsupported fd-relative openat(%d, \&quot;%s\&quot;, 0%o)&quot;,</span>
<span class="lineNum">     374 </span>            :                         fd, path, flags);
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       return BlockedSyscallTrap(aArgs, nullptr);</span>
<span class="lineNum">     376 </span>            :     }
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     return broker-&gt;Open(path, flags);</span>
<span class="lineNum">     378 </span>            :   }
<a name="379"><span class="lineNum">     379 </span>            : </a>
<span class="lineNum">     380 </span>            : #ifdef __NR_access
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   static intptr_t AccessTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     auto mode = static_cast&lt;int&gt;(aArgs.args[1]);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     return broker-&gt;Access(path, mode);</span>
<span class="lineNum">     386 </span>            :   }
<a name="387"><span class="lineNum">     387 </span>            : #endif</a>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   static intptr_t AccessAtTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     auto fd = static_cast&lt;int&gt;(aArgs.args[0]);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     auto mode = static_cast&lt;int&gt;(aArgs.args[2]);</span>
<span class="lineNum">     394 </span>            :     // Linux's faccessat syscall has no &quot;flags&quot; argument.  Attempting
<span class="lineNum">     395 </span>            :     // to handle the flags != 0 case is left to userspace; this is
<span class="lineNum">     396 </span>            :     // impossible to do correctly in all cases, but that's not our
<span class="lineNum">     397 </span>            :     // problem.
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     if (fd != AT_FDCWD &amp;&amp; path[0] != '/') {</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;unsupported fd-relative faccessat(%d, \&quot;%s\&quot;, %d)&quot;,</span>
<span class="lineNum">     400 </span>            :                         fd, path, mode);
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :       return BlockedSyscallTrap(aArgs, nullptr);</span>
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     return broker-&gt;Access(path, mode);</span>
<a name="404"><span class="lineNum">     404 </span>            :   }</a>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   static intptr_t StatTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     auto buf = reinterpret_cast&lt;statstruct*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     return broker-&gt;Stat(path, buf);</span>
<a name="411"><span class="lineNum">     411 </span>            :   }</a>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   static intptr_t LStatTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     auto buf = reinterpret_cast&lt;statstruct*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     return broker-&gt;LStat(path, buf);</span>
<a name="418"><span class="lineNum">     418 </span>            :   }</a>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   static intptr_t StatAtTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     auto fd = static_cast&lt;int&gt;(aArgs.args[0]);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     auto buf = reinterpret_cast&lt;statstruct*&gt;(aArgs.args[2]);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     auto flags = static_cast&lt;int&gt;(aArgs.args[3]);</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     if (fd != AT_FDCWD &amp;&amp; path[0] != '/') {</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;unsupported fd-relative fstatat(%d, \&quot;%s\&quot;, %p, %d)&quot;,</span>
<span class="lineNum">     428 </span>            :                         fd, path, buf, flags);
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       return BlockedSyscallTrap(aArgs, nullptr);</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     if ((flags &amp; ~AT_SYMLINK_NOFOLLOW) != 0) {</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;unsupported flags %d in fstatat(%d, \&quot;%s\&quot;, %p, %d)&quot;,</span>
<span class="lineNum">     433 </span>            :                         (flags &amp; ~AT_SYMLINK_NOFOLLOW), fd, path, buf, flags);
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       return BlockedSyscallTrap(aArgs, nullptr);</span>
<span class="lineNum">     435 </span>            :     }
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     return (flags &amp; AT_SYMLINK_NOFOLLOW) == 0</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       ? broker-&gt;Stat(path, buf)</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       : broker-&gt;LStat(path, buf);</span>
<a name="439"><span class="lineNum">     439 </span>            :   }</a>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   static intptr_t ChmodTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     auto mode = static_cast&lt;mode_t&gt;(aArgs.args[1]);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     return broker-&gt;Chmod(path, mode);</span>
<a name="446"><span class="lineNum">     446 </span>            :   }</a>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   static intptr_t LinkTrap(ArgsRef aArgs, void *aux) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     auto path2 = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     return broker-&gt;Link(path, path2);</span>
<a name="453"><span class="lineNum">     453 </span>            :   }</a>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   static intptr_t SymlinkTrap(ArgsRef aArgs, void *aux) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     auto path2 = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     return broker-&gt;Symlink(path, path2);</span>
<a name="460"><span class="lineNum">     460 </span>            :   }</a>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   static intptr_t RenameTrap(ArgsRef aArgs, void *aux) {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     auto path2 = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     return broker-&gt;Rename(path, path2);</span>
<a name="467"><span class="lineNum">     467 </span>            :   }</a>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   static intptr_t MkdirTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     auto mode = static_cast&lt;mode_t&gt;(aArgs.args[1]);</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     return broker-&gt;Mkdir(path, mode);</span>
<a name="474"><span class="lineNum">     474 </span>            :   }</a>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   static intptr_t RmdirTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     return broker-&gt;Rmdir(path);</span>
<a name="480"><span class="lineNum">     480 </span>            :   }</a>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   static intptr_t UnlinkTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     return broker-&gt;Unlink(path);</span>
<a name="486"><span class="lineNum">     486 </span>            :   }</a>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   static intptr_t ReadlinkTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     auto broker = static_cast&lt;SandboxBrokerClient*&gt;(aux);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     auto path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     auto buf = reinterpret_cast&lt;char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     auto size = static_cast&lt;size_t&gt;(aArgs.args[2]);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     return broker-&gt;Readlink(path, buf, size);</span>
<a name="494"><span class="lineNum">     494 </span>            :   }</a>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   static intptr_t GetPPidTrap(ArgsRef aArgs, void* aux) {</span>
<span class="lineNum">     497 </span>            :     // In a pid namespace, getppid() will return 0. We will return 0 instead
<span class="lineNum">     498 </span>            :     // of the real parent pid to see what breaks when we introduce the
<span class="lineNum">     499 </span>            :     // pid namespace (Bug 1151624).
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     501 </span>            :   }
<a name="502"><span class="lineNum">     502 </span>            : </a>
<span class="lineNum">     503 </span>            : public:
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   explicit ContentSandboxPolicy(SandboxBrokerClient* aBroker,</span>
<span class="lineNum">     505 </span>            :                                 const std::vector&lt;int&gt;&amp; aSyscallWhitelist)
<a name="506"><span class="lineNum">     506 </span>            :     : mBroker(aBroker),</a>
<a name="507"><span class="lineNum">     507 </span><span class="lineNoCov">          0 :       mSyscallWhitelist(aSyscallWhitelist) {}</span></a>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   virtual ~ContentSandboxPolicy() { }</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   virtual ResultExpr PrctlPolicy() const override {</span>
<span class="lineNum">     510 </span>            :     // Ideally this should be restricted to a whitelist, but content
<span class="lineNum">     511 </span>            :     // uses enough things that it's not trivial to determine it.
<a name="512"><span class="lineNum">     512 </span><span class="lineNoCov">          0 :     return Allow();</span></a>
<span class="lineNum">     513 </span>            :   }
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   virtual Maybe&lt;ResultExpr&gt; EvaluateSocketCall(int aCall) const override {</span>
<span class="lineNum">     515 </span>            :     switch(aCall) {
<span class="lineNum">     516 </span>            :     case SYS_RECVFROM:
<span class="lineNum">     517 </span>            :     case SYS_SENDTO:
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       return Some(Allow());</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :     case SYS_SOCKETPAIR: {
<span class="lineNum">     521 </span>            :       // See bug 1066750.
<span class="lineNum">     522 </span>            :       if (!kSocketCallHasArgs) {
<span class="lineNum">     523 </span>            :         // We can't filter the args if the platform passes them by pointer.
<span class="lineNum">     524 </span>            :         return Some(Allow());
<span class="lineNum">     525 </span>            :       }
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       Arg&lt;int&gt; domain(0), type(1);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       return Some(If(AllOf(domain == AF_UNIX,</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                            AnyOf(type == SOCK_STREAM, type == SOCK_SEQPACKET)),</span>
<span class="lineNum">     529 </span>            :                      Allow())
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                   .Else(InvalidSyscall()));</span>
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : #ifdef ANDROID
<span class="lineNum">     534 </span>            :     case SYS_SOCKET:
<span class="lineNum">     535 </span>            :       return Some(Error(EACCES));
<span class="lineNum">     536 </span>            : #else // #ifdef DESKTOP
<span class="lineNum">     537 </span>            :     case SYS_RECV:
<span class="lineNum">     538 </span>            :     case SYS_SEND:
<span class="lineNum">     539 </span>            :     case SYS_SOCKET: // DANGEROUS
<span class="lineNum">     540 </span>            :     case SYS_CONNECT: // DANGEROUS
<span class="lineNum">     541 </span>            :     case SYS_ACCEPT:
<span class="lineNum">     542 </span>            :     case SYS_ACCEPT4:
<span class="lineNum">     543 </span>            :     case SYS_BIND:
<span class="lineNum">     544 </span>            :     case SYS_LISTEN:
<span class="lineNum">     545 </span>            :     case SYS_GETSOCKOPT:
<span class="lineNum">     546 </span>            :     case SYS_SETSOCKOPT:
<span class="lineNum">     547 </span>            :     case SYS_GETSOCKNAME:
<span class="lineNum">     548 </span>            :     case SYS_GETPEERNAME:
<span class="lineNum">     549 </span>            :     case SYS_SHUTDOWN:
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :       return Some(Allow());</span>
<span class="lineNum">     551 </span>            : #endif
<span class="lineNum">     552 </span>            :     default:
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :       return SandboxPolicyCommon::EvaluateSocketCall(aCall);</span>
<span class="lineNum">     554 </span>            :     }
<span class="lineNum">     555 </span>            :   }
<a name="556"><span class="lineNum">     556 </span>            : </a>
<span class="lineNum">     557 </span>            : #ifdef DESKTOP
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   virtual Maybe&lt;ResultExpr&gt; EvaluateIpcCall(int aCall) const override {</span>
<span class="lineNum">     559 </span>            :     switch(aCall) {
<span class="lineNum">     560 </span>            :       // These are a problem: SysV shared memory follows the Unix
<span class="lineNum">     561 </span>            :       // &quot;same uid policy&quot; and can't be restricted/brokered like file
<span class="lineNum">     562 </span>            :       // access.  But the graphics layer might not be using them
<span class="lineNum">     563 </span>            :       // anymore; this needs to be studied.
<span class="lineNum">     564 </span>            :     case SHMGET:
<span class="lineNum">     565 </span>            :     case SHMCTL:
<span class="lineNum">     566 </span>            :     case SHMAT:
<span class="lineNum">     567 </span>            :     case SHMDT:
<span class="lineNum">     568 </span>            :     case SEMGET:
<span class="lineNum">     569 </span>            :     case SEMCTL:
<span class="lineNum">     570 </span>            :     case SEMOP:
<span class="lineNum">     571 </span>            :     case MSGGET:
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :       return Some(Allow());</span>
<span class="lineNum">     573 </span>            :     default:
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :       return SandboxPolicyCommon::EvaluateIpcCall(aCall);</span>
<span class="lineNum">     575 </span>            :     }
<span class="lineNum">     576 </span>            :   }
<a name="577"><span class="lineNum">     577 </span>            : #endif</a>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   virtual ResultExpr EvaluateSyscall(int sysno) const override {</span>
<span class="lineNum">     580 </span>            :     // Straight allow for anything that got overriden via prefs
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     if (std::find(mSyscallWhitelist.begin(), mSyscallWhitelist.end(), sysno)</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         != mSyscallWhitelist.end()) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       if (SandboxInfo::Get().Test(SandboxInfo::kVerbose)) {</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         SANDBOX_LOG_ERROR(&quot;Allowing syscall nr %d via whitelist&quot;, sysno);</span>
<span class="lineNum">     585 </span>            :       }
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     587 </span>            :     }
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     if (mBroker) {</span>
<span class="lineNum">     589 </span>            :       // Have broker; route the appropriate syscalls to it.
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       switch (sysno) {</span>
<span class="lineNum">     591 </span>            :       case __NR_open:
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :         return Trap(OpenTrap, mBroker);</span>
<span class="lineNum">     593 </span>            :       case __NR_openat:
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         return Trap(OpenAtTrap, mBroker);</span>
<span class="lineNum">     595 </span>            :       case __NR_access:
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         return Trap(AccessTrap, mBroker);</span>
<span class="lineNum">     597 </span>            :       case __NR_faccessat:
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         return Trap(AccessAtTrap, mBroker);</span>
<span class="lineNum">     599 </span>            :       CASES_FOR_stat:
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         return Trap(StatTrap, mBroker);</span>
<span class="lineNum">     601 </span>            :       CASES_FOR_lstat:
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :         return Trap(LStatTrap, mBroker);</span>
<span class="lineNum">     603 </span>            :       CASES_FOR_fstatat:
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         return Trap(StatAtTrap, mBroker);</span>
<span class="lineNum">     605 </span>            :       case __NR_chmod:
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         return Trap(ChmodTrap, mBroker);</span>
<span class="lineNum">     607 </span>            :       case __NR_link:
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         return Trap(LinkTrap, mBroker);</span>
<span class="lineNum">     609 </span>            :       case __NR_mkdir:
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         return Trap(MkdirTrap, mBroker);</span>
<span class="lineNum">     611 </span>            :       case __NR_symlink:
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         return Trap(SymlinkTrap, mBroker);</span>
<span class="lineNum">     613 </span>            :       case __NR_rename:
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         return Trap(RenameTrap, mBroker);</span>
<span class="lineNum">     615 </span>            :       case __NR_rmdir:
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         return Trap(RmdirTrap, mBroker);</span>
<span class="lineNum">     617 </span>            :       case __NR_unlink:
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         return Trap(UnlinkTrap, mBroker);</span>
<span class="lineNum">     619 </span>            :       case __NR_readlink:
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         return Trap(ReadlinkTrap, mBroker);</span>
<span class="lineNum">     621 </span>            :       }
<span class="lineNum">     622 </span>            :     } else {
<span class="lineNum">     623 </span>            :       // No broker; allow the syscalls directly.  )-:
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       switch(sysno) {</span>
<span class="lineNum">     625 </span>            :       case __NR_open:
<span class="lineNum">     626 </span>            :       case __NR_openat:
<span class="lineNum">     627 </span>            :       case __NR_access:
<span class="lineNum">     628 </span>            :       case __NR_faccessat:
<span class="lineNum">     629 </span>            :       CASES_FOR_stat:
<span class="lineNum">     630 </span>            :       CASES_FOR_lstat:
<span class="lineNum">     631 </span>            :       CASES_FOR_fstatat:
<span class="lineNum">     632 </span>            :       case __NR_chmod:
<span class="lineNum">     633 </span>            :       case __NR_link:
<span class="lineNum">     634 </span>            :       case __NR_mkdir:
<span class="lineNum">     635 </span>            :       case __NR_symlink:
<span class="lineNum">     636 </span>            :       case __NR_rename:
<span class="lineNum">     637 </span>            :       case __NR_rmdir:
<span class="lineNum">     638 </span>            :       case __NR_unlink:
<span class="lineNum">     639 </span>            :       case __NR_readlink:
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         return Allow();</span>
<span class="lineNum">     641 </span>            :       }
<span class="lineNum">     642 </span>            :     }
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     switch (sysno) {</span>
<span class="lineNum">     645 </span>            : #ifdef DESKTOP
<span class="lineNum">     646 </span>            :     case __NR_getppid:
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :       return Trap(GetPPidTrap, nullptr);</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :       // Filesystem syscalls that need more work to determine who's
<span class="lineNum">     650 </span>            :       // using them, if they need to be, and what we intend to about it.
<span class="lineNum">     651 </span>            :     case __NR_getcwd:
<span class="lineNum">     652 </span>            :     CASES_FOR_statfs:
<span class="lineNum">     653 </span>            :     CASES_FOR_fstatfs:
<span class="lineNum">     654 </span>            :     case __NR_quotactl:
<span class="lineNum">     655 </span>            :     CASES_FOR_fchown:
<span class="lineNum">     656 </span>            :     case __NR_fchmod:
<span class="lineNum">     657 </span>            :     case __NR_flock:
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :       // Bug 1354731: proprietary GL drivers try to mknod() their devices
<span class="lineNum">     661 </span>            :     case __NR_mknod: {
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       Arg&lt;mode_t&gt; mode(1);</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       return If((mode &amp; S_IFMT) == S_IFCHR, Error(EPERM))</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :         .Else(InvalidSyscall());</span>
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span>            : #endif
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :     case __NR_readlinkat:
<span class="lineNum">     669 </span>            : #ifdef DESKTOP
<span class="lineNum">     670 </span>            :       // Bug 1290896
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     672 </span>            : #else
<span class="lineNum">     673 </span>            :       // Workaround for bug 964455:
<span class="lineNum">     674 </span>            :       return Error(EINVAL);
<span class="lineNum">     675 </span>            : #endif
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :     CASES_FOR_select:
<span class="lineNum">     678 </span>            :     case __NR_pselect6:
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            :     CASES_FOR_getdents:
<span class="lineNum">     682 </span>            :     CASES_FOR_ftruncate:
<span class="lineNum">     683 </span>            :     case __NR_writev:
<span class="lineNum">     684 </span>            :     case __NR_pread64:
<span class="lineNum">     685 </span>            : #ifdef DESKTOP
<span class="lineNum">     686 </span>            :     case __NR_pwrite64:
<span class="lineNum">     687 </span>            :     case __NR_readahead:
<span class="lineNum">     688 </span>            : #endif
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :     case __NR_ioctl:
<span class="lineNum">     692 </span>            :       // ioctl() is for GL. Remove when GL proxy is implemented.
<span class="lineNum">     693 </span>            :       // Additionally ioctl() might be a place where we want to have
<span class="lineNum">     694 </span>            :       // argument filtering
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :     CASES_FOR_fcntl:
<span class="lineNum">     698 </span>            :       // Some fcntls have significant side effects like sending
<span class="lineNum">     699 </span>            :       // arbitrary signals, and there's probably nontrivial kernel
<span class="lineNum">     700 </span>            :       // attack surface; this should be locked down more if possible.
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :     case __NR_mprotect:
<span class="lineNum">     704 </span>            :     case __NR_brk:
<span class="lineNum">     705 </span>            :     case __NR_madvise:
<span class="lineNum">     706 </span>            :       // libc's realloc uses mremap (Bug 1286119); wasm does too (bug 1342385).
<span class="lineNum">     707 </span>            :     case __NR_mremap:
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :     case __NR_sigaltstack:
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : #ifdef __NR_set_thread_area
<span class="lineNum">     714 </span>            :     case __NR_set_thread_area:
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     716 </span>            : #endif
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :     case __NR_getrusage:
<span class="lineNum">     719 </span>            :     case __NR_times:
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     case __NR_dup:
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :     CASES_FOR_getuid:
<span class="lineNum">     726 </span>            :     CASES_FOR_getgid:
<span class="lineNum">     727 </span>            :     CASES_FOR_geteuid:
<span class="lineNum">     728 </span>            :     CASES_FOR_getegid:
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :     case __NR_fsync:
<span class="lineNum">     732 </span>            :     case __NR_msync:
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :     case __NR_getpriority:
<span class="lineNum">     736 </span>            :     case __NR_setpriority:
<span class="lineNum">     737 </span>            :     case __NR_sched_get_priority_min:
<span class="lineNum">     738 </span>            :     case __NR_sched_get_priority_max:
<span class="lineNum">     739 </span>            :     case __NR_sched_getscheduler:
<span class="lineNum">     740 </span>            :     case __NR_sched_setscheduler:
<span class="lineNum">     741 </span>            :     case __NR_sched_getparam:
<span class="lineNum">     742 </span>            :     case __NR_sched_setparam:
<span class="lineNum">     743 </span>            : #ifdef DESKTOP
<span class="lineNum">     744 </span>            :     case __NR_sched_getaffinity:
<span class="lineNum">     745 </span>            : #endif
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : #ifdef DESKTOP
<span class="lineNum">     749 </span>            :     case __NR_pipe2:
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :     CASES_FOR_getrlimit:
<span class="lineNum">     753 </span>            :     case __NR_clock_getres:
<span class="lineNum">     754 </span>            :     CASES_FOR_getresuid:
<span class="lineNum">     755 </span>            :     CASES_FOR_getresgid:
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :     case __NR_prlimit64: {
<span class="lineNum">     759 </span>            :       // Allow only the getrlimit() use case.  (glibc seems to use
<span class="lineNum">     760 </span>            :       // only pid 0 to indicate the current process; pid == getpid()
<span class="lineNum">     761 </span>            :       // is equivalent and could also be allowed if needed.)
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       Arg&lt;pid_t&gt; pid(0);</span>
<span class="lineNum">     763 </span>            :       // This is really a const struct ::rlimit*, but Arg&lt;&gt; doesn't
<span class="lineNum">     764 </span>            :       // work with pointers, only integer types.
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :       Arg&lt;uintptr_t&gt; new_limit(2);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :       return If(AllOf(pid == 0, new_limit == 0), Allow())</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         .Else(InvalidSyscall());</span>
<span class="lineNum">     768 </span>            :     }
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :     case __NR_umask:
<span class="lineNum">     771 </span>            :     case __NR_kill:
<span class="lineNum">     772 </span>            :     case __NR_wait4:
<span class="lineNum">     773 </span>            : #ifdef __NR_waitpid
<span class="lineNum">     774 </span>            :     case __NR_waitpid:
<span class="lineNum">     775 </span>            : #endif
<span class="lineNum">     776 </span>            : #ifdef __NR_arch_prctl
<span class="lineNum">     777 </span>            :     case __NR_arch_prctl:
<span class="lineNum">     778 </span>            : #endif
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :     case __NR_eventfd2:
<span class="lineNum">     782 </span>            :     case __NR_inotify_init1:
<span class="lineNum">     783 </span>            :     case __NR_inotify_add_watch:
<span class="lineNum">     784 </span>            :     case __NR_inotify_rm_watch:
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : #ifdef __NR_memfd_create
<span class="lineNum">     788 </span>            :     case __NR_memfd_create:
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     790 </span>            : #endif
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : #ifdef __NR_rt_tgsigqueueinfo
<span class="lineNum">     793 </span>            :       // Only allow to send signals within the process.
<span class="lineNum">     794 </span>            :     case __NR_rt_tgsigqueueinfo: {
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       Arg&lt;pid_t&gt; tgid(0);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :       return If(tgid == getpid(), Allow())</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         .Else(InvalidSyscall());</span>
<span class="lineNum">     798 </span>            :     }
<span class="lineNum">     799 </span>            : #endif
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :     case __NR_mlock:
<span class="lineNum">     802 </span>            :     case __NR_munlock:
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :       // We can't usefully allow fork+exec, even on a temporary basis;
<span class="lineNum">     806 </span>            :       // the child would inherit the seccomp-bpf policy and almost
<span class="lineNum">     807 </span>            :       // certainly die from an unexpected SIGSYS.  We also can't have
<span class="lineNum">     808 </span>            :       // fork() crash, currently, because there are too many system
<span class="lineNum">     809 </span>            :       // libraries/plugins that try to run commands.  But they can
<span class="lineNum">     810 </span>            :       // usually do something reasonable on error.
<span class="lineNum">     811 </span>            :     case __NR_clone:
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       return ClonePolicy(Error(EPERM));</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : #ifdef __NR_fadvise64
<span class="lineNum">     815 </span>            :     case __NR_fadvise64:
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     817 </span>            : #endif
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            : #ifdef __NR_fadvise64_64
<span class="lineNum">     820 </span>            :     case __NR_fadvise64_64:
<span class="lineNum">     821 </span>            :       return Allow();
<span class="lineNum">     822 </span>            : #endif
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :     case __NR_fallocate:
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :     case __NR_get_mempolicy:
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : #endif // DESKTOP
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            : #ifdef __NR_getrandom
<span class="lineNum">     833 </span>            :     case __NR_getrandom:
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     835 </span>            : #endif
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :       // nsSystemInfo uses uname (and we cache an instance, so
<span class="lineNum">     838 </span>            :       // the info remains present even if we block the syscall)
<span class="lineNum">     839 </span>            :     case __NR_uname:
<span class="lineNum">     840 </span>            : #ifdef DESKTOP
<span class="lineNum">     841 </span>            :     case __NR_sysinfo:
<span class="lineNum">     842 </span>            : #endif
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            : #ifdef MOZ_JPROF
<span class="lineNum">     846 </span>            :     case __NR_setitimer:
<span class="lineNum">     847 </span>            :       return Allow();
<span class="lineNum">     848 </span>            : #endif // MOZ_JPROF
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :     default:
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       return SandboxPolicyCommon::EvaluateSyscall(sysno);</span>
<span class="lineNum">     852 </span>            :     }
<span class="lineNum">     853 </span>            :   }
<span class="lineNum">     854 </span>            : };
<a name="855"><span class="lineNum">     855 </span>            : </a>
<span class="lineNum">     856 </span>            : UniquePtr&lt;sandbox::bpf_dsl::Policy&gt;
<span class="lineNum">     857 </span><span class="lineNoCov">          0 : GetContentSandboxPolicy(SandboxBrokerClient* aMaybeBroker,</span>
<span class="lineNum">     858 </span>            :                         const std::vector&lt;int&gt;&amp; aSyscallWhitelist)
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   return MakeUnique&lt;ContentSandboxPolicy&gt;(aMaybeBroker, aSyscallWhitelist);</span>
<span class="lineNum">     861 </span>            : }
<span class="lineNum">     862 </span>            : #endif // MOZ_CONTENT_SANDBOX
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            : #ifdef MOZ_GMP_SANDBOX
<span class="lineNum">     866 </span>            : // Unlike for content, the GeckoMediaPlugin seccomp-bpf policy needs
<span class="lineNum">     867 </span>            : // to be an effective sandbox by itself, because we allow GMP on Linux
<span class="lineNum">     868 </span>            : // systems where that's the only sandboxing mechanism we can use.
<span class="lineNum">     869 </span>            : //
<a name="870"><span class="lineNum">     870 </span>            : // Be especially careful about what this policy allows.</a>
<span class="lineNum">     871 </span>            : class GMPSandboxPolicy : public SandboxPolicyCommon {
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   static intptr_t OpenTrap(const sandbox::arch_seccomp_data&amp; aArgs,</span>
<span class="lineNum">     873 </span>            :                            void* aux)
<span class="lineNum">     874 </span>            :   {
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     auto plugin = static_cast&lt;SandboxOpenedFile*&gt;(aux);</span>
<span class="lineNum">     876 </span>            :     const char* path;
<span class="lineNum">     877 </span>            :     int flags;
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     switch (aArgs.nr) {</span>
<span class="lineNum">     880 </span>            : #ifdef __NR_open
<span class="lineNum">     881 </span>            :     case __NR_open:
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :       path = reinterpret_cast&lt;const char*&gt;(aArgs.args[0]);</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :       flags = static_cast&lt;int&gt;(aArgs.args[1]);</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     885 </span>            : #endif
<span class="lineNum">     886 </span>            :     case __NR_openat:
<span class="lineNum">     887 </span>            :       // The path has to be absolute to match the pre-opened file (see
<span class="lineNum">     888 </span>            :       // assertion in ctor) so the dirfd argument is ignored.
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       path = reinterpret_cast&lt;const char*&gt;(aArgs.args[1]);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       flags = static_cast&lt;int&gt;(aArgs.args[2]);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     892 </span>            :     default:
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;unexpected syscall number&quot;);</span>
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     if (strcmp(path, plugin-&gt;mPath) != 0) {</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;attempt to open file %s (flags=0%o) which is not the&quot;</span>
<span class="lineNum">     898 </span>            :                         &quot; media plugin %s&quot;, path, flags, plugin-&gt;mPath);
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :       return -EPERM;</span>
<span class="lineNum">     900 </span>            :     }
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if ((flags &amp; O_ACCMODE) != O_RDONLY) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;non-read-only open of file %s attempted (flags=0%o)&quot;,</span>
<span class="lineNum">     903 </span>            :                         path, flags);
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :       return -EPERM;</span>
<span class="lineNum">     905 </span>            :     }
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     int fd = plugin-&gt;mFd.exchange(-1);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     if (fd &lt; 0) {</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :       SANDBOX_LOG_ERROR(&quot;multiple opens of media plugin file unimplemented&quot;);</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :       return -ENOSYS;</span>
<span class="lineNum">     910 </span>            :     }
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     return fd;</span>
<a name="912"><span class="lineNum">     912 </span>            :   }</a>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   static intptr_t SchedTrap(const sandbox::arch_seccomp_data&amp; aArgs,</span>
<span class="lineNum">     915 </span>            :                             void* aux)
<span class="lineNum">     916 </span>            :   {
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     const pid_t tid = syscall(__NR_gettid);</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     if (aArgs.args[0] == static_cast&lt;uint64_t&gt;(tid)) {</span>
<span class="lineNum">     919 </span>            :       return syscall(aArgs.nr,
<span class="lineNum">     920 </span>            :                      0,
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :                      aArgs.args[1],</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                      aArgs.args[2],</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :                      aArgs.args[3],</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                      aArgs.args[4],</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :                      aArgs.args[5]);</span>
<span class="lineNum">     926 </span>            :     }
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     SANDBOX_LOG_ERROR(&quot;unsupported tid in SchedTrap&quot;);</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     return BlockedSyscallTrap(aArgs, nullptr);</span>
<span class="lineNum">     929 </span>            :   }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :   SandboxOpenedFile* mPlugin;
<span class="lineNum">     932 </span>            : public:
<span class="lineNum">     933 </span>            :   explicit GMPSandboxPolicy(SandboxOpenedFile* aPlugin)
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   : mPlugin(aPlugin)</span>
<span class="lineNum">     935 </span>            :   {
<span class="lineNum">     936 </span>            :     MOZ_ASSERT(aPlugin-&gt;mPath[0] == '/', &quot;plugin path should be absolute&quot;);
<a name="937"><span class="lineNum">     937 </span>            :   }</a>
<span class="lineNum">     938 </span>            : 
<a name="939"><span class="lineNum">     939 </span><span class="lineNoCov">          0 :   virtual ~GMPSandboxPolicy() { }</span></a>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   virtual ResultExpr EvaluateSyscall(int sysno) const override {</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     switch (sysno) {</span>
<span class="lineNum">     943 </span>            :       // Simulate opening the plugin file.
<span class="lineNum">     944 </span>            : #ifdef __NR_open
<span class="lineNum">     945 </span>            :     case __NR_open:
<span class="lineNum">     946 </span>            : #endif
<span class="lineNum">     947 </span>            :     case __NR_openat:
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :       return Trap(OpenTrap, mPlugin);</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :       // ipc::Shmem
<span class="lineNum">     951 </span>            :     case __NR_mprotect:
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     953 </span>            :     case __NR_madvise: {
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :       Arg&lt;int&gt; advice(2);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :       return If(advice == MADV_DONTNEED, Allow())</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         .ElseIf(advice == MADV_FREE, Allow())</span>
<span class="lineNum">     957 </span>            : #ifdef MOZ_ASAN
<span class="lineNum">     958 </span>            :         .ElseIf(advice == MADV_NOHUGEPAGE, Allow())
<span class="lineNum">     959 </span>            :         .ElseIf(advice == MADV_DONTDUMP, Allow())
<span class="lineNum">     960 </span>            : #endif
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         .Else(InvalidSyscall());</span>
<span class="lineNum">     962 </span>            :     }
<span class="lineNum">     963 </span>            :     case __NR_brk:
<span class="lineNum">     964 </span>            :     CASES_FOR_geteuid:
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     966 </span>            :     case __NR_sched_getparam:
<span class="lineNum">     967 </span>            :     case __NR_sched_getscheduler:
<span class="lineNum">     968 </span>            :     case __NR_sched_get_priority_min:
<span class="lineNum">     969 </span>            :     case __NR_sched_get_priority_max:
<span class="lineNum">     970 </span>            :     case __NR_sched_setscheduler: {
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :       Arg&lt;pid_t&gt; pid(0);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :       return If(pid == 0, Allow())</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         .Else(Trap(SchedTrap, nullptr));</span>
<span class="lineNum">     974 </span>            :     }
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            :     // For clock(3) on older glibcs; bug 1304220.
<span class="lineNum">     977 </span>            :     case __NR_times:
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       return Allow();</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :     default:
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :       return SandboxPolicyCommon::EvaluateSyscall(sysno);</span>
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span>            :   }
<span class="lineNum">     984 </span>            : };
<a name="985"><span class="lineNum">     985 </span>            : </a>
<span class="lineNum">     986 </span>            : UniquePtr&lt;sandbox::bpf_dsl::Policy&gt;
<span class="lineNum">     987 </span><span class="lineNoCov">          0 : GetMediaSandboxPolicy(SandboxOpenedFile* aPlugin)</span>
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   return UniquePtr&lt;sandbox::bpf_dsl::Policy&gt;(new GMPSandboxPolicy(aPlugin));</span>
<span class="lineNum">     990 </span>            : }
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            : #endif // MOZ_GMP_SANDBOX
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
