<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/sandbox/chromium/base/time/time.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">security/sandbox/chromium/base/time</a> - time.h<span style="font-size: 80%;"> (source / <a href="time.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21 12:59:10</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2012 The Chromium Authors. All rights reserved.</a>
<span class="lineNum">       2 </span>            : // Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       3 </span>            : // found in the LICENSE file.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : // Time represents an absolute point in coordinated universal time (UTC),
<span class="lineNum">       6 </span>            : // internally represented as microseconds (s/1,000,000) since the Windows epoch
<span class="lineNum">       7 </span>            : // (1601-01-01 00:00:00 UTC). System-dependent clock interface routines are
<span class="lineNum">       8 </span>            : // defined in time_PLATFORM.cc. Note that values for Time may skew and jump
<span class="lineNum">       9 </span>            : // around as the operating system makes adjustments to synchronize (e.g., with
<span class="lineNum">      10 </span>            : // NTP servers). Thus, client code that uses the Time class must account for
<span class="lineNum">      11 </span>            : // this.
<span class="lineNum">      12 </span>            : //
<span class="lineNum">      13 </span>            : // TimeDelta represents a duration of time, internally represented in
<span class="lineNum">      14 </span>            : // microseconds.
<span class="lineNum">      15 </span>            : //
<span class="lineNum">      16 </span>            : // TimeTicks and ThreadTicks represent an abstract time that is most of the time
<span class="lineNum">      17 </span>            : // incrementing, for use in measuring time durations. Internally, they are
<span class="lineNum">      18 </span>            : // represented in microseconds. They can not be converted to a human-readable
<span class="lineNum">      19 </span>            : // time, but are guaranteed not to decrease (unlike the Time class). Note that
<span class="lineNum">      20 </span>            : // TimeTicks may &quot;stand still&quot; (e.g., if the computer is suspended), and
<span class="lineNum">      21 </span>            : // ThreadTicks will &quot;stand still&quot; whenever the thread has been de-scheduled by
<span class="lineNum">      22 </span>            : // the operating system.
<span class="lineNum">      23 </span>            : //
<span class="lineNum">      24 </span>            : // All time classes are copyable, assignable, and occupy 64-bits per instance.
<span class="lineNum">      25 </span>            : // As a result, prefer passing them by value:
<span class="lineNum">      26 </span>            : //   void MyFunction(TimeDelta arg);
<span class="lineNum">      27 </span>            : // If circumstances require, you may also pass by const reference:
<span class="lineNum">      28 </span>            : //   void MyFunction(const TimeDelta&amp; arg);  // Not preferred.
<span class="lineNum">      29 </span>            : //
<span class="lineNum">      30 </span>            : // Definitions of operator&lt;&lt; are provided to make these types work with
<span class="lineNum">      31 </span>            : // DCHECK_EQ() and other log macros. For human-readable formatting, see
<span class="lineNum">      32 </span>            : // &quot;base/i18n/time_formatting.h&quot;.
<span class="lineNum">      33 </span>            : //
<span class="lineNum">      34 </span>            : // So many choices!  Which time class should you use?  Examples:
<span class="lineNum">      35 </span>            : //
<span class="lineNum">      36 </span>            : //   Time:        Interpreting the wall-clock time provided by a remote
<span class="lineNum">      37 </span>            : //                system. Detecting whether cached resources have
<span class="lineNum">      38 </span>            : //                expired. Providing the user with a display of the current date
<span class="lineNum">      39 </span>            : //                and time. Determining the amount of time between events across
<span class="lineNum">      40 </span>            : //                re-boots of the machine.
<span class="lineNum">      41 </span>            : //
<span class="lineNum">      42 </span>            : //   TimeTicks:   Tracking the amount of time a task runs. Executing delayed
<span class="lineNum">      43 </span>            : //                tasks at the right time. Computing presentation timestamps.
<span class="lineNum">      44 </span>            : //                Synchronizing audio and video using TimeTicks as a common
<span class="lineNum">      45 </span>            : //                reference clock (lip-sync). Measuring network round-trip
<span class="lineNum">      46 </span>            : //                latency.
<span class="lineNum">      47 </span>            : //
<span class="lineNum">      48 </span>            : //   ThreadTicks: Benchmarking how long the current thread has been doing actual
<span class="lineNum">      49 </span>            : //                work.
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #ifndef BASE_TIME_TIME_H_
<span class="lineNum">      52 </span>            : #define BASE_TIME_TIME_H_
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      55 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : #include &lt;iosfwd&gt;
<span class="lineNum">      58 </span>            : #include &lt;limits&gt;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : #include &quot;base/base_export.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;base/compiler_specific.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;base/numerics/safe_math.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;build/build_config.h&quot;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : #if defined(OS_MACOSX)
<span class="lineNum">      66 </span>            : #include &lt;CoreFoundation/CoreFoundation.h&gt;
<span class="lineNum">      67 </span>            : // Avoid Mac system header macro leak.
<span class="lineNum">      68 </span>            : #undef TYPE_BOOL
<span class="lineNum">      69 </span>            : #endif
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : #if defined(OS_POSIX)
<span class="lineNum">      72 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      73 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      74 </span>            : #endif
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : #if defined(OS_WIN)
<span class="lineNum">      77 </span>            : // For FILETIME in FromFileTime, until it moves to a new converter class.
<span class="lineNum">      78 </span>            : // See TODO(iyengar) below.
<span class="lineNum">      79 </span>            : #include &lt;windows.h&gt;
<span class="lineNum">      80 </span>            : #include &quot;base/gtest_prod_util.h&quot;
<span class="lineNum">      81 </span>            : #endif
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : namespace base {
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : class PlatformThreadHandle;
<span class="lineNum">      86 </span>            : class TimeDelta;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : // The functions in the time_internal namespace are meant to be used only by the
<span class="lineNum">      89 </span>            : // time classes and functions.  Please use the math operators defined in the
<span class="lineNum">      90 </span>            : // time classes instead.
<span class="lineNum">      91 </span>            : namespace time_internal {
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : // Add or subtract |value| from a TimeDelta. The int64_t argument and return
<span class="lineNum">      94 </span>            : // value are in terms of a microsecond timebase.
<span class="lineNum">      95 </span>            : BASE_EXPORT int64_t SaturatedAdd(TimeDelta delta, int64_t value);
<span class="lineNum">      96 </span>            : BASE_EXPORT int64_t SaturatedSub(TimeDelta delta, int64_t value);
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : }  // namespace time_internal
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : // TimeDelta ------------------------------------------------------------------
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : class BASE_EXPORT TimeDelta {
<span class="lineNum">     103 </span>            :  public:
<span class="lineNum">     104 </span>            :   TimeDelta() : delta_(0) {
<span class="lineNum">     105 </span>            :   }
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   // Converts units of time to TimeDeltas.
<span class="lineNum">     108 </span>            :   static constexpr TimeDelta FromDays(int days);
<span class="lineNum">     109 </span>            :   static constexpr TimeDelta FromHours(int hours);
<span class="lineNum">     110 </span>            :   static constexpr TimeDelta FromMinutes(int minutes);
<span class="lineNum">     111 </span>            :   static constexpr TimeDelta FromSeconds(int64_t secs);
<span class="lineNum">     112 </span>            :   static constexpr TimeDelta FromMilliseconds(int64_t ms);
<span class="lineNum">     113 </span>            :   static constexpr TimeDelta FromSecondsD(double secs);
<span class="lineNum">     114 </span>            :   static constexpr TimeDelta FromMillisecondsD(double ms);
<span class="lineNum">     115 </span>            :   static constexpr TimeDelta FromMicroseconds(int64_t us);
<span class="lineNum">     116 </span>            : #if defined(OS_POSIX)
<span class="lineNum">     117 </span>            :   static TimeDelta FromTimeSpec(const timespec&amp; ts);
<span class="lineNum">     118 </span>            : #endif
<span class="lineNum">     119 </span>            : #if defined(OS_WIN)
<span class="lineNum">     120 </span>            :   static TimeDelta FromQPCValue(LONGLONG qpc_value);
<span class="lineNum">     121 </span>            : #endif
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            :   // Converts an integer value representing TimeDelta to a class. This is used
<span class="lineNum">     124 </span>            :   // when deserializing a |TimeDelta| structure, using a value known to be
<span class="lineNum">     125 </span>            :   // compatible. It is not provided as a constructor because the integer type
<span class="lineNum">     126 </span>            :   // may be unclear from the perspective of a caller.
<span class="lineNum">     127 </span>            :   static TimeDelta FromInternalValue(int64_t delta) { return TimeDelta(delta); }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :   // Returns the maximum time delta, which should be greater than any reasonable
<span class="lineNum">     130 </span>            :   // time delta we might compare it to. Adding or subtracting the maximum time
<span class="lineNum">     131 </span>            :   // delta to a time or another time delta has an undefined result.
<span class="lineNum">     132 </span>            :   static TimeDelta Max();
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   // Returns the internal numeric value of the TimeDelta object. Please don't
<span class="lineNum">     135 </span>            :   // use this and do arithmetic on it, as it is more error prone than using the
<span class="lineNum">     136 </span>            :   // provided operators.
<span class="lineNum">     137 </span>            :   // For serializing, use FromInternalValue to reconstitute.
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   int64_t ToInternalValue() const { return delta_; }</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   // Returns the magnitude (absolute value) of this TimeDelta.
<span class="lineNum">     141 </span>            :   TimeDelta magnitude() const {
<span class="lineNum">     142 </span>            :     // Some toolchains provide an incomplete C++11 implementation and lack an
<span class="lineNum">     143 </span>            :     // int64_t overload for std::abs().  The following is a simple branchless
<span class="lineNum">     144 </span>            :     // implementation:
<span class="lineNum">     145 </span>            :     const int64_t mask = delta_ &gt;&gt; (sizeof(delta_) * 8 - 1);
<span class="lineNum">     146 </span>            :     return TimeDelta((delta_ + mask) ^ mask);
<span class="lineNum">     147 </span>            :   }
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   // Returns true if the time delta is zero.
<span class="lineNum">     150 </span>            :   bool is_zero() const {
<span class="lineNum">     151 </span>            :     return delta_ == 0;
<span class="lineNum">     152 </span>            :   }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   // Returns true if the time delta is the maximum time delta.
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   bool is_max() const { return delta_ == std::numeric_limits&lt;int64_t&gt;::max(); }</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : #if defined(OS_POSIX)
<span class="lineNum">     158 </span>            :   struct timespec ToTimeSpec() const;
<span class="lineNum">     159 </span>            : #endif
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :   // Returns the time delta in some unit. The F versions return a floating
<span class="lineNum">     162 </span>            :   // point value, the &quot;regular&quot; versions return a rounded-down value.
<span class="lineNum">     163 </span>            :   //
<span class="lineNum">     164 </span>            :   // InMillisecondsRoundedUp() instead returns an integer that is rounded up
<span class="lineNum">     165 </span>            :   // to the next full millisecond.
<span class="lineNum">     166 </span>            :   int InDays() const;
<span class="lineNum">     167 </span>            :   int InHours() const;
<span class="lineNum">     168 </span>            :   int InMinutes() const;
<span class="lineNum">     169 </span>            :   double InSecondsF() const;
<span class="lineNum">     170 </span>            :   int64_t InSeconds() const;
<span class="lineNum">     171 </span>            :   double InMillisecondsF() const;
<span class="lineNum">     172 </span>            :   int64_t InMilliseconds() const;
<span class="lineNum">     173 </span>            :   int64_t InMillisecondsRoundedUp() const;
<span class="lineNum">     174 </span>            :   int64_t InMicroseconds() const;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :   TimeDelta&amp; operator=(TimeDelta other) {
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     delta_ = other.delta_;</span>
<span class="lineNum">     178 </span>            :     return *this;
<span class="lineNum">     179 </span>            :   }
<a name="180"><span class="lineNum">     180 </span>            : </a>
<span class="lineNum">     181 </span>            :   // Computations with other deltas.
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   TimeDelta operator+(TimeDelta other) const {</span>
<a name="183"><span class="lineNum">     183 </span><span class="lineNoCov">          0 :     return TimeDelta(time_internal::SaturatedAdd(*this, other.delta_));</span></a>
<span class="lineNum">     184 </span>            :   }
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   TimeDelta operator-(TimeDelta other) const {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     return TimeDelta(time_internal::SaturatedSub(*this, other.delta_));</span>
<a name="187"><span class="lineNum">     187 </span>            :   }</a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   TimeDelta&amp; operator+=(TimeDelta other) {</span>
<a name="190"><span class="lineNum">     190 </span><span class="lineNoCov">          0 :     return *this = (*this + other);</span></a>
<span class="lineNum">     191 </span>            :   }
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   TimeDelta&amp; operator-=(TimeDelta other) {</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     return *this = (*this - other);</span>
<span class="lineNum">     194 </span>            :   }
<span class="lineNum">     195 </span>            :   TimeDelta operator-() const {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     return TimeDelta(-delta_);</span>
<span class="lineNum">     197 </span>            :   }
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   // Computations with numeric types.
<span class="lineNum">     200 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     201 </span>            :   TimeDelta operator*(T a) const {
<span class="lineNum">     202 </span>            :     CheckedNumeric&lt;int64_t&gt; rv(delta_);
<span class="lineNum">     203 </span>            :     rv *= a;
<span class="lineNum">     204 </span>            :     if (rv.IsValid())
<span class="lineNum">     205 </span>            :       return TimeDelta(rv.ValueOrDie());
<span class="lineNum">     206 </span>            :     // Matched sign overflows. Mismatched sign underflows.
<span class="lineNum">     207 </span>            :     if ((delta_ &lt; 0) ^ (a &lt; 0))
<span class="lineNum">     208 </span>            :       return TimeDelta(-std::numeric_limits&lt;int64_t&gt;::max());
<span class="lineNum">     209 </span>            :     return TimeDelta(std::numeric_limits&lt;int64_t&gt;::max());
<span class="lineNum">     210 </span>            :   }
<span class="lineNum">     211 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     212 </span>            :   TimeDelta operator/(T a) const {
<span class="lineNum">     213 </span>            :     CheckedNumeric&lt;int64_t&gt; rv(delta_);
<span class="lineNum">     214 </span>            :     rv /= a;
<span class="lineNum">     215 </span>            :     if (rv.IsValid())
<span class="lineNum">     216 </span>            :       return TimeDelta(rv.ValueOrDie());
<span class="lineNum">     217 </span>            :     // Matched sign overflows. Mismatched sign underflows.
<span class="lineNum">     218 </span>            :     // Special case to catch divide by zero.
<span class="lineNum">     219 </span>            :     if ((delta_ &lt; 0) ^ (a &lt;= 0))
<span class="lineNum">     220 </span>            :       return TimeDelta(-std::numeric_limits&lt;int64_t&gt;::max());
<span class="lineNum">     221 </span>            :     return TimeDelta(std::numeric_limits&lt;int64_t&gt;::max());
<span class="lineNum">     222 </span>            :   }
<span class="lineNum">     223 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     224 </span>            :   TimeDelta&amp; operator*=(T a) {
<span class="lineNum">     225 </span>            :     return *this = (*this * a);
<span class="lineNum">     226 </span>            :   }
<span class="lineNum">     227 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     228 </span>            :   TimeDelta&amp; operator/=(T a) {
<span class="lineNum">     229 </span>            :     return *this = (*this / a);
<span class="lineNum">     230 </span>            :   }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   int64_t operator/(TimeDelta a) const { return delta_ / a.delta_; }
<span class="lineNum">     233 </span>            :   TimeDelta operator%(TimeDelta a) const {
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     return TimeDelta(delta_ % a.delta_);</span>
<span class="lineNum">     235 </span>            :   }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :   // Comparison operators.
<span class="lineNum">     238 </span>            :   constexpr bool operator==(TimeDelta other) const {
<span class="lineNum">     239 </span>            :     return delta_ == other.delta_;
<span class="lineNum">     240 </span>            :   }
<span class="lineNum">     241 </span>            :   constexpr bool operator!=(TimeDelta other) const {
<span class="lineNum">     242 </span>            :     return delta_ != other.delta_;
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            :   constexpr bool operator&lt;(TimeDelta other) const {
<span class="lineNum">     245 </span>            :     return delta_ &lt; other.delta_;
<span class="lineNum">     246 </span>            :   }
<span class="lineNum">     247 </span>            :   constexpr bool operator&lt;=(TimeDelta other) const {
<span class="lineNum">     248 </span>            :     return delta_ &lt;= other.delta_;
<span class="lineNum">     249 </span>            :   }
<span class="lineNum">     250 </span>            :   constexpr bool operator&gt;(TimeDelta other) const {
<span class="lineNum">     251 </span>            :     return delta_ &gt; other.delta_;
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span>            :   constexpr bool operator&gt;=(TimeDelta other) const {
<span class="lineNum">     254 </span>            :     return delta_ &gt;= other.delta_;
<span class="lineNum">     255 </span>            :   }
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : #if defined(OS_WIN)
<span class="lineNum">     258 </span>            :   // This works around crbug.com/635974
<span class="lineNum">     259 </span>            :   constexpr TimeDelta(const TimeDelta&amp; other) : delta_(other.delta_) {}
<span class="lineNum">     260 </span>            : #endif
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :  private:
<span class="lineNum">     263 </span>            :   friend int64_t time_internal::SaturatedAdd(TimeDelta delta, int64_t value);
<span class="lineNum">     264 </span>            :   friend int64_t time_internal::SaturatedSub(TimeDelta delta, int64_t value);
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   // Constructs a delta given the duration in microseconds. This is private
<span class="lineNum">     267 </span>            :   // to avoid confusion by callers with an integer constructor. Use
<span class="lineNum">     268 </span>            :   // FromSeconds, FromMilliseconds, etc. instead.
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   constexpr explicit TimeDelta(int64_t delta_us) : delta_(delta_us) {}</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :   // Private method to build a delta from a double.
<span class="lineNum">     272 </span>            :   static constexpr TimeDelta FromDouble(double value);
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :   // Private method to build a delta from the product of a user-provided value
<span class="lineNum">     275 </span>            :   // and a known-positive value.
<span class="lineNum">     276 </span>            :   static constexpr TimeDelta FromProduct(int64_t value, int64_t positive_value);
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :   // Delta in microseconds.
<span class="lineNum">     279 </span>            :   int64_t delta_;
<span class="lineNum">     280 </span>            : };
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : template&lt;typename T&gt;
<span class="lineNum">     283 </span>            : inline TimeDelta operator*(T a, TimeDelta td) {
<span class="lineNum">     284 </span>            :   return td * a;
<span class="lineNum">     285 </span>            : }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : // For logging use only.
<span class="lineNum">     288 </span>            : BASE_EXPORT std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, TimeDelta time_delta);
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : // Do not reference the time_internal::TimeBase template class directly.  Please
<span class="lineNum">     291 </span>            : // use one of the time subclasses instead, and only reference the public
<span class="lineNum">     292 </span>            : // TimeBase members via those classes.
<span class="lineNum">     293 </span>            : namespace time_internal {
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : // TimeBase--------------------------------------------------------------------
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : // Provides value storage and comparison/math operations common to all time
<span class="lineNum">     298 </span>            : // classes. Each subclass provides for strong type-checking to ensure
<span class="lineNum">     299 </span>            : // semantically meaningful comparison/math of time values from the same clock
<span class="lineNum">     300 </span>            : // source or timeline.
<span class="lineNum">     301 </span>            : template&lt;class TimeClass&gt;
<span class="lineNum">     302 </span>            : class TimeBase {
<span class="lineNum">     303 </span>            :  public:
<span class="lineNum">     304 </span>            :   static const int64_t kHoursPerDay = 24;
<span class="lineNum">     305 </span>            :   static const int64_t kMillisecondsPerSecond = 1000;
<span class="lineNum">     306 </span>            :   static const int64_t kMillisecondsPerDay =
<span class="lineNum">     307 </span>            :       kMillisecondsPerSecond * 60 * 60 * kHoursPerDay;
<span class="lineNum">     308 </span>            :   static const int64_t kMicrosecondsPerMillisecond = 1000;
<span class="lineNum">     309 </span>            :   static const int64_t kMicrosecondsPerSecond =
<span class="lineNum">     310 </span>            :       kMicrosecondsPerMillisecond * kMillisecondsPerSecond;
<span class="lineNum">     311 </span>            :   static const int64_t kMicrosecondsPerMinute = kMicrosecondsPerSecond * 60;
<span class="lineNum">     312 </span>            :   static const int64_t kMicrosecondsPerHour = kMicrosecondsPerMinute * 60;
<span class="lineNum">     313 </span>            :   static const int64_t kMicrosecondsPerDay =
<span class="lineNum">     314 </span>            :       kMicrosecondsPerHour * kHoursPerDay;
<span class="lineNum">     315 </span>            :   static const int64_t kMicrosecondsPerWeek = kMicrosecondsPerDay * 7;
<span class="lineNum">     316 </span>            :   static const int64_t kNanosecondsPerMicrosecond = 1000;
<span class="lineNum">     317 </span>            :   static const int64_t kNanosecondsPerSecond =
<span class="lineNum">     318 </span>            :       kNanosecondsPerMicrosecond * kMicrosecondsPerSecond;
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   // Returns true if this object has not been initialized.
<span class="lineNum">     321 </span>            :   //
<span class="lineNum">     322 </span>            :   // Warning: Be careful when writing code that performs math on time values,
<span class="lineNum">     323 </span>            :   // since it's possible to produce a valid &quot;zero&quot; result that should not be
<span class="lineNum">     324 </span>            :   // interpreted as a &quot;null&quot; value.
<span class="lineNum">     325 </span>            :   bool is_null() const {
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     return us_ == 0;</span>
<span class="lineNum">     327 </span>            :   }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   // Returns true if this object represents the maximum time.
<span class="lineNum">     330 </span>            :   bool is_max() const { return us_ == std::numeric_limits&lt;int64_t&gt;::max(); }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :   // Returns the maximum time, which should be greater than any reasonable time
<span class="lineNum">     333 </span>            :   // with which we might compare it.
<span class="lineNum">     334 </span>            :   static TimeClass Max() {
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     return TimeClass(std::numeric_limits&lt;int64_t&gt;::max());</span>
<span class="lineNum">     336 </span>            :   }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :   // For serializing only. Use FromInternalValue() to reconstitute. Please don't
<span class="lineNum">     339 </span>            :   // use this and do arithmetic on it, as it is more error prone than using the
<span class="lineNum">     340 </span>            :   // provided operators.
<span class="lineNum">     341 </span>            :   int64_t ToInternalValue() const { return us_; }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   TimeClass&amp; operator=(TimeClass other) {
<span class="lineNum">     344 </span>            :     us_ = other.us_;
<span class="lineNum">     345 </span>            :     return *(static_cast&lt;TimeClass*&gt;(this));
<span class="lineNum">     346 </span>            :   }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   // Compute the difference between two times.
<span class="lineNum">     349 </span>            :   TimeDelta operator-(TimeClass other) const {
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     return TimeDelta::FromMicroseconds(us_ - other.us_);</span>
<span class="lineNum">     351 </span>            :   }
<a name="352"><span class="lineNum">     352 </span>            : </a>
<span class="lineNum">     353 </span>            :   // Return a new time modified by some delta.
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   TimeClass operator+(TimeDelta delta) const {</span>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 :     return TimeClass(time_internal::SaturatedAdd(delta, us_));</span></a>
<span class="lineNum">     356 </span>            :   }
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   TimeClass operator-(TimeDelta delta) const {</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     return TimeClass(-time_internal::SaturatedSub(delta, us_));</span>
<span class="lineNum">     359 </span>            :   }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   // Modify by some time delta.
<span class="lineNum">     362 </span>            :   TimeClass&amp; operator+=(TimeDelta delta) {
<span class="lineNum">     363 </span>            :     return static_cast&lt;TimeClass&amp;&gt;(*this = (*this + delta));
<span class="lineNum">     364 </span>            :   }
<span class="lineNum">     365 </span>            :   TimeClass&amp; operator-=(TimeDelta delta) {
<span class="lineNum">     366 </span>            :     return static_cast&lt;TimeClass&amp;&gt;(*this = (*this - delta));
<span class="lineNum">     367 </span>            :   }
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :   // Comparison operators
<span class="lineNum">     370 </span>            :   bool operator==(TimeClass other) const {
<span class="lineNum">     371 </span>            :     return us_ == other.us_;
<span class="lineNum">     372 </span>            :   }
<span class="lineNum">     373 </span>            :   bool operator!=(TimeClass other) const {
<span class="lineNum">     374 </span>            :     return us_ != other.us_;
<span class="lineNum">     375 </span>            :   }
<span class="lineNum">     376 </span>            :   bool operator&lt;(TimeClass other) const {
<span class="lineNum">     377 </span>            :     return us_ &lt; other.us_;
<span class="lineNum">     378 </span>            :   }
<span class="lineNum">     379 </span>            :   bool operator&lt;=(TimeClass other) const {
<span class="lineNum">     380 </span>            :     return us_ &lt;= other.us_;
<span class="lineNum">     381 </span>            :   }
<span class="lineNum">     382 </span>            :   bool operator&gt;(TimeClass other) const {
<span class="lineNum">     383 </span>            :     return us_ &gt; other.us_;
<span class="lineNum">     384 </span>            :   }
<span class="lineNum">     385 </span>            :   bool operator&gt;=(TimeClass other) const {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     return us_ &gt;= other.us_;</span>
<span class="lineNum">     387 </span>            :   }
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   // Converts an integer value representing TimeClass to a class. This is used
<span class="lineNum">     390 </span>            :   // when deserializing a |TimeClass| structure, using a value known to be
<span class="lineNum">     391 </span>            :   // compatible. It is not provided as a constructor because the integer type
<span class="lineNum">     392 </span>            :   // may be unclear from the perspective of a caller.
<span class="lineNum">     393 </span>            :   static TimeClass FromInternalValue(int64_t us) { return TimeClass(us); }
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :  protected:
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   explicit TimeBase(int64_t us) : us_(us) {}</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   // Time value in a microsecond timebase.
<span class="lineNum">     399 </span>            :   int64_t us_;
<span class="lineNum">     400 </span>            : };
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            : }  // namespace time_internal
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            : template&lt;class TimeClass&gt;
<span class="lineNum">     405 </span>            : inline TimeClass operator+(TimeDelta delta, TimeClass t) {
<span class="lineNum">     406 </span>            :   return t + delta;
<span class="lineNum">     407 </span>            : }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : // Time -----------------------------------------------------------------------
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : // Represents a wall clock time in UTC. Values are not guaranteed to be
<span class="lineNum">     412 </span>            : // monotonically non-decreasing and are subject to large amounts of skew.
<span class="lineNum">     413 </span>            : class BASE_EXPORT Time : public time_internal::TimeBase&lt;Time&gt; {
<span class="lineNum">     414 </span>            :  public:
<span class="lineNum">     415 </span>            :   // The representation of Jan 1, 1970 UTC in microseconds since the
<span class="lineNum">     416 </span>            :   // platform-dependent epoch.
<span class="lineNum">     417 </span>            :   static const int64_t kTimeTToMicrosecondsOffset;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            : #if !defined(OS_WIN)
<span class="lineNum">     420 </span>            :   // On Mac &amp; Linux, this value is the delta from the Windows epoch of 1601 to
<span class="lineNum">     421 </span>            :   // the Posix delta of 1970. This is used for migrating between the old
<span class="lineNum">     422 </span>            :   // 1970-based epochs to the new 1601-based ones. It should be removed from
<span class="lineNum">     423 </span>            :   // this global header and put in the platform-specific ones when we remove the
<span class="lineNum">     424 </span>            :   // migration code.
<span class="lineNum">     425 </span>            :   static const int64_t kWindowsEpochDeltaMicroseconds;
<span class="lineNum">     426 </span>            : #else
<span class="lineNum">     427 </span>            :   // To avoid overflow in QPC to Microseconds calculations, since we multiply
<span class="lineNum">     428 </span>            :   // by kMicrosecondsPerSecond, then the QPC value should not exceed
<span class="lineNum">     429 </span>            :   // (2^63 - 1) / 1E6. If it exceeds that threshold, we divide then multiply.
<span class="lineNum">     430 </span>            :   enum : int64_t{kQPCOverflowThreshold = 0x8637BD05AF7};
<span class="lineNum">     431 </span>            : #endif
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :   // Represents an exploded time that can be formatted nicely. This is kind of
<span class="lineNum">     434 </span>            :   // like the Win32 SYSTEMTIME structure or the Unix &quot;struct tm&quot; with a few
<span class="lineNum">     435 </span>            :   // additions and changes to prevent errors.
<span class="lineNum">     436 </span>            :   struct BASE_EXPORT Exploded {
<span class="lineNum">     437 </span>            :     int year;          // Four digit year &quot;2007&quot;
<span class="lineNum">     438 </span>            :     int month;         // 1-based month (values 1 = January, etc.)
<span class="lineNum">     439 </span>            :     int day_of_week;   // 0-based day of week (0 = Sunday, etc.)
<span class="lineNum">     440 </span>            :     int day_of_month;  // 1-based day of month (1-31)
<span class="lineNum">     441 </span>            :     int hour;          // Hour within the current day (0-23)
<span class="lineNum">     442 </span>            :     int minute;        // Minute within the current hour (0-59)
<span class="lineNum">     443 </span>            :     int second;        // Second within the current minute (0-59 plus leap
<span class="lineNum">     444 </span>            :                        //   seconds which may take it up to 60).
<span class="lineNum">     445 </span>            :     int millisecond;   // Milliseconds within the current second (0-999)
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :     // A cursory test for whether the data members are within their
<span class="lineNum">     448 </span>            :     // respective ranges. A 'true' return value does not guarantee the
<span class="lineNum">     449 </span>            :     // Exploded value can be successfully converted to a Time value.
<span class="lineNum">     450 </span>            :     bool HasValidValues() const;
<span class="lineNum">     451 </span>            :   };
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   // Contains the NULL time. Use Time::Now() to get the current time.
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   Time() : TimeBase(0) {</span>
<span class="lineNum">     455 </span>            :   }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :   // Returns the time for epoch in Unix-like system (Jan 1, 1970).
<span class="lineNum">     458 </span>            :   static Time UnixEpoch();
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   // Returns the current time. Watch out, the system might adjust its clock
<span class="lineNum">     461 </span>            :   // in which case time will actually go backwards. We don't guarantee that
<span class="lineNum">     462 </span>            :   // times are increasing, or that two calls to Now() won't be the same.
<span class="lineNum">     463 </span>            :   static Time Now();
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   // Returns the current time. Same as Now() except that this function always
<span class="lineNum">     466 </span>            :   // uses system time so that there are no discrepancies between the returned
<span class="lineNum">     467 </span>            :   // time and system time even on virtual environments including our test bot.
<span class="lineNum">     468 </span>            :   // For timing sensitive unittests, this function should be used.
<span class="lineNum">     469 </span>            :   static Time NowFromSystemTime();
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   // Converts to/from time_t in UTC and a Time class.
<span class="lineNum">     472 </span>            :   static Time FromTimeT(time_t tt);
<span class="lineNum">     473 </span>            :   time_t ToTimeT() const;
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :   // Converts time to/from a double which is the number of seconds since epoch
<span class="lineNum">     476 </span>            :   // (Jan 1, 1970).  Webkit uses this format to represent time.
<span class="lineNum">     477 </span>            :   // Because WebKit initializes double time value to 0 to indicate &quot;not
<span class="lineNum">     478 </span>            :   // initialized&quot;, we map it to empty Time object that also means &quot;not
<span class="lineNum">     479 </span>            :   // initialized&quot;.
<span class="lineNum">     480 </span>            :   static Time FromDoubleT(double dt);
<span class="lineNum">     481 </span>            :   double ToDoubleT() const;
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : #if defined(OS_POSIX)
<span class="lineNum">     484 </span>            :   // Converts the timespec structure to time. MacOS X 10.8.3 (and tentatively,
<span class="lineNum">     485 </span>            :   // earlier versions) will have the |ts|'s tv_nsec component zeroed out,
<span class="lineNum">     486 </span>            :   // having a 1 second resolution, which agrees with
<span class="lineNum">     487 </span>            :   // https://developer.apple.com/legacy/library/#technotes/tn/tn1150.html#HFSPlusDates.
<span class="lineNum">     488 </span>            :   static Time FromTimeSpec(const timespec&amp; ts);
<span class="lineNum">     489 </span>            : #endif
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // Converts to/from the Javascript convention for times, a number of
<span class="lineNum">     492 </span>            :   // milliseconds since the epoch:
<span class="lineNum">     493 </span>            :   // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime.
<span class="lineNum">     494 </span>            :   static Time FromJsTime(double ms_since_epoch);
<span class="lineNum">     495 </span>            :   double ToJsTime() const;
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   // Converts to Java convention for times, a number of
<span class="lineNum">     498 </span>            :   // milliseconds since the epoch.
<span class="lineNum">     499 </span>            :   int64_t ToJavaTime() const;
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : #if defined(OS_POSIX)
<span class="lineNum">     502 </span>            :   static Time FromTimeVal(struct timeval t);
<span class="lineNum">     503 </span>            :   struct timeval ToTimeVal() const;
<span class="lineNum">     504 </span>            : #endif
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : #if defined(OS_MACOSX)
<span class="lineNum">     507 </span>            :   static Time FromCFAbsoluteTime(CFAbsoluteTime t);
<span class="lineNum">     508 </span>            :   CFAbsoluteTime ToCFAbsoluteTime() const;
<span class="lineNum">     509 </span>            : #endif
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : #if defined(OS_WIN)
<span class="lineNum">     512 </span>            :   static Time FromFileTime(FILETIME ft);
<span class="lineNum">     513 </span>            :   FILETIME ToFileTime() const;
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :   // The minimum time of a low resolution timer.  This is basically a windows
<span class="lineNum">     516 </span>            :   // constant of ~15.6ms.  While it does vary on some older OS versions, we'll
<span class="lineNum">     517 </span>            :   // treat it as static across all windows versions.
<span class="lineNum">     518 </span>            :   static const int kMinLowResolutionThresholdMs = 16;
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :   // Enable or disable Windows high resolution timer.
<span class="lineNum">     521 </span>            :   static void EnableHighResolutionTimer(bool enable);
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :   // Activates or deactivates the high resolution timer based on the |activate|
<span class="lineNum">     524 </span>            :   // flag.  If the HighResolutionTimer is not Enabled (see
<span class="lineNum">     525 </span>            :   // EnableHighResolutionTimer), this function will return false.  Otherwise
<span class="lineNum">     526 </span>            :   // returns true.  Each successful activate call must be paired with a
<span class="lineNum">     527 </span>            :   // subsequent deactivate call.
<span class="lineNum">     528 </span>            :   // All callers to activate the high resolution timer must eventually call
<span class="lineNum">     529 </span>            :   // this function to deactivate the high resolution timer.
<span class="lineNum">     530 </span>            :   static bool ActivateHighResolutionTimer(bool activate);
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :   // Returns true if the high resolution timer is both enabled and activated.
<span class="lineNum">     533 </span>            :   // This is provided for testing only, and is not tracked in a thread-safe
<span class="lineNum">     534 </span>            :   // way.
<span class="lineNum">     535 </span>            :   static bool IsHighResolutionTimerInUse();
<span class="lineNum">     536 </span>            : #endif
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            :   // Converts an exploded structure representing either the local time or UTC
<span class="lineNum">     539 </span>            :   // into a Time class.
<span class="lineNum">     540 </span>            :   // TODO(maksims): Get rid of these in favor of the methods below when
<span class="lineNum">     541 </span>            :   // all the callers stop using these ones.
<span class="lineNum">     542 </span>            :   static Time FromUTCExploded(const Exploded&amp; exploded) {
<span class="lineNum">     543 </span>            :     base::Time time;
<span class="lineNum">     544 </span>            :     ignore_result(FromUTCExploded(exploded, &amp;time));
<a name="545"><span class="lineNum">     545 </span>            :     return time;</a>
<span class="lineNum">     546 </span>            :   }
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   static Time FromLocalExploded(const Exploded&amp; exploded) {</span>
<span class="lineNum">     548 </span>            :     base::Time time;
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     ignore_result(FromLocalExploded(exploded, &amp;time));</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     return time;</span>
<span class="lineNum">     551 </span>            :   }
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :   // Converts an exploded structure representing either the local time or UTC
<span class="lineNum">     554 </span>            :   // into a Time class. Returns false on a failure when, for example, a day of
<span class="lineNum">     555 </span>            :   // month is set to 31 on a 28-30 day month. Returns Time(0) on overflow.
<span class="lineNum">     556 </span>            :   static bool FromUTCExploded(const Exploded&amp; exploded,
<span class="lineNum">     557 </span>            :                               Time* time) WARN_UNUSED_RESULT {
<a name="558"><span class="lineNum">     558 </span>            :     return FromExploded(false, exploded, time);</a>
<span class="lineNum">     559 </span>            :   }
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   static bool FromLocalExploded(const Exploded&amp; exploded,</span>
<span class="lineNum">     561 </span>            :                                 Time* time) WARN_UNUSED_RESULT {
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     return FromExploded(true, exploded, time);</span>
<span class="lineNum">     563 </span>            :   }
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :   // Converts a string representation of time to a Time object.
<span class="lineNum">     566 </span>            :   // An example of a time string which is converted is as below:-
<span class="lineNum">     567 </span>            :   // &quot;Tue, 15 Nov 1994 12:45:26 GMT&quot;. If the timezone is not specified
<span class="lineNum">     568 </span>            :   // in the input string, FromString assumes local time and FromUTCString
<span class="lineNum">     569 </span>            :   // assumes UTC. A timezone that cannot be parsed (e.g. &quot;UTC&quot; which is not
<span class="lineNum">     570 </span>            :   // specified in RFC822) is treated as if the timezone is not specified.
<span class="lineNum">     571 </span>            :   // TODO(iyengar) Move the FromString/FromTimeT/ToTimeT/FromFileTime to
<span class="lineNum">     572 </span>            :   // a new time converter class.
<span class="lineNum">     573 </span>            :   static bool FromString(const char* time_string, Time* parsed_time) {
<span class="lineNum">     574 </span>            :     return FromStringInternal(time_string, true, parsed_time);
<span class="lineNum">     575 </span>            :   }
<span class="lineNum">     576 </span>            :   static bool FromUTCString(const char* time_string, Time* parsed_time) {
<span class="lineNum">     577 </span>            :     return FromStringInternal(time_string, false, parsed_time);
<span class="lineNum">     578 </span>            :   }
<span class="lineNum">     579 </span>            : 
<a name="580"><span class="lineNum">     580 </span>            :   // Fills the given exploded structure with either the local time or UTC from</a>
<span class="lineNum">     581 </span>            :   // this time structure (containing UTC).
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   void UTCExplode(Exploded* exploded) const {</span>
<a name="583"><span class="lineNum">     583 </span><span class="lineNoCov">          0 :     return Explode(false, exploded);</span></a>
<span class="lineNum">     584 </span>            :   }
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   void LocalExplode(Exploded* exploded) const {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     return Explode(true, exploded);</span>
<span class="lineNum">     587 </span>            :   }
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            :   // Rounds this time down to the nearest day in local time. It will represent
<span class="lineNum">     590 </span>            :   // midnight on that day.
<span class="lineNum">     591 </span>            :   Time LocalMidnight() const;
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :  private:
<span class="lineNum">     594 </span>            :   friend class time_internal::TimeBase&lt;Time&gt;;
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   explicit Time(int64_t us) : TimeBase(us) {}</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   // Explodes the given time to either local time |is_local = true| or UTC
<span class="lineNum">     599 </span>            :   // |is_local = false|.
<span class="lineNum">     600 </span>            :   void Explode(bool is_local, Exploded* exploded) const;
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :   // Unexplodes a given time assuming the source is either local time
<span class="lineNum">     603 </span>            :   // |is_local = true| or UTC |is_local = false|. Function returns false on
<span class="lineNum">     604 </span>            :   // failure and sets |time| to Time(0). Otherwise returns true and sets |time|
<span class="lineNum">     605 </span>            :   // to non-exploded time.
<span class="lineNum">     606 </span>            :   static bool FromExploded(bool is_local,
<span class="lineNum">     607 </span>            :                            const Exploded&amp; exploded,
<span class="lineNum">     608 </span>            :                            Time* time) WARN_UNUSED_RESULT;
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            :   // Converts a string representation of time to a Time object.
<span class="lineNum">     611 </span>            :   // An example of a time string which is converted is as below:-
<span class="lineNum">     612 </span>            :   // &quot;Tue, 15 Nov 1994 12:45:26 GMT&quot;. If the timezone is not specified
<span class="lineNum">     613 </span>            :   // in the input string, local time |is_local = true| or
<span class="lineNum">     614 </span>            :   // UTC |is_local = false| is assumed. A timezone that cannot be parsed
<span class="lineNum">     615 </span>            :   // (e.g. &quot;UTC&quot; which is not specified in RFC822) is treated as if the
<span class="lineNum">     616 </span>            :   // timezone is not specified.
<span class="lineNum">     617 </span>            :   static bool FromStringInternal(const char* time_string,
<span class="lineNum">     618 </span>            :                                  bool is_local,
<span class="lineNum">     619 </span>            :                                  Time* parsed_time);
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :   // Comparison does not consider |day_of_week| when doing the operation.
<span class="lineNum">     622 </span>            :   static bool ExplodedMostlyEquals(const Exploded&amp; lhs, const Exploded&amp; rhs);
<span class="lineNum">     623 </span>            : };
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : // static
<span class="lineNum">     626 </span>            : constexpr TimeDelta TimeDelta::FromDays(int days) {
<span class="lineNum">     627 </span>            :   return days == std::numeric_limits&lt;int&gt;::max()
<span class="lineNum">     628 </span>            :              ? Max()
<span class="lineNum">     629 </span>            :              : TimeDelta(days * Time::kMicrosecondsPerDay);
<span class="lineNum">     630 </span>            : }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : // static
<span class="lineNum">     633 </span>            : constexpr TimeDelta TimeDelta::FromHours(int hours) {
<span class="lineNum">     634 </span>            :   return hours == std::numeric_limits&lt;int&gt;::max()
<span class="lineNum">     635 </span>            :              ? Max()
<span class="lineNum">     636 </span>            :              : TimeDelta(hours * Time::kMicrosecondsPerHour);
<span class="lineNum">     637 </span>            : }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            : // static
<span class="lineNum">     640 </span>            : constexpr TimeDelta TimeDelta::FromMinutes(int minutes) {
<span class="lineNum">     641 </span>            :   return minutes == std::numeric_limits&lt;int&gt;::max()
<span class="lineNum">     642 </span>            :              ? Max()
<span class="lineNum">     643 </span>            :              : TimeDelta(minutes * Time::kMicrosecondsPerMinute);
<span class="lineNum">     644 </span>            : }
<a name="645"><span class="lineNum">     645 </span>            : </a>
<span class="lineNum">     646 </span>            : // static
<span class="lineNum">     647 </span><span class="lineNoCov">          0 : constexpr TimeDelta TimeDelta::FromSeconds(int64_t secs) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   return FromProduct(secs, Time::kMicrosecondsPerSecond);</span>
<span class="lineNum">     649 </span>            : }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : // static
<span class="lineNum">     652 </span>            : constexpr TimeDelta TimeDelta::FromMilliseconds(int64_t ms) {
<span class="lineNum">     653 </span>            :   return FromProduct(ms, Time::kMicrosecondsPerMillisecond);
<span class="lineNum">     654 </span>            : }
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : // static
<span class="lineNum">     657 </span><span class="lineNoCov">          0 : constexpr TimeDelta TimeDelta::FromSecondsD(double secs) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   return FromDouble(secs * Time::kMicrosecondsPerSecond);</span>
<span class="lineNum">     659 </span>            : }
<a name="660"><span class="lineNum">     660 </span>            : </a>
<span class="lineNum">     661 </span>            : // static
<span class="lineNum">     662 </span><span class="lineNoCov">          0 : constexpr TimeDelta TimeDelta::FromMillisecondsD(double ms) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   return FromDouble(ms * Time::kMicrosecondsPerMillisecond);</span>
<span class="lineNum">     664 </span>            : }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : // static
<span class="lineNum">     667 </span>            : constexpr TimeDelta TimeDelta::FromMicroseconds(int64_t us) {
<span class="lineNum">     668 </span>            :   return TimeDelta(us);
<span class="lineNum">     669 </span>            : }
<a name="670"><span class="lineNum">     670 </span>            : </a>
<span class="lineNum">     671 </span>            : // static
<span class="lineNum">     672 </span><span class="lineNoCov">          0 : constexpr TimeDelta TimeDelta::FromDouble(double value) {</span>
<span class="lineNum">     673 </span>            :   // TODO(crbug.com/612601): Use saturated_cast&lt;int64_t&gt;(value) once we sort out
<span class="lineNum">     674 </span>            :   // the Min() behavior.
<span class="lineNum">     675 </span>            :   return value &gt; std::numeric_limits&lt;int64_t&gt;::max()
<span class="lineNum">     676 </span>            :              ? Max()
<span class="lineNum">     677 </span>            :              : value &lt; -std::numeric_limits&lt;int64_t&gt;::max()
<span class="lineNum">     678 </span>            :                    ? -Max()
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :                    : TimeDelta(static_cast&lt;int64_t&gt;(value));</span>
<span class="lineNum">     680 </span>            : }
<a name="681"><span class="lineNum">     681 </span>            : </a>
<span class="lineNum">     682 </span>            : // static
<span class="lineNum">     683 </span><span class="lineNoCov">          0 : constexpr TimeDelta TimeDelta::FromProduct(int64_t value,</span>
<span class="lineNum">     684 </span>            :                                            int64_t positive_value) {
<span class="lineNum">     685 </span>            :   return (
<span class="lineNum">     686 </span>            : #if !defined(_PREFAST_) || !defined(OS_WIN)
<span class="lineNum">     687 </span>            :           // Avoid internal compiler errors in /analyze builds with VS 2015
<span class="lineNum">     688 </span>            :           // update 3.
<span class="lineNum">     689 </span>            :           // https://connect.microsoft.com/VisualStudio/feedback/details/2870865
<span class="lineNum">     690 </span>            :           DCHECK(positive_value &gt; 0),
<span class="lineNum">     691 </span>            : #endif
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :           value &gt; std::numeric_limits&lt;int64_t&gt;::max() / positive_value</span>
<span class="lineNum">     693 </span>            :               ? Max()
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :               : value &lt; -std::numeric_limits&lt;int64_t&gt;::max() / positive_value</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                     ? -Max()</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :                     : TimeDelta(value * positive_value));</span>
<span class="lineNum">     697 </span>            : }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : // For logging use only.
<span class="lineNum">     700 </span>            : BASE_EXPORT std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Time time);
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : // TimeTicks ------------------------------------------------------------------
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : // Represents monotonically non-decreasing clock time.
<span class="lineNum">     705 </span>            : class BASE_EXPORT TimeTicks : public time_internal::TimeBase&lt;TimeTicks&gt; {
<span class="lineNum">     706 </span>            :  public:
<span class="lineNum">     707 </span>            :   // The underlying clock used to generate new TimeTicks.
<span class="lineNum">     708 </span>            :   enum class Clock {
<span class="lineNum">     709 </span>            :     LINUX_CLOCK_MONOTONIC,
<span class="lineNum">     710 </span>            :     IOS_CF_ABSOLUTE_TIME_MINUS_KERN_BOOTTIME,
<span class="lineNum">     711 </span>            :     MAC_MACH_ABSOLUTE_TIME,
<span class="lineNum">     712 </span>            :     WIN_QPC,
<span class="lineNum">     713 </span>            :     WIN_ROLLOVER_PROTECTED_TIME_GET_TIME
<span class="lineNum">     714 </span>            :   };
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   TimeTicks() : TimeBase(0) {</span>
<span class="lineNum">     717 </span>            :   }
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   // Platform-dependent tick count representing &quot;right now.&quot; When
<span class="lineNum">     720 </span>            :   // IsHighResolution() returns false, the resolution of the clock could be
<span class="lineNum">     721 </span>            :   // as coarse as ~15.6ms. Otherwise, the resolution should be no worse than one
<span class="lineNum">     722 </span>            :   // microsecond.
<span class="lineNum">     723 </span>            :   static TimeTicks Now();
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :   // Returns true if the high resolution clock is working on this system and
<span class="lineNum">     726 </span>            :   // Now() will return high resolution values. Note that, on systems where the
<span class="lineNum">     727 </span>            :   // high resolution clock works but is deemed inefficient, the low resolution
<span class="lineNum">     728 </span>            :   // clock will be used instead.
<span class="lineNum">     729 </span>            :   static bool IsHighResolution();
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :   // Returns true if TimeTicks is consistent across processes, meaning that
<span class="lineNum">     732 </span>            :   // timestamps taken on different processes can be safely compared with one
<span class="lineNum">     733 </span>            :   // another. (Note that, even on platforms where this returns true, time values
<span class="lineNum">     734 </span>            :   // from different threads that are within one tick of each other must be
<span class="lineNum">     735 </span>            :   // considered to have an ambiguous ordering.)
<span class="lineNum">     736 </span>            :   static bool IsConsistentAcrossProcesses();
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            : #if defined(OS_WIN)
<span class="lineNum">     739 </span>            :   // Translates an absolute QPC timestamp into a TimeTicks value. The returned
<span class="lineNum">     740 </span>            :   // value has the same origin as Now(). Do NOT attempt to use this if
<span class="lineNum">     741 </span>            :   // IsHighResolution() returns false.
<span class="lineNum">     742 </span>            :   static TimeTicks FromQPCValue(LONGLONG qpc_value);
<span class="lineNum">     743 </span>            : #endif
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            : #if defined(OS_MACOSX) &amp;&amp; !defined(OS_IOS)
<span class="lineNum">     746 </span>            :   static TimeTicks FromMachAbsoluteTime(uint64_t mach_absolute_time);
<span class="lineNum">     747 </span>            : #endif  // defined(OS_MACOSX) &amp;&amp; !defined(OS_IOS)
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            :   // Get an estimate of the TimeTick value at the time of the UnixEpoch. Because
<span class="lineNum">     750 </span>            :   // Time and TimeTicks respond differently to user-set time and NTP
<span class="lineNum">     751 </span>            :   // adjustments, this number is only an estimate. Nevertheless, this can be
<span class="lineNum">     752 </span>            :   // useful when you need to relate the value of TimeTicks to a real time and
<span class="lineNum">     753 </span>            :   // date. Note: Upon first invocation, this function takes a snapshot of the
<span class="lineNum">     754 </span>            :   // realtime clock to establish a reference point.  This function will return
<span class="lineNum">     755 </span>            :   // the same value for the duration of the application, but will be different
<span class="lineNum">     756 </span>            :   // in future application runs.
<span class="lineNum">     757 </span>            :   static TimeTicks UnixEpoch();
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :   // Returns |this| snapped to the next tick, given a |tick_phase| and
<span class="lineNum">     760 </span>            :   // repeating |tick_interval| in both directions. |this| may be before,
<span class="lineNum">     761 </span>            :   // after, or equal to the |tick_phase|.
<span class="lineNum">     762 </span>            :   TimeTicks SnappedToNextTick(TimeTicks tick_phase,
<span class="lineNum">     763 </span>            :                               TimeDelta tick_interval) const;
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :   // Returns an enum indicating the underlying clock being used to generate
<span class="lineNum">     766 </span>            :   // TimeTicks timestamps. This function should only be used for debugging and
<span class="lineNum">     767 </span>            :   // logging purposes.
<span class="lineNum">     768 </span>            :   static Clock GetClock();
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : #if defined(OS_WIN)
<span class="lineNum">     771 </span>            :  protected:
<span class="lineNum">     772 </span>            :   typedef DWORD (*TickFunctionType)(void);
<span class="lineNum">     773 </span>            :   static TickFunctionType SetMockTickFunction(TickFunctionType ticker);
<span class="lineNum">     774 </span>            : #endif
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :  private:
<span class="lineNum">     777 </span>            :   friend class time_internal::TimeBase&lt;TimeTicks&gt;;
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            :   // Please use Now() to create a new object. This is for internal use
<span class="lineNum">     780 </span>            :   // and testing.
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   explicit TimeTicks(int64_t us) : TimeBase(us) {}</span>
<span class="lineNum">     782 </span>            : };
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : // For logging use only.
<span class="lineNum">     785 </span>            : BASE_EXPORT std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, TimeTicks time_ticks);
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : // ThreadTicks ----------------------------------------------------------------
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            : // Represents a clock, specific to a particular thread, than runs only while the
<span class="lineNum">     790 </span>            : // thread is running.
<span class="lineNum">     791 </span>            : class BASE_EXPORT ThreadTicks : public time_internal::TimeBase&lt;ThreadTicks&gt; {
<span class="lineNum">     792 </span>            :  public:
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   ThreadTicks() : TimeBase(0) {</span>
<span class="lineNum">     794 </span>            :   }
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :   // Returns true if ThreadTicks::Now() is supported on this system.
<span class="lineNum">     797 </span>            :   static bool IsSupported() {
<span class="lineNum">     798 </span>            : #if (defined(_POSIX_THREAD_CPUTIME) &amp;&amp; (_POSIX_THREAD_CPUTIME &gt;= 0)) || \
<span class="lineNum">     799 </span>            :     (defined(OS_MACOSX) &amp;&amp; !defined(OS_IOS)) || defined(OS_ANDROID)
<span class="lineNum">     800 </span>            :     return true;
<span class="lineNum">     801 </span>            : #elif defined(OS_WIN)
<span class="lineNum">     802 </span>            :     return IsSupportedWin();
<span class="lineNum">     803 </span>            : #else
<span class="lineNum">     804 </span>            :     return false;
<span class="lineNum">     805 </span>            : #endif
<span class="lineNum">     806 </span>            :   }
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :   // Waits until the initialization is completed. Needs to be guarded with a
<span class="lineNum">     809 </span>            :   // call to IsSupported().
<span class="lineNum">     810 </span>            :   static void WaitUntilInitialized() {
<span class="lineNum">     811 </span>            : #if defined(OS_WIN)
<span class="lineNum">     812 </span>            :     WaitUntilInitializedWin();
<span class="lineNum">     813 </span>            : #endif
<span class="lineNum">     814 </span>            :   }
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :   // Returns thread-specific CPU-time on systems that support this feature.
<span class="lineNum">     817 </span>            :   // Needs to be guarded with a call to IsSupported(). Use this timer
<span class="lineNum">     818 </span>            :   // to (approximately) measure how much time the calling thread spent doing
<span class="lineNum">     819 </span>            :   // actual work vs. being de-scheduled. May return bogus results if the thread
<span class="lineNum">     820 </span>            :   // migrates to another CPU between two calls. Returns an empty ThreadTicks
<span class="lineNum">     821 </span>            :   // object until the initialization is completed. If a clock reading is
<span class="lineNum">     822 </span>            :   // absolutely needed, call WaitUntilInitialized() before this method.
<span class="lineNum">     823 </span>            :   static ThreadTicks Now();
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : #if defined(OS_WIN)
<span class="lineNum">     826 </span>            :   // Similar to Now() above except this returns thread-specific CPU time for an
<span class="lineNum">     827 </span>            :   // arbitrary thread. All comments for Now() method above apply apply to this
<span class="lineNum">     828 </span>            :   // method as well.
<span class="lineNum">     829 </span>            :   static ThreadTicks GetForThread(const PlatformThreadHandle&amp; thread_handle);
<span class="lineNum">     830 </span>            : #endif
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :  private:
<span class="lineNum">     833 </span>            :   friend class time_internal::TimeBase&lt;ThreadTicks&gt;;
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :   // Please use Now() or GetForThread() to create a new object. This is for
<span class="lineNum">     836 </span>            :   // internal use and testing.
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   explicit ThreadTicks(int64_t us) : TimeBase(us) {}</span>
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : #if defined(OS_WIN)
<span class="lineNum">     840 </span>            :   FRIEND_TEST_ALL_PREFIXES(TimeTicks, TSCTicksPerSecond);
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :   // Returns the frequency of the TSC in ticks per second, or 0 if it hasn't
<span class="lineNum">     843 </span>            :   // been measured yet. Needs to be guarded with a call to IsSupported().
<span class="lineNum">     844 </span>            :   // This method is declared here rather than in the anonymous namespace to
<span class="lineNum">     845 </span>            :   // allow testing.
<span class="lineNum">     846 </span>            :   static double TSCTicksPerSecond();
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :   static bool IsSupportedWin();
<span class="lineNum">     849 </span>            :   static void WaitUntilInitializedWin();
<span class="lineNum">     850 </span>            : #endif
<span class="lineNum">     851 </span>            : };
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : // For logging use only.
<span class="lineNum">     854 </span>            : BASE_EXPORT std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ThreadTicks time_ticks);
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : }  // namespace base
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span>            : #endif  // BASE_TIME_TIME_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
