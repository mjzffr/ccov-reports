<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mochitest-e10s.info - js/xpconnect/src/XPCJSContext.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/xpconnect/src</a> - XPCJSContext.cpp<span style="font-size: 80%;"> (source / <a href="XPCJSContext.cpp.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mochitest-e10s.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">493</td>
            <td class="headerCovTableEntry">1365</td>
            <td class="headerCovTableEntryLo">36.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">65</td>
            <td class="headerCovTableEntry">153</td>
            <td class="headerCovTableEntryLo">42.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=4 et sw=4 tw=99: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* Per JSContext object */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;xpcprivate.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;xpcpublic.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;XPCWrapper.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;XPCJSMemoryReporter.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;WrapperFactory.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozJSComponentLoader.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsAutoPtr.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsNetUtil.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;nsIMemoryInfoDumper.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsIMemoryReporter.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsIObserverService.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIDebug2.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIDocShell.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsIRunnable.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;amIAddonManager.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsPIDOMWindow.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsPrintfCString.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/Services.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/dom/ScriptSettings.h&quot;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;nsCCUncollectableMarker.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsCycleCollectionNoteRootCallback.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;nsCycleCollector.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;nsScriptLoader.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;jsapi.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;jsprf.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;js/MemoryMetrics.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;mozilla/dom/GeneratedAtomList.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;mozilla/dom/BindingUtils.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;mozilla/dom/Element.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;mozilla/dom/WindowBinding.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;mozilla/jsipc/CrossProcessObjectWrappers.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;mozilla/Atomics.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;mozilla/ProcessHangMonitor.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;mozilla/Sprintf.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;mozilla/UniquePtrExtensions.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;mozilla/Unused.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;AccessCheck.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;nsGlobalWindow.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;nsAboutProtocolUtils.h&quot;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #include &quot;GeckoProfiler.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;nsIInputStream.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;nsIXULRuntime.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;nsJSPrincipals.h&quot;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : #ifdef MOZ_CRASHREPORTER
<span class="lineNum">      64 </span>            : #include &quot;nsExceptionHandler.h&quot;
<span class="lineNum">      65 </span>            : #endif
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #if defined(MOZ_JEMALLOC4)
<span class="lineNum">      68 </span>            : #include &quot;mozmemory.h&quot;
<span class="lineNum">      69 </span>            : #endif
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : #ifdef XP_WIN
<span class="lineNum">      72 </span>            : #include &lt;windows.h&gt;
<span class="lineNum">      73 </span>            : #endif
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : using namespace mozilla;
<span class="lineNum">      76 </span>            : using namespace xpc;
<span class="lineNum">      77 </span>            : using namespace JS;
<span class="lineNum">      78 </span>            : using mozilla::dom::PerThreadAtomCache;
<span class="lineNum">      79 </span>            : using mozilla::dom::AutoEntryScript;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : /***************************************************************************/
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : const char* const XPCJSContext::mStrings[] = {
<span class="lineNum">      84 </span>            :     &quot;constructor&quot;,          // IDX_CONSTRUCTOR
<span class="lineNum">      85 </span>            :     &quot;toString&quot;,             // IDX_TO_STRING
<span class="lineNum">      86 </span>            :     &quot;toSource&quot;,             // IDX_TO_SOURCE
<span class="lineNum">      87 </span>            :     &quot;lastResult&quot;,           // IDX_LAST_RESULT
<span class="lineNum">      88 </span>            :     &quot;returnCode&quot;,           // IDX_RETURN_CODE
<span class="lineNum">      89 </span>            :     &quot;value&quot;,                // IDX_VALUE
<span class="lineNum">      90 </span>            :     &quot;QueryInterface&quot;,       // IDX_QUERY_INTERFACE
<span class="lineNum">      91 </span>            :     &quot;Components&quot;,           // IDX_COMPONENTS
<span class="lineNum">      92 </span>            :     &quot;wrappedJSObject&quot;,      // IDX_WRAPPED_JSOBJECT
<span class="lineNum">      93 </span>            :     &quot;Object&quot;,               // IDX_OBJECT
<span class="lineNum">      94 </span>            :     &quot;Function&quot;,             // IDX_FUNCTION
<span class="lineNum">      95 </span>            :     &quot;prototype&quot;,            // IDX_PROTOTYPE
<span class="lineNum">      96 </span>            :     &quot;createInstance&quot;,       // IDX_CREATE_INSTANCE
<span class="lineNum">      97 </span>            :     &quot;item&quot;,                 // IDX_ITEM
<span class="lineNum">      98 </span>            :     &quot;__proto__&quot;,            // IDX_PROTO
<span class="lineNum">      99 </span>            :     &quot;__iterator__&quot;,         // IDX_ITERATOR
<span class="lineNum">     100 </span>            :     &quot;__exposedProps__&quot;,     // IDX_EXPOSEDPROPS
<span class="lineNum">     101 </span>            :     &quot;eval&quot;,                 // IDX_EVAL
<span class="lineNum">     102 </span>            :     &quot;controllers&quot;,          // IDX_CONTROLLERS
<span class="lineNum">     103 </span>            :     &quot;realFrameElement&quot;,     // IDX_REALFRAMEELEMENT
<span class="lineNum">     104 </span>            :     &quot;length&quot;,               // IDX_LENGTH
<span class="lineNum">     105 </span>            :     &quot;name&quot;,                 // IDX_NAME
<span class="lineNum">     106 </span>            :     &quot;undefined&quot;,            // IDX_UNDEFINED
<span class="lineNum">     107 </span>            :     &quot;&quot;,                     // IDX_EMPTYSTRING
<span class="lineNum">     108 </span>            :     &quot;fileName&quot;,             // IDX_FILENAME
<span class="lineNum">     109 </span>            :     &quot;lineNumber&quot;,           // IDX_LINENUMBER
<span class="lineNum">     110 </span>            :     &quot;columnNumber&quot;,         // IDX_COLUMNNUMBER
<span class="lineNum">     111 </span>            :     &quot;stack&quot;,                // IDX_STACK
<span class="lineNum">     112 </span>            :     &quot;message&quot;,              // IDX_MESSAGE
<span class="lineNum">     113 </span>            :     &quot;lastIndex&quot;             // IDX_LASTINDEX
<span class="lineNum">     114 </span>            : };
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : /***************************************************************************/
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : static mozilla::Atomic&lt;bool&gt; sDiscardSystemSource(false);
<a name="119"><span class="lineNum">     119 </span>            : </a>
<span class="lineNum">     120 </span>            : bool
<span class="lineNum">     121 </span><span class="lineCov">        665 : xpc::ShouldDiscardSystemSource() { return sDiscardSystemSource; }</span>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #ifdef DEBUG
<span class="lineNum">     124 </span>            : static mozilla::Atomic&lt;bool&gt; sExtraWarningsForSystemJS(false);
<a name="125"><span class="lineNum">     125 </span>            : bool xpc::ExtraWarningsForSystemJS() { return sExtraWarningsForSystemJS; }</a>
<span class="lineNum">     126 </span>            : #else
<span class="lineNum">     127 </span><span class="lineCov">        605 : bool xpc::ExtraWarningsForSystemJS() { return false; }</span>
<span class="lineNum">     128 </span>            : #endif
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : static mozilla::Atomic&lt;bool&gt; sSharedMemoryEnabled(false);
<a name="131"><span class="lineNum">     131 </span>            : </a>
<span class="lineNum">     132 </span>            : bool
<span class="lineNum">     133 </span><span class="lineCov">       1390 : xpc::SharedMemoryEnabled() { return sSharedMemoryEnabled; }</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : // *Some* NativeSets are referenced from mClassInfo2NativeSetMap.
<span class="lineNum">     136 </span>            : // *All* NativeSets are referenced from mNativeSetMap.
<span class="lineNum">     137 </span>            : // So, in mClassInfo2NativeSetMap we just clear references to the unmarked.
<a name="138"><span class="lineNum">     138 </span>            : // In mNativeSetMap we clear the references to the unmarked *and* delete them.</a>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">        180 : class AsyncFreeSnowWhite : public Runnable</span>
<a name="141"><span class="lineNum">     141 </span>            : {</a>
<span class="lineNum">     142 </span>            : public:
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   NS_IMETHOD Run() override</span>
<span class="lineNum">     144 </span>            :   {
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       TimeStamp start = TimeStamp::Now();</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :       bool hadSnowWhiteObjects = nsCycleCollector_doDeferredDeletion();</span>
<span class="lineNum">     147 </span>            :       Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_ASYNC_SNOW_WHITE_FREEING,
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :                             uint32_t((TimeStamp::Now() - start).ToMilliseconds()));</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       if (hadSnowWhiteObjects &amp;&amp; !mContinuation) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :           mContinuation = true;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :           if (NS_FAILED(Dispatch())) {</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :               mActive = false;</span>
<span class="lineNum">     153 </span>            :           }
<span class="lineNum">     154 </span>            :       } else {
<span class="lineNum">     155 </span>            : #if defined(MOZ_JEMALLOC4)
<span class="lineNum">     156 </span>            :           if (mPurge) {
<span class="lineNum">     157 </span>            :               /* Jemalloc purges dirty pages regularly during free() when the
<span class="lineNum">     158 </span>            :                * ratio of dirty pages compared to active pages is higher than
<span class="lineNum">     159 </span>            :                * 1 &lt;&lt; lg_dirty_mult. A high ratio can have an impact on
<span class="lineNum">     160 </span>            :                * performance, so we use the default ratio of 8, but force a
<span class="lineNum">     161 </span>            :                * regular purge of all remaining dirty pages, after cycle
<span class="lineNum">     162 </span>            :                * collection. */
<span class="lineNum">     163 </span>            :               Telemetry::AutoTimer&lt;Telemetry::MEMORY_FREE_PURGED_PAGES_MS&gt; timer;
<span class="lineNum">     164 </span>            :               jemalloc_free_dirty_pages();
<span class="lineNum">     165 </span>            :           }
<span class="lineNum">     166 </span>            : #endif
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :           mActive = false;</span>
<span class="lineNum">     168 </span>            :       }
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<a name="170"><span class="lineNum">     170 </span>            :   }</a>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   nsresult Dispatch()</span>
<span class="lineNum">     173 </span>            :   {
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       if (NS_IsMainThread()) {</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :           nsCOMPtr&lt;nsIRunnable&gt; self(this);</span>
<span class="lineNum">     176 </span>            :           return SystemGroup::Dispatch(&quot;AsyncFreeSnowWhite&quot;,
<span class="lineNum">     177 </span>            :                                        TaskCategory::GarbageCollection,
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                                        self.forget());</span>
<span class="lineNum">     179 </span>            :       } else {
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :           return NS_DispatchToCurrentThread(this);</span>
<span class="lineNum">     181 </span>            :       }
<a name="182"><span class="lineNum">     182 </span>            :   }</a>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   void Start(bool aContinuation = false, bool aPurge = false)</span>
<span class="lineNum">     185 </span>            :   {
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :       if (mContinuation) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :           mContinuation = aContinuation;</span>
<span class="lineNum">     188 </span>            :       }
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :       mPurge = aPurge;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       if (!mActive &amp;&amp; NS_SUCCEEDED(Dispatch())) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :           mActive = true;</span>
<span class="lineNum">     192 </span>            :       }
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineCov">         60 :   AsyncFreeSnowWhite()</span>
<span class="lineNum">     196 </span>            :     : Runnable(&quot;AsyncFreeSnowWhite&quot;)
<span class="lineNum">     197 </span>            :     , mContinuation(false)
<span class="lineNum">     198 </span>            :     , mActive(false)
<span class="lineNum">     199 </span><span class="lineCov">         60 :     , mPurge(false) {}</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : public:
<span class="lineNum">     202 </span>            :   bool mContinuation;
<span class="lineNum">     203 </span>            :   bool mActive;
<span class="lineNum">     204 </span>            :   bool mPurge;
<span class="lineNum">     205 </span>            : };
<span class="lineNum">     206 </span>            : 
<a name="207"><span class="lineNum">     207 </span>            : namespace xpc {</a>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineCov">        785 : CompartmentPrivate::CompartmentPrivate(JSCompartment* c)</span>
<span class="lineNum">     210 </span>            :     : wantXrays(false)
<span class="lineNum">     211 </span>            :     , allowWaivers(true)
<span class="lineNum">     212 </span>            :     , writeToGlobalPrototype(false)
<span class="lineNum">     213 </span>            :     , skipWriteToGlobalPrototype(false)
<span class="lineNum">     214 </span>            :     , isWebExtensionContentScript(false)
<span class="lineNum">     215 </span>            :     , waiveInterposition(false)
<span class="lineNum">     216 </span>            :     , allowCPOWs(false)
<span class="lineNum">     217 </span>            :     , universalXPConnectEnabled(false)
<span class="lineNum">     218 </span>            :     , forcePermissiveCOWs(false)
<span class="lineNum">     219 </span>            :     , wasNuked(false)
<span class="lineNum">     220 </span>            :     , scriptability(c)
<span class="lineNum">     221 </span>            :     , scope(nullptr)
<span class="lineNum">     222 </span><span class="lineCov">       2355 :     , mWrappedJSMap(JSObject2WrappedJSMap::newMap(XPC_JS_MAP_LENGTH))</span>
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span>            :     MOZ_COUNT_CTOR(xpc::CompartmentPrivate);
<span class="lineNum">     225 </span><span class="lineCov">        785 :     mozilla::PodArrayZero(wrapperDenialWarnings);</span>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">        785 : }</span></a>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineCov">       2355 : CompartmentPrivate::~CompartmentPrivate()</span>
<span class="lineNum">     229 </span>            : {
<span class="lineNum">     230 </span>            :     MOZ_COUNT_DTOR(xpc::CompartmentPrivate);
<span class="lineNum">     231 </span><span class="lineCov">        785 :     mWrappedJSMap-&gt;ShutdownMarker();</span>
<span class="lineNum">     232 </span><span class="lineCov">        785 :     delete mWrappedJSMap;</span>
<span class="lineNum">     233 </span><span class="lineCov">        785 : }</span>
<a name="234"><span class="lineNum">     234 </span>            : </a>
<span class="lineNum">     235 </span>            : static bool
<span class="lineNum">     236 </span><span class="lineNoCov">          0 : TryParseLocationURICandidate(const nsACString&amp; uristr,</span>
<span class="lineNum">     237 </span>            :                              CompartmentPrivate::LocationHint aLocationHint,
<span class="lineNum">     238 </span>            :                              nsIURI** aURI)
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     static NS_NAMED_LITERAL_CSTRING(kGRE, &quot;resource://gre/&quot;);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     static NS_NAMED_LITERAL_CSTRING(kToolkit, &quot;chrome://global/&quot;);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     static NS_NAMED_LITERAL_CSTRING(kBrowser, &quot;chrome://browser/&quot;);</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     if (aLocationHint == CompartmentPrivate::LocationHintAddon) {</span>
<span class="lineNum">     245 </span>            :         // Blacklist some known locations which are clearly not add-on related.
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         if (StringBeginsWith(uristr, kGRE) ||</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :             StringBeginsWith(uristr, kToolkit) ||</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :             StringBeginsWith(uristr, kBrowser))</span>
<span class="lineNum">     249 </span>            :             return false;
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :         // -- GROSS HACK ALERT --
<span class="lineNum">     252 </span>            :         // The Yandex Elements 8.10.2 extension implements its own &quot;xb://&quot; URL
<span class="lineNum">     253 </span>            :         // scheme. If we call NS_NewURI() on an &quot;xb://...&quot; URL, we'll end up
<span class="lineNum">     254 </span>            :         // calling into the extension's own JS-implemented nsIProtocolHandler
<span class="lineNum">     255 </span>            :         // object, which we can't allow while we're iterating over the JS heap.
<span class="lineNum">     256 </span>            :         // So just skip any such URL.
<span class="lineNum">     257 </span>            :         // -- GROSS HACK ALERT --
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         if (StringBeginsWith(uristr, NS_LITERAL_CSTRING(&quot;xb&quot;)))</span>
<span class="lineNum">     259 </span>            :             return false;
<span class="lineNum">     260 </span>            :     }
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :     nsCOMPtr&lt;nsIURI&gt; uri;
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), uristr)))</span>
<span class="lineNum">     264 </span>            :         return false;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     nsAutoCString scheme;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     if (NS_FAILED(uri-&gt;GetScheme(scheme)))</span>
<span class="lineNum">     268 </span>            :         return false;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :     // Cannot really map data: and blob:.
<span class="lineNum">     271 </span>            :     // Also, data: URIs are pretty memory hungry, which is kinda bad
<span class="lineNum">     272 </span>            :     // for memory reporter use.
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     if (scheme.EqualsLiteral(&quot;data&quot;) || scheme.EqualsLiteral(&quot;blob&quot;))</span>
<span class="lineNum">     274 </span>            :         return false;
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     uri.forget(aURI);
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="278"><span class="lineNum">     278 </span>            : }</a>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineNoCov">          0 : bool CompartmentPrivate::TryParseLocationURI(CompartmentPrivate::LocationHint aLocationHint,</span>
<span class="lineNum">     281 </span>            :                                              nsIURI** aURI)
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     if (!aURI)</span>
<span class="lineNum">     284 </span>            :         return false;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :     // Need to parse the URI.
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     if (location.IsEmpty())</span>
<span class="lineNum">     288 </span>            :         return false;
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     // Handle Sandbox location strings.
<span class="lineNum">     291 </span>            :     // A sandbox string looks like this:
<span class="lineNum">     292 </span>            :     // &lt;sandboxName&gt; (from: &lt;js-stack-frame-filename&gt;:&lt;lineno&gt;)
<span class="lineNum">     293 </span>            :     // where &lt;sandboxName&gt; is user-provided via Cu.Sandbox()
<span class="lineNum">     294 </span>            :     // and &lt;js-stack-frame-filename&gt; and &lt;lineno&gt; is the stack frame location
<span class="lineNum">     295 </span>            :     // from where Cu.Sandbox was called.
<span class="lineNum">     296 </span>            :     // &lt;js-stack-frame-filename&gt; furthermore is &quot;free form&quot;, often using a
<span class="lineNum">     297 </span>            :     // &quot;uri -&gt; uri -&gt; ...&quot; chain. The following code will and must handle this
<span class="lineNum">     298 </span>            :     // common case.
<span class="lineNum">     299 </span>            :     // It should be noted that other parts of the code may already rely on the
<span class="lineNum">     300 </span>            :     // &quot;format&quot; of these strings, such as the add-on SDK.
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     static const nsDependentCString from(&quot;(from: &quot;);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     static const nsDependentCString arrow(&quot; -&gt; &quot;);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     static const size_t fromLength = from.Length();</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     static const size_t arrowLength = arrow.Length();</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :     // See: XPCComponents.cpp#AssembleSandboxMemoryReporterName
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     int32_t idx = location.Find(from);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     if (idx &lt; 0)</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         return TryParseLocationURICandidate(location, aLocationHint, aURI);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :     // When parsing we're looking for the right-most URI. This URI may be in
<span class="lineNum">     314 </span>            :     // &lt;sandboxName&gt;, so we try this first.
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     if (TryParseLocationURICandidate(Substring(location, 0, idx), aLocationHint,</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                                      aURI))</span>
<span class="lineNum">     317 </span>            :         return true;
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     // Not in &lt;sandboxName&gt; so we need to inspect &lt;js-stack-frame-filename&gt; and
<span class="lineNum">     320 </span>            :     // the chain that is potentially contained within and grab the rightmost
<span class="lineNum">     321 </span>            :     // item that is actually a URI.
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     // First, hack off the :&lt;lineno&gt;) part as well
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     int32_t ridx = location.RFind(NS_LITERAL_CSTRING(&quot;:&quot;));</span>
<span class="lineNum">     325 </span>            :     nsAutoCString chain(Substring(location, idx + fromLength,
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                                   ridx - idx - fromLength));</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     // Loop over the &quot;-&gt;&quot; chain. This loop also works for non-chains, or more
<span class="lineNum">     329 </span>            :     // correctly chains with only one item.
<span class="lineNum">     330 </span>            :     for (;;) {
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         idx = chain.RFind(arrow);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         if (idx &lt; 0) {</span>
<span class="lineNum">     333 </span>            :             // This is the last chain item. Try to parse what is left.
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :             return TryParseLocationURICandidate(chain, aLocationHint, aURI);</span>
<span class="lineNum">     335 </span>            :         }
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :         // Try to parse current chain item
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         if (TryParseLocationURICandidate(Substring(chain, idx + arrowLength),</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                                          aLocationHint, aURI))</span>
<span class="lineNum">     340 </span>            :             return true;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :         // Current chain item couldn't be parsed.
<span class="lineNum">     343 </span>            :         // Strip current item and continue.
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         chain = Substring(chain, 0, idx);</span>
<span class="lineNum">     345 </span>            :     }
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     MOZ_CRASH(&quot;Chain parser loop does not terminate&quot;);
<span class="lineNum">     348 </span>            : }
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span>            : static bool
<span class="lineNum">     351 </span><span class="lineCov">        785 : PrincipalImmuneToScriptPolicy(nsIPrincipal* aPrincipal)</span>
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span>            :     // System principal gets a free pass.
<span class="lineNum">     354 </span><span class="lineCov">        785 :     if (nsXPConnect::SecurityManager()-&gt;IsSystemPrincipal(aPrincipal))</span>
<span class="lineNum">     355 </span>            :         return true;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :     // ExpandedPrincipal gets a free pass.
<span class="lineNum">     358 </span><span class="lineCov">        120 :     nsCOMPtr&lt;nsIExpandedPrincipal&gt; ep = do_QueryInterface(aPrincipal);</span>
<span class="lineNum">     359 </span><span class="lineCov">        120 :     if (ep)</span>
<span class="lineNum">     360 </span>            :         return true;
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :     // Check whether our URI is an &quot;about:&quot; URI that allows scripts.  If it is,
<span class="lineNum">     363 </span>            :     // we need to allow JS to run.
<span class="lineNum">     364 </span>            :     nsCOMPtr&lt;nsIURI&gt; principalURI;
<span class="lineNum">     365 </span><span class="lineCov">        120 :     aPrincipal-&gt;GetURI(getter_AddRefs(principalURI));</span>
<span class="lineNum">     366 </span>            :     MOZ_ASSERT(principalURI);
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :     // WebExtension principals gets a free pass.
<span class="lineNum">     369 </span>            :     nsString addonId;
<span class="lineNum">     370 </span><span class="lineCov">        120 :     aPrincipal-&gt;GetAddonId(addonId);</span>
<span class="lineNum">     371 </span><span class="lineCov">        120 :     bool isWebExtension = !addonId.IsEmpty();</span>
<span class="lineNum">     372 </span><span class="lineCov">        120 :     if (isWebExtension) {</span>
<span class="lineNum">     373 </span>            :         return true;
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :     bool isAbout;
<span class="lineNum">     377 </span><span class="lineCov">        120 :     nsresult rv = principalURI-&gt;SchemeIs(&quot;about&quot;, &amp;isAbout);</span>
<span class="lineNum">     378 </span><span class="lineCov">        120 :     if (NS_SUCCEEDED(rv) &amp;&amp; isAbout) {</span>
<span class="lineNum">     379 </span>            :         nsCOMPtr&lt;nsIAboutModule&gt; module;
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         rv = NS_GetAboutModule(principalURI, getter_AddRefs(module));</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     382 </span>            :             uint32_t flags;
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :             rv = module-&gt;GetURIFlags(principalURI, &amp;flags);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             if (NS_SUCCEEDED(rv) &amp;&amp;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                 (flags &amp; nsIAboutModule::ALLOW_SCRIPT)) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     387 </span>            :             }
<span class="lineNum">     388 </span>            :         }
<span class="lineNum">     389 </span>            :     }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :     return false;
<a name="392"><span class="lineNum">     392 </span>            : }</a>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">        785 : Scriptability::Scriptability(JSCompartment* c) : mScriptBlocks(0)</span>
<span class="lineNum">     395 </span>            :                                                , mDocShellAllowsScript(true)
<span class="lineNum">     396 </span><span class="lineCov">        785 :                                                , mScriptBlockedByPolicy(false)</span>
<span class="lineNum">     397 </span>            : {
<span class="lineNum">     398 </span><span class="lineCov">       1570 :     nsIPrincipal* prin = nsJSPrincipals::get(JS_GetCompartmentPrincipals(c));</span>
<span class="lineNum">     399 </span><span class="lineCov">        785 :     mImmuneToScriptPolicy = PrincipalImmuneToScriptPolicy(prin);</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :     // If we're not immune, we should have a real principal with a codebase URI.
<span class="lineNum">     402 </span>            :     // Check the URI against the new-style domain policy.
<span class="lineNum">     403 </span><span class="lineCov">        785 :     if (!mImmuneToScriptPolicy) {</span>
<span class="lineNum">     404 </span>            :         nsCOMPtr&lt;nsIURI&gt; codebase;
<span class="lineNum">     405 </span><span class="lineCov">        120 :         nsresult rv = prin-&gt;GetURI(getter_AddRefs(codebase));</span>
<span class="lineNum">     406 </span>            :         bool policyAllows;
<span class="lineNum">     407 </span><span class="lineCov">        360 :         if (NS_SUCCEEDED(rv) &amp;&amp; codebase &amp;&amp;</span>
<span class="lineNum">     408 </span><span class="lineCov">        240 :             NS_SUCCEEDED(nsXPConnect::SecurityManager()-&gt;PolicyAllowsScript(codebase, &amp;policyAllows)))</span>
<span class="lineNum">     409 </span>            :         {
<span class="lineNum">     410 </span><span class="lineCov">        120 :             mScriptBlockedByPolicy = !policyAllows;</span>
<span class="lineNum">     411 </span>            :         } else {
<span class="lineNum">     412 </span>            :             // Something went wrong - be safe and block script.
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :             mScriptBlockedByPolicy = true;</span>
<span class="lineNum">     414 </span>            :         }
<span class="lineNum">     415 </span>            :     }
<span class="lineNum">     416 </span><span class="lineCov">        785 : }</span>
<a name="417"><span class="lineNum">     417 </span>            : </a>
<span class="lineNum">     418 </span>            : bool
<span class="lineNum">     419 </span><span class="lineCov">        272 : Scriptability::Allowed()</span>
<span class="lineNum">     420 </span>            : {
<span class="lineNum">     421 </span><span class="lineCov">        544 :     return mDocShellAllowsScript &amp;&amp; !mScriptBlockedByPolicy &amp;&amp;</span>
<span class="lineNum">     422 </span><span class="lineCov">        544 :            mScriptBlocks == 0;</span>
<span class="lineNum">     423 </span>            : }
<a name="424"><span class="lineNum">     424 </span>            : </a>
<span class="lineNum">     425 </span>            : bool
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : Scriptability::IsImmuneToScriptPolicy()</span>
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     return mImmuneToScriptPolicy;</span>
<span class="lineNum">     429 </span>            : }
<a name="430"><span class="lineNum">     430 </span>            : </a>
<span class="lineNum">     431 </span>            : void
<a name="432"><span class="lineNum">     432 </span><span class="lineNoCov">          0 : Scriptability::Block()</span></a>
<span class="lineNum">     433 </span>            : {
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     ++mScriptBlocks;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 : }</span>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : void
<span class="lineNum">     438 </span><span class="lineNoCov">          0 : Scriptability::Unblock()</span>
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span>            :     MOZ_ASSERT(mScriptBlocks &gt; 0);
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     --mScriptBlocks;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : }</span>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<span class="lineNum">     444 </span>            : void
<span class="lineNum">     445 </span><span class="lineNoCov">          0 : Scriptability::SetDocShellAllowsScript(bool aAllowed)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     mDocShellAllowsScript = aAllowed || mImmuneToScriptPolicy;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     449 </span>            : 
<a name="450"><span class="lineNum">     450 </span>            : /* static */</a>
<span class="lineNum">     451 </span>            : Scriptability&amp;
<span class="lineNum">     452 </span><span class="lineCov">        272 : Scriptability::Get(JSObject* aScope)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span><span class="lineCov">        272 :     return CompartmentPrivate::Get(aScope)-&gt;scriptability;</span>
<span class="lineNum">     455 </span>            : }
<a name="456"><span class="lineNum">     456 </span>            : </a>
<span class="lineNum">     457 </span>            : bool
<span class="lineNum">     458 </span><span class="lineNoCov">          0 : IsContentXBLScope(JSCompartment* compartment)</span>
<span class="lineNum">     459 </span>            : {
<span class="lineNum">     460 </span>            :     // We always eagerly create compartment privates for XBL scopes.
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     if (!priv || !priv-&gt;scope)</span>
<span class="lineNum">     463 </span>            :         return false;
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     return priv-&gt;scope-&gt;IsContentXBLScope();</span>
<span class="lineNum">     465 </span>            : }
<a name="466"><span class="lineNum">     466 </span>            : </a>
<span class="lineNum">     467 </span>            : bool
<span class="lineNum">     468 </span><span class="lineNoCov">          0 : IsInContentXBLScope(JSObject* obj)</span>
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     return IsContentXBLScope(js::GetObjectCompartment(obj));</span>
<span class="lineNum">     471 </span>            : }
<a name="472"><span class="lineNum">     472 </span>            : </a>
<span class="lineNum">     473 </span>            : bool
<span class="lineNum">     474 </span><span class="lineCov">          6 : IsInAddonScope(JSObject* obj)</span>
<span class="lineNum">     475 </span>            : {
<span class="lineNum">     476 </span><span class="lineCov">          6 :     return ObjectScope(obj)-&gt;IsAddonScope();</span>
<span class="lineNum">     477 </span>            : }
<a name="478"><span class="lineNum">     478 </span>            : </a>
<span class="lineNum">     479 </span>            : bool
<span class="lineNum">     480 </span><span class="lineNoCov">          0 : IsUniversalXPConnectEnabled(JSCompartment* compartment)</span>
<span class="lineNum">     481 </span>            : {
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     if (!priv)</span>
<span class="lineNum">     484 </span>            :         return false;
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     return priv-&gt;universalXPConnectEnabled;</span>
<span class="lineNum">     486 </span>            : }
<a name="487"><span class="lineNum">     487 </span>            : </a>
<span class="lineNum">     488 </span>            : bool
<span class="lineNum">     489 </span><span class="lineNoCov">          0 : IsUniversalXPConnectEnabled(JSContext* cx)</span>
<span class="lineNum">     490 </span>            : {
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     JSCompartment* compartment = js::GetContextCompartment(cx);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     if (!compartment)</span>
<span class="lineNum">     493 </span>            :         return false;
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     return IsUniversalXPConnectEnabled(compartment);</span>
<span class="lineNum">     495 </span>            : }
<a name="496"><span class="lineNum">     496 </span>            : </a>
<span class="lineNum">     497 </span>            : bool
<span class="lineNum">     498 </span><span class="lineNoCov">          0 : EnableUniversalXPConnect(JSContext* cx)</span>
<span class="lineNum">     499 </span>            : {
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     JSCompartment* compartment = js::GetContextCompartment(cx);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     if (!compartment)</span>
<span class="lineNum">     502 </span>            :         return true;
<span class="lineNum">     503 </span>            :     // Never set universalXPConnectEnabled on a chrome compartment - it confuses
<span class="lineNum">     504 </span>            :     // the security wrapping code.
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     if (AccessCheck::isChrome(compartment))</span>
<span class="lineNum">     506 </span>            :         return true;
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     if (!priv)</span>
<span class="lineNum">     509 </span>            :         return true;
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     if (priv-&gt;universalXPConnectEnabled)</span>
<span class="lineNum">     511 </span>            :         return true;
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     priv-&gt;universalXPConnectEnabled = true;</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     // Recompute all the cross-compartment wrappers leaving the newly-privileged
<span class="lineNum">     515 </span>            :     // compartment.
<span class="lineNum">     516 </span>            :     bool ok = js::RecomputeWrappers(cx, js::SingleCompartment(compartment),
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                                     js::AllCompartments());</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(ok, false);</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :     // The Components object normally isn't defined for unprivileged web content,
<span class="lineNum">     521 </span>            :     // but we define it when UniversalXPConnect is enabled to support legacy
<span class="lineNum">     522 </span>            :     // tests.
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope* scope = priv-&gt;scope;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     if (!scope)</span>
<span class="lineNum">     525 </span>            :         return true;
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     scope-&gt;ForcePrivilegedComponents();</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     return scope-&gt;AttachComponentsObject(cx);</span>
<span class="lineNum">     528 </span>            : }
<a name="529"><span class="lineNum">     529 </span>            : </a>
<span class="lineNum">     530 </span>            : JSObject*
<span class="lineNum">     531 </span><span class="lineCov">        149 : UnprivilegedJunkScope()</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span><span class="lineCov">        298 :     return XPCJSContext::Get()-&gt;UnprivilegedJunkScope();</span>
<span class="lineNum">     534 </span>            : }
<a name="535"><span class="lineNum">     535 </span>            : </a>
<span class="lineNum">     536 </span>            : JSObject*
<span class="lineNum">     537 </span><span class="lineCov">         10 : PrivilegedJunkScope()</span>
<span class="lineNum">     538 </span>            : {
<span class="lineNum">     539 </span><span class="lineCov">         20 :     return XPCJSContext::Get()-&gt;PrivilegedJunkScope();</span>
<span class="lineNum">     540 </span>            : }
<a name="541"><span class="lineNum">     541 </span>            : </a>
<span class="lineNum">     542 </span>            : JSObject*
<span class="lineNum">     543 </span><span class="lineNoCov">          0 : CompilationScope()</span>
<span class="lineNum">     544 </span>            : {
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     return XPCJSContext::Get()-&gt;CompilationScope();</span>
<span class="lineNum">     546 </span>            : }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : nsGlobalWindow*
<span class="lineNum">     549 </span><span class="lineCov">        280 : WindowOrNull(JSObject* aObj)</span>
<span class="lineNum">     550 </span>            : {
<span class="lineNum">     551 </span>            :     MOZ_ASSERT(aObj);
<span class="lineNum">     552 </span>            :     MOZ_ASSERT(!js::IsWrapper(aObj));
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineCov">        280 :     nsGlobalWindow* win = nullptr;</span>
<span class="lineNum">     555 </span>            :     UNWRAP_OBJECT(Window, aObj, win);
<span class="lineNum">     556 </span><span class="lineCov">        280 :     return win;</span>
<span class="lineNum">     557 </span>            : }
<a name="558"><span class="lineNum">     558 </span>            : </a>
<span class="lineNum">     559 </span>            : nsGlobalWindow*
<span class="lineNum">     560 </span><span class="lineCov">        275 : WindowGlobalOrNull(JSObject* aObj)</span>
<span class="lineNum">     561 </span>            : {
<span class="lineNum">     562 </span>            :     MOZ_ASSERT(aObj);
<span class="lineNum">     563 </span><span class="lineCov">        275 :     JSObject* glob = js::GetGlobalForObjectCrossCompartment(aObj);</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineCov">        275 :     return WindowOrNull(glob);</span>
<span class="lineNum">     566 </span>            : }
<a name="567"><span class="lineNum">     567 </span>            : </a>
<span class="lineNum">     568 </span>            : nsGlobalWindow*
<span class="lineNum">     569 </span><span class="lineCov">          6 : AddonWindowOrNull(JSObject* aObj)</span>
<span class="lineNum">     570 </span>            : {
<span class="lineNum">     571 </span><span class="lineCov">          6 :     if (!IsInAddonScope(aObj))</span>
<span class="lineNum">     572 </span>            :         return nullptr;
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     JSObject* global = js::GetGlobalForObjectCrossCompartment(aObj);</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     JSObject* proto = js::GetPrototypeNoProxy(global);</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :     // Addons could theoretically change the prototype of the addon scope, but
<span class="lineNum">     578 </span>            :     // we pretty much just want to crash if that happens so that we find out
<span class="lineNum">     579 </span>            :     // about it and get them to change their code.
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(js::IsCrossCompartmentWrapper(proto) ||</span>
<span class="lineNum">     581 </span>            :                        xpc::IsSandboxPrototypeProxy(proto));
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     JSObject* mainGlobal = js::UncheckedUnwrap(proto, /* stopAtWindowProxy = */ false);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(JS_IsGlobalObject(mainGlobal));</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     return WindowOrNull(mainGlobal);</span>
<span class="lineNum">     586 </span>            : }
<a name="587"><span class="lineNum">     587 </span>            : </a>
<span class="lineNum">     588 </span>            : nsGlobalWindow*
<span class="lineNum">     589 </span><span class="lineCov">          5 : CurrentWindowOrNull(JSContext* cx)</span>
<span class="lineNum">     590 </span>            : {
<span class="lineNum">     591 </span><span class="lineCov">          5 :     JSObject* glob = JS::CurrentGlobalOrNull(cx);</span>
<span class="lineNum">     592 </span><span class="lineCov">          5 :     return glob ? WindowOrNull(glob) : nullptr;</span>
<span class="lineNum">     593 </span>            : }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : // Nukes all wrappers into or out of the given compartment, and prevents new
<span class="lineNum">     596 </span>            : // wrappers from being created. Additionally marks the compartment as
<span class="lineNum">     597 </span>            : // unscriptable after wrappers have been nuked.
<span class="lineNum">     598 </span>            : //
<span class="lineNum">     599 </span>            : // Note: This should *only* be called for browser or extension compartments.
<span class="lineNum">     600 </span>            : // Wrappers between web compartments must never be cut in web-observable
<span class="lineNum">     601 </span>            : // ways.
<span class="lineNum">     602 </span>            : void
<span class="lineNum">     603 </span><span class="lineNoCov">          0 : NukeAllWrappersForCompartment(JSContext* cx, JSCompartment* compartment,</span>
<span class="lineNum">     604 </span>            :                               js::NukeReferencesToWindow nukeReferencesToWindow)
<span class="lineNum">     605 </span>            : {
<span class="lineNum">     606 </span>            :     // First, nuke all wrappers into or out of the target compartment. Once
<span class="lineNum">     607 </span>            :     // the compartment is marked as nuked, WrapperFactory will refuse to
<span class="lineNum">     608 </span>            :     // create new live wrappers for it, in either direction. This means that
<span class="lineNum">     609 </span>            :     // we need to be sure that we don't have any existing cross-compartment
<span class="lineNum">     610 </span>            :     // wrappers which may be replaced with dead wrappers during unrelated
<span class="lineNum">     611 </span>            :     // wrapper recomputation *before* we set that bit.
<span class="lineNum">     612 </span>            :     js::NukeCrossCompartmentWrappers(cx, js::AllCompartments(),
<span class="lineNum">     613 </span>            :                                      js::SingleCompartment(compartment),
<span class="lineNum">     614 </span>            :                                      nukeReferencesToWindow,
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :                                      js::NukeAllReferences);</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :     // At this point, we should cross-compartment wrappers for the nuked
<span class="lineNum">     618 </span>            :     // compartment. Set the wasNuked bit so WrapperFactory will return a
<span class="lineNum">     619 </span>            :     // DeadObjectProxy when asked to create a new wrapper for it, and mark as
<span class="lineNum">     620 </span>            :     // unscriptable.
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     auto compartmentPrivate = xpc::CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     compartmentPrivate-&gt;wasNuked = true;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     compartmentPrivate-&gt;scriptability.Block();</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            : } // namespace xpc
<a name="627"><span class="lineNum">     627 </span>            : </a>
<span class="lineNum">     628 </span>            : static void
<span class="lineNum">     629 </span><span class="lineCov">        845 : CompartmentDestroyedCallback(JSFreeOp* fop, JSCompartment* compartment)</span>
<span class="lineNum">     630 </span>            : {
<span class="lineNum">     631 </span>            :     // NB - This callback may be called in JS_DestroyContext, which happens
<span class="lineNum">     632 </span>            :     // after the XPCJSContext has been torn down.
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :     // Get the current compartment private into an AutoPtr (which will do the
<span class="lineNum">     635 </span>            :     // cleanup for us), and null out the private (which may already be null).
<span class="lineNum">     636 </span><span class="lineCov">        845 :     nsAutoPtr&lt;CompartmentPrivate&gt; priv(CompartmentPrivate::Get(compartment));</span>
<span class="lineNum">     637 </span><span class="lineCov">        845 :     JS_SetCompartmentPrivate(compartment, nullptr);</span>
<span class="lineNum">     638 </span><span class="lineCov">        845 : }</span>
<a name="639"><span class="lineNum">     639 </span>            : </a>
<span class="lineNum">     640 </span>            : static size_t
<span class="lineNum">     641 </span><span class="lineNoCov">          0 : CompartmentSizeOfIncludingThisCallback(MallocSizeOf mallocSizeOf, JSCompartment* compartment)</span>
<span class="lineNum">     642 </span>            : {
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     return priv ? priv-&gt;SizeOfIncludingThis(mallocSizeOf) : 0;</span>
<span class="lineNum">     645 </span>            : }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : /*
<span class="lineNum">     648 </span>            :  * Return true if there exists a non-system inner window which is a current
<span class="lineNum">     649 </span>            :  * inner window and whose reflector is gray.  We don't merge system
<a name="650"><span class="lineNum">     650 </span>            :  * compartments, so we don't use them to trigger merging CCs.</a>
<span class="lineNum">     651 </span>            :  */
<span class="lineNum">     652 </span><span class="lineNoCov">          0 : bool XPCJSContext::UsefulToMergeZones() const</span>
<span class="lineNum">     653 </span>            : {
<span class="lineNum">     654 </span>            :     MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :     // Turns out, actually making this return true often enough makes Windows
<span class="lineNum">     657 </span>            :     // mochitest-gl OOM a lot.  Need to figure out what's going on there; see
<span class="lineNum">     658 </span>            :     // bug 1277036.
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="661"><span class="lineNum">     661 </span>            : }</a>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineCov">        240 : void XPCJSContext::TraceNativeBlackRoots(JSTracer* trc)</span>
<span class="lineNum">     664 </span>            : {
<span class="lineNum">     665 </span><span class="lineCov">        240 :     if (AutoMarkingPtr* roots = Get()-&gt;mAutoRoots)</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :         roots-&gt;TraceJSAll(trc);</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :     // XPCJSObjectHolders don't participate in cycle collection, so always
<span class="lineNum">     669 </span>            :     // trace them here.
<span class="lineNum">     670 </span>            :     XPCRootSetElem* e;
<span class="lineNum">     671 </span><span class="lineCov">        240 :     for (e = mObjectHolderRoots; e; e = e-&gt;GetNextRoot())</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         static_cast&lt;XPCJSObjectHolder*&gt;(e)-&gt;TraceJS(trc);</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :     dom::TraceBlackJS(trc, JS_GetGCParameter(Context(), JSGC_NUMBER),
<span class="lineNum">     675 </span><span class="lineCov">        240 :                       nsXPConnect::XPConnect()-&gt;IsShuttingDown());</span>
<a name="676"><span class="lineNum">     676 </span><span class="lineCov">        240 : }</span></a>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineCov">        240 : void XPCJSContext::TraceAdditionalNativeGrayRoots(JSTracer* trc)</span>
<span class="lineNum">     679 </span>            : {
<span class="lineNum">     680 </span><span class="lineCov">        240 :     XPCWrappedNativeScope::TraceWrappedNativesInAllScopes(trc, this);</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineCov">        240 :     for (XPCRootSetElem* e = mVariantRoots; e ; e = e-&gt;GetNextRoot())</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         static_cast&lt;XPCTraceableVariant*&gt;(e)-&gt;TraceJS(trc);</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">        532 :     for (XPCRootSetElem* e = mWrappedJSRoots; e ; e = e-&gt;GetNextRoot())</span>
<span class="lineNum">     686 </span><span class="lineCov">        292 :         static_cast&lt;nsXPCWrappedJS*&gt;(e)-&gt;TraceJS(trc);</span>
<span class="lineNum">     687 </span><span class="lineCov">        240 : }</span>
<a name="688"><span class="lineNum">     688 </span>            : </a>
<span class="lineNum">     689 </span>            : void
<span class="lineNum">     690 </span><span class="lineNoCov">          0 : XPCJSContext::TraverseAdditionalNativeRoots(nsCycleCollectionNoteRootCallback&amp; cb)</span>
<span class="lineNum">     691 </span>            : {
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope::SuspectAllWrappers(this, cb);</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     for (XPCRootSetElem* e = mVariantRoots; e ; e = e-&gt;GetNextRoot()) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         XPCTraceableVariant* v = static_cast&lt;XPCTraceableVariant*&gt;(e);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         if (nsCCUncollectableMarker::InGeneration(cb,</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                                                   v-&gt;CCGeneration())) {</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :            JS::Value val = v-&gt;GetJSValPreserveColor();</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :            if (val.isObject() &amp;&amp; !JS::ObjectIsMarkedGray(&amp;val.toObject()))</span>
<span class="lineNum">     700 </span>            :                continue;
<span class="lineNum">     701 </span>            :         }
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         cb.NoteXPCOMRoot(v);</span>
<span class="lineNum">     703 </span>            :     }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     for (XPCRootSetElem* e = mWrappedJSRoots; e ; e = e-&gt;GetNextRoot()) {</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         cb.NoteXPCOMRoot(ToSupports(static_cast&lt;nsXPCWrappedJS*&gt;(e)));</span>
<span class="lineNum">     707 </span>            :     }
<span class="lineNum">     708 </span><span class="lineNoCov">          0 : }</span>
<a name="709"><span class="lineNum">     709 </span>            : </a>
<span class="lineNum">     710 </span>            : void
<a name="711"><span class="lineNum">     711 </span><span class="lineNoCov">          0 : XPCJSContext::UnmarkSkippableJSHolders()</span></a>
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     CycleCollectedJSContext::UnmarkSkippableJSHolders();</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 : }</span>
<a name="715"><span class="lineNum">     715 </span>            : </a>
<span class="lineNum">     716 </span>            : void
<span class="lineNum">     717 </span><span class="lineNoCov">          0 : XPCJSContext::PrepareForForgetSkippable()</span>
<span class="lineNum">     718 </span>            : {
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     if (obs) {</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :         obs-&gt;NotifyObservers(nullptr, &quot;cycle-collector-forget-skippable&quot;, nullptr);</span>
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : }</span>
<a name="724"><span class="lineNum">     724 </span>            : </a>
<span class="lineNum">     725 </span>            : void
<span class="lineNum">     726 </span><span class="lineNoCov">          0 : XPCJSContext::BeginCycleCollectionCallback()</span>
<span class="lineNum">     727 </span>            : {
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     nsJSContext::BeginCycleCollectionCallback();</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     if (obs) {</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         obs-&gt;NotifyObservers(nullptr, &quot;cycle-collector-begin&quot;, nullptr);</span>
<span class="lineNum">     733 </span>            :     }
<span class="lineNum">     734 </span><span class="lineNoCov">          0 : }</span>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<span class="lineNum">     736 </span>            : void
<span class="lineNum">     737 </span><span class="lineNoCov">          0 : XPCJSContext::EndCycleCollectionCallback(CycleCollectorResults&amp; aResults)</span>
<span class="lineNum">     738 </span>            : {
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     nsJSContext::EndCycleCollectionCallback(aResults);</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     if (obs) {</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         obs-&gt;NotifyObservers(nullptr, &quot;cycle-collector-end&quot;, nullptr);</span>
<span class="lineNum">     744 </span>            :     }
<span class="lineNum">     745 </span><span class="lineNoCov">          0 : }</span>
<a name="746"><span class="lineNum">     746 </span>            : </a>
<span class="lineNum">     747 </span>            : void
<span class="lineNum">     748 </span><span class="lineNoCov">          0 : XPCJSContext::DispatchDeferredDeletion(bool aContinuation, bool aPurge)</span>
<span class="lineNum">     749 </span>            : {
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     mAsyncSnowWhiteFreer-&gt;Start(aContinuation, aPurge);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : void
<span class="lineNum">     754 </span><span class="lineNoCov">          0 : xpc_UnmarkSkippableJSHolders()</span>
<span class="lineNum">     755 </span>            : {
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     if (nsXPConnect::XPConnect()-&gt;GetContext()) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         nsXPConnect::XPConnect()-&gt;GetContext()-&gt;UnmarkSkippableJSHolders();</span>
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span><span class="lineNoCov">          0 : }</span>
<a name="760"><span class="lineNum">     760 </span>            : </a>
<span class="lineNum">     761 </span>            : /* static */ void
<span class="lineNum">     762 </span><span class="lineCov">        480 : XPCJSContext::GCSliceCallback(JSContext* cx,</span>
<span class="lineNum">     763 </span>            :                               JS::GCProgress progress,
<span class="lineNum">     764 </span>            :                               const JS::GCDescription&amp; desc)
<span class="lineNum">     765 </span>            : {
<span class="lineNum">     766 </span><span class="lineCov">        480 :     XPCJSContext* self = nsXPConnect::GetContextInstance();</span>
<span class="lineNum">     767 </span><span class="lineCov">        480 :     if (!self)</span>
<span class="lineNum">     768 </span><span class="lineCov">        480 :         return;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : #ifdef MOZ_CRASHREPORTER
<span class="lineNum">     771 </span>            :     CrashReporter::SetGarbageCollecting(progress == JS::GC_CYCLE_BEGIN ||
<span class="lineNum">     772 </span>            :                                         progress == JS::GC_SLICE_BEGIN);
<span class="lineNum">     773 </span>            : #endif
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineCov">        480 :     if (self-&gt;mPrevGCSliceCallback)</span>
<span class="lineNum">     776 </span><span class="lineCov">        480 :         (*self-&gt;mPrevGCSliceCallback)(cx, progress, desc);</span>
<span class="lineNum">     777 </span>            : }
<a name="778"><span class="lineNum">     778 </span>            : </a>
<span class="lineNum">     779 </span>            : /* static */ void
<span class="lineNum">     780 </span><span class="lineNoCov">          0 : XPCJSContext::DoCycleCollectionCallback(JSContext* cx)</span>
<span class="lineNum">     781 </span>            : {
<span class="lineNum">     782 </span>            :     // The GC has detected that a CC at this point would collect a tremendous
<a name="783"><span class="lineNum">     783 </span>            :     // amount of garbage that is being revivified unnecessarily.</a>
<span class="lineNum">     784 </span>            :     NS_DispatchToCurrentThread(
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :             NS_NewRunnableFunction([](){nsJSContext::CycleCollectNow(nullptr);}));</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     XPCJSContext* self = nsXPConnect::GetContextInstance();</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     if (!self)</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     if (self-&gt;mPrevDoCycleCollectionCallback)</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         (*self-&gt;mPrevDoCycleCollectionCallback)(cx);</span>
<span class="lineNum">     793 </span>            : }
<a name="794"><span class="lineNum">     794 </span>            : </a>
<span class="lineNum">     795 </span>            : void
<span class="lineNum">     796 </span><span class="lineCov">        480 : XPCJSContext::CustomGCCallback(JSGCStatus status)</span>
<span class="lineNum">     797 </span>            : {
<span class="lineNum">     798 </span><span class="lineCov">        480 :     nsTArray&lt;xpcGCCallback&gt; callbacks(extraGCCallbacks);</span>
<span class="lineNum">     799 </span><span class="lineCov">        960 :     for (uint32_t i = 0; i &lt; callbacks.Length(); ++i)</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         callbacks[i](status);</span>
<span class="lineNum">     801 </span><span class="lineCov">        480 : }</span>
<a name="802"><span class="lineNum">     802 </span>            : </a>
<span class="lineNum">     803 </span>            : /* static */ void
<span class="lineNum">     804 </span><span class="lineCov">        720 : XPCJSContext::FinalizeCallback(JSFreeOp* fop,</span>
<span class="lineNum">     805 </span>            :                                JSFinalizeStatus status,
<span class="lineNum">     806 </span>            :                                bool isZoneGC,
<span class="lineNum">     807 </span>            :                                void* data)
<span class="lineNum">     808 </span>            : {
<span class="lineNum">     809 </span><span class="lineCov">        720 :     XPCJSContext* self = nsXPConnect::GetContextInstance();</span>
<span class="lineNum">     810 </span><span class="lineCov">        720 :     if (!self)</span>
<span class="lineNum">     811 </span><span class="lineCov">        720 :         return;</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineCov">        720 :     switch (status) {</span>
<span class="lineNum">     814 </span>            :         case JSFINALIZE_GROUP_START:
<span class="lineNum">     815 </span>            :         {
<span class="lineNum">     816 </span>            :             MOZ_ASSERT(!self-&gt;mDoingFinalization, &quot;bad state&quot;);
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :             MOZ_ASSERT(!self-&gt;mGCIsRunning, &quot;bad state&quot;);
<span class="lineNum">     819 </span><span class="lineCov">        240 :             self-&gt;mGCIsRunning = true;</span>
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineCov">        240 :             self-&gt;mDoingFinalization = true;</span>
<span class="lineNum">     822 </span><span class="lineCov">        240 :             break;</span>
<span class="lineNum">     823 </span>            :         }
<span class="lineNum">     824 </span>            :         case JSFINALIZE_GROUP_END:
<span class="lineNum">     825 </span>            :         {
<span class="lineNum">     826 </span>            :             MOZ_ASSERT(self-&gt;mDoingFinalization, &quot;bad state&quot;);
<span class="lineNum">     827 </span><span class="lineCov">        240 :             self-&gt;mDoingFinalization = false;</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :             // Sweep scopes needing cleanup
<span class="lineNum">     830 </span><span class="lineCov">        240 :             XPCWrappedNativeScope::KillDyingScopes();</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :             MOZ_ASSERT(self-&gt;mGCIsRunning, &quot;bad state&quot;);
<span class="lineNum">     833 </span><span class="lineCov">        240 :             self-&gt;mGCIsRunning = false;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">        240 :             break;</span>
<span class="lineNum">     836 </span>            :         }
<span class="lineNum">     837 </span>            :         case JSFINALIZE_COLLECTION_END:
<span class="lineNum">     838 </span>            :         {
<span class="lineNum">     839 </span>            :             MOZ_ASSERT(!self-&gt;mGCIsRunning, &quot;bad state&quot;);
<span class="lineNum">     840 </span><span class="lineCov">        240 :             self-&gt;mGCIsRunning = true;</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineCov">        240 :             if (AutoMarkingPtr* roots = Get()-&gt;mAutoRoots)</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                 roots-&gt;MarkAfterJSFinalizeAll();</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :             // Now we are going to recycle any unused WrappedNativeTearoffs.
<span class="lineNum">     846 </span>            :             // We do this by iterating all the live callcontexts
<span class="lineNum">     847 </span>            :             // and marking the tearoffs in use. And then we
<span class="lineNum">     848 </span>            :             // iterate over all the WrappedNative wrappers and sweep their
<span class="lineNum">     849 </span>            :             // tearoffs.
<span class="lineNum">     850 </span>            :             //
<span class="lineNum">     851 </span>            :             // This allows us to perhaps minimize the growth of the
<span class="lineNum">     852 </span>            :             // tearoffs. And also makes us not hold references to interfaces
<span class="lineNum">     853 </span>            :             // on our wrapped natives that we are not actually using.
<span class="lineNum">     854 </span>            :             //
<span class="lineNum">     855 </span>            :             // XXX We may decide to not do this on *every* gc cycle.
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineCov">        240 :             XPCCallContext* ccxp = XPCJSContext::Get()-&gt;GetCallContext();</span>
<span class="lineNum">     858 </span><span class="lineCov">        480 :             while (ccxp) {</span>
<span class="lineNum">     859 </span>            :                 // Deal with the strictness of callcontext that
<span class="lineNum">     860 </span>            :                 // complains if you ask for a tearoff when
<span class="lineNum">     861 </span>            :                 // it is in a state where the tearoff could not
<span class="lineNum">     862 </span>            :                 // possibly be valid.
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                 if (ccxp-&gt;CanGetTearOff()) {</span>
<span class="lineNum">     864 </span>            :                     XPCWrappedNativeTearOff* to =
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :                         ccxp-&gt;GetTearOff();</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                     if (to)</span>
<span class="lineNum">     867 </span>            :                         to-&gt;Mark();
<span class="lineNum">     868 </span>            :                 }
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :                 ccxp = ccxp-&gt;GetPrevCallContext();</span>
<span class="lineNum">     870 </span>            :             }
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineCov">        240 :             XPCWrappedNativeScope::SweepAllWrappedNativeTearOffs();</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :             // Now we need to kill the 'Dying' XPCWrappedNativeProtos.
<span class="lineNum">     875 </span>            :             // We transfered these native objects to this table when their
<span class="lineNum">     876 </span>            :             // JSObject's were finalized. We did not destroy them immediately
<span class="lineNum">     877 </span>            :             // at that point because the ordering of JS finalization is not
<span class="lineNum">     878 </span>            :             // deterministic and we did not yet know if any wrappers that
<span class="lineNum">     879 </span>            :             // might still be referencing the protos where still yet to be
<span class="lineNum">     880 </span>            :             // finalized and destroyed. We *do* know that the protos'
<span class="lineNum">     881 </span>            :             // JSObjects would not have been finalized if there were any
<span class="lineNum">     882 </span>            :             // wrappers that referenced the proto but where not themselves
<span class="lineNum">     883 </span>            :             // slated for finalization in this gc cycle. So... at this point
<span class="lineNum">     884 </span>            :             // we know that any and all wrappers that might have been
<span class="lineNum">     885 </span>            :             // referencing the protos in the dying list are themselves dead.
<span class="lineNum">     886 </span>            :             // So, we can safely delete all the protos in the list.
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineCov">       3500 :             for (auto i = self-&gt;mDyingWrappedNativeProtoMap-&gt;Iter(); !i.Done(); i.Next()) {</span>
<span class="lineNum">     889 </span><span class="lineCov">       6520 :                 auto entry = static_cast&lt;XPCWrappedNativeProtoMap::Entry*&gt;(i.Get());</span>
<span class="lineNum">     890 </span><span class="lineCov">       3260 :                 delete static_cast&lt;const XPCWrappedNativeProto*&gt;(entry-&gt;key);</span>
<span class="lineNum">     891 </span><span class="lineCov">       3260 :                 i.Remove();</span>
<span class="lineNum">     892 </span><span class="lineCov">        240 :             }</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :             MOZ_ASSERT(self-&gt;mGCIsRunning, &quot;bad state&quot;);
<span class="lineNum">     895 </span><span class="lineCov">        240 :             self-&gt;mGCIsRunning = false;</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineCov">        240 :             break;</span>
<span class="lineNum">     898 </span>            :         }
<span class="lineNum">     899 </span>            :     }
<span class="lineNum">     900 </span>            : }
<a name="901"><span class="lineNum">     901 </span>            : </a>
<span class="lineNum">     902 </span>            : /* static */ void
<span class="lineNum">     903 </span><span class="lineCov">        240 : XPCJSContext::WeakPointerZonesCallback(JSContext* cx, void* data)</span>
<span class="lineNum">     904 </span>            : {
<span class="lineNum">     905 </span>            :     // Called before each sweeping slice -- after processing any final marking
<span class="lineNum">     906 </span>            :     // triggered by barriers -- to clear out any references to things that are
<span class="lineNum">     907 </span>            :     // about to be finalized and update any pointers to moved GC things.
<span class="lineNum">     908 </span><span class="lineCov">        240 :     XPCJSContext* self = static_cast&lt;XPCJSContext*&gt;(data);</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineCov">        240 :     self-&gt;mWrappedJSMap-&gt;UpdateWeakPointersAfterGC(self);</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span><span class="lineCov">        240 :     XPCWrappedNativeScope::UpdateWeakPointersAfterGC(self);</span>
<span class="lineNum">     913 </span><span class="lineCov">        240 : }</span>
<a name="914"><span class="lineNum">     914 </span>            : </a>
<span class="lineNum">     915 </span>            : /* static */ void
<span class="lineNum">     916 </span><span class="lineCov">       3072 : XPCJSContext::WeakPointerCompartmentCallback(JSContext* cx, JSCompartment* comp, void* data)</span>
<span class="lineNum">     917 </span>            : {
<span class="lineNum">     918 </span>            :     // Called immediately after the ZoneGroup weak pointer callback, but only
<span class="lineNum">     919 </span>            :     // once for each compartment that is being swept.
<span class="lineNum">     920 </span><span class="lineCov">       3072 :     XPCJSContext* self = static_cast&lt;XPCJSContext*&gt;(data);</span>
<span class="lineNum">     921 </span><span class="lineCov">       3072 :     CompartmentPrivate* xpcComp = CompartmentPrivate::Get(comp);</span>
<span class="lineNum">     922 </span><span class="lineCov">       3072 :     if (xpcComp)</span>
<span class="lineNum">     923 </span><span class="lineCov">       2592 :         xpcComp-&gt;UpdateWeakPointersAfterGC(self);</span>
<span class="lineNum">     924 </span><span class="lineCov">       3072 : }</span>
<a name="925"><span class="lineNum">     925 </span>            : </a>
<span class="lineNum">     926 </span>            : void
<span class="lineNum">     927 </span><span class="lineCov">       2592 : CompartmentPrivate::UpdateWeakPointersAfterGC(XPCJSContext* context)</span>
<span class="lineNum">     928 </span>            : {
<span class="lineNum">     929 </span><span class="lineCov">       2592 :     mWrappedJSMap-&gt;UpdateWeakPointersAfterGC(context);</span>
<span class="lineNum">     930 </span><span class="lineCov">       2592 : }</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            : static void WatchdogMain(void* arg);
<span class="lineNum">     933 </span>            : class Watchdog;
<span class="lineNum">     934 </span>            : class WatchdogManager;
<span class="lineNum">     935 </span>            : class AutoLockWatchdog {
<span class="lineNum">     936 </span>            :     Watchdog* const mWatchdog;
<span class="lineNum">     937 </span>            :   public:
<span class="lineNum">     938 </span>            :     explicit AutoLockWatchdog(Watchdog* aWatchdog);
<span class="lineNum">     939 </span>            :     ~AutoLockWatchdog();
<span class="lineNum">     940 </span>            : };
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            : class Watchdog
<a name="943"><span class="lineNum">     943 </span>            : {</a>
<span class="lineNum">     944 </span>            :   public:
<span class="lineNum">     945 </span><span class="lineCov">         60 :     explicit Watchdog(WatchdogManager* aManager)</span>
<span class="lineNum">     946 </span>            :       : mManager(aManager)
<span class="lineNum">     947 </span>            :       , mLock(nullptr)
<span class="lineNum">     948 </span>            :       , mWakeup(nullptr)
<span class="lineNum">     949 </span>            :       , mThread(nullptr)
<span class="lineNum">     950 </span>            :       , mHibernating(false)
<span class="lineNum">     951 </span>            :       , mInitialized(false)
<span class="lineNum">     952 </span>            :       , mShuttingDown(false)
<span class="lineNum">     953 </span><span class="lineCov">         60 :       , mMinScriptRunTimeSeconds(1)</span>
<span class="lineNum">     954 </span><span class="lineCov">         60 :     {}</span>
<span class="lineNum">     955 </span><span class="lineCov">         60 :     ~Watchdog() { MOZ_ASSERT(!Initialized()); }</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     WatchdogManager* Manager() { return mManager; }
<span class="lineNum">     958 </span>            :     bool Initialized() { return mInitialized; }
<span class="lineNum">     959 </span>            :     bool ShuttingDown() { return mShuttingDown; }
<a name="960"><span class="lineNum">     960 </span>            :     PRLock* GetLock() { return mLock; }</a>
<span class="lineNum">     961 </span>            :     bool Hibernating() { return mHibernating; }
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     void WakeUp()</span>
<span class="lineNum">     963 </span>            :     {
<span class="lineNum">     964 </span>            :         MOZ_ASSERT(Initialized());
<span class="lineNum">     965 </span>            :         MOZ_ASSERT(Hibernating());
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         mHibernating = false;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         PR_NotifyCondVar(mWakeup);</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :     //
<span class="lineNum">     971 </span>            :     // Invoked by the main thread only.
<a name="972"><span class="lineNum">     972 </span>            :     //</a>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineCov">         60 :     void Init()</span>
<span class="lineNum">     975 </span>            :     {
<span class="lineNum">     976 </span>            :         MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     977 </span><span class="lineCov">         60 :         mLock = PR_NewLock();</span>
<span class="lineNum">     978 </span><span class="lineCov">         60 :         if (!mLock)</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :             NS_RUNTIMEABORT(&quot;PR_NewLock failed.&quot;);</span>
<span class="lineNum">     980 </span><span class="lineCov">         60 :         mWakeup = PR_NewCondVar(mLock);</span>
<span class="lineNum">     981 </span><span class="lineCov">         60 :         if (!mWakeup)</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :             NS_RUNTIMEABORT(&quot;PR_NewCondVar failed.&quot;);</span>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :         {
<span class="lineNum">     985 </span>            :             AutoLockWatchdog lock(this);
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            :             // Gecko uses thread private for accounting and has to clean up at thread exit.
<span class="lineNum">     988 </span>            :             // Therefore, even though we don't have a return value from the watchdog, we need to
<span class="lineNum">     989 </span>            :             // join it on shutdown.
<span class="lineNum">     990 </span>            :             mThread = PR_CreateThread(PR_USER_THREAD, WatchdogMain, this,
<span class="lineNum">     991 </span>            :                                       PR_PRIORITY_NORMAL, PR_GLOBAL_THREAD,
<span class="lineNum">     992 </span><span class="lineCov">         60 :                                       PR_JOINABLE_THREAD, 0);</span>
<span class="lineNum">     993 </span><span class="lineCov">         60 :             if (!mThread)</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :                 NS_RUNTIMEABORT(&quot;PR_CreateThread failed!&quot;);</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :             // WatchdogMain acquires the lock and then asserts mInitialized. So
<span class="lineNum">     997 </span>            :             // make sure to set mInitialized before releasing the lock here so
<span class="lineNum">     998 </span>            :             // that it's atomic with the creation of the thread.
<span class="lineNum">     999 </span><span class="lineCov">         60 :             mInitialized = true;</span>
<span class="lineNum">    1000 </span>            :         }
<a name="1001"><span class="lineNum">    1001 </span><span class="lineCov">         60 :     }</span></a>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">         60 :     void Shutdown()</span>
<span class="lineNum">    1004 </span>            :     {
<span class="lineNum">    1005 </span>            :         MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">    1006 </span>            :         MOZ_ASSERT(Initialized());
<span class="lineNum">    1007 </span>            :         {   // Scoped lock.
<span class="lineNum">    1008 </span>            :             AutoLockWatchdog lock(this);
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :             // Signal to the watchdog thread that it's time to shut down.
<span class="lineNum">    1011 </span><span class="lineCov">         60 :             mShuttingDown = true;</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :             // Wake up the watchdog, and wait for it to call us back.
<span class="lineNum">    1014 </span><span class="lineCov">         60 :             PR_NotifyCondVar(mWakeup);</span>
<span class="lineNum">    1015 </span>            :         }
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineCov">         60 :         PR_JoinThread(mThread);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :         // The thread sets mShuttingDown to false as it exits.
<span class="lineNum">    1020 </span>            :         MOZ_ASSERT(!mShuttingDown);
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span>            :         // Destroy state.
<span class="lineNum">    1023 </span><span class="lineCov">         60 :         mThread = nullptr;</span>
<span class="lineNum">    1024 </span><span class="lineCov">         60 :         PR_DestroyCondVar(mWakeup);</span>
<span class="lineNum">    1025 </span><span class="lineCov">         60 :         mWakeup = nullptr;</span>
<span class="lineNum">    1026 </span><span class="lineCov">         60 :         PR_DestroyLock(mLock);</span>
<span class="lineNum">    1027 </span><span class="lineCov">         60 :         mLock = nullptr;</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            :         // All done.
<span class="lineNum">    1030 </span><span class="lineCov">         60 :         mInitialized = false;</span>
<span class="lineNum">    1031 </span><span class="lineCov">         60 :     }</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :     void SetMinScriptRunTimeSeconds(int32_t seconds)
<span class="lineNum">    1034 </span>            :     {
<span class="lineNum">    1035 </span>            :         // This variable is atomic, and is set from the main thread without
<a name="1036"><span class="lineNum">    1036 </span>            :         // locking.</a>
<span class="lineNum">    1037 </span>            :         MOZ_ASSERT(seconds &gt; 0);
<span class="lineNum">    1038 </span><span class="lineCov">         60 :         mMinScriptRunTimeSeconds = seconds;</span>
<span class="lineNum">    1039 </span>            :     }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :     //
<span class="lineNum">    1042 </span>            :     // Invoked by the watchdog thread only.
<a name="1043"><span class="lineNum">    1043 </span>            :     //</a>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     void Hibernate()</span>
<span class="lineNum">    1046 </span>            :     {
<span class="lineNum">    1047 </span>            :         MOZ_ASSERT(!NS_IsMainThread());
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         mHibernating = true;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         Sleep(PR_INTERVAL_NO_TIMEOUT);</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1051 </span>            :     void Sleep(PRIntervalTime timeout)
<a name="1052"><span class="lineNum">    1052 </span>            :     {</a>
<span class="lineNum">    1053 </span>            :         MOZ_ASSERT(!NS_IsMainThread());
<span class="lineNum">    1054 </span><span class="lineCov">         60 :         MOZ_ALWAYS_TRUE(PR_WaitCondVar(mWakeup, timeout) == PR_SUCCESS);</span>
<span class="lineNum">    1055 </span>            :     }
<span class="lineNum">    1056 </span>            :     void Finished()
<span class="lineNum">    1057 </span>            :     {
<span class="lineNum">    1058 </span>            :         MOZ_ASSERT(!NS_IsMainThread());
<span class="lineNum">    1059 </span><span class="lineCov">         60 :         mShuttingDown = false;</span>
<span class="lineNum">    1060 </span>            :     }
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            :     int32_t MinScriptRunTimeSeconds()
<span class="lineNum">    1063 </span>            :     {
<span class="lineNum">    1064 </span><span class="lineCov">         60 :         return mMinScriptRunTimeSeconds;</span>
<span class="lineNum">    1065 </span>            :     }
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :   private:
<span class="lineNum">    1068 </span>            :     WatchdogManager* mManager;
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            :     PRLock* mLock;
<span class="lineNum">    1071 </span>            :     PRCondVar* mWakeup;
<span class="lineNum">    1072 </span>            :     PRThread* mThread;
<span class="lineNum">    1073 </span>            :     bool mHibernating;
<span class="lineNum">    1074 </span>            :     bool mInitialized;
<span class="lineNum">    1075 </span>            :     bool mShuttingDown;
<span class="lineNum">    1076 </span>            :     mozilla::Atomic&lt;int32_t&gt; mMinScriptRunTimeSeconds;
<span class="lineNum">    1077 </span>            : };
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : #define PREF_MAX_SCRIPT_RUN_TIME_CONTENT &quot;dom.max_script_run_time&quot;
<span class="lineNum">    1080 </span>            : #define PREF_MAX_SCRIPT_RUN_TIME_CHROME &quot;dom.max_chrome_script_run_time&quot;
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            : class WatchdogManager : public nsIObserver
<span class="lineNum">    1083 </span>            : {
<span class="lineNum">    1084 </span>            :   public:
<a name="1085"><span class="lineNum">    1085 </span>            : </a>
<span class="lineNum">    1086 </span>            :     NS_DECL_ISUPPORTS
<span class="lineNum">    1087 </span><span class="lineCov">         60 :     explicit WatchdogManager(XPCJSContext* aContext) : mContext(aContext)</span>
<span class="lineNum">    1088 </span><span class="lineCov">        240 :                                                      , mContextState(CONTEXT_INACTIVE)</span>
<span class="lineNum">    1089 </span>            :     {
<span class="lineNum">    1090 </span>            :         // All the timestamps start at zero except for context state change.
<span class="lineNum">    1091 </span><span class="lineCov">         60 :         PodArrayZero(mTimestamps);</span>
<span class="lineNum">    1092 </span><span class="lineCov">         60 :         mTimestamps[TimestampContextStateChange] = PR_Now();</span>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            :         // Enable the watchdog, if appropriate.
<span class="lineNum">    1095 </span><span class="lineCov">         60 :         RefreshWatchdog();</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            :         // Register ourselves as an observer to get updates on the pref.
<span class="lineNum">    1098 </span><span class="lineCov">         60 :         mozilla::Preferences::AddStrongObserver(this, &quot;dom.use_watchdog&quot;);</span>
<span class="lineNum">    1099 </span><span class="lineCov">         60 :         mozilla::Preferences::AddStrongObserver(this, PREF_MAX_SCRIPT_RUN_TIME_CONTENT);</span>
<span class="lineNum">    1100 </span><span class="lineCov">         60 :         mozilla::Preferences::AddStrongObserver(this, PREF_MAX_SCRIPT_RUN_TIME_CHROME);</span>
<span class="lineNum">    1101 </span><span class="lineCov">         60 :     }</span>
<span class="lineNum">    1102 </span>            : 
<a name="1103"><span class="lineNum">    1103 </span>            :   protected:</a>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineCov">        120 :     virtual ~WatchdogManager()</span>
<span class="lineNum">    1106 </span><span class="lineCov">        120 :     {</span>
<span class="lineNum">    1107 </span>            :         // Shutting down the watchdog requires context-switching to the watchdog
<span class="lineNum">    1108 </span>            :         // thread, which isn't great to do in a destructor. So we require
<span class="lineNum">    1109 </span>            :         // consumers to shut it down manually before releasing it.
<span class="lineNum">    1110 </span>            :         MOZ_ASSERT(!mWatchdog);
<span class="lineNum">    1111 </span><span class="lineCov">         60 :         mozilla::Preferences::RemoveObserver(this, &quot;dom.use_watchdog&quot;);</span>
<span class="lineNum">    1112 </span><span class="lineCov">         60 :         mozilla::Preferences::RemoveObserver(this, PREF_MAX_SCRIPT_RUN_TIME_CONTENT);</span>
<span class="lineNum">    1113 </span><span class="lineCov">         60 :         mozilla::Preferences::RemoveObserver(this, PREF_MAX_SCRIPT_RUN_TIME_CHROME);</span>
<span class="lineNum">    1114 </span><span class="lineCov">        180 :     }</span>
<span class="lineNum">    1115 </span>            : 
<a name="1116"><span class="lineNum">    1116 </span>            :   public:</a>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     NS_IMETHOD Observe(nsISupports* aSubject, const char* aTopic,</span>
<span class="lineNum">    1119 </span>            :                        const char16_t* aData) override
<span class="lineNum">    1120 </span>            :     {
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         RefreshWatchdog();</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    1123 </span>            :     }
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            :     // Context statistics. These live on the watchdog manager, are written
<span class="lineNum">    1126 </span>            :     // from the main thread, and are read from the watchdog thread (holding
<a name="1127"><span class="lineNum">    1127 </span>            :     // the lock in each case).</a>
<span class="lineNum">    1128 </span>            :     void
<span class="lineNum">    1129 </span><span class="lineCov">       1870 :     RecordContextActivity(bool active)</span>
<span class="lineNum">    1130 </span>            :     {
<span class="lineNum">    1131 </span>            :         // The watchdog reads this state, so acquire the lock before writing it.
<span class="lineNum">    1132 </span>            :         MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">    1133 </span>            :         Maybe&lt;AutoLockWatchdog&gt; lock;
<span class="lineNum">    1134 </span><span class="lineCov">       3740 :         if (mWatchdog)</span>
<span class="lineNum">    1135 </span><span class="lineCov">       1870 :             lock.emplace(mWatchdog);</span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :         // Write state.
<span class="lineNum">    1138 </span><span class="lineCov">       1870 :         mTimestamps[TimestampContextStateChange] = PR_Now();</span>
<span class="lineNum">    1139 </span><span class="lineCov">       1870 :         mContextState = active ? CONTEXT_ACTIVE : CONTEXT_INACTIVE;</span>
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            :         // The watchdog may be hibernating, waiting for the context to go
<span class="lineNum">    1142 </span>            :         // active. Wake it up if necessary.
<span class="lineNum">    1143 </span><span class="lineCov">       2805 :         if (active &amp;&amp; mWatchdog &amp;&amp; mWatchdog-&gt;Hibernating())</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :             mWatchdog-&gt;WakeUp();</span>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineCov">       1870 :     }</span></a>
<span class="lineNum">    1146 </span>            :     bool IsContextActive() { return mContextState == CONTEXT_ACTIVE; }
<span class="lineNum">    1147 </span><span class="lineCov">         60 :     PRTime TimeSinceLastContextStateChange()</span>
<span class="lineNum">    1148 </span>            :     {
<span class="lineNum">    1149 </span><span class="lineCov">         60 :         return PR_Now() - GetTimestamp(TimestampContextStateChange);</span>
<span class="lineNum">    1150 </span>            :     }
<span class="lineNum">    1151 </span>            : 
<a name="1152"><span class="lineNum">    1152 </span>            :     // Note - Because of the context activity timestamp, these are read and</a>
<span class="lineNum">    1153 </span>            :     // written from both threads.
<span class="lineNum">    1154 </span><span class="lineCov">         60 :     void RecordTimestamp(WatchdogTimestampCategory aCategory)</span>
<span class="lineNum">    1155 </span>            :     {
<span class="lineNum">    1156 </span>            :         // The watchdog thread always holds the lock when it runs.
<span class="lineNum">    1157 </span>            :         Maybe&lt;AutoLockWatchdog&gt; maybeLock;
<span class="lineNum">    1158 </span><span class="lineCov">         60 :         if (NS_IsMainThread() &amp;&amp; mWatchdog)</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :             maybeLock.emplace(mWatchdog);</span>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineCov">         60 :         mTimestamps[aCategory] = PR_Now();</span></a>
<span class="lineNum">    1161 </span><span class="lineCov">         60 :     }</span>
<span class="lineNum">    1162 </span><span class="lineCov">         60 :     PRTime GetTimestamp(WatchdogTimestampCategory aCategory)</span>
<span class="lineNum">    1163 </span>            :     {
<span class="lineNum">    1164 </span>            :         // The watchdog thread always holds the lock when it runs.
<span class="lineNum">    1165 </span>            :         Maybe&lt;AutoLockWatchdog&gt; maybeLock;
<span class="lineNum">    1166 </span><span class="lineCov">         60 :         if (NS_IsMainThread() &amp;&amp; mWatchdog)</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             maybeLock.emplace(mWatchdog);</span>
<span class="lineNum">    1168 </span><span class="lineCov">        120 :         return mTimestamps[aCategory];</span>
<span class="lineNum">    1169 </span>            :     }
<a name="1170"><span class="lineNum">    1170 </span>            : </a>
<span class="lineNum">    1171 </span>            :     XPCJSContext* Context() { return mContext; }
<span class="lineNum">    1172 </span><span class="lineCov">         60 :     Watchdog* GetWatchdog() { return mWatchdog; }</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineCov">         60 :     void RefreshWatchdog()</span>
<span class="lineNum">    1175 </span>            :     {
<span class="lineNum">    1176 </span><span class="lineCov">         60 :         bool wantWatchdog = Preferences::GetBool(&quot;dom.use_watchdog&quot;, true);</span>
<span class="lineNum">    1177 </span><span class="lineCov">        120 :         if (wantWatchdog != !!mWatchdog) {</span>
<span class="lineNum">    1178 </span><span class="lineCov">         60 :             if (wantWatchdog)</span>
<span class="lineNum">    1179 </span><span class="lineCov">         60 :                 StartWatchdog();</span>
<span class="lineNum">    1180 </span>            :             else
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                 StopWatchdog();</span>
<span class="lineNum">    1182 </span>            :         }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">        120 :         if (mWatchdog) {</span>
<span class="lineNum">    1185 </span><span class="lineCov">         60 :             int32_t contentTime = Preferences::GetInt(PREF_MAX_SCRIPT_RUN_TIME_CONTENT, 10);</span>
<span class="lineNum">    1186 </span><span class="lineCov">         60 :             if (contentTime &lt;= 0)</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                 contentTime = INT32_MAX;</span>
<span class="lineNum">    1188 </span><span class="lineCov">         60 :             int32_t chromeTime = Preferences::GetInt(PREF_MAX_SCRIPT_RUN_TIME_CHROME, 20);</span>
<span class="lineNum">    1189 </span><span class="lineCov">         60 :             if (chromeTime &lt;= 0)</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :                 chromeTime = INT32_MAX;</span>
<span class="lineNum">    1191 </span><span class="lineCov">        120 :             mWatchdog-&gt;SetMinScriptRunTimeSeconds(std::min(contentTime, chromeTime));</span>
<span class="lineNum">    1192 </span>            :         }
<a name="1193"><span class="lineNum">    1193 </span><span class="lineCov">         60 :     }</span></a>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineCov">         60 :     void StartWatchdog()</span>
<span class="lineNum">    1196 </span>            :     {
<span class="lineNum">    1197 </span>            :         MOZ_ASSERT(!mWatchdog);
<span class="lineNum">    1198 </span><span class="lineCov">         60 :         mWatchdog = new Watchdog(this);</span>
<span class="lineNum">    1199 </span><span class="lineCov">        120 :         mWatchdog-&gt;Init();</span>
<a name="1200"><span class="lineNum">    1200 </span><span class="lineCov">         60 :     }</span></a>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineCov">         60 :     void StopWatchdog()</span>
<span class="lineNum">    1203 </span>            :     {
<span class="lineNum">    1204 </span>            :         MOZ_ASSERT(mWatchdog);
<span class="lineNum">    1205 </span><span class="lineCov">        120 :         mWatchdog-&gt;Shutdown();</span>
<span class="lineNum">    1206 </span><span class="lineCov">         60 :         mWatchdog = nullptr;</span>
<span class="lineNum">    1207 </span><span class="lineCov">         60 :     }</span>
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            :   private:
<span class="lineNum">    1210 </span>            :     XPCJSContext* mContext;
<span class="lineNum">    1211 </span>            :     nsAutoPtr&lt;Watchdog&gt; mWatchdog;
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            :     enum { CONTEXT_ACTIVE, CONTEXT_INACTIVE } mContextState;
<span class="lineNum">    1214 </span>            :     PRTime mTimestamps[TimestampCount];
<a name="1215"><span class="lineNum">    1215 </span>            : };</a>
<span class="lineNum">    1216 </span>            : 
<a name="1217"><span class="lineNum">    1217 </span><span class="lineCov">       2640 : NS_IMPL_ISUPPORTS(WatchdogManager, nsIObserver)</span></a>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span><span class="lineCov">       2050 : AutoLockWatchdog::AutoLockWatchdog(Watchdog* aWatchdog) : mWatchdog(aWatchdog)</span>
<span class="lineNum">    1220 </span>            : {
<span class="lineNum">    1221 </span><span class="lineCov">       2050 :     PR_Lock(mWatchdog-&gt;GetLock());</span>
<a name="1222"><span class="lineNum">    1222 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span><span class="lineCov">       2050 : AutoLockWatchdog::~AutoLockWatchdog()</span>
<span class="lineNum">    1225 </span>            : {
<span class="lineNum">    1226 </span><span class="lineCov">       2050 :     PR_Unlock(mWatchdog-&gt;GetLock());</span>
<span class="lineNum">    1227 </span><span class="lineCov">       2050 : }</span>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            : static void
<span class="lineNum">    1230 </span><span class="lineCov">         60 : WatchdogMain(void* arg)</span>
<span class="lineNum">    1231 </span>            : {
<span class="lineNum">    1232 </span>            :     mozilla::AutoProfilerRegister registerThread(&quot;JS Watchdog&quot;);
<span class="lineNum">    1233 </span><span class="lineCov">         60 :     PR_SetCurrentThreadName(&quot;JS Watchdog&quot;);</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineCov">         60 :     Watchdog* self = static_cast&lt;Watchdog*&gt;(arg);</span>
<span class="lineNum">    1236 </span><span class="lineCov">         60 :     WatchdogManager* manager = self-&gt;Manager();</span>
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            :     // Lock lasts until we return
<span class="lineNum">    1239 </span><span class="lineCov">         60 :     AutoLockWatchdog lock(self);</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :     MOZ_ASSERT(self-&gt;Initialized());
<span class="lineNum">    1242 </span>            :     MOZ_ASSERT(!self-&gt;ShuttingDown());
<span class="lineNum">    1243 </span><span class="lineCov">        120 :     while (!self-&gt;ShuttingDown()) {</span>
<span class="lineNum">    1244 </span>            :         // Sleep only 1 second if recently (or currently) active; otherwise, hibernate
<span class="lineNum">    1245 </span><span class="lineCov">        120 :         if (manager-&gt;IsContextActive() ||</span>
<span class="lineNum">    1246 </span><span class="lineCov">         60 :             manager-&gt;TimeSinceLastContextStateChange() &lt;= PRTime(2*PR_USEC_PER_SEC))</span>
<span class="lineNum">    1247 </span>            :         {
<span class="lineNum">    1248 </span><span class="lineCov">         60 :             self-&gt;Sleep(PR_TicksPerSecond());</span>
<span class="lineNum">    1249 </span>            :         } else {
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :             manager-&gt;RecordTimestamp(TimestampWatchdogHibernateStart);</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :             self-&gt;Hibernate();</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :             manager-&gt;RecordTimestamp(TimestampWatchdogHibernateStop);</span>
<span class="lineNum">    1253 </span>            :         }
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            :         // Rise and shine.
<span class="lineNum">    1256 </span><span class="lineCov">         60 :         manager-&gt;RecordTimestamp(TimestampWatchdogWakeup);</span>
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span>            :         // Don't request an interrupt callback unless the current script has
<span class="lineNum">    1259 </span>            :         // been running long enough that we might show the slow script dialog.
<span class="lineNum">    1260 </span>            :         // Triggering the callback from off the main thread can be expensive.
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :         // We want to avoid showing the slow script dialog if the user's laptop
<span class="lineNum">    1263 </span>            :         // goes to sleep in the middle of running a script. To ensure this, we
<span class="lineNum">    1264 </span>            :         // invoke the interrupt callback after only half the timeout has
<span class="lineNum">    1265 </span>            :         // elapsed. The callback simply records the fact that it was called in
<span class="lineNum">    1266 </span>            :         // the mSlowScriptSecondHalf flag. Then we wait another (timeout/2)
<span class="lineNum">    1267 </span>            :         // seconds and invoke the callback again. This time around it sees
<span class="lineNum">    1268 </span>            :         // mSlowScriptSecondHalf is set and so it shows the slow script
<span class="lineNum">    1269 </span>            :         // dialog. If the computer is put to sleep during one of the (timeout/2)
<span class="lineNum">    1270 </span>            :         // periods, the script still has the other (timeout/2) seconds to
<span class="lineNum">    1271 </span>            :         // finish.
<span class="lineNum">    1272 </span><span class="lineCov">         60 :         PRTime usecs = self-&gt;MinScriptRunTimeSeconds() * PR_USEC_PER_SEC / 2;</span>
<span class="lineNum">    1273 </span><span class="lineCov">         60 :         if (manager-&gt;IsContextActive() &amp;&amp;</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :             manager-&gt;TimeSinceLastContextStateChange() &gt;= usecs)</span>
<span class="lineNum">    1275 </span>            :         {
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :             bool debuggerAttached = false;</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :             nsCOMPtr&lt;nsIDebug2&gt; dbg = do_GetService(&quot;@mozilla.org/xpcom/debug;1&quot;);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :             if (dbg)</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :                 dbg-&gt;GetIsDebuggerAttached(&amp;debuggerAttached);</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :             if (!debuggerAttached)</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                 JS_RequestInterruptCallback(manager-&gt;Context()-&gt;Context());</span>
<span class="lineNum">    1282 </span>            :         }
<span class="lineNum">    1283 </span>            :     }
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            :     // Tell the manager that we've shut down.
<span class="lineNum">    1286 </span><span class="lineCov">         60 :     self-&gt;Finished();</span>
<span class="lineNum">    1287 </span><span class="lineCov">         60 : }</span>
<a name="1288"><span class="lineNum">    1288 </span>            : </a>
<span class="lineNum">    1289 </span>            : PRTime
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 : XPCJSContext::GetWatchdogTimestamp(WatchdogTimestampCategory aCategory)</span>
<span class="lineNum">    1291 </span>            : {
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     return mWatchdogManager-&gt;GetTimestamp(aCategory);</span>
<span class="lineNum">    1293 </span>            : }
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<span class="lineNum">    1295 </span>            : void
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 : xpc::SimulateActivityCallback(bool aActive)</span>
<span class="lineNum">    1297 </span>            : {
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     XPCJSContext::ActivityCallback(XPCJSContext::Get(), aActive);</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1300 </span>            : 
<a name="1301"><span class="lineNum">    1301 </span>            : // static</a>
<span class="lineNum">    1302 </span>            : void
<span class="lineNum">    1303 </span><span class="lineCov">       1870 : XPCJSContext::ActivityCallback(void* arg, bool active)</span>
<span class="lineNum">    1304 </span>            : {
<span class="lineNum">    1305 </span><span class="lineCov">       1870 :     if (!active) {</span>
<span class="lineNum">    1306 </span><span class="lineCov">        935 :         ProcessHangMonitor::ClearHang();</span>
<span class="lineNum">    1307 </span>            :     }
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineCov">       1870 :     XPCJSContext* self = static_cast&lt;XPCJSContext*&gt;(arg);</span>
<span class="lineNum">    1310 </span><span class="lineCov">       3740 :     self-&gt;mWatchdogManager-&gt;RecordContextActivity(active);</span>
<span class="lineNum">    1311 </span><span class="lineCov">       1870 : }</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : // static
<span class="lineNum">    1314 </span>            : bool
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 : XPCJSContext::InterruptCallback(JSContext* cx)</span>
<span class="lineNum">    1316 </span>            : {
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :     XPCJSContext* self = XPCJSContext::Get();</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :     // Now is a good time to turn on profiling if it's pending.
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :     profiler_js_interrupt_callback();</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :     // Normally we record mSlowScriptCheckpoint when we start to process an
<span class="lineNum">    1323 </span>            :     // event. However, we can run JS outside of event handlers. This code takes
<span class="lineNum">    1324 </span>            :     // care of that case.
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     if (self-&gt;mSlowScriptCheckpoint.IsNull()) {</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         self-&gt;mSlowScriptCheckpoint = TimeStamp::NowLoRes();</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :         self-&gt;mSlowScriptSecondHalf = false;</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :         self-&gt;mSlowScriptActualWait = mozilla::TimeDuration();</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :         self-&gt;mTimeoutAccumulated = false;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1331 </span>            :     }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            :     // Sometimes we get called back during XPConnect initialization, before Gecko
<span class="lineNum">    1334 </span>            :     // has finished bootstrapping. Avoid crashing in nsContentUtils below.
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     if (!nsContentUtils::IsInitialized())</span>
<span class="lineNum">    1336 </span>            :         return true;
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            :     // This is at least the second interrupt callback we've received since
<span class="lineNum">    1339 </span>            :     // returning to the event loop. See how long it's been, and what the limit
<span class="lineNum">    1340 </span>            :     // is.
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :     TimeDuration duration = TimeStamp::NowLoRes() - self-&gt;mSlowScriptCheckpoint;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :     bool chrome = nsContentUtils::IsSystemCaller(cx);</span>
<span class="lineNum">    1343 </span>            :     const char* prefName = chrome ? PREF_MAX_SCRIPT_RUN_TIME_CHROME
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :                                   : PREF_MAX_SCRIPT_RUN_TIME_CONTENT;</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :     int32_t limit = Preferences::GetInt(prefName, chrome ? 20 : 10);</span>
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span>            :     // If there's no limit, or we're within the limit, let it go.
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :     if (limit == 0 || duration.ToSeconds() &lt; limit / 2.0)</span>
<span class="lineNum">    1349 </span>            :         return true;
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :     self-&gt;mSlowScriptActualWait += duration;</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :     // In order to guard against time changes or laptops going to sleep, we
<span class="lineNum">    1354 </span>            :     // don't trigger the slow script warning until (limit/2) seconds have
<span class="lineNum">    1355 </span>            :     // elapsed twice.
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     if (!self-&gt;mSlowScriptSecondHalf) {</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :         self-&gt;mSlowScriptCheckpoint = TimeStamp::NowLoRes();</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :         self-&gt;mSlowScriptSecondHalf = true;</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1360 </span>            :     }
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span>            :     //
<span class="lineNum">    1363 </span>            :     // This has gone on long enough! Time to take action. ;-)
<span class="lineNum">    1364 </span>            :     //
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :     // Get the DOM window associated with the running script. If the script is
<span class="lineNum">    1367 </span>            :     // running in a non-DOM scope, we have to just let it keep running.
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     RootedObject global(cx, JS::CurrentGlobalOrNull(cx));</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     RefPtr&lt;nsGlobalWindow&gt; win = WindowOrNull(global);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :     if (!win &amp;&amp; IsSandbox(global)) {</span>
<span class="lineNum">    1371 </span>            :         // If this is a sandbox associated with a DOMWindow via a
<span class="lineNum">    1372 </span>            :         // sandboxPrototype, use that DOMWindow. This supports GreaseMonkey
<span class="lineNum">    1373 </span>            :         // and JetPack content scripts.
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :         JS::Rooted&lt;JSObject*&gt; proto(cx);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :         if (!JS_GetPrototype(cx, global, &amp;proto))</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :         if (proto &amp;&amp; IsSandboxPrototypeProxy(proto) &amp;&amp;</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :             (proto = js::CheckedUnwrap(proto, /* stopAtWindowProxy = */ false)))</span>
<span class="lineNum">    1379 </span>            :         {
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :             win = WindowGlobalOrNull(proto);</span>
<span class="lineNum">    1381 </span>            :         }
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     if (!win) {</span>
<span class="lineNum">    1385 </span>            :         NS_WARNING(&quot;No active window&quot;);
<span class="lineNum">    1386 </span>            :         return true;
<span class="lineNum">    1387 </span>            :     }
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     if (win-&gt;IsDying()) {</span>
<span class="lineNum">    1390 </span>            :         // The window is being torn down. When that happens we try to prevent
<span class="lineNum">    1391 </span>            :         // the dispatch of new runnables, so it also makes sense to kill any
<span class="lineNum">    1392 </span>            :         // long-running script. The user is primarily interested in this page
<span class="lineNum">    1393 </span>            :         // going away.
<span class="lineNum">    1394 </span>            :         return false;
<span class="lineNum">    1395 </span>            :     }
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     if (win-&gt;GetIsPrerendered()) {</span>
<span class="lineNum">    1398 </span>            :         // We cannot display a dialog if the page is being prerendered, so
<span class="lineNum">    1399 </span>            :         // just kill the page.
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         mozilla::dom::HandlePrerenderingViolation(win-&gt;AsInner());</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1402 </span>            :     }
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            :     // Accumulate slow script invokation delay.
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :     if (!chrome &amp;&amp; !self-&gt;mTimeoutAccumulated) {</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :       uint32_t delay = uint32_t(self-&gt;mSlowScriptActualWait.ToMilliseconds() - (limit * 1000.0));</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :       Telemetry::Accumulate(Telemetry::SLOW_SCRIPT_NOTIFY_DELAY, delay);</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :       self-&gt;mTimeoutAccumulated = true;</span>
<span class="lineNum">    1409 </span>            :     }
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :     // Show the prompt to the user, and kill if requested.
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     nsGlobalWindow::SlowScriptResponse response = win-&gt;ShowSlowScriptDialog();</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     if (response == nsGlobalWindow::KillSlowScript) {</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         if (Preferences::GetBool(&quot;dom.global_stop_script&quot;, true))</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :             xpc::Scriptability::Get(global).Block();</span>
<span class="lineNum">    1416 </span>            :         return false;
<span class="lineNum">    1417 </span>            :     }
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :     // The user chose to continue the script. Reset the timer, and disable this
<span class="lineNum">    1420 </span>            :     // machinery with a pref of the user opted out of future slow-script dialogs.
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     if (response != nsGlobalWindow::ContinueSlowScriptAndKeepNotifying)</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         self-&gt;mSlowScriptCheckpoint = TimeStamp::NowLoRes();</span>
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :     if (response == nsGlobalWindow::AlwaysContinueSlowScript)</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :         Preferences::SetInt(prefName, 0);</span>
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            :     return true;
<span class="lineNum">    1428 </span>            : }
<a name="1429"><span class="lineNum">    1429 </span>            : </a>
<span class="lineNum">    1430 </span>            : void
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 : XPCJSContext::CustomOutOfMemoryCallback()</span>
<span class="lineNum">    1432 </span>            : {
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     if (!Preferences::GetBool(&quot;memory.dump_reports_on_oom&quot;)) {</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1435 </span>            :     }
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            :     nsCOMPtr&lt;nsIMemoryInfoDumper&gt; dumper =
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :         do_GetService(&quot;@mozilla.org/memory-info-dumper;1&quot;);</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     if (!dumper) {</span>
<span class="lineNum">    1440 </span>            :         return;
<span class="lineNum">    1441 </span>            :     }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            :     // If this fails, it fails silently.
<span class="lineNum">    1444 </span>            :     dumper-&gt;DumpMemoryInfoToTempDir(NS_LITERAL_STRING(&quot;due-to-JS-OOM&quot;),
<span class="lineNum">    1445 </span>            :                                     /* anonymize = */ false,
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :                                     /* minimizeMemoryUsage = */ false);</span>
<span class="lineNum">    1447 </span>            : }
<a name="1448"><span class="lineNum">    1448 </span>            : </a>
<span class="lineNum">    1449 </span>            : void
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 : XPCJSContext::OnLargeAllocationFailure()</span>
<span class="lineNum">    1451 </span>            : {
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     CycleCollectedJSContext::SetLargeAllocationFailure(OOMState::Reporting);</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; os = mozilla::services::GetObserverService();</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     if (os) {</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :         os-&gt;NotifyObservers(nullptr, &quot;memory-pressure&quot;, u&quot;heap-minimize&quot;);</span>
<span class="lineNum">    1457 </span>            :     }
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     CycleCollectedJSContext::SetLargeAllocationFailure(OOMState::Reported);</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            : class LargeAllocationFailureRunnable final : public Runnable
<span class="lineNum">    1463 </span>            : {
<span class="lineNum">    1464 </span>            :     Mutex mMutex;
<span class="lineNum">    1465 </span>            :     CondVar mCondVar;
<a name="1466"><span class="lineNum">    1466 </span>            :     bool mWaiting;</a>
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     virtual ~LargeAllocationFailureRunnable()</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1470 </span>            :         MOZ_ASSERT(!mWaiting);
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     }</span>
<a name="1472"><span class="lineNum">    1472 </span>            : </a>
<span class="lineNum">    1473 </span>            :   protected:
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :     NS_IMETHOD Run() override</span>
<span class="lineNum">    1475 </span>            :     {
<span class="lineNum">    1476 </span>            :         MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         XPCJSContext::Get()-&gt;OnLargeAllocationFailure();</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         MutexAutoLock lock(mMutex);</span>
<span class="lineNum">    1481 </span>            :         MOZ_ASSERT(mWaiting);
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :         mWaiting = false;</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :         mCondVar.Notify();</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    1486 </span>            :     }
<a name="1487"><span class="lineNum">    1487 </span>            : </a>
<span class="lineNum">    1488 </span>            :   public:
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :     LargeAllocationFailureRunnable()</span>
<span class="lineNum">    1490 </span>            :       : mMutex(&quot;LargeAllocationFailureRunnable::mMutex&quot;),
<span class="lineNum">    1491 </span>            :         mCondVar(mMutex, &quot;LargeAllocationFailureRunnable::mCondVar&quot;),
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         mWaiting(true)</span>
<span class="lineNum">    1493 </span>            :     {
<span class="lineNum">    1494 </span>            :         MOZ_ASSERT(!NS_IsMainThread());
<a name="1495"><span class="lineNum">    1495 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     void BlockUntilDone()</span>
<span class="lineNum">    1498 </span>            :     {
<span class="lineNum">    1499 </span>            :         MOZ_ASSERT(!NS_IsMainThread());
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         MutexAutoLock lock(mMutex);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :         while (mWaiting) {</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :             mCondVar.Wait();</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1506 </span>            : };
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<span class="lineNum">    1508 </span>            : static void
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 : OnLargeAllocationFailureCallback()</span>
<span class="lineNum">    1510 </span>            : {
<span class="lineNum">    1511 </span>            :     // This callback can be called from any thread, including internal JS helper
<span class="lineNum">    1512 </span>            :     // and DOM worker threads. We need to send the low-memory event via the
<span class="lineNum">    1513 </span>            :     // observer service which can only be called on the main thread, so proxy to
<span class="lineNum">    1514 </span>            :     // the main thread if we're not there already. The purpose of this callback
<span class="lineNum">    1515 </span>            :     // is to synchronously free some memory so the caller can retry a failed
<span class="lineNum">    1516 </span>            :     // allocation, so block on the completion.
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     if (NS_IsMainThread()) {</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :         XPCJSContext::Get()-&gt;OnLargeAllocationFailure();</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1521 </span>            :     }
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     RefPtr&lt;LargeAllocationFailureRunnable&gt; r = new LargeAllocationFailureRunnable;</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :     if (NS_WARN_IF(NS_FAILED(NS_DispatchToMainThread(r)))) {</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1526 </span>            :     }
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :     r-&gt;BlockUntilDone();</span>
<span class="lineNum">    1529 </span>            : }
<a name="1530"><span class="lineNum">    1530 </span>            : </a>
<span class="lineNum">    1531 </span>            : size_t
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 : XPCJSContext::SizeOfIncludingThis(MallocSizeOf mallocSizeOf)</span>
<span class="lineNum">    1533 </span>            : {
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     size_t n = 0;</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :     n += mallocSizeOf(this);</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     n += mWrappedJSMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     n += mIID2NativeInterfaceMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     n += mClassInfo2NativeSetMap-&gt;ShallowSizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     n += mNativeSetMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     n += CycleCollectedJSContext::SizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            :     // There are other XPCJSContext members that could be measured; the above
<span class="lineNum">    1544 </span>            :     // ones have been seen by DMD to be worth measuring.  More stuff may be
<span class="lineNum">    1545 </span>            :     // added later.
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :     return n;</span>
<span class="lineNum">    1548 </span>            : }
<a name="1549"><span class="lineNum">    1549 </span>            : </a>
<span class="lineNum">    1550 </span>            : size_t
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 : CompartmentPrivate::SizeOfIncludingThis(MallocSizeOf mallocSizeOf)</span>
<span class="lineNum">    1552 </span>            : {
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :     size_t n = mallocSizeOf(this);</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     n += mWrappedJSMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     n += mWrappedJSMap-&gt;SizeOfWrappedJS(mallocSizeOf);</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :     return n;</span>
<span class="lineNum">    1557 </span>            : }
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            : /***************************************************************************/
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            : #define JS_OPTIONS_DOT_STR &quot;javascript.options.&quot;
<a name="1562"><span class="lineNum">    1562 </span>            : </a>
<span class="lineNum">    1563 </span>            : static void
<span class="lineNum">    1564 </span><span class="lineCov">         60 : ReloadPrefsCallback(const char* pref, void* data)</span>
<span class="lineNum">    1565 </span>            : {
<span class="lineNum">    1566 </span><span class="lineCov">         60 :     XPCJSContext* xpccx = reinterpret_cast&lt;XPCJSContext*&gt;(data);</span>
<span class="lineNum">    1567 </span><span class="lineCov">         60 :     JSContext* cx = xpccx-&gt;Context();</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineCov">         60 :     bool safeMode = false;</span>
<span class="lineNum">    1570 </span><span class="lineCov">         60 :     nsCOMPtr&lt;nsIXULRuntime&gt; xr = do_GetService(&quot;@mozilla.org/xre/runtime;1&quot;);</span>
<span class="lineNum">    1571 </span><span class="lineCov">         60 :     if (xr) {</span>
<span class="lineNum">    1572 </span><span class="lineCov">         60 :         xr-&gt;GetInSafeMode(&amp;safeMode);</span>
<span class="lineNum">    1573 </span>            :     }
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineCov">         60 :     bool useBaseline = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;baselinejit&quot;) &amp;&amp; !safeMode;</span>
<span class="lineNum">    1576 </span><span class="lineCov">         60 :     bool useIon = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;ion&quot;) &amp;&amp; !safeMode;</span>
<span class="lineNum">    1577 </span><span class="lineCov">         60 :     bool useAsmJS = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;asmjs&quot;) &amp;&amp; !safeMode;</span>
<span class="lineNum">    1578 </span><span class="lineCov">         60 :     bool useWasm = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;wasm&quot;) &amp;&amp; !safeMode;</span>
<span class="lineNum">    1579 </span><span class="lineCov">         60 :     bool useWasmBaseline = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;wasm_baselinejit&quot;) &amp;&amp; !safeMode;</span>
<span class="lineNum">    1580 </span>            :     bool throwOnAsmJSValidationFailure = Preferences::GetBool(JS_OPTIONS_DOT_STR
<span class="lineNum">    1581 </span><span class="lineCov">         60 :                                                               &quot;throw_on_asmjs_validation_failure&quot;);</span>
<span class="lineNum">    1582 </span><span class="lineCov">         60 :     bool useNativeRegExp = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;native_regexp&quot;) &amp;&amp; !safeMode;</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineCov">         60 :     bool parallelParsing = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;parallel_parsing&quot;);</span>
<span class="lineNum">    1585 </span>            :     bool offthreadIonCompilation = Preferences::GetBool(JS_OPTIONS_DOT_STR
<span class="lineNum">    1586 </span><span class="lineCov">         60 :                                                        &quot;ion.offthread_compilation&quot;);</span>
<span class="lineNum">    1587 </span>            :     bool useBaselineEager = Preferences::GetBool(JS_OPTIONS_DOT_STR
<span class="lineNum">    1588 </span><span class="lineCov">         60 :                                                  &quot;baselinejit.unsafe_eager_compilation&quot;);</span>
<span class="lineNum">    1589 </span><span class="lineCov">         60 :     bool useIonEager = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;ion.unsafe_eager_compilation&quot;);</span>
<span class="lineNum">    1590 </span>            : #ifdef DEBUG
<span class="lineNum">    1591 </span>            :     bool fullJitDebugChecks = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;jit.full_debug_checks&quot;);
<span class="lineNum">    1592 </span>            : #endif
<span class="lineNum">    1593 </span>            : 
<span class="lineNum">    1594 </span><span class="lineCov">         60 :     int32_t baselineThreshold = Preferences::GetInt(JS_OPTIONS_DOT_STR &quot;baselinejit.threshold&quot;, -1);</span>
<span class="lineNum">    1595 </span><span class="lineCov">         60 :     int32_t ionThreshold = Preferences::GetInt(JS_OPTIONS_DOT_STR &quot;ion.threshold&quot;, -1);</span>
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span><span class="lineCov">         60 :     sDiscardSystemSource = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;discardSystemSource&quot;);</span>
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span><span class="lineCov">         60 :     bool useAsyncStack = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;asyncstack&quot;);</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            :     bool throwOnDebuggeeWouldRun = Preferences::GetBool(JS_OPTIONS_DOT_STR
<span class="lineNum">    1602 </span><span class="lineCov">         60 :                                                         &quot;throw_on_debuggee_would_run&quot;);</span>
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span>            :     bool dumpStackOnDebuggeeWouldRun = Preferences::GetBool(JS_OPTIONS_DOT_STR
<span class="lineNum">    1605 </span><span class="lineCov">         60 :                                                             &quot;dump_stack_on_debuggee_would_run&quot;);</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineCov">         60 :     bool werror = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;werror&quot;);</span>
<span class="lineNum">    1608 </span>            : 
<span class="lineNum">    1609 </span><span class="lineCov">         60 :     bool extraWarnings = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;strict&quot;);</span>
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineCov">         60 :     sSharedMemoryEnabled = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;shared_memory&quot;);</span>
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            : #ifdef DEBUG
<span class="lineNum">    1614 </span>            :     sExtraWarningsForSystemJS = Preferences::GetBool(JS_OPTIONS_DOT_STR &quot;strict.debug&quot;);
<span class="lineNum">    1615 </span>            : #endif
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            : #ifdef JS_GC_ZEAL
<span class="lineNum">    1618 </span>            :     int32_t zeal = Preferences::GetInt(JS_OPTIONS_DOT_STR &quot;gczeal&quot;, -1);
<span class="lineNum">    1619 </span>            :     int32_t zeal_frequency =
<span class="lineNum">    1620 </span>            :         Preferences::GetInt(JS_OPTIONS_DOT_STR &quot;gczeal.frequency&quot;,
<span class="lineNum">    1621 </span>            :                             JS_DEFAULT_ZEAL_FREQ);
<span class="lineNum">    1622 </span>            :     if (zeal &gt;= 0) {
<span class="lineNum">    1623 </span>            :         JS_SetGCZeal(cx, (uint8_t)zeal, zeal_frequency);
<span class="lineNum">    1624 </span>            :     }
<span class="lineNum">    1625 </span>            : #endif // JS_GC_ZEAL
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            : #ifdef FUZZING
<span class="lineNum">    1628 </span>            :     bool fuzzingEnabled = Preferences::GetBool(&quot;fuzzing.enabled&quot;);
<span class="lineNum">    1629 </span>            : #endif
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineCov">        120 :     JS::ContextOptionsRef(cx).setBaseline(useBaseline)</span>
<span class="lineNum">    1632 </span><span class="lineCov">         60 :                              .setIon(useIon)</span>
<span class="lineNum">    1633 </span><span class="lineCov">         60 :                              .setAsmJS(useAsmJS)</span>
<span class="lineNum">    1634 </span><span class="lineCov">         60 :                              .setWasm(useWasm)</span>
<span class="lineNum">    1635 </span><span class="lineCov">         60 :                              .setWasmAlwaysBaseline(useWasmBaseline)</span>
<span class="lineNum">    1636 </span><span class="lineCov">         60 :                              .setThrowOnAsmJSValidationFailure(throwOnAsmJSValidationFailure)</span>
<span class="lineNum">    1637 </span><span class="lineCov">         60 :                              .setNativeRegExp(useNativeRegExp)</span>
<span class="lineNum">    1638 </span><span class="lineCov">         60 :                              .setAsyncStack(useAsyncStack)</span>
<span class="lineNum">    1639 </span><span class="lineCov">         60 :                              .setThrowOnDebuggeeWouldRun(throwOnDebuggeeWouldRun)</span>
<span class="lineNum">    1640 </span><span class="lineCov">         60 :                              .setDumpStackOnDebuggeeWouldRun(dumpStackOnDebuggeeWouldRun)</span>
<span class="lineNum">    1641 </span><span class="lineCov">         60 :                              .setWerror(werror)</span>
<span class="lineNum">    1642 </span>            : #ifdef FUZZING
<span class="lineNum">    1643 </span>            :                              .setFuzzing(fuzzingEnabled)
<span class="lineNum">    1644 </span>            : #endif
<span class="lineNum">    1645 </span>            :                              .setExtraWarnings(extraWarnings);
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span><span class="lineCov">         60 :     JS_SetParallelParsingEnabled(cx, parallelParsing);</span>
<span class="lineNum">    1648 </span><span class="lineCov">         60 :     JS_SetOffthreadIonCompilationEnabled(cx, offthreadIonCompilation);</span>
<span class="lineNum">    1649 </span>            :     JS_SetGlobalJitCompilerOption(cx, JSJITCOMPILER_BASELINE_WARMUP_TRIGGER,
<span class="lineNum">    1650 </span><span class="lineCov">         60 :                                   useBaselineEager ? 0 : baselineThreshold);</span>
<span class="lineNum">    1651 </span>            :     JS_SetGlobalJitCompilerOption(cx, JSJITCOMPILER_ION_WARMUP_TRIGGER,
<span class="lineNum">    1652 </span><span class="lineCov">         60 :                                   useIonEager ? 0 : ionThreshold);</span>
<span class="lineNum">    1653 </span>            : #ifdef DEBUG
<span class="lineNum">    1654 </span>            :     JS_SetGlobalJitCompilerOption(cx, JSJITCOMPILER_FULL_DEBUG_CHECKS, fullJitDebugChecks);
<span class="lineNum">    1655 </span>            : #endif
<a name="1656"><span class="lineNum">    1656 </span><span class="lineCov">         60 : }</span></a>
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span><span class="lineCov">        480 : XPCJSContext::~XPCJSContext()</span>
<span class="lineNum">    1659 </span>            : {
<span class="lineNum">    1660 </span>            :     // Elsewhere we abort immediately if XPCJSContext initialization fails.
<span class="lineNum">    1661 </span>            :     // Therefore the context must be non-null.
<span class="lineNum">    1662 </span>            :     MOZ_ASSERT(MaybeContext());
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span>            :     // This destructor runs before ~CycleCollectedJSContext, which does the
<span class="lineNum">    1665 </span>            :     // actual JS_DestroyContext() call. But destroying the context triggers
<span class="lineNum">    1666 </span>            :     // one final GC, which can call back into the context with various
<span class="lineNum">    1667 </span>            :     // callbacks if we aren't careful. Null out the relevant callbacks.
<span class="lineNum">    1668 </span><span class="lineCov">         60 :     js::SetActivityCallback(Context(), nullptr, nullptr);</span>
<span class="lineNum">    1669 </span><span class="lineCov">         60 :     JS_RemoveFinalizeCallback(Context(), FinalizeCallback);</span>
<span class="lineNum">    1670 </span><span class="lineCov">         60 :     JS_RemoveWeakPointerZonesCallback(Context(), WeakPointerZonesCallback);</span>
<span class="lineNum">    1671 </span><span class="lineCov">         60 :     JS_RemoveWeakPointerCompartmentCallback(Context(), WeakPointerCompartmentCallback);</span>
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :     // Clear any pending exception.  It might be an XPCWrappedJS, and if we try
<span class="lineNum">    1674 </span>            :     // to destroy it later we will crash.
<span class="lineNum">    1675 </span><span class="lineCov">         60 :     SetPendingException(nullptr);</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineCov">         60 :     JS::SetGCSliceCallback(Context(), mPrevGCSliceCallback);</span>
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span><span class="lineCov">         60 :     xpc_DelocalizeContext(Context());</span>
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span><span class="lineCov">        180 :     if (mWatchdogManager-&gt;GetWatchdog())</span>
<span class="lineNum">    1682 </span><span class="lineCov">         60 :         mWatchdogManager-&gt;StopWatchdog();</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineCov">         60 :     if (mCallContext)</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :         mCallContext-&gt;SystemIsBeingShutDown();</span>
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineCov">         60 :     auto rtPrivate = static_cast&lt;PerThreadAtomCache*&gt;(JS_GetContextPrivate(Context()));</span>
<span class="lineNum">    1688 </span>            :     delete rtPrivate;
<span class="lineNum">    1689 </span><span class="lineCov">         60 :     JS_SetContextPrivate(Context(), nullptr);</span>
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            :     // clean up and destroy maps...
<span class="lineNum">    1692 </span><span class="lineCov">         60 :     mWrappedJSMap-&gt;ShutdownMarker();</span>
<span class="lineNum">    1693 </span><span class="lineCov">         60 :     delete mWrappedJSMap;</span>
<span class="lineNum">    1694 </span><span class="lineCov">         60 :     mWrappedJSMap = nullptr;</span>
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span><span class="lineCov">         60 :     delete mWrappedJSClassMap;</span>
<span class="lineNum">    1697 </span><span class="lineCov">         60 :     mWrappedJSClassMap = nullptr;</span>
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span><span class="lineCov">         60 :     delete mIID2NativeInterfaceMap;</span>
<span class="lineNum">    1700 </span><span class="lineCov">         60 :     mIID2NativeInterfaceMap = nullptr;</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span><span class="lineCov">         60 :     delete mClassInfo2NativeSetMap;</span>
<span class="lineNum">    1703 </span><span class="lineCov">         60 :     mClassInfo2NativeSetMap = nullptr;</span>
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineCov">         60 :     delete mNativeSetMap;</span>
<span class="lineNum">    1706 </span><span class="lineCov">         60 :     mNativeSetMap = nullptr;</span>
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span><span class="lineCov">         60 :     delete mThisTranslatorMap;</span>
<span class="lineNum">    1709 </span><span class="lineCov">         60 :     mThisTranslatorMap = nullptr;</span>
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span><span class="lineCov">         60 :     delete mDyingWrappedNativeProtoMap;</span>
<span class="lineNum">    1712 </span><span class="lineCov">         60 :     mDyingWrappedNativeProtoMap = nullptr;</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            : #ifdef MOZ_GECKO_PROFILER
<span class="lineNum">    1715 </span>            :     // Tell the profiler that the context is gone
<span class="lineNum">    1716 </span><span class="lineCov">         60 :     profiler_clear_js_context();</span>
<span class="lineNum">    1717 </span>            : #endif
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            :     Preferences::UnregisterPrefixCallback(ReloadPrefsCallback,
<span class="lineNum">    1720 </span><span class="lineCov">         60 :                                           JS_OPTIONS_DOT_STR, this);</span>
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span>            : #ifdef FUZZING
<span class="lineNum">    1723 </span>            :     Preferences::UnregisterCallback(ReloadPrefsCallback, &quot;fuzzing.enabled&quot;, this);
<span class="lineNum">    1724 </span>            : #endif
<span class="lineNum">    1725 </span><span class="lineCov">        180 : }</span>
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span>            : // If |*anonymizeID| is non-zero and this is a user compartment, the name will
<a name="1728"><span class="lineNum">    1728 </span>            : // be anonymized.</a>
<span class="lineNum">    1729 </span>            : static void
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 : GetCompartmentName(JSCompartment* c, nsCString&amp; name, int* anonymizeID,</span>
<span class="lineNum">    1731 </span>            :                    bool replaceSlashes)
<span class="lineNum">    1732 </span>            : {
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :     if (js::IsAtomsCompartment(c)) {</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :         name.AssignLiteral(&quot;atoms&quot;);</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     } else if (*anonymizeID &amp;&amp; !js::IsSystemCompartment(c)) {</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :         name.AppendPrintf(&quot;&lt;anonymized-%d&gt;&quot;, *anonymizeID);</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :         *anonymizeID += 1;</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :     } else if (JSPrincipals* principals = JS_GetCompartmentPrincipals(c)) {</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :         nsresult rv = nsJSPrincipals::get(principals)-&gt;GetScriptLocation(name);</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :             name.AssignLiteral(&quot;(unknown)&quot;);</span>
<span class="lineNum">    1742 </span>            :         }
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span>            :         // If the compartment's location (name) differs from the principal's
<span class="lineNum">    1745 </span>            :         // script location, append the compartment's location to allow
<span class="lineNum">    1746 </span>            :         // differentiation of multiple compartments owned by the same principal
<span class="lineNum">    1747 </span>            :         // (e.g. components owned by the system or null principal).
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :         CompartmentPrivate* compartmentPrivate = CompartmentPrivate::Get(c);</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :         if (compartmentPrivate) {</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :             const nsACString&amp; location = compartmentPrivate-&gt;GetLocation();</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :             if (!location.IsEmpty() &amp;&amp; !location.Equals(name)) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                 name.AppendLiteral(&quot;, &quot;);</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :                 name.Append(location);</span>
<span class="lineNum">    1754 </span>            :             }
<span class="lineNum">    1755 </span>            :         }
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :         if (*anonymizeID) {</span>
<span class="lineNum">    1758 </span>            :             // We might have a file:// URL that includes a path from the local
<span class="lineNum">    1759 </span>            :             // filesystem, which should be omitted if we're anonymizing.
<span class="lineNum">    1760 </span>            :             static const char* filePrefix = &quot;file://&quot;;
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :             int filePos = name.Find(filePrefix);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :             if (filePos &gt;= 0) {</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :                 int pathPos = filePos + strlen(filePrefix);</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :                 int lastSlashPos = -1;</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :                 for (int i = pathPos; i &lt; int(name.Length()); i++) {</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :                     if (name[i] == '/' || name[i] == '\\') {</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :                         lastSlashPos = i;</span>
<span class="lineNum">    1768 </span>            :                     }
<span class="lineNum">    1769 </span>            :                 }
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                 if (lastSlashPos != -1) {</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :                     name.ReplaceASCII(pathPos, lastSlashPos - pathPos,</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :                                       &quot;&lt;anonymized&gt;&quot;);</span>
<span class="lineNum">    1773 </span>            :                 } else {
<span class="lineNum">    1774 </span>            :                     // Something went wrong. Anonymize the entire path to be
<span class="lineNum">    1775 </span>            :                     // safe.
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :                     name.Truncate(pathPos);</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :                     name += &quot;&lt;anonymized?!&gt;&quot;;</span>
<span class="lineNum">    1778 </span>            :                 }
<span class="lineNum">    1779 </span>            :             }
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            :             // We might have a location like this:
<span class="lineNum">    1782 </span>            :             //   inProcessTabChildGlobal?ownedBy=http://www.example.com/
<span class="lineNum">    1783 </span>            :             // The owner should be omitted if it's not a chrome: URI and we're
<span class="lineNum">    1784 </span>            :             // anonymizing.
<span class="lineNum">    1785 </span>            :             static const char* ownedByPrefix =
<span class="lineNum">    1786 </span>            :                 &quot;inProcessTabChildGlobal?ownedBy=&quot;;
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :             int ownedByPos = name.Find(ownedByPrefix);</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :             if (ownedByPos &gt;= 0) {</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :                 const char* chrome = &quot;chrome:&quot;;</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :                 int ownerPos = ownedByPos + strlen(ownedByPrefix);</span>
<span class="lineNum">    1791 </span>            :                 const nsDependentCSubstring&amp; ownerFirstPart =
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :                     Substring(name, ownerPos, strlen(chrome));</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :                 if (!ownerFirstPart.EqualsASCII(chrome)) {</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :                     name.Truncate(ownerPos);</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :                     name += &quot;&lt;anonymized&gt;&quot;;</span>
<span class="lineNum">    1796 </span>            :                 }
<span class="lineNum">    1797 </span>            :             }
<span class="lineNum">    1798 </span>            :         }
<span class="lineNum">    1799 </span>            : 
<span class="lineNum">    1800 </span>            :         // A hack: replace forward slashes with '\\' so they aren't
<span class="lineNum">    1801 </span>            :         // treated as path separators.  Users of the reporters
<span class="lineNum">    1802 </span>            :         // (such as about:memory) have to undo this change.
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :         if (replaceSlashes)</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :             name.ReplaceChar('/', '\\');</span>
<span class="lineNum">    1805 </span>            :     } else {
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :         name.AssignLiteral(&quot;null-principal&quot;);</span>
<span class="lineNum">    1807 </span>            :     }
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 : }</span>
<a name="1809"><span class="lineNum">    1809 </span>            : </a>
<span class="lineNum">    1810 </span>            : extern void
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 : xpc::GetCurrentCompartmentName(JSContext* cx, nsCString&amp; name)</span>
<span class="lineNum">    1812 </span>            : {
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :     RootedObject global(cx, JS::CurrentGlobalOrNull(cx));</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :     if (!global) {</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :         name.AssignLiteral(&quot;no global&quot;);</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1817 </span>            :     }
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :     JSCompartment* compartment = GetObjectCompartment(global);</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :     int anonymizeID = 0;</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :     GetCompartmentName(compartment, name, &amp;anonymizeID, false);</span>
<span class="lineNum">    1822 </span>            : }
<a name="1823"><span class="lineNum">    1823 </span>            : </a>
<span class="lineNum">    1824 </span>            : void
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 : xpc::AddGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    1826 </span>            : {
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :     XPCJSContext::Get()-&gt;AddGCCallback(cb);</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 : }</span>
<a name="1829"><span class="lineNum">    1829 </span>            : </a>
<span class="lineNum">    1830 </span>            : void
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 : xpc::RemoveGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    1832 </span>            : {
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :     XPCJSContext::Get()-&gt;RemoveGCCallback(cb);</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 : }</span>
<a name="1835"><span class="lineNum">    1835 </span>            : </a>
<span class="lineNum">    1836 </span>            : static int64_t
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 : JSMainRuntimeGCHeapDistinguishedAmount()</span>
<span class="lineNum">    1838 </span>            : {
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :     JSContext* cx = danger::GetJSContext();</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :     return int64_t(JS_GetGCParameter(cx, JSGC_TOTAL_CHUNKS)) *</span>
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :            js::gc::ChunkSize;</span>
<span class="lineNum">    1842 </span>            : }
<a name="1843"><span class="lineNum">    1843 </span>            : </a>
<span class="lineNum">    1844 </span>            : static int64_t
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 : JSMainRuntimeTemporaryPeakDistinguishedAmount()</span>
<span class="lineNum">    1846 </span>            : {
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :     JSContext* cx = danger::GetJSContext();</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     return JS::PeakSizeOfTemporary(cx);</span>
<span class="lineNum">    1849 </span>            : }
<a name="1850"><span class="lineNum">    1850 </span>            : </a>
<span class="lineNum">    1851 </span>            : static int64_t
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 : JSMainRuntimeCompartmentsSystemDistinguishedAmount()</span>
<span class="lineNum">    1853 </span>            : {
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :     JSContext* cx = danger::GetJSContext();</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :     return JS::SystemCompartmentCount(cx);</span>
<span class="lineNum">    1856 </span>            : }
<a name="1857"><span class="lineNum">    1857 </span>            : </a>
<span class="lineNum">    1858 </span>            : static int64_t
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 : JSMainRuntimeCompartmentsUserDistinguishedAmount()</span>
<span class="lineNum">    1860 </span>            : {
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :     JSContext* cx = nsXPConnect::GetContextInstance()-&gt;Context();</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :     return JS::UserCompartmentCount(cx);</span>
<a name="1863"><span class="lineNum">    1863 </span>            : }</a>
<span class="lineNum">    1864 </span>            : 
<a name="1865"><span class="lineNum">    1865 </span><span class="lineCov">        120 : class JSMainRuntimeTemporaryPeakReporter final : public nsIMemoryReporter</span></a>
<span class="lineNum">    1866 </span>            : {
<span class="lineNum">    1867 </span><span class="lineCov">         60 :     ~JSMainRuntimeTemporaryPeakReporter() {}</span>
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span>            :   public:
<a name="1870"><span class="lineNum">    1870 </span>            :     NS_DECL_ISUPPORTS</a>
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     NS_IMETHOD CollectReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">    1873 </span>            :                               nsISupports* aData, bool aAnonymize) override
<span class="lineNum">    1874 </span>            :     {
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :         MOZ_COLLECT_REPORT(</span>
<span class="lineNum">    1876 </span>            :             &quot;js-main-runtime-temporary-peak&quot;, KIND_OTHER, UNITS_BYTES,
<span class="lineNum">    1877 </span>            :             JSMainRuntimeTemporaryPeakDistinguishedAmount(),
<span class="lineNum">    1878 </span>            :             &quot;Peak transient data size in the main JSRuntime (the current size &quot;
<span class="lineNum">    1879 </span>            :             &quot;of which is reported as &quot;
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :             &quot;'explicit/js-non-window/runtime/temporary').&quot;);</span>
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    1883 </span>            :     }
<a name="1884"><span class="lineNum">    1884 </span>            : };</a>
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineCov">       1200 : NS_IMPL_ISUPPORTS(JSMainRuntimeTemporaryPeakReporter, nsIMemoryReporter)</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            : // The REPORT* macros do an unconditional report.  The ZCREPORT* macros are for
<span class="lineNum">    1889 </span>            : // compartments and zones; they aggregate any entries smaller than
<span class="lineNum">    1890 </span>            : // SUNDRIES_THRESHOLD into the &quot;sundries/gc-heap&quot; and &quot;sundries/malloc-heap&quot;
<span class="lineNum">    1891 </span>            : // entries for the compartment.
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            : #define SUNDRIES_THRESHOLD js::MemoryReportingSundriesThreshold()
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span>            : #define REPORT(_path, _kind, _units, _amount, _desc) \
<span class="lineNum">    1896 </span>            :     handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1897 </span>            :                            nsIMemoryReporter::_kind, \
<span class="lineNum">    1898 </span>            :                            nsIMemoryReporter::_units, _amount, \
<span class="lineNum">    1899 </span>            :                            NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span>            : #define REPORT_BYTES(_path, _kind, _amount, _desc) \
<span class="lineNum">    1902 </span>            :     REPORT(_path, _kind, UNITS_BYTES, _amount, _desc);
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span>            : #define REPORT_GC_BYTES(_path, _amount, _desc) \
<span class="lineNum">    1905 </span>            :     do { \
<span class="lineNum">    1906 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1907 </span>            :         handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1908 </span>            :                                nsIMemoryReporter::KIND_NONHEAP, \
<span class="lineNum">    1909 </span>            :                                nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1910 </span>            :                                NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1911 </span>            :         gcTotal += amount; \
<span class="lineNum">    1912 </span>            :     } while (0)
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span>            : // Report compartment/zone non-GC (KIND_HEAP) bytes.
<span class="lineNum">    1915 </span>            : #define ZCREPORT_BYTES(_path, _amount, _desc) \
<span class="lineNum">    1916 </span>            :     do { \
<span class="lineNum">    1917 </span>            :         /* Assign _descLiteral plus &quot;&quot; into a char* to prove that it's */ \
<span class="lineNum">    1918 </span>            :         /* actually a literal. */ \
<span class="lineNum">    1919 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1920 </span>            :         if (amount &gt;= SUNDRIES_THRESHOLD) { \
<span class="lineNum">    1921 </span>            :             handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1922 </span>            :                                    nsIMemoryReporter::KIND_HEAP, \
<span class="lineNum">    1923 </span>            :                                    nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1924 </span>            :                                    NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1925 </span>            :         } else { \
<span class="lineNum">    1926 </span>            :             sundriesMallocHeap += amount; \
<span class="lineNum">    1927 </span>            :         } \
<span class="lineNum">    1928 </span>            :     } while (0)
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            : // Report compartment/zone GC bytes.
<span class="lineNum">    1931 </span>            : #define ZCREPORT_GC_BYTES(_path, _amount, _desc) \
<span class="lineNum">    1932 </span>            :     do { \
<span class="lineNum">    1933 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1934 </span>            :         if (amount &gt;= SUNDRIES_THRESHOLD) { \
<span class="lineNum">    1935 </span>            :             handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1936 </span>            :                                    nsIMemoryReporter::KIND_NONHEAP, \
<span class="lineNum">    1937 </span>            :                                    nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1938 </span>            :                                    NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1939 </span>            :             gcTotal += amount; \
<span class="lineNum">    1940 </span>            :         } else { \
<span class="lineNum">    1941 </span>            :             sundriesGCHeap += amount; \
<span class="lineNum">    1942 </span>            :         } \
<span class="lineNum">    1943 </span>            :     } while (0)
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span>            : // Report runtime bytes.
<span class="lineNum">    1946 </span>            : #define RREPORT_BYTES(_path, _kind, _amount, _desc) \
<span class="lineNum">    1947 </span>            :     do { \
<span class="lineNum">    1948 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1949 </span>            :         handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1950 </span>            :                                nsIMemoryReporter::_kind, \
<span class="lineNum">    1951 </span>            :                                nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1952 </span>            :                                NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1953 </span>            :         rtTotal += amount; \
<span class="lineNum">    1954 </span>            :     } while (0)
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span>            : // Report GC thing bytes.
<span class="lineNum">    1957 </span>            : #define MREPORT_BYTES(_path, _kind, _amount, _desc) \
<span class="lineNum">    1958 </span>            :     do { \
<span class="lineNum">    1959 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1960 </span>            :         handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1961 </span>            :                                nsIMemoryReporter::_kind, \
<span class="lineNum">    1962 </span>            :                                nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1963 </span>            :                                NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1964 </span>            :         gcThingTotal += amount; \
<a name="1965"><span class="lineNum">    1965 </span>            :     } while (0)</a>
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 : MOZ_DEFINE_MALLOC_SIZE_OF(JSMallocSizeOf)</span>
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span>            : namespace xpc {
<a name="1970"><span class="lineNum">    1970 </span>            : </a>
<span class="lineNum">    1971 </span>            : static void
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 : ReportZoneStats(const JS::ZoneStats&amp; zStats,</span>
<span class="lineNum">    1973 </span>            :                 const xpc::ZoneStatsExtras&amp; extras,
<span class="lineNum">    1974 </span>            :                 nsIHandleReportCallback* handleReport,
<span class="lineNum">    1975 </span>            :                 nsISupports* data,
<span class="lineNum">    1976 </span>            :                 bool anonymize,
<span class="lineNum">    1977 </span>            :                 size_t* gcTotalOut = nullptr)
<span class="lineNum">    1978 </span>            : {
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :     const nsCString&amp; pathPrefix = extras.pathPrefix;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     size_t gcTotal = 0, sundriesGCHeap = 0, sundriesMallocHeap = 0;</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            :     MOZ_ASSERT(!gcTotalOut == zStats.isTotals);
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;symbols/gc-heap&quot;),</span>
<span class="lineNum">    1985 </span>            :         zStats.symbolsGCHeap,
<span class="lineNum">    1986 </span>            :         &quot;Symbols.&quot;);
<span class="lineNum">    1987 </span>            : 
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;gc-heap-arena-admin&quot;),</span>
<span class="lineNum">    1989 </span>            :         zStats.gcHeapArenaAdmin,
<span class="lineNum">    1990 </span>            :         &quot;Bookkeeping information and alignment padding within GC arenas.&quot;);
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;unused-gc-things&quot;),</span>
<span class="lineNum">    1993 </span>            :         zStats.unusedGCThings.totalSize(),
<span class="lineNum">    1994 </span>            :         &quot;Unused GC thing cells within non-empty arenas.&quot;);
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;unique-id-map&quot;),</span>
<span class="lineNum">    1997 </span>            :         zStats.uniqueIdMap,
<span class="lineNum">    1998 </span>            :         &quot;Address-independent cell identities.&quot;);
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shape-tables&quot;),</span>
<span class="lineNum">    2001 </span>            :         zStats.shapeTables,
<span class="lineNum">    2002 </span>            :         &quot;Tables storing shape information.&quot;);
<span class="lineNum">    2003 </span>            : 
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;lazy-scripts/gc-heap&quot;),</span>
<span class="lineNum">    2005 </span>            :         zStats.lazyScriptsGCHeap,
<span class="lineNum">    2006 </span>            :         &quot;Scripts that haven't executed yet.&quot;);
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;lazy-scripts/malloc-heap&quot;),</span>
<span class="lineNum">    2009 </span>            :         zStats.lazyScriptsMallocHeap,
<span class="lineNum">    2010 </span>            :         &quot;Lazy script tables containing closed-over bindings or inner functions.&quot;);
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;jit-codes-gc-heap&quot;),</span>
<span class="lineNum">    2013 </span>            :         zStats.jitCodesGCHeap,
<span class="lineNum">    2014 </span>            :         &quot;References to executable code pools used by the JITs.&quot;);
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;object-groups/gc-heap&quot;),</span>
<span class="lineNum">    2017 </span>            :         zStats.objectGroupsGCHeap,
<span class="lineNum">    2018 </span>            :         &quot;Classification and type inference information about objects.&quot;);
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;object-groups/malloc-heap&quot;),</span>
<span class="lineNum">    2021 </span>            :         zStats.objectGroupsMallocHeap,
<span class="lineNum">    2022 </span>            :         &quot;Object group addenda.&quot;);
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;scopes/gc-heap&quot;),</span>
<span class="lineNum">    2025 </span>            :         zStats.scopesGCHeap,
<span class="lineNum">    2026 </span>            :         &quot;Scope information for scripts.&quot;);
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;scopes/malloc-heap&quot;),</span>
<span class="lineNum">    2029 </span>            :         zStats.scopesMallocHeap,
<span class="lineNum">    2030 </span>            :         &quot;Arrays of binding names and other binding-related data.&quot;);
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;regexp-shareds/gc-heap&quot;),</span>
<span class="lineNum">    2033 </span>            :         zStats.regExpSharedsGCHeap,
<span class="lineNum">    2034 </span>            :         &quot;Shared compiled regexp data.&quot;);
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;regexp-shareds/malloc-heap&quot;),</span>
<span class="lineNum">    2037 </span>            :         zStats.regExpSharedsMallocHeap,
<span class="lineNum">    2038 </span>            :         &quot;Shared compiled regexp data.&quot;);
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;type-pool&quot;),</span>
<span class="lineNum">    2041 </span>            :         zStats.typePool,
<span class="lineNum">    2042 </span>            :         &quot;Type sets and related data.&quot;);
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;baseline/optimized-stubs&quot;),</span>
<span class="lineNum">    2045 </span>            :         zStats.baselineStubsOptimized,
<span class="lineNum">    2046 </span>            :         &quot;The Baseline JIT's optimized IC stubs (excluding code).&quot;);
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :     size_t stringsNotableAboutMemoryGCHeap = 0;</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :     size_t stringsNotableAboutMemoryMallocHeap = 0;</span>
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            :     #define MAYBE_INLINE \
<span class="lineNum">    2052 </span>            :         &quot;The characters may be inline or on the malloc heap.&quot;
<span class="lineNum">    2053 </span>            :     #define MAYBE_OVERALLOCATED \
<span class="lineNum">    2054 </span>            :         &quot;Sometimes over-allocated to simplify string concatenation.&quot;
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; zStats.notableStrings.length(); i++) {</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :         const JS::NotableStringInfo&amp; info = zStats.notableStrings[i];</span>
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span>            :         MOZ_ASSERT(!zStats.isTotals);
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            :         // We don't do notable string detection when anonymizing, because
<span class="lineNum">    2062 </span>            :         // there's a good chance its for crash submission, and the memory
<span class="lineNum">    2063 </span>            :         // required for notable string detection is high.
<span class="lineNum">    2064 </span>            :         MOZ_ASSERT(!anonymize);
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :         nsDependentCString notableString(info.buffer);</span>
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            :         // Viewing about:memory generates many notable strings which contain
<span class="lineNum">    2069 </span>            :         // &quot;string(length=&quot;.  If we report these as notable, then we'll create
<span class="lineNum">    2070 </span>            :         // even more notable strings the next time we open about:memory (unless
<span class="lineNum">    2071 </span>            :         // there's a GC in the meantime), and so on ad infinitum.
<span class="lineNum">    2072 </span>            :         //
<span class="lineNum">    2073 </span>            :         // To avoid cluttering up about:memory like this, we stick notable
<span class="lineNum">    2074 </span>            :         // strings which contain &quot;string(length=&quot; into their own bucket.
<span class="lineNum">    2075 </span>            : #       define STRING_LENGTH &quot;string(length=&quot;
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :         if (FindInReadable(NS_LITERAL_CSTRING(STRING_LENGTH), notableString)) {</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryGCHeap += info.gcHeapLatin1;</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryGCHeap += info.gcHeapTwoByte;</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryMallocHeap += info.mallocHeapLatin1;</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryMallocHeap += info.mallocHeapTwoByte;</span>
<span class="lineNum">    2081 </span>            :             continue;
<span class="lineNum">    2082 </span>            :         }
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            :         // Escape / to \ before we put notableString into the memory reporter
<span class="lineNum">    2085 </span>            :         // path, because we don't want any forward slashes in the string to
<span class="lineNum">    2086 </span>            :         // count as path separators.
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :         nsCString escapedString(notableString);</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :         escapedString.ReplaceSubstring(&quot;/&quot;, &quot;\\&quot;);</span>
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :         bool truncated = notableString.Length() &lt; info.length;</span>
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :         nsCString path = pathPrefix +</span>
<span class="lineNum">    2093 </span>            :             nsPrintfCString(&quot;strings/&quot; STRING_LENGTH &quot;%&quot; PRIuSIZE &quot;, copies=%d, \&quot;%s\&quot;%s)/&quot;,
<span class="lineNum">    2094 </span>            :                             info.length, info.numCopies, escapedString.get(),
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :                             truncated ? &quot; (truncated)&quot; : &quot;&quot;);</span>
<span class="lineNum">    2096 </span>            : 
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :         if (info.gcHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :             REPORT_GC_BYTES(path + NS_LITERAL_CSTRING(&quot;gc-heap/latin1&quot;),</span>
<span class="lineNum">    2099 </span>            :                 info.gcHeapLatin1,
<span class="lineNum">    2100 </span>            :                 &quot;Latin1 strings. &quot; MAYBE_INLINE);
<span class="lineNum">    2101 </span>            :         }
<span class="lineNum">    2102 </span>            : 
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         if (info.gcHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :             REPORT_GC_BYTES(path + NS_LITERAL_CSTRING(&quot;gc-heap/two-byte&quot;),</span>
<span class="lineNum">    2105 </span>            :                 info.gcHeapTwoByte,
<span class="lineNum">    2106 </span>            :                 &quot;TwoByte strings. &quot; MAYBE_INLINE);
<span class="lineNum">    2107 </span>            :         }
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :         if (info.mallocHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :             REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;malloc-heap/latin1&quot;),</span>
<span class="lineNum">    2111 </span>            :                 KIND_HEAP, info.mallocHeapLatin1,
<span class="lineNum">    2112 </span>            :                 &quot;Non-inline Latin1 string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    2113 </span>            :         }
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :         if (info.mallocHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :             REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;malloc-heap/two-byte&quot;),</span>
<span class="lineNum">    2117 </span>            :                 KIND_HEAP, info.mallocHeapTwoByte,
<span class="lineNum">    2118 </span>            :                 &quot;Non-inline TwoByte string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    2119 </span>            :         }
<span class="lineNum">    2120 </span>            :     }
<span class="lineNum">    2121 </span>            : 
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :     nsCString nonNotablePath = pathPrefix;</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :     nonNotablePath += (zStats.isTotals || anonymize)</span>
<span class="lineNum">    2124 </span>            :                     ? NS_LITERAL_CSTRING(&quot;strings/&quot;)
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :                     : NS_LITERAL_CSTRING(&quot;strings/string(&lt;non-notable strings&gt;)/&quot;);</span>
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.gcHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;gc-heap/latin1&quot;),</span>
<span class="lineNum">    2129 </span>            :             zStats.stringInfo.gcHeapLatin1,
<span class="lineNum">    2130 </span>            :             &quot;Latin1 strings. &quot; MAYBE_INLINE);
<span class="lineNum">    2131 </span>            :     }
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.gcHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;gc-heap/two-byte&quot;),</span>
<span class="lineNum">    2135 </span>            :             zStats.stringInfo.gcHeapTwoByte,
<span class="lineNum">    2136 </span>            :             &quot;TwoByte strings. &quot; MAYBE_INLINE);
<span class="lineNum">    2137 </span>            :     }
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.mallocHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :         REPORT_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;malloc-heap/latin1&quot;),</span>
<span class="lineNum">    2141 </span>            :             KIND_HEAP, zStats.stringInfo.mallocHeapLatin1,
<span class="lineNum">    2142 </span>            :             &quot;Non-inline Latin1 string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    2143 </span>            :     }
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.mallocHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :         REPORT_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;malloc-heap/two-byte&quot;),</span>
<span class="lineNum">    2147 </span>            :             KIND_HEAP, zStats.stringInfo.mallocHeapTwoByte,
<span class="lineNum">    2148 </span>            :             &quot;Non-inline TwoByte string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    2149 </span>            :     }
<span class="lineNum">    2150 </span>            : 
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :     if (stringsNotableAboutMemoryGCHeap &gt; 0) {</span>
<span class="lineNum">    2152 </span>            :         MOZ_ASSERT(!zStats.isTotals);
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;strings/string(&lt;about-memory&gt;)/gc-heap&quot;),</span>
<span class="lineNum">    2154 </span>            :             stringsNotableAboutMemoryGCHeap,
<span class="lineNum">    2155 </span>            :             &quot;Strings that contain the characters '&quot; STRING_LENGTH &quot;', which &quot;
<span class="lineNum">    2156 </span>            :             &quot;are probably from about:memory itself.&quot; MAYBE_INLINE
<span class="lineNum">    2157 </span>            :             &quot; We filter them out rather than display them, because displaying &quot;
<span class="lineNum">    2158 </span>            :             &quot;them would create even more such strings every time about:memory &quot;
<span class="lineNum">    2159 </span>            :             &quot;is refreshed.&quot;);
<span class="lineNum">    2160 </span>            :     }
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :     if (stringsNotableAboutMemoryMallocHeap &gt; 0) {</span>
<span class="lineNum">    2163 </span>            :         MOZ_ASSERT(!zStats.isTotals);
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;strings/string(&lt;about-memory&gt;)/malloc-heap&quot;),</span>
<span class="lineNum">    2165 </span>            :             KIND_HEAP, stringsNotableAboutMemoryMallocHeap,
<span class="lineNum">    2166 </span>            :             &quot;Non-inline string characters of strings that contain the &quot;
<span class="lineNum">    2167 </span>            :             &quot;characters '&quot; STRING_LENGTH &quot;', which are probably from &quot;
<span class="lineNum">    2168 </span>            :             &quot;about:memory itself. &quot; MAYBE_OVERALLOCATED
<span class="lineNum">    2169 </span>            :             &quot; We filter them out rather than display them, because displaying &quot;
<span class="lineNum">    2170 </span>            :             &quot;them would create even more such strings every time about:memory &quot;
<span class="lineNum">    2171 </span>            :             &quot;is refreshed.&quot;);
<span class="lineNum">    2172 </span>            :     }
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :     const JS::ShapeInfo&amp; shapeInfo = zStats.shapeInfo;</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesGCHeapTree &gt; 0) {</span>
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/gc-heap/tree&quot;),</span>
<span class="lineNum">    2177 </span>            :             shapeInfo.shapesGCHeapTree,
<span class="lineNum">    2178 </span>            :         &quot;Shapes in a property tree.&quot;);
<span class="lineNum">    2179 </span>            :     }
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesGCHeapDict &gt; 0) {</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/gc-heap/dict&quot;),</span>
<span class="lineNum">    2183 </span>            :             shapeInfo.shapesGCHeapDict,
<span class="lineNum">    2184 </span>            :         &quot;Shapes in dictionary mode.&quot;);
<span class="lineNum">    2185 </span>            :     }
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesGCHeapBase &gt; 0) {</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/gc-heap/base&quot;),</span>
<span class="lineNum">    2189 </span>            :             shapeInfo.shapesGCHeapBase,
<span class="lineNum">    2190 </span>            :             &quot;Base shapes, which collate data common to many shapes.&quot;);
<span class="lineNum">    2191 </span>            :     }
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesMallocHeapTreeTables &gt; 0) {</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/malloc-heap/tree-tables&quot;),</span>
<span class="lineNum">    2195 </span>            :             KIND_HEAP, shapeInfo.shapesMallocHeapTreeTables,
<span class="lineNum">    2196 </span>            :             &quot;Property tables of shapes in a property tree.&quot;);
<span class="lineNum">    2197 </span>            :     }
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesMallocHeapDictTables &gt; 0) {</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/malloc-heap/dict-tables&quot;),</span>
<span class="lineNum">    2201 </span>            :             KIND_HEAP, shapeInfo.shapesMallocHeapDictTables,
<span class="lineNum">    2202 </span>            :             &quot;Property tables of shapes in dictionary mode.&quot;);
<span class="lineNum">    2203 </span>            :     }
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesMallocHeapTreeKids &gt; 0) {</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/malloc-heap/tree-kids&quot;),</span>
<span class="lineNum">    2207 </span>            :             KIND_HEAP, shapeInfo.shapesMallocHeapTreeKids,
<span class="lineNum">    2208 </span>            :             &quot;Kid hashes of shapes in a property tree.&quot;);
<span class="lineNum">    2209 </span>            :     }
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :     if (sundriesGCHeap &gt; 0) {</span>
<span class="lineNum">    2212 </span>            :         // We deliberately don't use ZCREPORT_GC_BYTES here.
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;sundries/gc-heap&quot;),</span>
<span class="lineNum">    2214 </span>            :             sundriesGCHeap,
<span class="lineNum">    2215 </span>            :             &quot;The sum of all 'gc-heap' measurements that are too small to be &quot;
<span class="lineNum">    2216 </span>            :             &quot;worth showing individually.&quot;);
<span class="lineNum">    2217 </span>            :     }
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :     if (sundriesMallocHeap &gt; 0) {</span>
<span class="lineNum">    2220 </span>            :         // We deliberately don't use ZCREPORT_BYTES here.
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;sundries/malloc-heap&quot;),</span>
<span class="lineNum">    2222 </span>            :             KIND_HEAP, sundriesMallocHeap,
<span class="lineNum">    2223 </span>            :             &quot;The sum of all 'malloc-heap' measurements that are too small to &quot;
<span class="lineNum">    2224 </span>            :             &quot;be worth showing individually.&quot;);
<span class="lineNum">    2225 </span>            :     }
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :     if (gcTotalOut)</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :         *gcTotalOut += gcTotal;</span>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span>            : #   undef STRING_LENGTH
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 : }</span>
<a name="2232"><span class="lineNum">    2232 </span>            : </a>
<span class="lineNum">    2233 </span>            : static void
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 : ReportClassStats(const ClassInfo&amp; classInfo, const nsACString&amp; path,</span>
<span class="lineNum">    2235 </span>            :                  nsIHandleReportCallback* handleReport,
<span class="lineNum">    2236 </span>            :                  nsISupports* data, size_t&amp; gcTotal)
<span class="lineNum">    2237 </span>            : {
<span class="lineNum">    2238 </span>            :     // We deliberately don't use ZCREPORT_BYTES, so that these per-class values
<span class="lineNum">    2239 </span>            :     // don't go into sundries.
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :     if (classInfo.objectsGCHeap &gt; 0) {</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/gc-heap&quot;),</span>
<span class="lineNum">    2243 </span>            :             classInfo.objectsGCHeap,
<span class="lineNum">    2244 </span>            :             &quot;Objects, including fixed slots.&quot;);
<span class="lineNum">    2245 </span>            :     }
<span class="lineNum">    2246 </span>            : 
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapSlots &gt; 0) {</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/slots&quot;),</span>
<span class="lineNum">    2249 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapSlots,
<span class="lineNum">    2250 </span>            :             &quot;Non-fixed object slots.&quot;);
<span class="lineNum">    2251 </span>            :     }
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapElementsNormal &gt; 0) {</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/elements/normal&quot;),</span>
<span class="lineNum">    2255 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapElementsNormal,
<span class="lineNum">    2256 </span>            :             &quot;Normal (non-wasm) indexed elements.&quot;);
<span class="lineNum">    2257 </span>            :     }
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapElementsAsmJS &gt; 0) {</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/elements/asm.js&quot;),</span>
<span class="lineNum">    2261 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapElementsAsmJS,
<span class="lineNum">    2262 </span>            :             &quot;asm.js array buffer elements allocated in the malloc heap.&quot;);
<span class="lineNum">    2263 </span>            :     }
<span class="lineNum">    2264 </span>            : 
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapMisc &gt; 0) {</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/misc&quot;),</span>
<span class="lineNum">    2267 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapMisc,
<span class="lineNum">    2268 </span>            :             &quot;Miscellaneous object data.&quot;);
<span class="lineNum">    2269 </span>            :     }
<span class="lineNum">    2270 </span>            : 
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapElementsNormal &gt; 0) {</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/elements/normal&quot;),</span>
<span class="lineNum">    2273 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapElementsNormal,
<span class="lineNum">    2274 </span>            :             &quot;Memory-mapped non-shared array buffer elements.&quot;);
<span class="lineNum">    2275 </span>            :     }
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapElementsShared &gt; 0) {</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/elements/shared&quot;),</span>
<span class="lineNum">    2279 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapElementsShared,
<span class="lineNum">    2280 </span>            :             &quot;Memory-mapped shared array buffer elements. These elements are &quot;
<span class="lineNum">    2281 </span>            :             &quot;shared between one or more runtimes; the reported size is divided &quot;
<span class="lineNum">    2282 </span>            :             &quot;by the buffer's refcount.&quot;);
<span class="lineNum">    2283 </span>            :     }
<span class="lineNum">    2284 </span>            : 
<span class="lineNum">    2285 </span>            :     // WebAssembly memories are always non-heap-allocated (mmap). We never put
<span class="lineNum">    2286 </span>            :     // these under sundries, because (a) in practice they're almost always
<span class="lineNum">    2287 </span>            :     // larger than the sundries threshold, and (b) we'd need a third category of
<span class="lineNum">    2288 </span>            :     // sundries (&quot;non-heap&quot;), which would be a pain.
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapElementsWasm &gt; 0) {</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/elements/wasm&quot;),</span>
<span class="lineNum">    2291 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapElementsWasm,
<span class="lineNum">    2292 </span>            :             &quot;wasm/asm.js array buffer elements allocated outside both the &quot;
<span class="lineNum">    2293 </span>            :             &quot;malloc heap and the GC heap.&quot;);
<span class="lineNum">    2294 </span>            :     }
<span class="lineNum">    2295 </span>            : 
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapCodeWasm &gt; 0) {</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/code/wasm&quot;),</span>
<span class="lineNum">    2298 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapCodeWasm,
<span class="lineNum">    2299 </span>            :             &quot;AOT-compiled wasm/asm.js code.&quot;);
<span class="lineNum">    2300 </span>            :     }
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span>            :     // Although wasm guard pages aren't committed in memory they can be very
<span class="lineNum">    2303 </span>            :     // large and contribute greatly to vsize and so are worth reporting.
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :     if (classInfo.wasmGuardPages &gt; 0) {</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :         REPORT_BYTES(NS_LITERAL_CSTRING(&quot;wasm-guard-pages&quot;),</span>
<span class="lineNum">    2306 </span>            :             KIND_OTHER, classInfo.wasmGuardPages,
<span class="lineNum">    2307 </span>            :             &quot;Guard pages mapped after the end of wasm memories, reserved for &quot;
<span class="lineNum">    2308 </span>            :             &quot;optimization tricks, but not committed and thus never contributing&quot;
<span class="lineNum">    2309 </span>            :             &quot; to RSS, only vsize.&quot;);
<span class="lineNum">    2310 </span>            :     }
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 : }</span>
<a name="2312"><span class="lineNum">    2312 </span>            : </a>
<span class="lineNum">    2313 </span>            : static void
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 : ReportCompartmentStats(const JS::CompartmentStats&amp; cStats,</span>
<span class="lineNum">    2315 </span>            :                        const xpc::CompartmentStatsExtras&amp; extras,
<span class="lineNum">    2316 </span>            :                        amIAddonManager* addonManager,
<span class="lineNum">    2317 </span>            :                        nsIHandleReportCallback* handleReport,
<span class="lineNum">    2318 </span>            :                        nsISupports* data, size_t* gcTotalOut = nullptr)
<span class="lineNum">    2319 </span>            : {
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :     static const nsDependentCString addonPrefix(&quot;explicit/add-ons/&quot;);</span>
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :     size_t gcTotal = 0, sundriesGCHeap = 0, sundriesMallocHeap = 0;</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :     nsAutoCString cJSPathPrefix(extras.jsPathPrefix);</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :     nsAutoCString cDOMPathPrefix(extras.domPathPrefix);</span>
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span>            :     MOZ_ASSERT(!gcTotalOut == cStats.isTotals);
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            :     // Only attempt to prefix if we got a location and the path wasn't already
<span class="lineNum">    2329 </span>            :     // prefixed.
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :     if (extras.location &amp;&amp; addonManager &amp;&amp;</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :         cJSPathPrefix.Find(addonPrefix, false, 0, 0) != 0) {</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         nsAutoCString addonId;</span>
<span class="lineNum">    2333 </span>            :         bool ok;
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :         if (NS_SUCCEEDED(addonManager-&gt;MapURIToAddonID(extras.location,</span>
<span class="lineNum">    2335 </span>            :                                                         addonId, &amp;ok))
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :             &amp;&amp; ok) {</span>
<span class="lineNum">    2337 </span>            :             // Insert the add-on id as &quot;add-ons/@id@/&quot; after &quot;explicit/&quot; to
<span class="lineNum">    2338 </span>            :             // aggregate add-on compartments.
<span class="lineNum">    2339 </span>            :             static const size_t explicitLength = strlen(&quot;explicit/&quot;);
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :             addonId.Insert(NS_LITERAL_CSTRING(&quot;add-ons/&quot;), 0);</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :             addonId += &quot;/&quot;;</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :             cJSPathPrefix.Insert(addonId, explicitLength);</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :             cDOMPathPrefix.Insert(addonId, explicitLength);</span>
<span class="lineNum">    2344 </span>            :         }
<span class="lineNum">    2345 </span>            :     }
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :     nsCString nonNotablePath = cJSPathPrefix;</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :     nonNotablePath += cStats.isTotals</span>
<span class="lineNum">    2349 </span>            :                     ? NS_LITERAL_CSTRING(&quot;classes/&quot;)
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :                     : NS_LITERAL_CSTRING(&quot;classes/class(&lt;non-notable classes&gt;)/&quot;);</span>
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span>            :     ReportClassStats(cStats.classInfo, nonNotablePath, handleReport, data,
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :                      gcTotal);</span>
<span class="lineNum">    2354 </span>            : 
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; cStats.notableClasses.length(); i++) {</span>
<span class="lineNum">    2356 </span>            :         MOZ_ASSERT(!cStats.isTotals);
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :         const JS::NotableClassInfo&amp; classInfo = cStats.notableClasses[i];</span>
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :         nsCString classPath = cJSPathPrefix +</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :             nsPrintfCString(&quot;classes/class(%s)/&quot;, classInfo.className_);</span>
<span class="lineNum">    2361 </span>            : 
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :         ReportClassStats(classInfo, classPath, handleReport, data, gcTotal);</span>
<span class="lineNum">    2363 </span>            :     }
<span class="lineNum">    2364 </span>            : 
<span class="lineNum">    2365 </span>            :     // Note that we use cDOMPathPrefix here.  This is because we measure orphan
<span class="lineNum">    2366 </span>            :     // DOM nodes in the JS reporter, but we want to report them in a &quot;dom&quot;
<span class="lineNum">    2367 </span>            :     // sub-tree rather than a &quot;js&quot; sub-tree.
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cDOMPathPrefix + NS_LITERAL_CSTRING(&quot;orphan-nodes&quot;),</span>
<span class="lineNum">    2369 </span>            :         cStats.objectsPrivate,
<span class="lineNum">    2370 </span>            :         &quot;Orphan DOM nodes, i.e. those that are only reachable from JavaScript &quot;
<span class="lineNum">    2371 </span>            :         &quot;objects.&quot;);
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;scripts/gc-heap&quot;),</span>
<span class="lineNum">    2374 </span>            :         cStats.scriptsGCHeap,
<span class="lineNum">    2375 </span>            :         &quot;JSScript instances. There is one per user-defined function in a &quot;
<span class="lineNum">    2376 </span>            :         &quot;script, and one for the top-level code in a script.&quot;);
<span class="lineNum">    2377 </span>            : 
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;scripts/malloc-heap/data&quot;),</span>
<span class="lineNum">    2379 </span>            :         cStats.scriptsMallocHeapData,
<span class="lineNum">    2380 </span>            :         &quot;Various variable-length tables in JSScripts.&quot;);
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;baseline/data&quot;),</span>
<span class="lineNum">    2383 </span>            :         cStats.baselineData,
<span class="lineNum">    2384 </span>            :         &quot;The Baseline JIT's compilation data (BaselineScripts).&quot;);
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;baseline/fallback-stubs&quot;),</span>
<span class="lineNum">    2387 </span>            :         cStats.baselineStubsFallback,
<span class="lineNum">    2388 </span>            :         &quot;The Baseline JIT's fallback IC stubs (excluding code).&quot;);
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;ion-data&quot;),</span>
<span class="lineNum">    2391 </span>            :         cStats.ionData,
<span class="lineNum">    2392 </span>            :         &quot;The IonMonkey JIT's compilation data (IonScripts).&quot;);
<span class="lineNum">    2393 </span>            : 
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/type-scripts&quot;),</span>
<span class="lineNum">    2395 </span>            :         cStats.typeInferenceTypeScripts,
<span class="lineNum">    2396 </span>            :         &quot;Type sets associated with scripts.&quot;);
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/allocation-site-tables&quot;),</span>
<span class="lineNum">    2399 </span>            :         cStats.typeInferenceAllocationSiteTables,
<span class="lineNum">    2400 </span>            :         &quot;Tables of type objects associated with allocation sites.&quot;);
<span class="lineNum">    2401 </span>            : 
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/array-type-tables&quot;),</span>
<span class="lineNum">    2403 </span>            :         cStats.typeInferenceArrayTypeTables,
<span class="lineNum">    2404 </span>            :         &quot;Tables of type objects associated with array literals.&quot;);
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/object-type-tables&quot;),</span>
<span class="lineNum">    2407 </span>            :         cStats.typeInferenceObjectTypeTables,
<span class="lineNum">    2408 </span>            :         &quot;Tables of type objects associated with object literals.&quot;);
<span class="lineNum">    2409 </span>            : 
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;compartment-object&quot;),</span>
<span class="lineNum">    2411 </span>            :         cStats.compartmentObject,
<span class="lineNum">    2412 </span>            :         &quot;The JSCompartment object itself.&quot;);
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;compartment-tables&quot;),</span>
<span class="lineNum">    2415 </span>            :         cStats.compartmentTables,
<span class="lineNum">    2416 </span>            :         &quot;Compartment-wide tables storing object group information and wasm instances.&quot;);
<span class="lineNum">    2417 </span>            : 
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;inner-views&quot;),</span>
<span class="lineNum">    2419 </span>            :         cStats.innerViewsTable,
<span class="lineNum">    2420 </span>            :         &quot;The table for array buffer inner views.&quot;);
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;lazy-array-buffers&quot;),</span>
<span class="lineNum">    2423 </span>            :         cStats.lazyArrayBuffersTable,
<span class="lineNum">    2424 </span>            :         &quot;The table for typed object lazy array buffers.&quot;);
<span class="lineNum">    2425 </span>            : 
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;object-metadata&quot;),</span>
<span class="lineNum">    2427 </span>            :         cStats.objectMetadataTable,
<span class="lineNum">    2428 </span>            :         &quot;The table used by debugging tools for tracking object metadata&quot;);
<span class="lineNum">    2429 </span>            : 
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;cross-compartment-wrapper-table&quot;),</span>
<span class="lineNum">    2431 </span>            :         cStats.crossCompartmentWrappersTable,
<span class="lineNum">    2432 </span>            :         &quot;The cross-compartment wrapper table.&quot;);
<span class="lineNum">    2433 </span>            : 
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;regexp-compartment&quot;),</span>
<span class="lineNum">    2435 </span>            :         cStats.regexpCompartment,
<span class="lineNum">    2436 </span>            :         &quot;The regexp compartment and regexp data.&quot;);
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;saved-stacks-set&quot;),</span>
<span class="lineNum">    2439 </span>            :         cStats.savedStacksSet,
<span class="lineNum">    2440 </span>            :         &quot;The saved stacks set.&quot;);
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;non-syntactic-lexical-scopes-table&quot;),</span>
<span class="lineNum">    2443 </span>            :         cStats.nonSyntacticLexicalScopesTable,
<span class="lineNum">    2444 </span>            :         &quot;The non-syntactic lexical scopes table.&quot;);
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;template-literal-map&quot;),</span>
<span class="lineNum">    2447 </span>            :         cStats.templateLiteralMap,
<span class="lineNum">    2448 </span>            :         &quot;The template literal registry.&quot;);
<span class="lineNum">    2449 </span>            : 
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;jit-compartment&quot;),</span>
<span class="lineNum">    2451 </span>            :         cStats.jitCompartment,
<span class="lineNum">    2452 </span>            :         &quot;The JIT compartment.&quot;);
<span class="lineNum">    2453 </span>            : 
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;private-data&quot;),</span>
<span class="lineNum">    2455 </span>            :         cStats.privateData,
<span class="lineNum">    2456 </span>            :         &quot;Extra data attached to the compartment by XPConnect, including &quot;
<span class="lineNum">    2457 </span>            :         &quot;its wrapped-js.&quot;);
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :     if (sundriesGCHeap &gt; 0) {</span>
<span class="lineNum">    2460 </span>            :         // We deliberately don't use ZCREPORT_GC_BYTES here.
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;sundries/gc-heap&quot;),</span>
<span class="lineNum">    2462 </span>            :             sundriesGCHeap,
<span class="lineNum">    2463 </span>            :             &quot;The sum of all 'gc-heap' measurements that are too small to be &quot;
<span class="lineNum">    2464 </span>            :             &quot;worth showing individually.&quot;);
<span class="lineNum">    2465 </span>            :     }
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :     if (sundriesMallocHeap &gt; 0) {</span>
<span class="lineNum">    2468 </span>            :         // We deliberately don't use ZCREPORT_BYTES here.
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :         REPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;sundries/malloc-heap&quot;),</span>
<span class="lineNum">    2470 </span>            :             KIND_HEAP, sundriesMallocHeap,
<span class="lineNum">    2471 </span>            :             &quot;The sum of all 'malloc-heap' measurements that are too small to &quot;
<span class="lineNum">    2472 </span>            :             &quot;be worth showing individually.&quot;);
<span class="lineNum">    2473 </span>            :     }
<span class="lineNum">    2474 </span>            : 
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :     if (gcTotalOut)</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :         *gcTotalOut += gcTotal;</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 : }</span>
<a name="2478"><span class="lineNum">    2478 </span>            : </a>
<span class="lineNum">    2479 </span>            : static void
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 : ReportScriptSourceStats(const ScriptSourceInfo&amp; scriptSourceInfo,</span>
<span class="lineNum">    2481 </span>            :                         const nsACString&amp; path,
<span class="lineNum">    2482 </span>            :                         nsIHandleReportCallback* handleReport,
<span class="lineNum">    2483 </span>            :                         nsISupports* data, size_t&amp; rtTotal)
<span class="lineNum">    2484 </span>            : {
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :     if (scriptSourceInfo.misc &gt; 0) {</span>
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :         RREPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;misc&quot;),</span>
<span class="lineNum">    2487 </span>            :             KIND_HEAP, scriptSourceInfo.misc,
<span class="lineNum">    2488 </span>            :             &quot;Miscellaneous data relating to JavaScript source code.&quot;);
<span class="lineNum">    2489 </span>            :     }
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 : }</span>
<a name="2491"><span class="lineNum">    2491 </span>            : </a>
<span class="lineNum">    2492 </span>            : static void
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 : ReportJSRuntimeExplicitTreeStats(const JS::RuntimeStats&amp; rtStats,</span>
<span class="lineNum">    2494 </span>            :                                  const nsACString&amp; rtPath,
<span class="lineNum">    2495 </span>            :                                  amIAddonManager* addonManager,
<span class="lineNum">    2496 </span>            :                                  nsIHandleReportCallback* handleReport,
<span class="lineNum">    2497 </span>            :                                  nsISupports* data,
<span class="lineNum">    2498 </span>            :                                  bool anonymize,
<span class="lineNum">    2499 </span>            :                                  size_t* rtTotalOut)
<span class="lineNum">    2500 </span>            : {
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :     size_t gcTotal = 0;</span>
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; rtStats.zoneStatsVector.length(); i++) {</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :         const JS::ZoneStats&amp; zStats = rtStats.zoneStatsVector[i];</span>
<span class="lineNum">    2505 </span>            :         const xpc::ZoneStatsExtras* extras =
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :           static_cast&lt;const xpc::ZoneStatsExtras*&gt;(zStats.extra);</span>
<span class="lineNum">    2507 </span>            :         ReportZoneStats(zStats, *extras, handleReport, data, anonymize,
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :                         &amp;gcTotal);</span>
<span class="lineNum">    2509 </span>            :     }
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; rtStats.compartmentStatsVector.length(); i++) {</span>
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :         const JS::CompartmentStats&amp; cStats = rtStats.compartmentStatsVector[i];</span>
<span class="lineNum">    2513 </span>            :         const xpc::CompartmentStatsExtras* extras =
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :             static_cast&lt;const xpc::CompartmentStatsExtras*&gt;(cStats.extra);</span>
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span>            :         ReportCompartmentStats(cStats, *extras, addonManager, handleReport,
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :                                data, &amp;gcTotal);</span>
<span class="lineNum">    2518 </span>            :     }
<span class="lineNum">    2519 </span>            : 
<span class="lineNum">    2520 </span>            :     // Report the rtStats.runtime numbers under &quot;runtime/&quot;, and compute their
<span class="lineNum">    2521 </span>            :     // total for later.
<span class="lineNum">    2522 </span>            : 
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :     size_t rtTotal = 0;</span>
<span class="lineNum">    2524 </span>            : 
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/runtime-object&quot;),</span>
<span class="lineNum">    2526 </span>            :         KIND_HEAP, rtStats.runtime.object,
<span class="lineNum">    2527 </span>            :         &quot;The JSRuntime object.&quot;);
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/atoms-table&quot;),</span>
<span class="lineNum">    2530 </span>            :         KIND_HEAP, rtStats.runtime.atomsTable,
<span class="lineNum">    2531 </span>            :         &quot;The atoms table.&quot;);
<span class="lineNum">    2532 </span>            : 
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/atoms-mark-bitmaps&quot;),</span>
<span class="lineNum">    2534 </span>            :         KIND_HEAP, rtStats.runtime.atomsMarkBitmaps,
<span class="lineNum">    2535 </span>            :         &quot;Mark bitmaps for atoms held by each zone.&quot;);
<span class="lineNum">    2536 </span>            : 
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/contexts&quot;),</span>
<span class="lineNum">    2538 </span>            :         KIND_HEAP, rtStats.runtime.contexts,
<span class="lineNum">    2539 </span>            :         &quot;JSContext objects and structures that belong to them.&quot;);
<span class="lineNum">    2540 </span>            : 
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/temporary&quot;),</span>
<span class="lineNum">    2542 </span>            :         KIND_HEAP, rtStats.runtime.temporary,
<span class="lineNum">    2543 </span>            :         &quot;Transient data (mostly parse nodes) held by the JSRuntime during &quot;
<span class="lineNum">    2544 </span>            :         &quot;compilation.&quot;);
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/interpreter-stack&quot;),</span>
<span class="lineNum">    2547 </span>            :         KIND_HEAP, rtStats.runtime.interpreterStack,
<span class="lineNum">    2548 </span>            :         &quot;JS interpreter frames.&quot;);
<span class="lineNum">    2549 </span>            : 
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/math-cache&quot;),</span>
<span class="lineNum">    2551 </span>            :         KIND_HEAP, rtStats.runtime.mathCache,
<span class="lineNum">    2552 </span>            :         &quot;The math cache.&quot;);
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/shared-immutable-strings-cache&quot;),</span>
<span class="lineNum">    2555 </span>            :         KIND_HEAP, rtStats.runtime.sharedImmutableStringsCache,
<span class="lineNum">    2556 </span>            :         &quot;Immutable strings (such as JS scripts' source text) shared across all JSRuntimes.&quot;);
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/shared-intl-data&quot;),</span>
<span class="lineNum">    2559 </span>            :         KIND_HEAP, rtStats.runtime.sharedIntlData,
<span class="lineNum">    2560 </span>            :         &quot;Shared internationalization data.&quot;);
<span class="lineNum">    2561 </span>            : 
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/uncompressed-source-cache&quot;),</span>
<span class="lineNum">    2563 </span>            :         KIND_HEAP, rtStats.runtime.uncompressedSourceCache,
<span class="lineNum">    2564 </span>            :         &quot;The uncompressed source code cache.&quot;);
<span class="lineNum">    2565 </span>            : 
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/script-data&quot;),</span>
<span class="lineNum">    2567 </span>            :         KIND_HEAP, rtStats.runtime.scriptData,
<span class="lineNum">    2568 </span>            :         &quot;The table holding script data shared in the runtime.&quot;);
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span>            :     nsCString nonNotablePath =
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :         rtPath + nsPrintfCString(&quot;runtime/script-sources/source(scripts=%d, &lt;non-notable files&gt;)/&quot;,</span>
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :                                  rtStats.runtime.scriptSourceInfo.numScripts);</span>
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span>            :     ReportScriptSourceStats(rtStats.runtime.scriptSourceInfo,
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :                             nonNotablePath, handleReport, data, rtTotal);</span>
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; rtStats.runtime.notableScriptSources.length(); i++) {</span>
<span class="lineNum">    2578 </span>            :         const JS::NotableScriptSourceInfo&amp; scriptSourceInfo =
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :             rtStats.runtime.notableScriptSources[i];</span>
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span>            :         // Escape / to \ before we put the filename into the memory reporter
<span class="lineNum">    2582 </span>            :         // path, because we don't want any forward slashes in the string to
<span class="lineNum">    2583 </span>            :         // count as path separators. Consumers of memory reporters (e.g.
<span class="lineNum">    2584 </span>            :         // about:memory) will convert them back to / after doing path
<span class="lineNum">    2585 </span>            :         // splitting.
<span class="lineNum">    2586 </span>            :         nsCString escapedFilename;
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :         if (anonymize) {</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :             escapedFilename.AppendPrintf(&quot;&lt;anonymized-source-%d&gt;&quot;, int(i));</span>
<span class="lineNum">    2589 </span>            :         } else {
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 :             nsDependentCString filename(scriptSourceInfo.filename_);</span>
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :             escapedFilename.Append(filename);</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :             escapedFilename.ReplaceSubstring(&quot;/&quot;, &quot;\\&quot;);</span>
<span class="lineNum">    2593 </span>            :         }
<span class="lineNum">    2594 </span>            : 
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :         nsCString notablePath = rtPath +</span>
<span class="lineNum">    2596 </span>            :             nsPrintfCString(&quot;runtime/script-sources/source(scripts=%d, %s)/&quot;,
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :                             scriptSourceInfo.numScripts, escapedFilename.get());</span>
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span>            :         ReportScriptSourceStats(scriptSourceInfo, notablePath,
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :                                 handleReport, data, rtTotal);</span>
<span class="lineNum">    2601 </span>            :     }
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/ion&quot;),</span>
<span class="lineNum">    2604 </span>            :         KIND_NONHEAP, rtStats.runtime.code.ion,
<span class="lineNum">    2605 </span>            :         &quot;Code generated by the IonMonkey JIT.&quot;);
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/baseline&quot;),</span>
<span class="lineNum">    2608 </span>            :         KIND_NONHEAP, rtStats.runtime.code.baseline,
<span class="lineNum">    2609 </span>            :         &quot;Code generated by the Baseline JIT.&quot;);
<span class="lineNum">    2610 </span>            : 
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/regexp&quot;),</span>
<span class="lineNum">    2612 </span>            :         KIND_NONHEAP, rtStats.runtime.code.regexp,
<span class="lineNum">    2613 </span>            :         &quot;Code generated by the regexp JIT.&quot;);
<span class="lineNum">    2614 </span>            : 
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/other&quot;),</span>
<span class="lineNum">    2616 </span>            :         KIND_NONHEAP, rtStats.runtime.code.other,
<span class="lineNum">    2617 </span>            :         &quot;Code generated by the JITs for wrappers and trampolines.&quot;);
<span class="lineNum">    2618 </span>            : 
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/unused&quot;),</span>
<span class="lineNum">    2620 </span>            :         KIND_NONHEAP, rtStats.runtime.code.unused,
<span class="lineNum">    2621 </span>            :         &quot;Memory allocated by one of the JITs to hold code, but which is &quot;
<span class="lineNum">    2622 </span>            :         &quot;currently unused.&quot;);
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/marker&quot;),</span>
<span class="lineNum">    2625 </span>            :         KIND_HEAP, rtStats.runtime.gc.marker,
<span class="lineNum">    2626 </span>            :         &quot;The GC mark stack and gray roots.&quot;);
<span class="lineNum">    2627 </span>            : 
<span class="lineNum">    2628 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/nursery-committed&quot;),</span>
<span class="lineNum">    2629 </span>            :         KIND_NONHEAP, rtStats.runtime.gc.nurseryCommitted,
<span class="lineNum">    2630 </span>            :         &quot;Memory being used by the GC's nursery.&quot;);
<span class="lineNum">    2631 </span>            : 
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/nursery-malloced-buffers&quot;),</span>
<span class="lineNum">    2633 </span>            :         KIND_HEAP, rtStats.runtime.gc.nurseryMallocedBuffers,
<span class="lineNum">    2634 </span>            :         &quot;Out-of-line slots and elements belonging to objects in the nursery.&quot;);
<span class="lineNum">    2635 </span>            : 
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/vals&quot;),</span>
<span class="lineNum">    2637 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferVals,
<span class="lineNum">    2638 </span>            :         &quot;Values in the store buffer.&quot;);
<span class="lineNum">    2639 </span>            : 
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/cells&quot;),</span>
<span class="lineNum">    2641 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferCells,
<span class="lineNum">    2642 </span>            :         &quot;Cells in the store buffer.&quot;);
<span class="lineNum">    2643 </span>            : 
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/slots&quot;),</span>
<span class="lineNum">    2645 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferSlots,
<span class="lineNum">    2646 </span>            :         &quot;Slots in the store buffer.&quot;);
<span class="lineNum">    2647 </span>            : 
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/whole-cells&quot;),</span>
<span class="lineNum">    2649 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferWholeCells,
<span class="lineNum">    2650 </span>            :         &quot;Whole cells in the store buffer.&quot;);
<span class="lineNum">    2651 </span>            : 
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/generics&quot;),</span>
<span class="lineNum">    2653 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferGenerics,
<span class="lineNum">    2654 </span>            :         &quot;Generic things in the store buffer.&quot;);
<span class="lineNum">    2655 </span>            : 
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :     if (rtTotalOut)</span>
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :         *rtTotalOut = rtTotal;</span>
<span class="lineNum">    2658 </span>            : 
<span class="lineNum">    2659 </span>            :     // Report GC numbers that don't belong to a compartment.
<span class="lineNum">    2660 </span>            : 
<span class="lineNum">    2661 </span>            :     // We don't want to report decommitted memory in &quot;explicit&quot;, so we just
<span class="lineNum">    2662 </span>            :     // change the leading &quot;explicit/&quot; to &quot;decommitted/&quot;.
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :     nsCString rtPath2(rtPath);</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :     rtPath2.Replace(0, strlen(&quot;explicit&quot;), NS_LITERAL_CSTRING(&quot;decommitted&quot;));</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath2 + NS_LITERAL_CSTRING(&quot;gc-heap/decommitted-arenas&quot;),</span>
<span class="lineNum">    2666 </span>            :         rtStats.gcHeapDecommittedArenas,
<span class="lineNum">    2667 </span>            :         &quot;GC arenas in non-empty chunks that is decommitted, i.e. it takes up &quot;
<span class="lineNum">    2668 </span>            :         &quot;address space but no physical memory or swap space.&quot;);
<span class="lineNum">    2669 </span>            : 
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;gc-heap/unused-chunks&quot;),</span>
<span class="lineNum">    2671 </span>            :         rtStats.gcHeapUnusedChunks,
<span class="lineNum">    2672 </span>            :         &quot;Empty GC chunks which will soon be released unless claimed for new &quot;
<span class="lineNum">    2673 </span>            :         &quot;allocations.&quot;);
<span class="lineNum">    2674 </span>            : 
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;gc-heap/unused-arenas&quot;),</span>
<span class="lineNum">    2676 </span>            :         rtStats.gcHeapUnusedArenas,
<span class="lineNum">    2677 </span>            :         &quot;Empty GC arenas within non-empty chunks.&quot;);
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;gc-heap/chunk-admin&quot;),</span>
<span class="lineNum">    2680 </span>            :         rtStats.gcHeapChunkAdmin,
<span class="lineNum">    2681 </span>            :         &quot;Bookkeeping information within GC chunks.&quot;);
<span class="lineNum">    2682 </span>            : 
<span class="lineNum">    2683 </span>            :     // gcTotal is the sum of everything we've reported for the GC heap.  It
<span class="lineNum">    2684 </span>            :     // should equal rtStats.gcHeapChunkTotal.
<span class="lineNum">    2685 </span>            :     MOZ_ASSERT(gcTotal == rtStats.gcHeapChunkTotal);
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 : }</span>
<a name="2687"><span class="lineNum">    2687 </span>            : </a>
<span class="lineNum">    2688 </span>            : void
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 : ReportJSRuntimeExplicitTreeStats(const JS::RuntimeStats&amp; rtStats,</span>
<span class="lineNum">    2690 </span>            :                                  const nsACString&amp; rtPath,
<span class="lineNum">    2691 </span>            :                                  nsIHandleReportCallback* handleReport,
<span class="lineNum">    2692 </span>            :                                  nsISupports* data,
<span class="lineNum">    2693 </span>            :                                  bool anonymize,
<span class="lineNum">    2694 </span>            :                                  size_t* rtTotalOut)
<span class="lineNum">    2695 </span>            : {
<span class="lineNum">    2696 </span>            :     nsCOMPtr&lt;amIAddonManager&gt; am;
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :     if (XRE_IsParentProcess()) {</span>
<span class="lineNum">    2698 </span>            :         // Only try to access the service from the main process.
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :         am = do_GetService(&quot;@mozilla.org/addons/integration;1&quot;);</span>
<span class="lineNum">    2700 </span>            :     }
<span class="lineNum">    2701 </span>            :     ReportJSRuntimeExplicitTreeStats(rtStats, rtPath, am.get(), handleReport,
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :                                      data, anonymize, rtTotalOut);</span>
<span class="lineNum">    2703 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2704 </span>            : 
<span class="lineNum">    2705 </span>            : 
<span class="lineNum">    2706 </span>            : } // namespace xpc
<span class="lineNum">    2707 </span>            : 
<span class="lineNum">    2708 </span><span class="lineCov">        120 : class JSMainRuntimeCompartmentsReporter final : public nsIMemoryReporter</span>
<a name="2709"><span class="lineNum">    2709 </span>            : {</a>
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span><span class="lineCov">         60 :     ~JSMainRuntimeCompartmentsReporter() {}</span>
<span class="lineNum">    2712 </span>            : 
<span class="lineNum">    2713 </span>            :   public:
<a name="2714"><span class="lineNum">    2714 </span>            :     NS_DECL_ISUPPORTS</a>
<span class="lineNum">    2715 </span>            : 
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :     struct Data {</span>
<span class="lineNum">    2717 </span>            :         int anonymizeID;
<span class="lineNum">    2718 </span>            :         js::Vector&lt;nsCString, 0, js::SystemAllocPolicy&gt; paths;
<a name="2719"><span class="lineNum">    2719 </span>            :     };</a>
<span class="lineNum">    2720 </span>            : 
<span class="lineNum">    2721 </span><span class="lineNoCov">          0 :     static void CompartmentCallback(JSContext* cx, void* vdata, JSCompartment* c) {</span>
<span class="lineNum">    2722 </span>            :         // silently ignore OOM errors
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :         Data* data = static_cast&lt;Data*&gt;(vdata);</span>
<span class="lineNum">    2724 </span>            :         nsCString path;
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :         GetCompartmentName(c, path, &amp;data-&gt;anonymizeID, /* replaceSlashes = */ true);</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :         path.Insert(js::IsSystemCompartment(c)</span>
<span class="lineNum">    2727 </span>            :                     ? NS_LITERAL_CSTRING(&quot;js-main-runtime-compartments/system/&quot;)
<span class="lineNum">    2728 </span>            :                     : NS_LITERAL_CSTRING(&quot;js-main-runtime-compartments/user/&quot;),
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :                     0);</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :         mozilla::Unused &lt;&lt; data-&gt;paths.append(path);</span>
<a name="2731"><span class="lineNum">    2731 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2732 </span>            : 
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :     NS_IMETHOD CollectReports(nsIHandleReportCallback* handleReport,</span>
<span class="lineNum">    2734 </span>            :                               nsISupports* data, bool anonymize) override
<span class="lineNum">    2735 </span>            :     {
<span class="lineNum">    2736 </span>            :         // First we collect the compartment paths.  Then we report them.  Doing
<span class="lineNum">    2737 </span>            :         // the two steps interleaved is a bad idea, because calling
<span class="lineNum">    2738 </span>            :         // |handleReport| from within CompartmentCallback() leads to all manner
<span class="lineNum">    2739 </span>            :         // of assertions.
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span><span class="lineNoCov">          0 :         Data d;</span>
<span class="lineNum">    2742 </span><span class="lineNoCov">          0 :         d.anonymizeID = anonymize ? 1 : 0;</span>
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :         JS_IterateCompartments(nsXPConnect::GetContextInstance()-&gt;Context(),</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :                                &amp;d, CompartmentCallback);</span>
<span class="lineNum">    2745 </span>            : 
<span class="lineNum">    2746 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; d.paths.length(); i++)</span>
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :             REPORT(nsCString(d.paths[i]), KIND_OTHER, UNITS_COUNT, 1,</span>
<span class="lineNum">    2748 </span>            :                 &quot;A live compartment in the main JSRuntime.&quot;);
<span class="lineNum">    2749 </span>            : 
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    2751 </span>            :     }
<a name="2752"><span class="lineNum">    2752 </span>            : };</a>
<span class="lineNum">    2753 </span>            : 
<a name="2754"><span class="lineNum">    2754 </span><span class="lineCov">       1200 : NS_IMPL_ISUPPORTS(JSMainRuntimeCompartmentsReporter, nsIMemoryReporter)</span></a>
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 : MOZ_DEFINE_MALLOC_SIZE_OF(OrphanMallocSizeOf)</span>
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span>            : namespace xpc {
<a name="2759"><span class="lineNum">    2759 </span>            : </a>
<span class="lineNum">    2760 </span>            : static size_t
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 : SizeOfTreeIncludingThis(nsINode* tree)</span>
<span class="lineNum">    2762 </span>            : {
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :     size_t n = tree-&gt;SizeOfIncludingThis(OrphanMallocSizeOf);</span>
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :     for (nsIContent* child = tree-&gt;GetFirstChild(); child; child = child-&gt;GetNextNode(tree))</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :         n += child-&gt;SizeOfIncludingThis(OrphanMallocSizeOf);</span>
<span class="lineNum">    2766 </span>            : 
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :     return n;</span>
<a name="2768"><span class="lineNum">    2768 </span>            : }</a>
<span class="lineNum">    2769 </span>            : 
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 : class OrphanReporter : public JS::ObjectPrivateVisitor</span>
<a name="2771"><span class="lineNum">    2771 </span>            : {</a>
<span class="lineNum">    2772 </span>            :   public:
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :     explicit OrphanReporter(GetISupportsFun aGetISupports)</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :       : JS::ObjectPrivateVisitor(aGetISupports)</span>
<span class="lineNum">    2775 </span>            :     {
<a name="2776"><span class="lineNum">    2776 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2777 </span>            : 
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :     virtual size_t sizeOfIncludingThis(nsISupports* aSupports) override {</span>
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :         size_t n = 0;</span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsINode&gt; node = do_QueryInterface(aSupports);</span>
<span class="lineNum">    2781 </span>            :         // https://bugzilla.mozilla.org/show_bug.cgi?id=773533#c11 explains
<span class="lineNum">    2782 </span>            :         // that we have to skip XBL elements because they violate certain
<span class="lineNum">    2783 </span>            :         // assumptions.  Yuk.
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :         if (node &amp;&amp; !node-&gt;IsInUncomposedDoc() &amp;&amp;</span>
<span class="lineNum">    2785 </span><span class="lineNoCov">          0 :             !(node-&gt;IsElement() &amp;&amp; node-&gt;AsElement()-&gt;IsInNamespace(kNameSpaceID_XBL)))</span>
<span class="lineNum">    2786 </span>            :         {
<span class="lineNum">    2787 </span>            :             // This is an orphan node.  If we haven't already handled the
<span class="lineNum">    2788 </span>            :             // sub-tree that this node belongs to, measure the sub-tree's size
<span class="lineNum">    2789 </span>            :             // and then record its root so we don't measure it again.
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 :             nsCOMPtr&lt;nsINode&gt; orphanTree = node-&gt;SubtreeRoot();</span>
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :             if (orphanTree &amp;&amp;</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :                 !mAlreadyMeasuredOrphanTrees.Contains(orphanTree)) {</span>
<span class="lineNum">    2793 </span>            :                 // If PutEntry() fails we don't measure this tree, which could
<span class="lineNum">    2794 </span>            :                 // lead to under-measurement. But that's better than the
<span class="lineNum">    2795 </span>            :                 // alternatives, which are over-measurement or an OOM abort.
<span class="lineNum">    2796 </span><span class="lineNoCov">          0 :                 if (mAlreadyMeasuredOrphanTrees.PutEntry(orphanTree, fallible)) {</span>
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :                     n += SizeOfTreeIncludingThis(orphanTree);</span>
<span class="lineNum">    2798 </span>            :                 }
<span class="lineNum">    2799 </span>            :             }
<span class="lineNum">    2800 </span>            :         }
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :         return n;</span>
<span class="lineNum">    2802 </span>            :     }
<span class="lineNum">    2803 </span>            : 
<span class="lineNum">    2804 </span>            :   private:
<span class="lineNum">    2805 </span>            :     nsTHashtable &lt;nsISupportsHashKey&gt; mAlreadyMeasuredOrphanTrees;
<span class="lineNum">    2806 </span>            : };
<span class="lineNum">    2807 </span>            : 
<span class="lineNum">    2808 </span>            : #ifdef DEBUG
<span class="lineNum">    2809 </span>            : static bool
<span class="lineNum">    2810 </span>            : StartsWithExplicit(nsACString&amp; s)
<span class="lineNum">    2811 </span>            : {
<span class="lineNum">    2812 </span>            :     return StringBeginsWith(s, NS_LITERAL_CSTRING(&quot;explicit/&quot;));
<span class="lineNum">    2813 </span>            : }
<span class="lineNum">    2814 </span>            : #endif
<span class="lineNum">    2815 </span>            : 
<span class="lineNum">    2816 </span>            : class XPCJSContextStats : public JS::RuntimeStats
<span class="lineNum">    2817 </span>            : {
<span class="lineNum">    2818 </span>            :     WindowPaths* mWindowPaths;
<span class="lineNum">    2819 </span>            :     WindowPaths* mTopWindowPaths;
<span class="lineNum">    2820 </span>            :     bool mGetLocations;
<span class="lineNum">    2821 </span>            :     int mAnonymizeID;
<a name="2822"><span class="lineNum">    2822 </span>            : </a>
<span class="lineNum">    2823 </span>            :   public:
<span class="lineNum">    2824 </span><span class="lineNoCov">          0 :     XPCJSContextStats(WindowPaths* windowPaths, WindowPaths* topWindowPaths,</span>
<span class="lineNum">    2825 </span>            :                       bool getLocations, bool anonymize)
<span class="lineNum">    2826 </span>            :       : JS::RuntimeStats(JSMallocSizeOf),
<span class="lineNum">    2827 </span>            :         mWindowPaths(windowPaths),
<span class="lineNum">    2828 </span>            :         mTopWindowPaths(topWindowPaths),
<span class="lineNum">    2829 </span>            :         mGetLocations(getLocations),
<span class="lineNum">    2830 </span><span class="lineNoCov">          0 :         mAnonymizeID(anonymize ? 1 : 0)</span>
<a name="2831"><span class="lineNum">    2831 </span><span class="lineNoCov">          0 :     {}</span></a>
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :     ~XPCJSContextStats() {</span>
<span class="lineNum">    2834 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i != compartmentStatsVector.length(); ++i)</span>
<span class="lineNum">    2835 </span><span class="lineNoCov">          0 :             delete static_cast&lt;xpc::CompartmentStatsExtras*&gt;(compartmentStatsVector[i].extra);</span>
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span>            : 
<span class="lineNum">    2838 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i != zoneStatsVector.length(); ++i)</span>
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :             delete static_cast&lt;xpc::ZoneStatsExtras*&gt;(zoneStatsVector[i].extra);</span>
<a name="2840"><span class="lineNum">    2840 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2841 </span>            : 
<span class="lineNum">    2842 </span><span class="lineNoCov">          0 :     virtual void initExtraZoneStats(JS::Zone* zone, JS::ZoneStats* zStats) override {</span>
<span class="lineNum">    2843 </span>            :         // Get the compartment's global.
<span class="lineNum">    2844 </span><span class="lineNoCov">          0 :         nsXPConnect* xpc = nsXPConnect::XPConnect();</span>
<span class="lineNum">    2845 </span><span class="lineNoCov">          0 :         AutoSafeJSContext cx;</span>
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 :         JSCompartment* comp = js::GetAnyCompartmentInZone(zone);</span>
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :         xpc::ZoneStatsExtras* extras = new xpc::ZoneStatsExtras;</span>
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 :         extras-&gt;pathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :         RootedObject global(cx, JS_GetGlobalForCompartmentOrNull(cx, comp));</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :         if (global) {</span>
<span class="lineNum">    2851 </span>            :             // Need to enter the compartment, otherwise GetNativeOfWrapper()
<span class="lineNum">    2852 </span>            :             // might crash.
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 :             JSAutoCompartment ac(cx, global);</span>
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :             nsISupports* native = xpc-&gt;GetNativeOfWrapper(cx, global);</span>
<span class="lineNum">    2855 </span><span class="lineNoCov">          0 :             if (nsCOMPtr&lt;nsPIDOMWindowInner&gt; piwindow = do_QueryInterface(native)) {</span>
<span class="lineNum">    2856 </span>            :                 // The global is a |window| object.  Use the path prefix that
<span class="lineNum">    2857 </span>            :                 // we should have already created for it.
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :                 if (mTopWindowPaths-&gt;Get(piwindow-&gt;WindowID(),</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :                                          &amp;extras-&gt;pathPrefix))</span>
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :                     extras-&gt;pathPrefix.AppendLiteral(&quot;/js-&quot;);</span>
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2862 </span>            :         }
<span class="lineNum">    2863 </span>            : 
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :         extras-&gt;pathPrefix += nsPrintfCString(&quot;zone(0x%p)/&quot;, (void*)zone);</span>
<span class="lineNum">    2865 </span>            : 
<span class="lineNum">    2866 </span>            :         MOZ_ASSERT(StartsWithExplicit(extras-&gt;pathPrefix));
<span class="lineNum">    2867 </span>            : 
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :         zStats-&gt;extra = extras;</span>
<a name="2869"><span class="lineNum">    2869 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2870 </span>            : 
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :     virtual void initExtraCompartmentStats(JSCompartment* c,</span>
<span class="lineNum">    2872 </span>            :                                            JS::CompartmentStats* cstats) override
<span class="lineNum">    2873 </span>            :     {
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :         xpc::CompartmentStatsExtras* extras = new xpc::CompartmentStatsExtras;</span>
<span class="lineNum">    2875 </span>            :         nsCString cName;
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :         GetCompartmentName(c, cName, &amp;mAnonymizeID, /* replaceSlashes = */ true);</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :         CompartmentPrivate* cp = CompartmentPrivate::Get(c);</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :         if (cp) {</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :             if (mGetLocations) {</span>
<span class="lineNum">    2880 </span>            :                 cp-&gt;GetLocationURI(CompartmentPrivate::LocationHintAddon,
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :                                    getter_AddRefs(extras-&gt;location));</span>
<span class="lineNum">    2882 </span>            :             }
<span class="lineNum">    2883 </span>            :             // Note: cannot use amIAddonManager implementation at this point,
<span class="lineNum">    2884 </span>            :             // as it is a JS service and the JS heap is currently not idle.
<span class="lineNum">    2885 </span>            :             // Otherwise, we could have computed the add-on id at this point.
<span class="lineNum">    2886 </span>            :         }
<span class="lineNum">    2887 </span>            : 
<span class="lineNum">    2888 </span>            :         // Get the compartment's global.
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :         nsXPConnect* xpc = nsXPConnect::XPConnect();</span>
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :         AutoSafeJSContext cx;</span>
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :         bool needZone = true;</span>
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :         RootedObject global(cx, JS_GetGlobalForCompartmentOrNull(cx, c));</span>
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :         if (global) {</span>
<span class="lineNum">    2894 </span>            :             // Need to enter the compartment, otherwise GetNativeOfWrapper()
<span class="lineNum">    2895 </span>            :             // might crash.
<span class="lineNum">    2896 </span><span class="lineNoCov">          0 :             JSAutoCompartment ac(cx, global);</span>
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :             nsISupports* native = xpc-&gt;GetNativeOfWrapper(cx, global);</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :             if (nsCOMPtr&lt;nsPIDOMWindowInner&gt; piwindow = do_QueryInterface(native)) {</span>
<span class="lineNum">    2899 </span>            :                 // The global is a |window| object.  Use the path prefix that
<span class="lineNum">    2900 </span>            :                 // we should have already created for it.
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :                 if (mWindowPaths-&gt;Get(piwindow-&gt;WindowID(),</span>
<span class="lineNum">    2902 </span><span class="lineNoCov">          0 :                                       &amp;extras-&gt;jsPathPrefix)) {</span>
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :                     extras-&gt;domPathPrefix.Assign(extras-&gt;jsPathPrefix);</span>
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :                     extras-&gt;domPathPrefix.AppendLiteral(&quot;/dom/&quot;);</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :                     extras-&gt;jsPathPrefix.AppendLiteral(&quot;/js-&quot;);</span>
<span class="lineNum">    2906 </span><span class="lineNoCov">          0 :                     needZone = false;</span>
<span class="lineNum">    2907 </span>            :                 } else {
<span class="lineNum">    2908 </span><span class="lineNoCov">          0 :                     extras-&gt;jsPathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :                     extras-&gt;domPathPrefix.AssignLiteral(&quot;explicit/dom/unknown-window-global?!/&quot;);</span>
<span class="lineNum">    2910 </span>            :                 }
<span class="lineNum">    2911 </span>            :             } else {
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :                 extras-&gt;jsPathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2913 </span><span class="lineNoCov">          0 :                 extras-&gt;domPathPrefix.AssignLiteral(&quot;explicit/dom/non-window-global?!/&quot;);</span>
<span class="lineNum">    2914 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2915 </span>            :         } else {
<span class="lineNum">    2916 </span><span class="lineNoCov">          0 :             extras-&gt;jsPathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2917 </span><span class="lineNoCov">          0 :             extras-&gt;domPathPrefix.AssignLiteral(&quot;explicit/dom/no-global?!/&quot;);</span>
<span class="lineNum">    2918 </span>            :         }
<span class="lineNum">    2919 </span>            : 
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :         if (needZone)</span>
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :             extras-&gt;jsPathPrefix += nsPrintfCString(&quot;zone(0x%p)/&quot;, (void*)js::GetCompartmentZone(c));</span>
<span class="lineNum">    2922 </span>            : 
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :         extras-&gt;jsPathPrefix += NS_LITERAL_CSTRING(&quot;compartment(&quot;) + cName + NS_LITERAL_CSTRING(&quot;)/&quot;);</span>
<span class="lineNum">    2924 </span>            : 
<span class="lineNum">    2925 </span>            :         // extras-&gt;jsPathPrefix is used for almost all the compartment-specific
<span class="lineNum">    2926 </span>            :         // reports. At this point it has the form
<span class="lineNum">    2927 </span>            :         // &quot;&lt;something&gt;compartment(&lt;cname&gt;)/&quot;.
<span class="lineNum">    2928 </span>            :         //
<span class="lineNum">    2929 </span>            :         // extras-&gt;domPathPrefix is used for DOM orphan nodes, which are
<span class="lineNum">    2930 </span>            :         // counted by the JS reporter but reported as part of the DOM
<span class="lineNum">    2931 </span>            :         // measurements. At this point it has the form &quot;&lt;something&gt;/dom/&quot; if
<span class="lineNum">    2932 </span>            :         // this compartment belongs to an nsGlobalWindow, and
<span class="lineNum">    2933 </span>            :         // &quot;explicit/dom/&lt;something&gt;?!/&quot; otherwise (in which case it shouldn't
<span class="lineNum">    2934 </span>            :         // be used, because non-nsGlobalWindow compartments shouldn't have
<span class="lineNum">    2935 </span>            :         // orphan DOM nodes).
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span>            :         MOZ_ASSERT(StartsWithExplicit(extras-&gt;jsPathPrefix));
<span class="lineNum">    2938 </span>            :         MOZ_ASSERT(StartsWithExplicit(extras-&gt;domPathPrefix));
<span class="lineNum">    2939 </span>            : 
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :         cstats-&gt;extra = extras;</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2942 </span>            : };
<a name="2943"><span class="lineNum">    2943 </span>            : </a>
<span class="lineNum">    2944 </span>            : void
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 : JSReporter::CollectReports(WindowPaths* windowPaths,</span>
<span class="lineNum">    2946 </span>            :                            WindowPaths* topWindowPaths,
<span class="lineNum">    2947 </span>            :                            nsIHandleReportCallback* handleReport,
<span class="lineNum">    2948 </span>            :                            nsISupports* data,
<span class="lineNum">    2949 </span>            :                            bool anonymize)
<span class="lineNum">    2950 </span>            : {
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :     XPCJSContext* xpccx = nsXPConnect::GetContextInstance();</span>
<span class="lineNum">    2952 </span>            : 
<span class="lineNum">    2953 </span>            :     // In the first step we get all the stats and stash them in a local
<span class="lineNum">    2954 </span>            :     // data structure.  In the second step we pass all the stashed stats to
<span class="lineNum">    2955 </span>            :     // the callback.  Separating these steps is important because the
<span class="lineNum">    2956 </span>            :     // callback may be a JS function, and executing JS while getting these
<span class="lineNum">    2957 </span>            :     // stats seems like a bad idea.
<span class="lineNum">    2958 </span>            : 
<span class="lineNum">    2959 </span>            :     nsCOMPtr&lt;amIAddonManager&gt; addonManager;
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :     if (XRE_IsParentProcess()) {</span>
<span class="lineNum">    2961 </span>            :         // Only try to access the service from the main process.
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :         addonManager = do_GetService(&quot;@mozilla.org/addons/integration;1&quot;);</span>
<span class="lineNum">    2963 </span>            :     }
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :     bool getLocations = !!addonManager;</span>
<span class="lineNum">    2965 </span>            :     XPCJSContextStats rtStats(windowPaths, topWindowPaths, getLocations,
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :                               anonymize);</span>
<span class="lineNum">    2967 </span><span class="lineNoCov">          0 :     OrphanReporter orphanReporter(XPCConvert::GetISupportsFromJSObject);</span>
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :     if (!JS::CollectRuntimeStats(xpccx-&gt;Context(), &amp;rtStats, &amp;orphanReporter,</span>
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :                                  anonymize))</span>
<span class="lineNum">    2970 </span>            :     {
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2972 </span>            :     }
<span class="lineNum">    2973 </span>            : 
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :     size_t xpcJSRuntimeSize = xpccx-&gt;SizeOfIncludingThis(JSMallocSizeOf);</span>
<span class="lineNum">    2975 </span>            : 
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :     size_t wrappedJSSize = xpccx-&gt;GetMultiCompartmentWrappedJSMap()-&gt;SizeOfWrappedJS(JSMallocSizeOf);</span>
<span class="lineNum">    2977 </span>            : 
<span class="lineNum">    2978 </span>            :     XPCWrappedNativeScope::ScopeSizeInfo sizeInfo(JSMallocSizeOf);
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope::AddSizeOfAllScopesIncludingThis(&amp;sizeInfo);</span>
<span class="lineNum">    2980 </span>            : 
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :     mozJSComponentLoader* loader = mozJSComponentLoader::Get();</span>
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :     size_t jsComponentLoaderSize = loader ? loader-&gt;SizeOfIncludingThis(JSMallocSizeOf) : 0;</span>
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span>            :     // This is the second step (see above).  First we report stuff in the
<span class="lineNum">    2985 </span>            :     // &quot;explicit&quot; tree, then we report other stuff.
<span class="lineNum">    2986 </span>            : 
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :     size_t rtTotal = 0;</span>
<span class="lineNum">    2988 </span>            :     xpc::ReportJSRuntimeExplicitTreeStats(rtStats,
<span class="lineNum">    2989 </span>            :                                           NS_LITERAL_CSTRING(&quot;explicit/js-non-window/&quot;),
<span class="lineNum">    2990 </span>            :                                           addonManager, handleReport, data,
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :                                           anonymize, &amp;rtTotal);</span>
<span class="lineNum">    2992 </span>            : 
<span class="lineNum">    2993 </span>            :     // Report the sums of the compartment numbers.
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :     xpc::CompartmentStatsExtras cExtrasTotal;</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :     cExtrasTotal.jsPathPrefix.AssignLiteral(&quot;js-main-runtime/compartments/&quot;);</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :     cExtrasTotal.domPathPrefix.AssignLiteral(&quot;window-objects/dom/&quot;);</span>
<span class="lineNum">    2997 </span>            :     ReportCompartmentStats(rtStats.cTotals, cExtrasTotal, addonManager,
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :                            handleReport, data);</span>
<span class="lineNum">    2999 </span>            : 
<span class="lineNum">    3000 </span>            :     xpc::ZoneStatsExtras zExtrasTotal;
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :     zExtrasTotal.pathPrefix.AssignLiteral(&quot;js-main-runtime/zones/&quot;);</span>
<span class="lineNum">    3002 </span>            :     ReportZoneStats(rtStats.zTotals, zExtrasTotal, handleReport, data,
<span class="lineNum">    3003 </span><span class="lineNoCov">          0 :                     anonymize);</span>
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span>            :     // Report the sum of the runtime/ numbers.
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/runtime&quot;),</span>
<span class="lineNum">    3007 </span>            :         KIND_OTHER, rtTotal,
<span class="lineNum">    3008 </span>            :         &quot;The sum of all measurements under 'explicit/js-non-window/runtime/'.&quot;);
<span class="lineNum">    3009 </span>            : 
<span class="lineNum">    3010 </span>            :     // Report the numbers for memory outside of compartments.
<span class="lineNum">    3011 </span>            : 
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/gc-heap/unused-chunks&quot;),</span>
<span class="lineNum">    3013 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedChunks,
<span class="lineNum">    3014 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-chunks'.&quot;);
<span class="lineNum">    3015 </span>            : 
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/gc-heap/unused-arenas&quot;),</span>
<span class="lineNum">    3017 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedArenas,
<span class="lineNum">    3018 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-arenas'.&quot;);
<span class="lineNum">    3019 </span>            : 
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/gc-heap/chunk-admin&quot;),</span>
<span class="lineNum">    3021 </span>            :         KIND_OTHER, rtStats.gcHeapChunkAdmin,
<span class="lineNum">    3022 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/chunk-admin'.&quot;);
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span>            :     // Report a breakdown of the committed GC space.
<span class="lineNum">    3025 </span>            : 
<span class="lineNum">    3026 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/chunks&quot;),</span>
<span class="lineNum">    3027 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedChunks,
<span class="lineNum">    3028 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-chunks'.&quot;);
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/arenas&quot;),</span>
<span class="lineNum">    3031 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedArenas,
<span class="lineNum">    3032 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-arenas'.&quot;);
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/objects&quot;),</span>
<span class="lineNum">    3035 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.object,
<span class="lineNum">    3036 </span>            :         &quot;Unused object cells within non-empty arenas.&quot;);
<span class="lineNum">    3037 </span>            : 
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/strings&quot;),</span>
<span class="lineNum">    3039 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.string,
<span class="lineNum">    3040 </span>            :         &quot;Unused string cells within non-empty arenas.&quot;);
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/symbols&quot;),</span>
<span class="lineNum">    3043 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.symbol,
<span class="lineNum">    3044 </span>            :         &quot;Unused symbol cells within non-empty arenas.&quot;);
<span class="lineNum">    3045 </span>            : 
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/shapes&quot;),</span>
<span class="lineNum">    3047 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.shape,
<span class="lineNum">    3048 </span>            :         &quot;Unused shape cells within non-empty arenas.&quot;);
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/base-shapes&quot;),</span>
<span class="lineNum">    3051 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.baseShape,
<span class="lineNum">    3052 </span>            :         &quot;Unused base shape cells within non-empty arenas.&quot;);
<span class="lineNum">    3053 </span>            : 
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/object-groups&quot;),</span>
<span class="lineNum">    3055 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.objectGroup,
<span class="lineNum">    3056 </span>            :         &quot;Unused object group cells within non-empty arenas.&quot;);
<span class="lineNum">    3057 </span>            : 
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/scopes&quot;),</span>
<span class="lineNum">    3059 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.scope,
<span class="lineNum">    3060 </span>            :         &quot;Unused scope cells within non-empty arenas.&quot;);
<span class="lineNum">    3061 </span>            : 
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/scripts&quot;),</span>
<span class="lineNum">    3063 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.script,
<span class="lineNum">    3064 </span>            :         &quot;Unused script cells within non-empty arenas.&quot;);
<span class="lineNum">    3065 </span>            : 
<span class="lineNum">    3066 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/lazy-scripts&quot;),</span>
<span class="lineNum">    3067 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.lazyScript,
<span class="lineNum">    3068 </span>            :         &quot;Unused lazy script cells within non-empty arenas.&quot;);
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/jitcode&quot;),</span>
<span class="lineNum">    3071 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.jitcode,
<span class="lineNum">    3072 </span>            :         &quot;Unused jitcode cells within non-empty arenas.&quot;);
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/regexp-shareds&quot;),</span>
<span class="lineNum">    3075 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.regExpShared,
<span class="lineNum">    3076 </span>            :         &quot;Unused regexpshared cells within non-empty arenas.&quot;);
<span class="lineNum">    3077 </span>            : 
<span class="lineNum">    3078 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/chunk-admin&quot;),</span>
<span class="lineNum">    3079 </span>            :         KIND_OTHER, rtStats.gcHeapChunkAdmin,
<span class="lineNum">    3080 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/chunk-admin'.&quot;);
<span class="lineNum">    3081 </span>            : 
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/arena-admin&quot;),</span>
<span class="lineNum">    3083 </span>            :         KIND_OTHER, rtStats.zTotals.gcHeapArenaAdmin,
<span class="lineNum">    3084 </span>            :         &quot;The same as 'js-main-runtime/zones/gc-heap-arena-admin'.&quot;);
<span class="lineNum">    3085 </span>            : 
<span class="lineNum">    3086 </span><span class="lineNoCov">          0 :     size_t gcThingTotal = 0;</span>
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/objects&quot;),</span>
<span class="lineNum">    3089 </span>            :         KIND_OTHER, rtStats.cTotals.classInfo.objectsGCHeap,
<span class="lineNum">    3090 </span>            :         &quot;Used object cells.&quot;);
<span class="lineNum">    3091 </span>            : 
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/strings&quot;),</span>
<span class="lineNum">    3093 </span>            :         KIND_OTHER, rtStats.zTotals.stringInfo.sizeOfLiveGCThings(),
<span class="lineNum">    3094 </span>            :         &quot;Used string cells.&quot;);
<span class="lineNum">    3095 </span>            : 
<span class="lineNum">    3096 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/symbols&quot;),</span>
<span class="lineNum">    3097 </span>            :         KIND_OTHER, rtStats.zTotals.symbolsGCHeap,
<span class="lineNum">    3098 </span>            :         &quot;Used symbol cells.&quot;);
<span class="lineNum">    3099 </span>            : 
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/shapes&quot;),</span>
<span class="lineNum">    3101 </span>            :         KIND_OTHER,
<span class="lineNum">    3102 </span>            :         rtStats.zTotals.shapeInfo.shapesGCHeapTree + rtStats.zTotals.shapeInfo.shapesGCHeapDict,
<span class="lineNum">    3103 </span>            :         &quot;Used shape cells.&quot;);
<span class="lineNum">    3104 </span>            : 
<span class="lineNum">    3105 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/base-shapes&quot;),</span>
<span class="lineNum">    3106 </span>            :         KIND_OTHER, rtStats.zTotals.shapeInfo.shapesGCHeapBase,
<span class="lineNum">    3107 </span>            :         &quot;Used base shape cells.&quot;);
<span class="lineNum">    3108 </span>            : 
<span class="lineNum">    3109 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/object-groups&quot;),</span>
<span class="lineNum">    3110 </span>            :         KIND_OTHER, rtStats.zTotals.objectGroupsGCHeap,
<span class="lineNum">    3111 </span>            :         &quot;Used object group cells.&quot;);
<span class="lineNum">    3112 </span>            : 
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/scopes&quot;),</span>
<span class="lineNum">    3114 </span>            :         KIND_OTHER, rtStats.zTotals.scopesGCHeap,
<span class="lineNum">    3115 </span>            :         &quot;Used scope cells.&quot;);
<span class="lineNum">    3116 </span>            : 
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/scripts&quot;),</span>
<span class="lineNum">    3118 </span>            :         KIND_OTHER, rtStats.cTotals.scriptsGCHeap,
<span class="lineNum">    3119 </span>            :         &quot;Used script cells.&quot;);
<span class="lineNum">    3120 </span>            : 
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/lazy-scripts&quot;),</span>
<span class="lineNum">    3122 </span>            :         KIND_OTHER, rtStats.zTotals.lazyScriptsGCHeap,
<span class="lineNum">    3123 </span>            :         &quot;Used lazy script cells.&quot;);
<span class="lineNum">    3124 </span>            : 
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/jitcode&quot;),</span>
<span class="lineNum">    3126 </span>            :         KIND_OTHER, rtStats.zTotals.jitCodesGCHeap,
<span class="lineNum">    3127 </span>            :         &quot;Used jitcode cells.&quot;);
<span class="lineNum">    3128 </span>            : 
<span class="lineNum">    3129 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/regexp-shareds&quot;),</span>
<span class="lineNum">    3130 </span>            :         KIND_OTHER, rtStats.zTotals.regExpSharedsGCHeap,
<span class="lineNum">    3131 </span>            :         &quot;Used regexpshared cells.&quot;);
<span class="lineNum">    3132 </span>            : 
<span class="lineNum">    3133 </span>            :     MOZ_ASSERT(gcThingTotal == rtStats.gcHeapGCThings);
<span class="lineNum">    3134 </span>            : 
<span class="lineNum">    3135 </span>            :     // Report xpconnect.
<span class="lineNum">    3136 </span>            : 
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/runtime&quot;),</span>
<span class="lineNum">    3138 </span>            :         KIND_HEAP, xpcJSRuntimeSize,
<span class="lineNum">    3139 </span>            :         &quot;The XPConnect runtime.&quot;);
<span class="lineNum">    3140 </span>            : 
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/wrappedjs&quot;),</span>
<span class="lineNum">    3142 </span>            :         KIND_HEAP, wrappedJSSize,
<span class="lineNum">    3143 </span>            :         &quot;Wrappers used to implement XPIDL interfaces with JS.&quot;);
<span class="lineNum">    3144 </span>            : 
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/scopes&quot;),</span>
<span class="lineNum">    3146 </span>            :         KIND_HEAP, sizeInfo.mScopeAndMapSize,
<span class="lineNum">    3147 </span>            :         &quot;XPConnect scopes.&quot;);
<span class="lineNum">    3148 </span>            : 
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/proto-iface-cache&quot;),</span>
<span class="lineNum">    3150 </span>            :         KIND_HEAP, sizeInfo.mProtoAndIfaceCacheSize,
<span class="lineNum">    3151 </span>            :         &quot;Prototype and interface binding caches.&quot;);
<span class="lineNum">    3152 </span>            : 
<span class="lineNum">    3153 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/js-component-loader&quot;),</span>
<span class="lineNum">    3154 </span>            :         KIND_HEAP, jsComponentLoaderSize,
<span class="lineNum">    3155 </span>            :         &quot;XPConnect's JS component loader.&quot;);
<span class="lineNum">    3156 </span>            : }
<a name="3157"><span class="lineNum">    3157 </span>            : </a>
<span class="lineNum">    3158 </span>            : static nsresult
<span class="lineNum">    3159 </span><span class="lineNoCov">          0 : JSSizeOfTab(JSObject* objArg, size_t* jsObjectsSize, size_t* jsStringsSize,</span>
<span class="lineNum">    3160 </span>            :             size_t* jsPrivateSize, size_t* jsOtherSize)
<span class="lineNum">    3161 </span>            : {
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :     JSContext* cx = nsXPConnect::GetContextInstance()-&gt;Context();</span>
<span class="lineNum">    3163 </span><span class="lineNoCov">          0 :     JS::RootedObject obj(cx, objArg);</span>
<span class="lineNum">    3164 </span>            : 
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :     TabSizes sizes;</span>
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 :     OrphanReporter orphanReporter(XPCConvert::GetISupportsFromJSObject);</span>
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(JS::AddSizeOfTab(cx, obj, moz_malloc_size_of,</span>
<span class="lineNum">    3168 </span>            :                                     &amp;orphanReporter, &amp;sizes),
<span class="lineNum">    3169 </span>            :                    NS_ERROR_OUT_OF_MEMORY);
<span class="lineNum">    3170 </span>            : 
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 :     *jsObjectsSize = sizes.objects;</span>
<span class="lineNum">    3172 </span><span class="lineNoCov">          0 :     *jsStringsSize = sizes.strings;</span>
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :     *jsPrivateSize = sizes.private_;</span>
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 :     *jsOtherSize   = sizes.other;</span>
<span class="lineNum">    3175 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    3176 </span>            : }
<span class="lineNum">    3177 </span>            : 
<span class="lineNum">    3178 </span>            : } // namespace xpc
<a name="3179"><span class="lineNum">    3179 </span>            : </a>
<span class="lineNum">    3180 </span>            : static void
<span class="lineNum">    3181 </span><span class="lineCov">       6240 : AccumulateTelemetryCallback(int id, uint32_t sample, const char* key)</span>
<span class="lineNum">    3182 </span>            : {
<span class="lineNum">    3183 </span><span class="lineCov">       6240 :     switch (id) {</span>
<span class="lineNum">    3184 </span>            :       case JS_TELEMETRY_GC_REASON:
<span class="lineNum">    3185 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_REASON_2, sample);</span>
<span class="lineNum">    3186 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3187 </span>            :       case JS_TELEMETRY_GC_IS_ZONE_GC:
<span class="lineNum">    3188 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_IS_COMPARTMENTAL, sample);</span>
<span class="lineNum">    3189 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3190 </span>            :       case JS_TELEMETRY_GC_MS:
<span class="lineNum">    3191 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_MS, sample);</span>
<span class="lineNum">    3192 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3193 </span>            :       case JS_TELEMETRY_GC_BUDGET_MS:
<span class="lineNum">    3194 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_BUDGET_MS, sample);</span>
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3196 </span>            :       case JS_TELEMETRY_GC_ANIMATION_MS:
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_ANIMATION_MS, sample);</span>
<span class="lineNum">    3198 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3199 </span>            :       case JS_TELEMETRY_GC_MAX_PAUSE_MS:
<span class="lineNum">    3200 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_MAX_PAUSE_MS, sample);</span>
<span class="lineNum">    3201 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3202 </span>            :       case JS_TELEMETRY_GC_MARK_MS:
<span class="lineNum">    3203 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_MARK_MS, sample);</span>
<span class="lineNum">    3204 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3205 </span>            :       case JS_TELEMETRY_GC_SWEEP_MS:
<span class="lineNum">    3206 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_SWEEP_MS, sample);</span>
<span class="lineNum">    3207 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3208 </span>            :       case JS_TELEMETRY_GC_COMPACT_MS:
<span class="lineNum">    3209 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_COMPACT_MS, sample);</span>
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3211 </span>            :       case JS_TELEMETRY_GC_MARK_ROOTS_MS:
<span class="lineNum">    3212 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_MARK_ROOTS_MS, sample);</span>
<span class="lineNum">    3213 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3214 </span>            :       case JS_TELEMETRY_GC_MARK_GRAY_MS:
<span class="lineNum">    3215 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_MARK_GRAY_MS, sample);</span>
<span class="lineNum">    3216 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3217 </span>            :       case JS_TELEMETRY_GC_SLICE_MS:
<span class="lineNum">    3218 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_SLICE_MS, sample);</span>
<span class="lineNum">    3219 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3220 </span>            :       case JS_TELEMETRY_GC_SLOW_PHASE:
<span class="lineNum">    3221 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_SLOW_PHASE, sample);</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3223 </span>            :       case JS_TELEMETRY_GC_MMU_50:
<span class="lineNum">    3224 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_MMU_50, sample);</span>
<span class="lineNum">    3225 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3226 </span>            :       case JS_TELEMETRY_GC_RESET:
<span class="lineNum">    3227 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_RESET, sample);</span>
<span class="lineNum">    3228 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3229 </span>            :       case JS_TELEMETRY_GC_RESET_REASON:
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_RESET_REASON, sample);</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3232 </span>            :       case JS_TELEMETRY_GC_INCREMENTAL_DISABLED:
<span class="lineNum">    3233 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_INCREMENTAL_DISABLED, sample);</span>
<span class="lineNum">    3234 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3235 </span>            :       case JS_TELEMETRY_GC_NON_INCREMENTAL:
<span class="lineNum">    3236 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_NON_INCREMENTAL, sample);</span>
<span class="lineNum">    3237 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3238 </span>            :       case JS_TELEMETRY_GC_NON_INCREMENTAL_REASON:
<span class="lineNum">    3239 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_NON_INCREMENTAL_REASON, sample);</span>
<span class="lineNum">    3240 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3241 </span>            :       case JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS:
<span class="lineNum">    3242 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_SCC_SWEEP_TOTAL_MS, sample);</span>
<span class="lineNum">    3243 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3244 </span>            :       case JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS:
<span class="lineNum">    3245 </span><span class="lineCov">        300 :         Telemetry::Accumulate(Telemetry::GC_SCC_SWEEP_MAX_PAUSE_MS, sample);</span>
<span class="lineNum">    3246 </span><span class="lineCov">        300 :         break;</span>
<span class="lineNum">    3247 </span>            :       case JS_TELEMETRY_GC_MINOR_REASON:
<span class="lineNum">    3248 </span><span class="lineCov">        360 :         Telemetry::Accumulate(Telemetry::GC_MINOR_REASON, sample);</span>
<span class="lineNum">    3249 </span><span class="lineCov">        360 :         break;</span>
<span class="lineNum">    3250 </span>            :       case JS_TELEMETRY_GC_MINOR_REASON_LONG:
<span class="lineNum">    3251 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MINOR_REASON_LONG, sample);</span>
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3253 </span>            :       case JS_TELEMETRY_GC_MINOR_US:
<span class="lineNum">    3254 </span><span class="lineCov">        360 :         Telemetry::Accumulate(Telemetry::GC_MINOR_US, sample);</span>
<span class="lineNum">    3255 </span><span class="lineCov">        360 :         break;</span>
<span class="lineNum">    3256 </span>            :       case JS_TELEMETRY_GC_NURSERY_BYTES:
<span class="lineNum">    3257 </span><span class="lineCov">        360 :         Telemetry::Accumulate(Telemetry::GC_NURSERY_BYTES, sample);</span>
<span class="lineNum">    3258 </span><span class="lineCov">        360 :         break;</span>
<span class="lineNum">    3259 </span>            :       case JS_TELEMETRY_GC_PRETENURE_COUNT:
<span class="lineNum">    3260 </span><span class="lineCov">        360 :         Telemetry::Accumulate(Telemetry::GC_PRETENURE_COUNT, sample);</span>
<span class="lineNum">    3261 </span><span class="lineCov">        360 :         break;</span>
<span class="lineNum">    3262 </span>            :       case JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT:
<span class="lineNum">    3263 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT, sample);</span>
<span class="lineNum">    3264 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3265 </span>            :       case JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS:
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS, sample);</span>
<span class="lineNum">    3267 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3268 </span>            :       case JS_TELEMETRY_ADDON_EXCEPTIONS:
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_TELEMETRY_ADDON_EXCEPTIONS, nsDependentCString(key), sample);</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3271 </span>            :       case JS_TELEMETRY_AOT_USAGE:
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_AOT_USAGE, sample);</span>
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3274 </span>            :       case JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS:
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS, sample);</span>
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3277 </span>            :       case JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS:
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_WEB_PARSER_COMPILE_LAZY_AFTER_MS, sample);</span>
<span class="lineNum">    3279 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3280 </span>            :       default:
<span class="lineNum">    3281 </span>            :         MOZ_ASSERT_UNREACHABLE(&quot;Unexpected JS_TELEMETRY id&quot;);
<span class="lineNum">    3282 </span>            :     }
<span class="lineNum">    3283 </span><span class="lineCov">       6240 : }</span>
<a name="3284"><span class="lineNum">    3284 </span>            : </a>
<span class="lineNum">    3285 </span>            : static void
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 : CompartmentNameCallback(JSContext* cx, JSCompartment* comp,</span>
<span class="lineNum">    3287 </span>            :                         char* buf, size_t bufsize)
<span class="lineNum">    3288 </span>            : {
<span class="lineNum">    3289 </span>            :     nsCString name;
<span class="lineNum">    3290 </span>            :     // This is called via the JSAPI and isn't involved in memory reporting, so
<span class="lineNum">    3291 </span>            :     // we don't need to anonymize compartment names.
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :     int anonymizeID = 0;</span>
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :     GetCompartmentName(comp, name, &amp;anonymizeID, /* replaceSlashes = */ false);</span>
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :     if (name.Length() &gt;= bufsize)</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :         name.Truncate(bufsize - 1);</span>
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :     memcpy(buf, name.get(), name.Length() + 1);</span>
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 : }</span>
<a name="3298"><span class="lineNum">    3298 </span>            : </a>
<span class="lineNum">    3299 </span>            : static bool
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 : PreserveWrapper(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    3301 </span>            : {
<span class="lineNum">    3302 </span>            :     MOZ_ASSERT(cx);
<span class="lineNum">    3303 </span>            :     MOZ_ASSERT(obj);
<span class="lineNum">    3304 </span>            :     MOZ_ASSERT(IS_WN_REFLECTOR(obj) || mozilla::dom::IsDOMObject(obj));
<span class="lineNum">    3305 </span>            : 
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :     return mozilla::dom::IsDOMObject(obj) &amp;&amp; mozilla::dom::TryPreserveWrapper(obj);</span>
<span class="lineNum">    3307 </span>            : }
<a name="3308"><span class="lineNum">    3308 </span>            : </a>
<span class="lineNum">    3309 </span>            : static nsresult
<span class="lineNum">    3310 </span><span class="lineNoCov">          0 : ReadSourceFromFilename(JSContext* cx, const char* filename, char16_t** src, size_t* len)</span>
<span class="lineNum">    3311 </span>            : {
<span class="lineNum">    3312 </span>            :     nsresult rv;
<span class="lineNum">    3313 </span>            : 
<span class="lineNum">    3314 </span>            :     // mozJSSubScriptLoader prefixes the filenames of the scripts it loads with
<span class="lineNum">    3315 </span>            :     // the filename of its caller. Axe that if present.
<span class="lineNum">    3316 </span>            :     const char* arrow;
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :     while ((arrow = strstr(filename, &quot; -&gt; &quot;)))</span>
<span class="lineNum">    3318 </span><span class="lineNoCov">          0 :         filename = arrow + strlen(&quot; -&gt; &quot;);</span>
<span class="lineNum">    3319 </span>            : 
<span class="lineNum">    3320 </span>            :     // Get the URI.
<span class="lineNum">    3321 </span>            :     nsCOMPtr&lt;nsIURI&gt; uri;
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :     rv = NS_NewURI(getter_AddRefs(uri), filename);</span>
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3324 </span>            : 
<span class="lineNum">    3325 </span>            :     nsCOMPtr&lt;nsIChannel&gt; scriptChannel;
<span class="lineNum">    3326 </span>            :     rv = NS_NewChannel(getter_AddRefs(scriptChannel),
<span class="lineNum">    3327 </span>            :                        uri,
<span class="lineNum">    3328 </span>            :                        nsContentUtils::GetSystemPrincipal(),
<span class="lineNum">    3329 </span>            :                        nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL,
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :                        nsIContentPolicy::TYPE_OTHER);</span>
<span class="lineNum">    3331 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3332 </span>            : 
<span class="lineNum">    3333 </span>            :     // Only allow local reading.
<span class="lineNum">    3334 </span>            :     nsCOMPtr&lt;nsIURI&gt; actualUri;
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 :     rv = scriptChannel-&gt;GetURI(getter_AddRefs(actualUri));</span>
<span class="lineNum">    3336 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3337 </span>            :     nsCString scheme;
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 :     rv = actualUri-&gt;GetScheme(scheme);</span>
<span class="lineNum">    3339 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3340 </span><span class="lineNoCov">          0 :     if (!scheme.EqualsLiteral(&quot;file&quot;) &amp;&amp; !scheme.EqualsLiteral(&quot;jar&quot;))</span>
<span class="lineNum">    3341 </span>            :         return NS_OK;
<span class="lineNum">    3342 </span>            : 
<span class="lineNum">    3343 </span>            :     // Explicitly set the content type so that we don't load the
<span class="lineNum">    3344 </span>            :     // exthandler to guess it.
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :     scriptChannel-&gt;SetContentType(NS_LITERAL_CSTRING(&quot;text/plain&quot;));</span>
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span>            :     nsCOMPtr&lt;nsIInputStream&gt; scriptStream;
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :     rv = scriptChannel-&gt;Open2(getter_AddRefs(scriptStream));</span>
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3350 </span>            : 
<span class="lineNum">    3351 </span>            :     uint64_t rawLen;
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :     rv = scriptStream-&gt;Available(&amp;rawLen);</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :     if (!rawLen)</span>
<span class="lineNum">    3355 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">    3356 </span>            : 
<span class="lineNum">    3357 </span>            :     // Technically, this should be SIZE_MAX, but we don't run on machines
<span class="lineNum">    3358 </span>            :     // where that would be less than UINT32_MAX, and the latter is already
<span class="lineNum">    3359 </span>            :     // well beyond a reasonable limit.
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 :     if (rawLen &gt; UINT32_MAX)</span>
<span class="lineNum">    3361 </span>            :         return NS_ERROR_FILE_TOO_BIG;
<span class="lineNum">    3362 </span>            : 
<span class="lineNum">    3363 </span>            :     // Allocate an internal buf the size of the file.
<span class="lineNum">    3364 </span><span class="lineNoCov">          0 :     auto buf = MakeUniqueFallible&lt;unsigned char[]&gt;(rawLen);</span>
<span class="lineNum">    3365 </span><span class="lineNoCov">          0 :     if (!buf)</span>
<span class="lineNum">    3366 </span>            :         return NS_ERROR_OUT_OF_MEMORY;
<span class="lineNum">    3367 </span>            : 
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :     unsigned char* ptr = buf.get();</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :     unsigned char* end = ptr + rawLen;</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :     while (ptr &lt; end) {</span>
<span class="lineNum">    3371 </span>            :         uint32_t bytesRead;
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :         rv = scriptStream-&gt;Read(reinterpret_cast&lt;char*&gt;(ptr), end - ptr, &amp;bytesRead);</span>
<span class="lineNum">    3373 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv))</span>
<span class="lineNum">    3374 </span><span class="lineNoCov">          0 :             return rv;</span>
<span class="lineNum">    3375 </span>            :         MOZ_ASSERT(bytesRead &gt; 0, &quot;stream promised more bytes before EOF&quot;);
<span class="lineNum">    3376 </span><span class="lineNoCov">          0 :         ptr += bytesRead;</span>
<span class="lineNum">    3377 </span>            :     }
<span class="lineNum">    3378 </span>            : 
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :     rv = nsScriptLoader::ConvertToUTF16(scriptChannel, buf.get(), rawLen, EmptyString(),</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :                                         nullptr, *src, *len);</span>
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    3382 </span>            : 
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :     if (!*src)</span>
<span class="lineNum">    3384 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">    3385 </span>            : 
<span class="lineNum">    3386 </span>            :     // Historically this method used JS_malloc() which updates the GC memory
<span class="lineNum">    3387 </span>            :     // accounting.  Since ConvertToUTF16() now uses js_malloc() instead we
<span class="lineNum">    3388 </span>            :     // update the accounting manually after the fact.
<span class="lineNum">    3389 </span><span class="lineNoCov">          0 :     JS_updateMallocCounter(cx, *len);</span>
<span class="lineNum">    3390 </span>            : 
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    3392 </span>            : }
<span class="lineNum">    3393 </span>            : 
<span class="lineNum">    3394 </span>            : // The JS engine calls this object's 'load' member function when it needs
<a name="3395"><span class="lineNum">    3395 </span>            : // the source for a chrome JS function. See the comment in the XPCJSContext</a>
<a name="3396"><span class="lineNum">    3396 </span>            : // constructor.</a>
<span class="lineNum">    3397 </span><span class="lineCov">        300 : class XPCJSSourceHook: public js::SourceHook {</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :     bool load(JSContext* cx, const char* filename, char16_t** src, size_t* length) {</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :         *src = nullptr;</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :         *length = 0;</span>
<span class="lineNum">    3401 </span>            : 
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :         if (!nsContentUtils::IsSystemCaller(cx))</span>
<span class="lineNum">    3403 </span>            :             return true;
<span class="lineNum">    3404 </span>            : 
<span class="lineNum">    3405 </span><span class="lineNoCov">          0 :         if (!filename)</span>
<span class="lineNum">    3406 </span>            :             return true;
<span class="lineNum">    3407 </span>            : 
<span class="lineNum">    3408 </span><span class="lineNoCov">          0 :         nsresult rv = ReadSourceFromFilename(cx, filename, src, length);</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 :             xpc::Throw(cx, rv);</span>
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3412 </span>            :         }
<span class="lineNum">    3413 </span>            : 
<span class="lineNum">    3414 </span>            :         return true;
<span class="lineNum">    3415 </span>            :     }
<span class="lineNum">    3416 </span>            : };
<span class="lineNum">    3417 </span>            : 
<span class="lineNum">    3418 </span>            : static const JSWrapObjectCallbacks WrapObjectCallbacks = {
<span class="lineNum">    3419 </span>            :     xpc::WrapperFactory::Rewrap,
<span class="lineNum">    3420 </span>            :     xpc::WrapperFactory::PrepareForWrapping
<a name="3421"><span class="lineNum">    3421 </span>            : };</a>
<span class="lineNum">    3422 </span>            : 
<span class="lineNum">    3423 </span><span class="lineCov">         60 : XPCJSContext::XPCJSContext()</span>
<span class="lineNum">    3424 </span>            :  : mCallContext(nullptr),
<span class="lineNum">    3425 </span>            :    mAutoRoots(nullptr),
<span class="lineNum">    3426 </span>            :    mResolveName(JSID_VOID),
<span class="lineNum">    3427 </span>            :    mResolvingWrapper(nullptr),
<span class="lineNum">    3428 </span><span class="lineCov">         60 :    mWrappedJSMap(JSObject2WrappedJSMap::newMap(XPC_JS_MAP_LENGTH)),</span>
<span class="lineNum">    3429 </span><span class="lineCov">         60 :    mWrappedJSClassMap(IID2WrappedJSClassMap::newMap(XPC_JS_CLASS_MAP_LENGTH)),</span>
<span class="lineNum">    3430 </span><span class="lineCov">         60 :    mIID2NativeInterfaceMap(IID2NativeInterfaceMap::newMap(XPC_NATIVE_INTERFACE_MAP_LENGTH)),</span>
<span class="lineNum">    3431 </span><span class="lineCov">         60 :    mClassInfo2NativeSetMap(ClassInfo2NativeSetMap::newMap(XPC_NATIVE_SET_MAP_LENGTH)),</span>
<span class="lineNum">    3432 </span><span class="lineCov">         60 :    mNativeSetMap(NativeSetMap::newMap(XPC_NATIVE_SET_MAP_LENGTH)),</span>
<span class="lineNum">    3433 </span><span class="lineCov">         60 :    mThisTranslatorMap(IID2ThisTranslatorMap::newMap(XPC_THIS_TRANSLATOR_MAP_LENGTH)),</span>
<span class="lineNum">    3434 </span><span class="lineCov">         60 :    mDyingWrappedNativeProtoMap(XPCWrappedNativeProtoMap::newMap(XPC_DYING_NATIVE_PROTO_MAP_LENGTH)),</span>
<span class="lineNum">    3435 </span>            :    mGCIsRunning(false),
<span class="lineNum">    3436 </span>            :    mNativesToReleaseArray(),
<span class="lineNum">    3437 </span>            :    mDoingFinalization(false),
<span class="lineNum">    3438 </span>            :    mVariantRoots(nullptr),
<span class="lineNum">    3439 </span>            :    mWrappedJSRoots(nullptr),
<span class="lineNum">    3440 </span>            :    mObjectHolderRoots(nullptr),
<span class="lineNum">    3441 </span><span class="lineCov">         60 :    mWatchdogManager(new WatchdogManager(this)),</span>
<span class="lineNum">    3442 </span>            :    mAsyncSnowWhiteFreer(new AsyncFreeSnowWhite()),
<span class="lineNum">    3443 </span>            :    mSlowScriptSecondHalf(false),
<span class="lineNum">    3444 </span>            :    mTimeoutAccumulated(false),
<span class="lineNum">    3445 </span><span class="lineCov">        900 :    mPendingResult(NS_OK)</span>
<span class="lineNum">    3446 </span>            : {
<span class="lineNum">    3447 </span><span class="lineCov">         60 : }</span>
<span class="lineNum">    3448 </span>            : 
<span class="lineNum">    3449 </span>            : #ifdef XP_WIN
<span class="lineNum">    3450 </span>            : static size_t
<span class="lineNum">    3451 </span>            : GetWindowsStackSize()
<span class="lineNum">    3452 </span>            : {
<span class="lineNum">    3453 </span>            :     // First, get the stack base. Because the stack grows down, this is the top
<span class="lineNum">    3454 </span>            :     // of the stack.
<span class="lineNum">    3455 </span>            :     const uint8_t* stackTop;
<span class="lineNum">    3456 </span>            : #ifdef _WIN64
<span class="lineNum">    3457 </span>            :     PNT_TIB64 pTib = reinterpret_cast&lt;PNT_TIB64&gt;(NtCurrentTeb());
<span class="lineNum">    3458 </span>            :     stackTop = reinterpret_cast&lt;const uint8_t*&gt;(pTib-&gt;StackBase);
<span class="lineNum">    3459 </span>            : #else
<span class="lineNum">    3460 </span>            :     PNT_TIB pTib = reinterpret_cast&lt;PNT_TIB&gt;(NtCurrentTeb());
<span class="lineNum">    3461 </span>            :     stackTop = reinterpret_cast&lt;const uint8_t*&gt;(pTib-&gt;StackBase);
<span class="lineNum">    3462 </span>            : #endif
<span class="lineNum">    3463 </span>            : 
<span class="lineNum">    3464 </span>            :     // Now determine the stack bottom. Note that we can't use tib-&gt;StackLimit,
<span class="lineNum">    3465 </span>            :     // because that's the size of the committed area and we're also interested
<span class="lineNum">    3466 </span>            :     // in the reserved pages below that.
<span class="lineNum">    3467 </span>            :     MEMORY_BASIC_INFORMATION mbi;
<span class="lineNum">    3468 </span>            :     if (!VirtualQuery(&amp;mbi, &amp;mbi, sizeof(mbi)))
<span class="lineNum">    3469 </span>            :         MOZ_CRASH(&quot;VirtualQuery failed&quot;);
<span class="lineNum">    3470 </span>            : 
<span class="lineNum">    3471 </span>            :     const uint8_t* stackBottom = reinterpret_cast&lt;const uint8_t*&gt;(mbi.AllocationBase);
<span class="lineNum">    3472 </span>            : 
<span class="lineNum">    3473 </span>            :     // Do some sanity checks.
<span class="lineNum">    3474 </span>            :     size_t stackSize = size_t(stackTop - stackBottom);
<span class="lineNum">    3475 </span>            :     MOZ_RELEASE_ASSERT(stackSize &gt;= 1 * 1024 * 1024);
<span class="lineNum">    3476 </span>            :     MOZ_RELEASE_ASSERT(stackSize &lt;= 32 * 1024 * 1024);
<span class="lineNum">    3477 </span>            : 
<span class="lineNum">    3478 </span>            :     // Subtract 40 KB (Win32) or 80 KB (Win64) to account for things like
<span class="lineNum">    3479 </span>            :     // the guard page and large PGO stack frames.
<span class="lineNum">    3480 </span>            :     return stackSize - 10 * sizeof(uintptr_t) * 1024;
<span class="lineNum">    3481 </span>            : }
<span class="lineNum">    3482 </span>            : #endif
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span>            : nsresult
<span class="lineNum">    3485 </span><span class="lineCov">         60 : XPCJSContext::Initialize()</span>
<span class="lineNum">    3486 </span>            : {
<span class="lineNum">    3487 </span>            :     nsresult rv = CycleCollectedJSContext::Initialize(nullptr,
<span class="lineNum">    3488 </span>            :                                                       JS::DefaultHeapMaxBytes,
<span class="lineNum">    3489 </span><span class="lineCov">         60 :                                                       JS::DefaultNurseryBytes);</span>
<span class="lineNum">    3490 </span><span class="lineCov">         60 :     if (NS_WARN_IF(NS_FAILED(rv))) {</span>
<span class="lineNum">    3491 </span>            :       return rv;
<span class="lineNum">    3492 </span>            :     }
<span class="lineNum">    3493 </span>            : 
<span class="lineNum">    3494 </span>            :     MOZ_ASSERT(Context());
<span class="lineNum">    3495 </span><span class="lineCov">         60 :     JSContext* cx = Context();</span>
<span class="lineNum">    3496 </span>            : 
<span class="lineNum">    3497 </span><span class="lineCov">         60 :     mUnprivilegedJunkScope.init(cx, nullptr);</span>
<span class="lineNum">    3498 </span><span class="lineCov">         60 :     mPrivilegedJunkScope.init(cx, nullptr);</span>
<span class="lineNum">    3499 </span><span class="lineCov">         60 :     mCompilationScope.init(cx, nullptr);</span>
<span class="lineNum">    3500 </span>            : 
<span class="lineNum">    3501 </span>            :     // these jsids filled in later when we have a JSContext to work with.
<span class="lineNum">    3502 </span><span class="lineCov">         60 :     mStrIDs[0] = JSID_VOID;</span>
<span class="lineNum">    3503 </span>            : 
<span class="lineNum">    3504 </span><span class="lineCov">         60 :     auto cxPrivate = new PerThreadAtomCache();</span>
<span class="lineNum">    3505 </span><span class="lineCov">         60 :     memset(cxPrivate, 0, sizeof(PerThreadAtomCache));</span>
<span class="lineNum">    3506 </span><span class="lineCov">         60 :     JS_SetContextPrivate(cx, cxPrivate);</span>
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span>            :     // Unconstrain the runtime's threshold on nominal heap size, to avoid
<span class="lineNum">    3509 </span>            :     // triggering GC too often if operating continuously near an arbitrary
<span class="lineNum">    3510 </span>            :     // finite threshold (0xffffffff is infinity for uint32_t parameters).
<span class="lineNum">    3511 </span>            :     // This leaves the maximum-JS_malloc-bytes threshold still in effect
<span class="lineNum">    3512 </span>            :     // to cause period, and we hope hygienic, last-ditch GCs from within
<span class="lineNum">    3513 </span>            :     // the GC's allocator.
<span class="lineNum">    3514 </span><span class="lineCov">         60 :     JS_SetGCParameter(cx, JSGC_MAX_BYTES, 0xffffffff);</span>
<span class="lineNum">    3515 </span>            : 
<span class="lineNum">    3516 </span>            :     // The JS engine permits us to set different stack limits for system code,
<span class="lineNum">    3517 </span>            :     // trusted script, and untrusted script. We have tests that ensure that
<span class="lineNum">    3518 </span>            :     // we can always execute 10 &quot;heavy&quot; (eval+with) stack frames deeper in
<span class="lineNum">    3519 </span>            :     // privileged code. Our stack sizes vary greatly in different configurations,
<span class="lineNum">    3520 </span>            :     // so satisfying those tests requires some care. Manual measurements of the
<span class="lineNum">    3521 </span>            :     // number of heavy stack frames achievable gives us the following rough data,
<span class="lineNum">    3522 </span>            :     // ordered by the effective categories in which they are grouped in the
<span class="lineNum">    3523 </span>            :     // JS_SetNativeStackQuota call (which predates this analysis).
<span class="lineNum">    3524 </span>            :     //
<span class="lineNum">    3525 </span>            :     // (NB: These numbers may have drifted recently - see bug 938429)
<span class="lineNum">    3526 </span>            :     // OSX 64-bit Debug: 7MB stack, 636 stack frames =&gt; ~11.3k per stack frame
<span class="lineNum">    3527 </span>            :     // OSX64 Opt: 7MB stack, 2440 stack frames =&gt; ~3k per stack frame
<span class="lineNum">    3528 </span>            :     //
<span class="lineNum">    3529 </span>            :     // Linux 32-bit Debug: 2MB stack, 426 stack frames =&gt; ~4.8k per stack frame
<span class="lineNum">    3530 </span>            :     // Linux 64-bit Debug: 4MB stack, 455 stack frames =&gt; ~9.0k per stack frame
<span class="lineNum">    3531 </span>            :     //
<span class="lineNum">    3532 </span>            :     // Windows (Opt+Debug): 900K stack, 235 stack frames =&gt; ~3.4k per stack frame
<span class="lineNum">    3533 </span>            :     //
<span class="lineNum">    3534 </span>            :     // Linux 32-bit Opt: 1MB stack, 272 stack frames =&gt; ~3.8k per stack frame
<span class="lineNum">    3535 </span>            :     // Linux 64-bit Opt: 2MB stack, 316 stack frames =&gt; ~6.5k per stack frame
<span class="lineNum">    3536 </span>            :     //
<span class="lineNum">    3537 </span>            :     // We tune the trusted/untrusted quotas for each configuration to achieve our
<span class="lineNum">    3538 </span>            :     // invariants while attempting to minimize overhead. In contrast, our buffer
<span class="lineNum">    3539 </span>            :     // between system code and trusted script is a very unscientific 10k.
<span class="lineNum">    3540 </span><span class="lineCov">         60 :     const size_t kSystemCodeBuffer = 10 * 1024;</span>
<span class="lineNum">    3541 </span>            : 
<span class="lineNum">    3542 </span>            :     // Our &quot;default&quot; stack is what we use in configurations where we don't have
<span class="lineNum">    3543 </span>            :     // a compelling reason to do things differently. This is effectively 512KB
<span class="lineNum">    3544 </span>            :     // on 32-bit platforms and 1MB on 64-bit platforms.
<span class="lineNum">    3545 </span><span class="lineCov">         60 :     const size_t kDefaultStackQuota = 128 * sizeof(size_t) * 1024;</span>
<span class="lineNum">    3546 </span>            : 
<span class="lineNum">    3547 </span>            :     // Set stack sizes for different configurations. It's probably not great for
<span class="lineNum">    3548 </span>            :     // the web to base this decision primarily on the default stack size that the
<span class="lineNum">    3549 </span>            :     // underlying platform makes available, but that seems to be what we do. :-(
<span class="lineNum">    3550 </span>            : 
<span class="lineNum">    3551 </span>            : #if defined(XP_MACOSX) || defined(DARWIN)
<span class="lineNum">    3552 </span>            :     // MacOS has a gargantuan default stack size of 8MB. Go wild with 7MB,
<span class="lineNum">    3553 </span>            :     // and give trusted script 180k extra. The stack is huge on mac anyway.
<span class="lineNum">    3554 </span>            :     const size_t kStackQuota = 7 * 1024 * 1024;
<span class="lineNum">    3555 </span>            :     const size_t kTrustedScriptBuffer = 180 * 1024;
<span class="lineNum">    3556 </span>            : #elif defined(MOZ_ASAN)
<span class="lineNum">    3557 </span>            :     // ASan requires more stack space due to red-zones, so give it double the
<span class="lineNum">    3558 </span>            :     // default (1MB on 32-bit, 2MB on 64-bit). ASAN stack frame measurements
<span class="lineNum">    3559 </span>            :     // were not taken at the time of this writing, so we hazard a guess that
<span class="lineNum">    3560 </span>            :     // ASAN builds have roughly thrice the stack overhead as normal builds.
<span class="lineNum">    3561 </span>            :     // On normal builds, the largest stack frame size we might encounter is
<span class="lineNum">    3562 </span>            :     // 9.0k (see above), so let's use a buffer of 9.0 * 5 * 10 = 450k.
<span class="lineNum">    3563 </span>            :     const size_t kStackQuota =  2 * kDefaultStackQuota;
<span class="lineNum">    3564 </span>            :     const size_t kTrustedScriptBuffer = 450 * 1024;
<span class="lineNum">    3565 </span>            : #elif defined(XP_WIN)
<span class="lineNum">    3566 </span>            :     // 1MB is the default stack size on Windows. We use the /STACK linker flag
<span class="lineNum">    3567 </span>            :     // to request a larger stack, so we determine the stack size at runtime.
<span class="lineNum">    3568 </span>            :     const size_t kStackQuota = GetWindowsStackSize();
<span class="lineNum">    3569 </span>            :     const size_t kTrustedScriptBuffer = (sizeof(size_t) == 8) ? 180 * 1024   //win64
<span class="lineNum">    3570 </span>            :                                                               : 120 * 1024;  //win32
<span class="lineNum">    3571 </span>            :     // The following two configurations are linux-only. Given the numbers above,
<span class="lineNum">    3572 </span>            :     // we use 50k and 100k trusted buffers on 32-bit and 64-bit respectively.
<span class="lineNum">    3573 </span>            : #elif defined(ANDROID)
<span class="lineNum">    3574 </span>            :     // Android appears to have 1MB stacks. Allow the use of 3/4 of that size
<span class="lineNum">    3575 </span>            :     // (768KB on 32-bit), since otherwise we can crash with a stack overflow
<span class="lineNum">    3576 </span>            :     // when nearing the 1MB limit.
<span class="lineNum">    3577 </span>            :     const size_t kStackQuota = kDefaultStackQuota + kDefaultStackQuota / 2;
<span class="lineNum">    3578 </span>            :     const size_t kTrustedScriptBuffer = sizeof(size_t) * 12800;
<span class="lineNum">    3579 </span>            : #elif defined(DEBUG)
<span class="lineNum">    3580 </span>            :     // Bug 803182: account for the 4x difference in the size of js::Interpret
<span class="lineNum">    3581 </span>            :     // between optimized and debug builds.
<span class="lineNum">    3582 </span>            :     // XXXbholley - Then why do we only account for 2x of difference?
<span class="lineNum">    3583 </span>            :     const size_t kStackQuota = 2 * kDefaultStackQuota;
<span class="lineNum">    3584 </span>            :     const size_t kTrustedScriptBuffer = sizeof(size_t) * 12800;
<span class="lineNum">    3585 </span>            : #else
<span class="lineNum">    3586 </span><span class="lineCov">         60 :     const size_t kStackQuota = kDefaultStackQuota;</span>
<span class="lineNum">    3587 </span><span class="lineCov">         60 :     const size_t kTrustedScriptBuffer = sizeof(size_t) * 12800;</span>
<span class="lineNum">    3588 </span>            : #endif
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            :     // Avoid an unused variable warning on platforms where we don't use the
<span class="lineNum">    3591 </span>            :     // default.
<span class="lineNum">    3592 </span>            :     (void) kDefaultStackQuota;
<span class="lineNum">    3593 </span>            : 
<span class="lineNum">    3594 </span>            :     JS_SetNativeStackQuota(cx,
<span class="lineNum">    3595 </span>            :                            kStackQuota,
<span class="lineNum">    3596 </span>            :                            kStackQuota - kSystemCodeBuffer,
<span class="lineNum">    3597 </span><span class="lineCov">         60 :                            kStackQuota - kSystemCodeBuffer - kTrustedScriptBuffer);</span>
<span class="lineNum">    3598 </span>            : 
<span class="lineNum">    3599 </span><span class="lineCov">         60 :     JS_SetDestroyCompartmentCallback(cx, CompartmentDestroyedCallback);</span>
<span class="lineNum">    3600 </span><span class="lineCov">         60 :     JS_SetSizeOfIncludingThisCompartmentCallback(cx, CompartmentSizeOfIncludingThisCallback);</span>
<span class="lineNum">    3601 </span><span class="lineCov">         60 :     JS_SetCompartmentNameCallback(cx, CompartmentNameCallback);</span>
<span class="lineNum">    3602 </span><span class="lineCov">         60 :     mPrevGCSliceCallback = JS::SetGCSliceCallback(cx, GCSliceCallback);</span>
<span class="lineNum">    3603 </span>            :     mPrevDoCycleCollectionCallback = JS::SetDoCycleCollectionCallback(cx,
<span class="lineNum">    3604 </span><span class="lineCov">         60 :             DoCycleCollectionCallback);</span>
<span class="lineNum">    3605 </span><span class="lineCov">         60 :     JS_AddFinalizeCallback(cx, FinalizeCallback, nullptr);</span>
<span class="lineNum">    3606 </span><span class="lineCov">         60 :     JS_AddWeakPointerZonesCallback(cx, WeakPointerZonesCallback, this);</span>
<span class="lineNum">    3607 </span><span class="lineCov">         60 :     JS_AddWeakPointerCompartmentCallback(cx, WeakPointerCompartmentCallback, this);</span>
<span class="lineNum">    3608 </span><span class="lineCov">         60 :     JS_SetWrapObjectCallbacks(cx, &amp;WrapObjectCallbacks);</span>
<span class="lineNum">    3609 </span><span class="lineCov">         60 :     js::SetPreserveWrapperCallback(cx, PreserveWrapper);</span>
<span class="lineNum">    3610 </span>            : #ifdef MOZ_GECKO_PROFILER
<span class="lineNum">    3611 </span><span class="lineCov">         60 :     profiler_set_js_context(cx);</span>
<span class="lineNum">    3612 </span>            : #endif
<span class="lineNum">    3613 </span><span class="lineCov">         60 :     JS_SetAccumulateTelemetryCallback(cx, AccumulateTelemetryCallback);</span>
<span class="lineNum">    3614 </span><span class="lineCov">         60 :     js::SetActivityCallback(cx, ActivityCallback, this);</span>
<span class="lineNum">    3615 </span><span class="lineCov">         60 :     JS_AddInterruptCallback(cx, InterruptCallback);</span>
<span class="lineNum">    3616 </span><span class="lineCov">         60 :     js::SetWindowProxyClass(cx, &amp;OuterWindowProxyClass);</span>
<span class="lineNum">    3617 </span><span class="lineCov">         60 :     JS::SetProcessLargeAllocationFailureCallback(OnLargeAllocationFailureCallback);</span>
<span class="lineNum">    3618 </span>            : 
<span class="lineNum">    3619 </span>            :     // The JS engine needs to keep the source code around in order to implement
<span class="lineNum">    3620 </span>            :     // Function.prototype.toSource(). It'd be nice to not have to do this for
<span class="lineNum">    3621 </span>            :     // chrome code and simply stub out requests for source on it. Life is not so
<span class="lineNum">    3622 </span>            :     // easy, unfortunately. Nobody relies on chrome toSource() working in core
<span class="lineNum">    3623 </span>            :     // browser code, but chrome tests use it. The worst offenders are addons,
<span class="lineNum">    3624 </span>            :     // which like to monkeypatch chrome functions by calling toSource() on them
<span class="lineNum">    3625 </span>            :     // and using regular expressions to modify them. We avoid keeping most browser
<span class="lineNum">    3626 </span>            :     // JS source code in memory by setting LAZY_SOURCE on JS::CompileOptions when
<span class="lineNum">    3627 </span>            :     // compiling some chrome code. This causes the JS engine not save the source
<span class="lineNum">    3628 </span>            :     // code in memory. When the JS engine is asked to provide the source for a
<span class="lineNum">    3629 </span>            :     // function compiled with LAZY_SOURCE, it calls SourceHook to load it.
<span class="lineNum">    3630 </span>            :     ///
<span class="lineNum">    3631 </span>            :     // Note we do have to retain the source code in memory for scripts compiled in
<span class="lineNum">    3632 </span>            :     // isRunOnce mode and compiled function bodies (from
<span class="lineNum">    3633 </span>            :     // JS::CompileFunction). In practice, this means content scripts and event
<span class="lineNum">    3634 </span>            :     // handlers.
<span class="lineNum">    3635 </span><span class="lineCov">         60 :     mozilla::UniquePtr&lt;XPCJSSourceHook&gt; hook(new XPCJSSourceHook);</span>
<span class="lineNum">    3636 </span><span class="lineCov">        120 :     js::SetSourceHook(cx, Move(hook));</span>
<span class="lineNum">    3637 </span>            : 
<span class="lineNum">    3638 </span>            :     // Set up locale information and callbacks for the newly-created context so
<span class="lineNum">    3639 </span>            :     // that the various toLocaleString() methods, localeCompare(), and other
<span class="lineNum">    3640 </span>            :     // internationalization APIs work as desired.
<span class="lineNum">    3641 </span><span class="lineCov">         60 :     if (!xpc_LocalizeContext(cx))</span>
<span class="lineNum">    3642 </span><span class="lineNoCov">          0 :         NS_RUNTIMEABORT(&quot;xpc_LocalizeContext failed.&quot;);</span>
<span class="lineNum">    3643 </span>            : 
<span class="lineNum">    3644 </span>            :     // Register memory reporters and distinguished amount functions.
<span class="lineNum">    3645 </span><span class="lineCov">        120 :     RegisterStrongMemoryReporter(new JSMainRuntimeCompartmentsReporter());</span>
<span class="lineNum">    3646 </span><span class="lineCov">        120 :     RegisterStrongMemoryReporter(new JSMainRuntimeTemporaryPeakReporter());</span>
<span class="lineNum">    3647 </span><span class="lineCov">         60 :     RegisterJSMainRuntimeGCHeapDistinguishedAmount(JSMainRuntimeGCHeapDistinguishedAmount);</span>
<span class="lineNum">    3648 </span><span class="lineCov">         60 :     RegisterJSMainRuntimeTemporaryPeakDistinguishedAmount(JSMainRuntimeTemporaryPeakDistinguishedAmount);</span>
<span class="lineNum">    3649 </span><span class="lineCov">         60 :     RegisterJSMainRuntimeCompartmentsSystemDistinguishedAmount(JSMainRuntimeCompartmentsSystemDistinguishedAmount);</span>
<span class="lineNum">    3650 </span><span class="lineCov">         60 :     RegisterJSMainRuntimeCompartmentsUserDistinguishedAmount(JSMainRuntimeCompartmentsUserDistinguishedAmount);</span>
<span class="lineNum">    3651 </span><span class="lineCov">         60 :     mozilla::RegisterJSSizeOfTab(JSSizeOfTab);</span>
<span class="lineNum">    3652 </span>            : 
<span class="lineNum">    3653 </span>            :     // Watch for the JS boolean options.
<span class="lineNum">    3654 </span><span class="lineCov">         60 :     ReloadPrefsCallback(nullptr, this);</span>
<span class="lineNum">    3655 </span>            :     Preferences::RegisterPrefixCallback(ReloadPrefsCallback,
<span class="lineNum">    3656 </span><span class="lineCov">         60 :                                         JS_OPTIONS_DOT_STR, this);</span>
<span class="lineNum">    3657 </span>            : 
<span class="lineNum">    3658 </span>            : #ifdef FUZZING
<span class="lineNum">    3659 </span>            :     Preferences::RegisterCallback(ReloadPrefsCallback, &quot;fuzzing.enabled&quot;, this);
<span class="lineNum">    3660 </span>            : #endif
<span class="lineNum">    3661 </span>            : 
<span class="lineNum">    3662 </span><span class="lineCov">         60 :     return NS_OK;</span>
<span class="lineNum">    3663 </span>            : }
<span class="lineNum">    3664 </span>            : 
<a name="3665"><span class="lineNum">    3665 </span>            : // static</a>
<span class="lineNum">    3666 </span>            : XPCJSContext*
<span class="lineNum">    3667 </span><span class="lineCov">         60 : XPCJSContext::newXPCJSContext()</span>
<span class="lineNum">    3668 </span>            : {
<span class="lineNum">    3669 </span><span class="lineCov">         60 :     XPCJSContext* self = new XPCJSContext();</span>
<span class="lineNum">    3670 </span><span class="lineCov">         60 :     nsresult rv = self-&gt;Initialize();</span>
<span class="lineNum">    3671 </span><span class="lineCov">         60 :     if (NS_FAILED(rv)) {</span>
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :         NS_RUNTIMEABORT(&quot;new XPCJSContext failed to initialize.&quot;);</span>
<span class="lineNum">    3673 </span><span class="lineNoCov">          0 :         delete self;</span>
<span class="lineNum">    3674 </span>            :         return nullptr;
<span class="lineNum">    3675 </span>            :     }
<span class="lineNum">    3676 </span>            : 
<span class="lineNum">    3677 </span><span class="lineCov">        180 :     if (self-&gt;Context()                         &amp;&amp;</span>
<span class="lineNum">    3678 </span><span class="lineCov">        120 :         self-&gt;GetMultiCompartmentWrappedJSMap() &amp;&amp;</span>
<span class="lineNum">    3679 </span><span class="lineCov">        120 :         self-&gt;GetWrappedJSClassMap()            &amp;&amp;</span>
<span class="lineNum">    3680 </span><span class="lineCov">        120 :         self-&gt;GetIID2NativeInterfaceMap()       &amp;&amp;</span>
<span class="lineNum">    3681 </span><span class="lineCov">        120 :         self-&gt;GetClassInfo2NativeSetMap()       &amp;&amp;</span>
<span class="lineNum">    3682 </span><span class="lineCov">        120 :         self-&gt;GetNativeSetMap()                 &amp;&amp;</span>
<span class="lineNum">    3683 </span><span class="lineCov">        120 :         self-&gt;GetThisTranslatorMap()            &amp;&amp;</span>
<span class="lineNum">    3684 </span><span class="lineCov">        180 :         self-&gt;GetDyingWrappedNativeProtoMap()   &amp;&amp;</span>
<span class="lineNum">    3685 </span><span class="lineCov">         60 :         self-&gt;mWatchdogManager) {</span>
<span class="lineNum">    3686 </span>            :         return self;
<span class="lineNum">    3687 </span>            :     }
<span class="lineNum">    3688 </span>            : 
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :     NS_RUNTIMEABORT(&quot;new XPCJSContext failed to initialize.&quot;);</span>
<span class="lineNum">    3690 </span>            : 
<span class="lineNum">    3691 </span><span class="lineNoCov">          0 :     delete self;</span>
<span class="lineNum">    3692 </span>            :     return nullptr;
<span class="lineNum">    3693 </span>            : }
<a name="3694"><span class="lineNum">    3694 </span>            : </a>
<span class="lineNum">    3695 </span>            : bool
<span class="lineNum">    3696 </span><span class="lineCov">         60 : XPCJSContext::JSContextInitialized(JSContext* cx)</span>
<span class="lineNum">    3697 </span>            : {
<span class="lineNum">    3698 </span><span class="lineCov">         60 :     JSAutoRequest ar(cx);</span>
<span class="lineNum">    3699 </span>            : 
<span class="lineNum">    3700 </span>            :     // if it is our first context then we need to generate our string ids
<span class="lineNum">    3701 </span><span class="lineCov">         60 :     if (JSID_IS_VOID(mStrIDs[0])) {</span>
<span class="lineNum">    3702 </span><span class="lineCov">         60 :         RootedString str(cx);</span>
<span class="lineNum">    3703 </span><span class="lineCov">       1860 :         for (unsigned i = 0; i &lt; IDX_TOTAL_COUNT; i++) {</span>
<span class="lineNum">    3704 </span><span class="lineCov">       3600 :             str = JS_AtomizeAndPinString(cx, mStrings[i]);</span>
<span class="lineNum">    3705 </span><span class="lineCov">       1800 :             if (!str) {</span>
<span class="lineNum">    3706 </span><span class="lineNoCov">          0 :                 mStrIDs[0] = JSID_VOID;</span>
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    3708 </span>            :             }
<span class="lineNum">    3709 </span><span class="lineCov">       1800 :             mStrIDs[i] = INTERNED_STRING_TO_JSID(cx, str);</span>
<span class="lineNum">    3710 </span><span class="lineCov">       1800 :             mStrJSVals[i].setString(str);</span>
<span class="lineNum">    3711 </span>            :         }
<span class="lineNum">    3712 </span>            : 
<span class="lineNum">    3713 </span><span class="lineCov">         60 :         if (!mozilla::dom::DefineStaticJSVals(cx)) {</span>
<span class="lineNum">    3714 </span>            :             return false;
<span class="lineNum">    3715 </span>            :         }
<span class="lineNum">    3716 </span>            :     }
<span class="lineNum">    3717 </span>            : 
<span class="lineNum">    3718 </span><span class="lineCov">         60 :     return true;</span>
<span class="lineNum">    3719 </span>            : }
<a name="3720"><span class="lineNum">    3720 </span>            : </a>
<span class="lineNum">    3721 </span>            : bool
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 : XPCJSContext::DescribeCustomObjects(JSObject* obj, const js::Class* clasp,</span>
<span class="lineNum">    3723 </span>            :                                     char (&amp;name)[72]) const
<span class="lineNum">    3724 </span>            : {
<span class="lineNum">    3725 </span>            : 
<span class="lineNum">    3726 </span><span class="lineNoCov">          0 :     if (!IS_PROTO_CLASS(clasp)) {</span>
<span class="lineNum">    3727 </span>            :         return false;
<span class="lineNum">    3728 </span>            :     }
<span class="lineNum">    3729 </span>            : 
<span class="lineNum">    3730 </span>            :     XPCWrappedNativeProto* p =
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :         static_cast&lt;XPCWrappedNativeProto*&gt;(xpc_GetJSPrivate(obj));</span>
<span class="lineNum">    3732 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIXPCScriptable&gt; scr = p-&gt;GetScriptable();</span>
<span class="lineNum">    3733 </span><span class="lineNoCov">          0 :     if (!scr) {</span>
<span class="lineNum">    3734 </span>            :         return false;
<span class="lineNum">    3735 </span>            :     }
<span class="lineNum">    3736 </span>            : 
<span class="lineNum">    3737 </span>            :     SprintfLiteral(name, &quot;JS Object (%s - %s)&quot;,
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :                    clasp-&gt;name, scr-&gt;GetJSClass()-&gt;name);</span>
<span class="lineNum">    3739 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3740 </span>            : }
<a name="3741"><span class="lineNum">    3741 </span>            : </a>
<span class="lineNum">    3742 </span>            : bool
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 : XPCJSContext::NoteCustomGCThingXPCOMChildren(const js::Class* clasp, JSObject* obj,</span>
<span class="lineNum">    3744 </span>            :                                              nsCycleCollectionTraversalCallback&amp; cb) const
<span class="lineNum">    3745 </span>            : {
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :     if (clasp != &amp;XPC_WN_Tearoff_JSClass) {</span>
<span class="lineNum">    3747 </span>            :         return false;
<span class="lineNum">    3748 </span>            :     }
<span class="lineNum">    3749 </span>            : 
<span class="lineNum">    3750 </span>            :     // A tearoff holds a strong reference to its native object
<span class="lineNum">    3751 </span>            :     // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
<span class="lineNum">    3752 </span>            :     // will be held alive through the parent of the JSObject of the tearoff.
<span class="lineNum">    3753 </span>            :     XPCWrappedNativeTearOff* to =
<span class="lineNum">    3754 </span><span class="lineNoCov">          0 :         static_cast&lt;XPCWrappedNativeTearOff*&gt;(xpc_GetJSPrivate(obj));</span>
<span class="lineNum">    3755 </span>            :     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;xpc_GetJSPrivate(obj)-&gt;mNative&quot;);
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :     cb.NoteXPCOMChild(to-&gt;GetNative());</span>
<span class="lineNum">    3757 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3758 </span>            : }
<a name="3759"><span class="lineNum">    3759 </span>            : </a>
<span class="lineNum">    3760 </span>            : void
<span class="lineNum">    3761 </span><span class="lineCov">       1371 : XPCJSContext::BeforeProcessTask(bool aMightBlock)</span>
<span class="lineNum">    3762 </span>            : {
<span class="lineNum">    3763 </span>            :     MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">    3764 </span>            : 
<span class="lineNum">    3765 </span>            :     // If ProcessNextEvent was called during a Promise &quot;then&quot; callback, we
<span class="lineNum">    3766 </span>            :     // must process any pending microtasks before blocking in the event loop,
<span class="lineNum">    3767 </span>            :     // otherwise we may deadlock until an event enters the queue later.
<span class="lineNum">    3768 </span><span class="lineCov">       1371 :     if (aMightBlock) {</span>
<span class="lineNum">    3769 </span><span class="lineCov">        806 :         if (Promise::PerformMicroTaskCheckpoint()) {</span>
<span class="lineNum">    3770 </span>            :             // If any microtask was processed, we post a dummy event in order to
<span class="lineNum">    3771 </span>            :             // force the ProcessNextEvent call not to block.  This is required
<span class="lineNum">    3772 </span>            :             // to support nested event loops implemented using a pattern like
<span class="lineNum">    3773 </span>            :             // &quot;while (condition) thread.processNextEvent(true)&quot;, in case the
<span class="lineNum">    3774 </span>            :             // condition is triggered here by a Promise &quot;then&quot; callback.
<span class="lineNum">    3775 </span>            : 
<span class="lineNum">    3776 </span><span class="lineCov">         59 :             NS_DispatchToMainThread(new Runnable(&quot;Empty_microtask_runnable&quot;));</span>
<span class="lineNum">    3777 </span>            :         }
<span class="lineNum">    3778 </span>            :     }
<span class="lineNum">    3779 </span>            : 
<span class="lineNum">    3780 </span>            :     // Start the slow script timer.
<span class="lineNum">    3781 </span><span class="lineCov">       1371 :     mSlowScriptCheckpoint = mozilla::TimeStamp::NowLoRes();</span>
<span class="lineNum">    3782 </span><span class="lineCov">       1371 :     mSlowScriptSecondHalf = false;</span>
<span class="lineNum">    3783 </span><span class="lineCov">       1371 :     mSlowScriptActualWait = mozilla::TimeDuration();</span>
<span class="lineNum">    3784 </span><span class="lineCov">       1371 :     mTimeoutAccumulated = false;</span>
<span class="lineNum">    3785 </span>            : 
<span class="lineNum">    3786 </span>            :     // As we may be entering a nested event loop, we need to
<span class="lineNum">    3787 </span>            :     // cancel any ongoing performance measurement.
<span class="lineNum">    3788 </span><span class="lineCov">       1371 :     js::ResetPerformanceMonitoring(Get()-&gt;Context());</span>
<span class="lineNum">    3789 </span>            : 
<span class="lineNum">    3790 </span><span class="lineCov">       1371 :     CycleCollectedJSContext::BeforeProcessTask(aMightBlock);</span>
<span class="lineNum">    3791 </span><span class="lineCov">       1371 : }</span>
<a name="3792"><span class="lineNum">    3792 </span>            : </a>
<span class="lineNum">    3793 </span>            : void
<span class="lineNum">    3794 </span><span class="lineCov">       1371 : XPCJSContext::AfterProcessTask(uint32_t aNewRecursionDepth)</span>
<span class="lineNum">    3795 </span>            : {
<span class="lineNum">    3796 </span>            :     // Now that we're back to the event loop, reset the slow script checkpoint.
<span class="lineNum">    3797 </span><span class="lineCov">       1371 :     mSlowScriptCheckpoint = mozilla::TimeStamp();</span>
<span class="lineNum">    3798 </span><span class="lineCov">       1371 :     mSlowScriptSecondHalf = false;</span>
<span class="lineNum">    3799 </span>            : 
<span class="lineNum">    3800 </span>            :     // Call cycle collector occasionally.
<span class="lineNum">    3801 </span>            :     MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">    3802 </span><span class="lineCov">       1371 :     nsJSContext::MaybePokeCC();</span>
<span class="lineNum">    3803 </span>            : 
<span class="lineNum">    3804 </span><span class="lineCov">       1371 :     CycleCollectedJSContext::AfterProcessTask(aNewRecursionDepth);</span>
<span class="lineNum">    3805 </span>            : 
<span class="lineNum">    3806 </span>            :     // Now that we are certain that the event is complete,
<span class="lineNum">    3807 </span>            :     // we can flush any ongoing performance measurement.
<span class="lineNum">    3808 </span><span class="lineCov">       1371 :     js::FlushPerformanceMonitoring(Get()-&gt;Context());</span>
<span class="lineNum">    3809 </span>            : 
<span class="lineNum">    3810 </span><span class="lineCov">       1371 :     mozilla::jsipc::AfterProcessTask();</span>
<span class="lineNum">    3811 </span><span class="lineCov">       1371 : }</span>
<span class="lineNum">    3812 </span>            : 
<span class="lineNum">    3813 </span>            : /***************************************************************************/
<a name="3814"><span class="lineNum">    3814 </span>            : </a>
<span class="lineNum">    3815 </span>            : void
<span class="lineNum">    3816 </span><span class="lineNoCov">          0 : XPCJSContext::DebugDump(int16_t depth)</span>
<span class="lineNum">    3817 </span>            : {
<span class="lineNum">    3818 </span>            : #ifdef DEBUG
<span class="lineNum">    3819 </span>            :     depth--;
<span class="lineNum">    3820 </span>            :     XPC_LOG_ALWAYS((&quot;XPCJSContext @ %p&quot;, this));
<span class="lineNum">    3821 </span>            :         XPC_LOG_INDENT();
<span class="lineNum">    3822 </span>            :         XPC_LOG_ALWAYS((&quot;mJSContext @ %p&quot;, Context()));
<span class="lineNum">    3823 </span>            : 
<span class="lineNum">    3824 </span>            :         XPC_LOG_ALWAYS((&quot;mWrappedJSClassMap @ %p with %d wrapperclasses(s)&quot;,
<span class="lineNum">    3825 </span>            :                         mWrappedJSClassMap, mWrappedJSClassMap-&gt;Count()));
<span class="lineNum">    3826 </span>            :         // iterate wrappersclasses...
<span class="lineNum">    3827 </span>            :         if (depth &amp;&amp; mWrappedJSClassMap-&gt;Count()) {
<span class="lineNum">    3828 </span>            :             XPC_LOG_INDENT();
<span class="lineNum">    3829 </span>            :             for (auto i = mWrappedJSClassMap-&gt;Iter(); !i.Done(); i.Next()) {
<span class="lineNum">    3830 </span>            :                 auto entry = static_cast&lt;IID2WrappedJSClassMap::Entry*&gt;(i.Get());
<span class="lineNum">    3831 </span>            :                 entry-&gt;value-&gt;DebugDump(depth);
<span class="lineNum">    3832 </span>            :             }
<span class="lineNum">    3833 </span>            :             XPC_LOG_OUTDENT();
<span class="lineNum">    3834 </span>            :         }
<span class="lineNum">    3835 </span>            : 
<span class="lineNum">    3836 </span>            :         // iterate wrappers...
<span class="lineNum">    3837 </span>            :         XPC_LOG_ALWAYS((&quot;mWrappedJSMap @ %p with %d wrappers(s)&quot;,
<span class="lineNum">    3838 </span>            :                         mWrappedJSMap, mWrappedJSMap-&gt;Count()));
<span class="lineNum">    3839 </span>            :         if (depth &amp;&amp; mWrappedJSMap-&gt;Count()) {
<span class="lineNum">    3840 </span>            :             XPC_LOG_INDENT();
<span class="lineNum">    3841 </span>            :             mWrappedJSMap-&gt;Dump(depth);
<span class="lineNum">    3842 </span>            :             XPC_LOG_OUTDENT();
<span class="lineNum">    3843 </span>            :         }
<span class="lineNum">    3844 </span>            : 
<span class="lineNum">    3845 </span>            :         XPC_LOG_ALWAYS((&quot;mIID2NativeInterfaceMap @ %p with %d interface(s)&quot;,
<span class="lineNum">    3846 </span>            :                         mIID2NativeInterfaceMap,
<span class="lineNum">    3847 </span>            :                         mIID2NativeInterfaceMap-&gt;Count()));
<span class="lineNum">    3848 </span>            : 
<span class="lineNum">    3849 </span>            :         XPC_LOG_ALWAYS((&quot;mClassInfo2NativeSetMap @ %p with %d sets(s)&quot;,
<span class="lineNum">    3850 </span>            :                         mClassInfo2NativeSetMap,
<span class="lineNum">    3851 </span>            :                         mClassInfo2NativeSetMap-&gt;Count()));
<span class="lineNum">    3852 </span>            : 
<span class="lineNum">    3853 </span>            :         XPC_LOG_ALWAYS((&quot;mThisTranslatorMap @ %p with %d translator(s)&quot;,
<span class="lineNum">    3854 </span>            :                         mThisTranslatorMap, mThisTranslatorMap-&gt;Count()));
<span class="lineNum">    3855 </span>            : 
<span class="lineNum">    3856 </span>            :         XPC_LOG_ALWAYS((&quot;mNativeSetMap @ %p with %d sets(s)&quot;,
<span class="lineNum">    3857 </span>            :                         mNativeSetMap, mNativeSetMap-&gt;Count()));
<span class="lineNum">    3858 </span>            : 
<span class="lineNum">    3859 </span>            :         // iterate sets...
<span class="lineNum">    3860 </span>            :         if (depth &amp;&amp; mNativeSetMap-&gt;Count()) {
<span class="lineNum">    3861 </span>            :             XPC_LOG_INDENT();
<span class="lineNum">    3862 </span>            :             for (auto i = mNativeSetMap-&gt;Iter(); !i.Done(); i.Next()) {
<span class="lineNum">    3863 </span>            :                 auto entry = static_cast&lt;NativeSetMap::Entry*&gt;(i.Get());
<span class="lineNum">    3864 </span>            :                 entry-&gt;key_value-&gt;DebugDump(depth);
<span class="lineNum">    3865 </span>            :             }
<span class="lineNum">    3866 </span>            :             XPC_LOG_OUTDENT();
<span class="lineNum">    3867 </span>            :         }
<span class="lineNum">    3868 </span>            : 
<span class="lineNum">    3869 </span>            :         XPC_LOG_ALWAYS((&quot;mPendingResult of %&quot; PRIx32, static_cast&lt;uint32_t&gt;(mPendingResult)));
<span class="lineNum">    3870 </span>            : 
<span class="lineNum">    3871 </span>            :         XPC_LOG_OUTDENT();
<span class="lineNum">    3872 </span>            : #endif
<span class="lineNum">    3873 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3874 </span>            : 
<span class="lineNum">    3875 </span>            : /***************************************************************************/
<a name="3876"><span class="lineNum">    3876 </span>            : </a>
<span class="lineNum">    3877 </span>            : void
<span class="lineNum">    3878 </span><span class="lineCov">        265 : XPCRootSetElem::AddToRootSet(XPCRootSetElem** listHead)</span>
<span class="lineNum">    3879 </span>            : {
<span class="lineNum">    3880 </span>            :     MOZ_ASSERT(!mSelfp, &quot;Must be not linked&quot;);
<span class="lineNum">    3881 </span>            : 
<span class="lineNum">    3882 </span><span class="lineCov">        265 :     mSelfp = listHead;</span>
<span class="lineNum">    3883 </span><span class="lineCov">        265 :     mNext = *listHead;</span>
<span class="lineNum">    3884 </span><span class="lineCov">        265 :     if (mNext) {</span>
<span class="lineNum">    3885 </span>            :         MOZ_ASSERT(mNext-&gt;mSelfp == listHead, &quot;Must be list start&quot;);
<span class="lineNum">    3886 </span><span class="lineCov">        205 :         mNext-&gt;mSelfp = &amp;mNext;</span>
<span class="lineNum">    3887 </span>            :     }
<span class="lineNum">    3888 </span><span class="lineCov">        265 :     *listHead = this;</span>
<span class="lineNum">    3889 </span><span class="lineCov">        265 : }</span>
<a name="3890"><span class="lineNum">    3890 </span>            : </a>
<span class="lineNum">    3891 </span>            : void
<span class="lineNum">    3892 </span><span class="lineCov">        265 : XPCRootSetElem::RemoveFromRootSet()</span>
<span class="lineNum">    3893 </span>            : {
<span class="lineNum">    3894 </span><span class="lineCov">        265 :     nsXPConnect* xpc = nsXPConnect::XPConnect();</span>
<span class="lineNum">    3895 </span><span class="lineCov">        265 :     JS::PokeGC(xpc-&gt;GetContext()-&gt;Context());</span>
<span class="lineNum">    3896 </span>            : 
<span class="lineNum">    3897 </span>            :     MOZ_ASSERT(mSelfp, &quot;Must be linked&quot;);
<span class="lineNum">    3898 </span>            : 
<span class="lineNum">    3899 </span>            :     MOZ_ASSERT(*mSelfp == this, &quot;Link invariant&quot;);
<span class="lineNum">    3900 </span><span class="lineCov">        265 :     *mSelfp = mNext;</span>
<span class="lineNum">    3901 </span><span class="lineCov">        265 :     if (mNext)</span>
<span class="lineNum">    3902 </span><span class="lineCov">        145 :         mNext-&gt;mSelfp = mSelfp;</span>
<span class="lineNum">    3903 </span>            : #ifdef DEBUG
<span class="lineNum">    3904 </span>            :     mSelfp = nullptr;
<span class="lineNum">    3905 </span>            :     mNext = nullptr;
<span class="lineNum">    3906 </span>            : #endif
<span class="lineNum">    3907 </span><span class="lineCov">        265 : }</span>
<a name="3908"><span class="lineNum">    3908 </span>            : </a>
<span class="lineNum">    3909 </span>            : void
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 : XPCJSContext::AddGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    3911 </span>            : {
<span class="lineNum">    3912 </span>            :     MOZ_ASSERT(cb, &quot;null callback&quot;);
<span class="lineNum">    3913 </span><span class="lineNoCov">          0 :     extraGCCallbacks.AppendElement(cb);</span>
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 : }</span>
<a name="3915"><span class="lineNum">    3915 </span>            : </a>
<span class="lineNum">    3916 </span>            : void
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 : XPCJSContext::RemoveGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    3918 </span>            : {
<span class="lineNum">    3919 </span>            :     MOZ_ASSERT(cb, &quot;null callback&quot;);
<span class="lineNum">    3920 </span><span class="lineNoCov">          0 :     bool found = extraGCCallbacks.RemoveElement(cb);</span>
<span class="lineNum">    3921 </span>            :     if (!found) {
<span class="lineNum">    3922 </span>            :         NS_ERROR(&quot;Removing a callback which was never added.&quot;);
<span class="lineNum">    3923 </span>            :     }
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 : }</span>
<a name="3925"><span class="lineNum">    3925 </span>            : </a>
<span class="lineNum">    3926 </span>            : void
<span class="lineNum">    3927 </span><span class="lineCov">         60 : XPCJSContext::InitSingletonScopes()</span>
<span class="lineNum">    3928 </span>            : {
<span class="lineNum">    3929 </span>            :     // This all happens very early, so we don't bother with cx pushing.
<span class="lineNum">    3930 </span><span class="lineCov">         60 :     JSContext* cx = Context();</span>
<span class="lineNum">    3931 </span><span class="lineCov">         60 :     JSAutoRequest ar(cx);</span>
<span class="lineNum">    3932 </span><span class="lineCov">         60 :     RootedValue v(cx);</span>
<span class="lineNum">    3933 </span>            :     nsresult rv;
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span>            :     // Create the Unprivileged Junk Scope.
<span class="lineNum">    3936 </span><span class="lineCov">        120 :     SandboxOptions unprivilegedJunkScopeOptions;</span>
<span class="lineNum">    3937 </span><span class="lineCov">         60 :     unprivilegedJunkScopeOptions.sandboxName.AssignLiteral(&quot;XPConnect Junk Compartment&quot;);</span>
<span class="lineNum">    3938 </span><span class="lineCov">         60 :     unprivilegedJunkScopeOptions.invisibleToDebugger = true;</span>
<span class="lineNum">    3939 </span><span class="lineCov">         60 :     rv = CreateSandboxObject(cx, &amp;v, nullptr, unprivilegedJunkScopeOptions);</span>
<span class="lineNum">    3940 </span><span class="lineCov">         60 :     MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    3941 </span><span class="lineCov">         60 :     mUnprivilegedJunkScope = js::UncheckedUnwrap(&amp;v.toObject());</span>
<span class="lineNum">    3942 </span>            : 
<span class="lineNum">    3943 </span>            :     // Create the Privileged Junk Scope.
<span class="lineNum">    3944 </span><span class="lineCov">        120 :     SandboxOptions privilegedJunkScopeOptions;</span>
<span class="lineNum">    3945 </span><span class="lineCov">         60 :     privilegedJunkScopeOptions.sandboxName.AssignLiteral(&quot;XPConnect Privileged Junk Compartment&quot;);</span>
<span class="lineNum">    3946 </span><span class="lineCov">         60 :     privilegedJunkScopeOptions.invisibleToDebugger = true;</span>
<span class="lineNum">    3947 </span><span class="lineCov">         60 :     privilegedJunkScopeOptions.wantComponents = false;</span>
<span class="lineNum">    3948 </span><span class="lineCov">        120 :     rv = CreateSandboxObject(cx, &amp;v, nsXPConnect::SystemPrincipal(), privilegedJunkScopeOptions);</span>
<span class="lineNum">    3949 </span><span class="lineCov">         60 :     MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    3950 </span><span class="lineCov">         60 :     mPrivilegedJunkScope = js::UncheckedUnwrap(&amp;v.toObject());</span>
<span class="lineNum">    3951 </span>            : 
<span class="lineNum">    3952 </span>            :     // Create the Compilation Scope.
<span class="lineNum">    3953 </span><span class="lineCov">        120 :     SandboxOptions compilationScopeOptions;</span>
<span class="lineNum">    3954 </span><span class="lineCov">         60 :     compilationScopeOptions.sandboxName.AssignLiteral(&quot;XPConnect Compilation Compartment&quot;);</span>
<span class="lineNum">    3955 </span><span class="lineCov">         60 :     compilationScopeOptions.invisibleToDebugger = true;</span>
<span class="lineNum">    3956 </span><span class="lineCov">         60 :     compilationScopeOptions.discardSource = ShouldDiscardSystemSource();</span>
<span class="lineNum">    3957 </span><span class="lineCov">         60 :     rv = CreateSandboxObject(cx, &amp;v, /* principal = */ nullptr, compilationScopeOptions);</span>
<span class="lineNum">    3958 </span><span class="lineCov">         60 :     MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    3959 </span><span class="lineCov">        120 :     mCompilationScope = js::UncheckedUnwrap(&amp;v.toObject());</span>
<span class="lineNum">    3960 </span><span class="lineCov">         60 : }</span>
<a name="3961"><span class="lineNum">    3961 </span>            : </a>
<span class="lineNum">    3962 </span>            : void
<span class="lineNum">    3963 </span><span class="lineCov">         60 : XPCJSContext::DeleteSingletonScopes()</span>
<span class="lineNum">    3964 </span>            : {
<span class="lineNum">    3965 </span><span class="lineCov">         60 :     mUnprivilegedJunkScope = nullptr;</span>
<span class="lineNum">    3966 </span><span class="lineCov">         60 :     mPrivilegedJunkScope = nullptr;</span>
<span class="lineNum">    3967 </span><span class="lineCov">         60 :     mCompilationScope = nullptr;</span>
<span class="lineNum">    3968 </span><span class="lineCov">         60 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
