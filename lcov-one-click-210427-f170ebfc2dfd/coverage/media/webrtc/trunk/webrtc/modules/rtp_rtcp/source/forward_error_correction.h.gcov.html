<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mochitest-e10s.info - media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/forward_error_correction.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/rtp_rtcp/source</a> - forward_error_correction.h<span style="font-size: 80%;"> (source / <a href="forward_error_correction.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mochitest-e10s.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #ifndef WEBRTC_MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_H_
<span class="lineNum">      12 </span>            : #define WEBRTC_MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_H_
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &lt;list&gt;
<span class="lineNum">      15 </span>            : #include &lt;vector&gt;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;webrtc/base/scoped_ref_ptr.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;webrtc/modules/rtp_rtcp/include/rtp_rtcp_defines.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;webrtc/system_wrappers/include/ref_count.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;webrtc/typedefs.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : namespace webrtc {
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : // Forward declaration.
<span class="lineNum">      25 </span>            : class FecPacket;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // Performs codec-independent forward error correction (FEC), based on RFC 5109.
<span class="lineNum">      28 </span>            : // Option exists to enable unequal protection (UEP) across packets.
<span class="lineNum">      29 </span>            : // This is not to be confused with protection within packets
<span class="lineNum">      30 </span>            : // (referred to as uneven level protection (ULP) in RFC 5109).
<span class="lineNum">      31 </span>            : class ForwardErrorCorrection {
<span class="lineNum">      32 </span>            :  public:
<span class="lineNum">      33 </span>            :   // Maximum number of media packets we can protect
<span class="lineNum">      34 </span>            :   static const unsigned int kMaxMediaPackets = 48u;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :   // TODO(holmer): As a next step all these struct-like packet classes should be
<span class="lineNum">      37 </span>            :   // refactored into proper classes, and their members should be made private.
<span class="lineNum">      38 </span>            :   // This will require parts of the functionality in forward_error_correction.cc
<span class="lineNum">      39 </span>            :   // and receiver_fec.cc to be refactored into the packet classes.
<a name="40"><span class="lineNum">      40 </span>            :   class Packet {</a>
<a name="41"><span class="lineNum">      41 </span>            :    public:</a>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :     Packet() : length(0), data(), ref_count_(0) {}</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     virtual ~Packet() {}</span>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :     // Add a reference.
<span class="lineNum">      46 </span>            :     virtual int32_t AddRef();
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            :     // Release a reference. Will delete the object if the reference count
<span class="lineNum">      49 </span>            :     // reaches zero.
<span class="lineNum">      50 </span>            :     virtual int32_t Release();
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :     size_t length;               // Length of packet in bytes.
<span class="lineNum">      53 </span>            :     uint8_t data[IP_PACKET_SIZE];  // Packet data.
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :    private:
<span class="lineNum">      56 </span>            :     int32_t ref_count_;  // Counts the number of references to a packet.
<span class="lineNum">      57 </span>            :   };
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">      60 </span>            :   class SortablePacket {
<span class="lineNum">      61 </span>            :    public:
<span class="lineNum">      62 </span>            :     // True if first is &lt;= than second.
<span class="lineNum">      63 </span>            :     static bool LessThan(const SortablePacket* first,
<span class="lineNum">      64 </span>            :                          const SortablePacket* second);
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :     uint16_t seq_num;
<span class="lineNum">      67 </span>            :   };
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :   // The received list parameter of #DecodeFEC() must reference structs of this
<span class="lineNum">      70 </span>            :   // type. The last_media_pkt_in_frame is not required to be used for correct
<span class="lineNum">      71 </span>            :   // recovery, but will reduce delay by allowing #DecodeFEC() to pre-emptively
<span class="lineNum">      72 </span>            :   // determine frame completion. If set, we assume a FEC stream, and the
<span class="lineNum">      73 </span>            :   // following assumptions must hold:\n
<span class="lineNum">      74 </span>            :   //
<span class="lineNum">      75 </span>            :   // 1. The media packets in a frame have contiguous sequence numbers, i.e. the
<span class="lineNum">      76 </span>            :   //    frame's FEC packets have sequence numbers either lower than the first
<span class="lineNum">      77 </span>            :   //    media packet or higher than the last media packet.\n
<span class="lineNum">      78 </span>            :   // 2. All FEC packets have a sequence number base equal to the first media
<span class="lineNum">      79 </span>            :   //    packet in the corresponding frame.\n
<span class="lineNum">      80 </span>            :   //
<span class="lineNum">      81 </span>            :   // The ssrc member is needed to ensure we can restore the SSRC field of
<span class="lineNum">      82 </span>            :   // recovered packets. In most situations this could be retrieved from other
<span class="lineNum">      83 </span>            :   // media packets, but in the case of an FEC packet protecting a single
<span class="lineNum">      84 </span>            :   // missing media packet, we have no other means of obtaining it.
<span class="lineNum">      85 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">      86 </span>            :   class ReceivedPacket : public SortablePacket {
<span class="lineNum">      87 </span>            :    public:
<span class="lineNum">      88 </span>            :     ReceivedPacket();
<span class="lineNum">      89 </span>            :     ~ReceivedPacket();
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :     uint32_t ssrc;  // SSRC of the current frame. Must be set for FEC
<span class="lineNum">      92 </span>            :                     // packets, but not required for media packets.
<span class="lineNum">      93 </span>            :     bool is_fec;    // Set to true if this is an FEC packet and false
<span class="lineNum">      94 </span>            :                     // otherwise.
<span class="lineNum">      95 </span>            :     rtc::scoped_refptr&lt;Packet&gt; pkt;  // Pointer to the packet storage.
<span class="lineNum">      96 </span>            :   };
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   // The recovered list parameter of #DecodeFEC() will reference structs of
<span class="lineNum">      99 </span>            :   // this type.
<span class="lineNum">     100 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">     101 </span>            :   class RecoveredPacket : public SortablePacket {
<span class="lineNum">     102 </span>            :    public:
<span class="lineNum">     103 </span>            :     RecoveredPacket();
<span class="lineNum">     104 </span>            :     ~RecoveredPacket();
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :     bool was_recovered;  // Will be true if this packet was recovered by
<span class="lineNum">     107 </span>            :                          // the FEC. Otherwise it was a media packet passed in
<span class="lineNum">     108 </span>            :                          // through the received packet list.
<span class="lineNum">     109 </span>            :     bool returned;  // True when the packet already has been returned to the
<span class="lineNum">     110 </span>            :                     // caller through the callback.
<span class="lineNum">     111 </span>            :     uint8_t length_recovery[2];  // Two bytes used for recovering the packet
<span class="lineNum">     112 </span>            :                                  // length with XOR operations.
<span class="lineNum">     113 </span>            :     rtc::scoped_refptr&lt;Packet&gt; pkt;  // Pointer to the packet storage.
<span class="lineNum">     114 </span>            :   };
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :   typedef std::list&lt;Packet*&gt; PacketList;
<span class="lineNum">     117 </span>            :   typedef std::list&lt;ReceivedPacket*&gt; ReceivedPacketList;
<span class="lineNum">     118 </span>            :   typedef std::list&lt;RecoveredPacket*&gt; RecoveredPacketList;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   ForwardErrorCorrection();
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   virtual ~ForwardErrorCorrection();
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :   /**
<span class="lineNum">     125 </span>            :    * Generates a list of FEC packets from supplied media packets.
<span class="lineNum">     126 </span>            :    *
<span class="lineNum">     127 </span>            :    * \param[in]  mediaPacketList     List of media packets to protect, of type
<span class="lineNum">     128 </span>            :    *                                 #Packet. All packets must belong to the
<span class="lineNum">     129 </span>            :    *                                 same frame and the list must not be empty.
<span class="lineNum">     130 </span>            :    * \param[in]  protectionFactor    FEC protection overhead in the [0, 255]
<span class="lineNum">     131 </span>            :    *                                 domain. To obtain 100% overhead, or an
<span class="lineNum">     132 </span>            :    *                                 equal number of FEC packets as media
<span class="lineNum">     133 </span>            :    *                                 packets, use 255.
<span class="lineNum">     134 </span>            :    * \param[in] numImportantPackets  The number of &quot;important&quot; packets in the
<span class="lineNum">     135 </span>            :    *                                 frame. These packets may receive greater
<span class="lineNum">     136 </span>            :    *                                 protection than the remaining packets. The
<span class="lineNum">     137 </span>            :    *                                 important packets must be located at the
<span class="lineNum">     138 </span>            :    *                                 start of the media packet list. For codecs
<span class="lineNum">     139 </span>            :    *                                 with data partitioning, the important
<span class="lineNum">     140 </span>            :    *                                 packets may correspond to first partition
<span class="lineNum">     141 </span>            :    *                                 packets.
<span class="lineNum">     142 </span>            :    * \param[in] useUnequalProtection Parameter to enable/disable unequal
<span class="lineNum">     143 </span>            :    *                                 protection  (UEP) across packets. Enabling
<span class="lineNum">     144 </span>            :    *                                 UEP will allocate more protection to the
<span class="lineNum">     145 </span>            :    *                                 numImportantPackets from the start of the
<span class="lineNum">     146 </span>            :    *                                 mediaPacketList.
<span class="lineNum">     147 </span>            :    * \param[in]  fec_mask_type       The type of packet mask used in the FEC.
<span class="lineNum">     148 </span>            :    *                                 Random or bursty type may be selected. The
<span class="lineNum">     149 </span>            :    *                                 bursty type is only defined up to 12 media
<span class="lineNum">     150 </span>            :    *                                 packets. If the number of media packets is
<span class="lineNum">     151 </span>            :    *                                 above 12, the packets masks from the
<span class="lineNum">     152 </span>            :    *                                 random table will be selected.
<span class="lineNum">     153 </span>            :    * \param[out] fecPacketList       List of FEC packets, of type #Packet. Must
<span class="lineNum">     154 </span>            :    *                                 be empty on entry. The memory available
<span class="lineNum">     155 </span>            :    *                                 through the list will be valid until the
<span class="lineNum">     156 </span>            :    *                                 next call to GenerateFEC().
<span class="lineNum">     157 </span>            :    *
<span class="lineNum">     158 </span>            :    * \return 0 on success, -1 on failure.
<span class="lineNum">     159 </span>            :    */
<span class="lineNum">     160 </span>            :   int32_t GenerateFEC(const PacketList&amp; media_packet_list,
<span class="lineNum">     161 </span>            :                       uint8_t protection_factor, int num_important_packets,
<span class="lineNum">     162 </span>            :                       bool use_unequal_protection, FecMaskType fec_mask_type,
<span class="lineNum">     163 </span>            :                       PacketList* fec_packet_list);
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :   /**
<span class="lineNum">     166 </span>            :    *  Decodes a list of media and FEC packets. It will parse the input received
<span class="lineNum">     167 </span>            :    *  packet list, storing FEC packets internally and inserting media packets to
<span class="lineNum">     168 </span>            :    *  the output recovered packet list. The recovered list will be sorted by
<span class="lineNum">     169 </span>            :    *  ascending sequence number and have duplicates removed. The function
<span class="lineNum">     170 </span>            :    *  should be called as new packets arrive, with the recovered list being
<span class="lineNum">     171 </span>            :    *  progressively assembled with each call. The received packet list will be
<span class="lineNum">     172 </span>            :    *  empty at output.\n
<span class="lineNum">     173 </span>            :    *
<span class="lineNum">     174 </span>            :    *  The user will allocate packets submitted through the received list. The
<span class="lineNum">     175 </span>            :    *  function will handle allocation of recovered packets and optionally
<span class="lineNum">     176 </span>            :    *  deleting of all packet memory. The user may delete the recovered list
<span class="lineNum">     177 </span>            :    *  packets, in which case they must remove deleted packets from the
<span class="lineNum">     178 </span>            :    *  recovered list.\n
<span class="lineNum">     179 </span>            :    *
<span class="lineNum">     180 </span>            :    * \param[in]  receivedPacketList  List of new received packets, of type
<span class="lineNum">     181 </span>            :    *                                 #ReceivedPacket, belonging to a single
<span class="lineNum">     182 </span>            :    *                                 frame. At output the list will be empty,
<span class="lineNum">     183 </span>            :    *                                 with packets  either stored internally,
<span class="lineNum">     184 </span>            :    *                                 or accessible through the recovered list.
<span class="lineNum">     185 </span>            :    * \param[out] recoveredPacketList List of recovered media packets, of type
<span class="lineNum">     186 </span>            :    *                                 #RecoveredPacket, belonging to a single
<span class="lineNum">     187 </span>            :    *                                 frame. The memory available through the
<span class="lineNum">     188 </span>            :    *                                 list will be valid until the next call to
<span class="lineNum">     189 </span>            :    *                                 DecodeFEC().
<span class="lineNum">     190 </span>            :    *
<span class="lineNum">     191 </span>            :    * \return 0 on success, -1 on failure.
<span class="lineNum">     192 </span>            :    */
<span class="lineNum">     193 </span>            :   int32_t DecodeFEC(ReceivedPacketList* received_packet_list,
<span class="lineNum">     194 </span>            :                     RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Get the number of FEC packets, given the number of media packets and the
<span class="lineNum">     197 </span>            :   // protection factor.
<span class="lineNum">     198 </span>            :   int GetNumberOfFecPackets(int num_media_packets, int protection_factor);
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   // Gets the size in bytes of the FEC/ULP headers, which must be accounted for
<span class="lineNum">     201 </span>            :   // as packet overhead.
<span class="lineNum">     202 </span>            :   // \return Packet overhead in bytes.
<span class="lineNum">     203 </span>            :   static size_t PacketOverhead();
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   // Reset internal states from last frame and clear the recovered_packet_list.
<span class="lineNum">     206 </span>            :   // Frees all memory allocated by this class.
<span class="lineNum">     207 </span>            :   void ResetState(RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :  private:
<span class="lineNum">     210 </span>            :   typedef std::list&lt;FecPacket*&gt; FecPacketList;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :   void GenerateFecUlpHeaders(const PacketList&amp; media_packet_list,
<span class="lineNum">     213 </span>            :                              uint8_t* packet_mask, bool l_bit,
<span class="lineNum">     214 </span>            :                              int num_fec_packets);
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :   // Analyzes |media_packets| for holes in the sequence and inserts zero columns
<span class="lineNum">     217 </span>            :   // into the |packet_mask| where those holes are found. Zero columns means that
<span class="lineNum">     218 </span>            :   // those packets will have no protection.
<span class="lineNum">     219 </span>            :   // Returns the number of bits used for one row of the new packet mask.
<span class="lineNum">     220 </span>            :   // Requires that |packet_mask| has at least 6 * |num_fec_packets| bytes
<span class="lineNum">     221 </span>            :   // allocated.
<span class="lineNum">     222 </span>            :   int InsertZerosInBitMasks(const PacketList&amp; media_packets,
<span class="lineNum">     223 </span>            :                             uint8_t* packet_mask, int num_mask_bytes,
<span class="lineNum">     224 </span>            :                             int num_fec_packets);
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   // Inserts |num_zeros| zero columns into |new_mask| at position
<span class="lineNum">     227 </span>            :   // |new_bit_index|. If the current byte of |new_mask| can't fit all zeros, the
<span class="lineNum">     228 </span>            :   // byte will be filled with zeros from |new_bit_index|, but the next byte will
<span class="lineNum">     229 </span>            :   // be untouched.
<span class="lineNum">     230 </span>            :   static void InsertZeroColumns(int num_zeros, uint8_t* new_mask,
<span class="lineNum">     231 </span>            :                                 int new_mask_bytes, int num_fec_packets,
<span class="lineNum">     232 </span>            :                                 int new_bit_index);
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :   // Copies the left most bit column from the byte pointed to by
<span class="lineNum">     235 </span>            :   // |old_bit_index| in |old_mask| to the right most column of the byte pointed
<span class="lineNum">     236 </span>            :   // to by |new_bit_index| in |new_mask|. |old_mask_bytes| and |new_mask_bytes|
<span class="lineNum">     237 </span>            :   // represent the number of bytes used per row for each mask. |num_fec_packets|
<span class="lineNum">     238 </span>            :   // represent the number of rows of the masks.
<span class="lineNum">     239 </span>            :   // The copied bit is shifted out from |old_mask| and is shifted one step to
<span class="lineNum">     240 </span>            :   // the left in |new_mask|. |new_mask| will contain &quot;xxxx xxn0&quot; after this
<span class="lineNum">     241 </span>            :   // operation, where x are previously inserted bits and n is the new bit.
<span class="lineNum">     242 </span>            :   static void CopyColumn(uint8_t* new_mask, int new_mask_bytes,
<span class="lineNum">     243 </span>            :                          uint8_t* old_mask, int old_mask_bytes,
<span class="lineNum">     244 </span>            :                          int num_fec_packets, int new_bit_index,
<span class="lineNum">     245 </span>            :                          int old_bit_index);
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :   void GenerateFecBitStrings(const PacketList&amp; media_packet_list,
<span class="lineNum">     248 </span>            :                              uint8_t* packet_mask, int num_fec_packets,
<span class="lineNum">     249 </span>            :                              bool l_bit);
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :   // Insert received packets into FEC or recovered list.
<span class="lineNum">     252 </span>            :   void InsertPackets(ReceivedPacketList* received_packet_list,
<span class="lineNum">     253 </span>            :                      RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   // Insert media packet into recovered packet list. We delete duplicates.
<span class="lineNum">     256 </span>            :   void InsertMediaPacket(ReceivedPacket* rx_packet,
<span class="lineNum">     257 </span>            :                          RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   // Assigns pointers to the recovered packet from all FEC packets which cover
<span class="lineNum">     260 </span>            :   // it.
<span class="lineNum">     261 </span>            :   // Note: This reduces the complexity when we want to try to recover a packet
<span class="lineNum">     262 </span>            :   // since we don't have to find the intersection between recovered packets and
<span class="lineNum">     263 </span>            :   // packets covered by the FEC packet.
<span class="lineNum">     264 </span>            :   void UpdateCoveringFECPackets(RecoveredPacket* packet);
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   // Insert packet into FEC list. We delete duplicates.
<span class="lineNum">     267 </span>            :   void InsertFECPacket(ReceivedPacket* rx_packet,
<span class="lineNum">     268 </span>            :                        const RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   // Assigns pointers to already recovered packets covered by this FEC packet.
<span class="lineNum">     271 </span>            :   static void AssignRecoveredPackets(
<span class="lineNum">     272 </span>            :       FecPacket* fec_packet, const RecoveredPacketList* recovered_packets);
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :   // Insert into recovered list in correct position.
<span class="lineNum">     275 </span>            :   void InsertRecoveredPacket(RecoveredPacket* rec_packet_to_insert,
<span class="lineNum">     276 </span>            :                              RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :   // Attempt to recover missing packets.
<span class="lineNum">     279 </span>            :   void AttemptRecover(RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :   // Initializes the packet recovery using the FEC packet.
<span class="lineNum">     282 </span>            :   static bool InitRecovery(const FecPacket* fec_packet,
<span class="lineNum">     283 </span>            :                            RecoveredPacket* recovered);
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   // Performs XOR between |src_packet| and |dst_packet| and stores the result
<span class="lineNum">     286 </span>            :   // in |dst_packet|.
<span class="lineNum">     287 </span>            :   static void XorPackets(const Packet* src_packet, RecoveredPacket* dst_packet);
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :   // Finish up the recovery of a packet.
<span class="lineNum">     290 </span>            :   static bool FinishRecovery(RecoveredPacket* recovered);
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :   // Recover a missing packet.
<span class="lineNum">     293 </span>            :   bool RecoverPacket(const FecPacket* fec_packet,
<span class="lineNum">     294 </span>            :                      RecoveredPacket* rec_packet_to_insert);
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   // Get the number of missing media packets which are covered by this
<span class="lineNum">     297 </span>            :   // FEC packet. An FEC packet can recover at most one packet, and if zero
<span class="lineNum">     298 </span>            :   // packets are missing the FEC packet can be discarded.
<span class="lineNum">     299 </span>            :   // This function returns 2 when two or more packets are missing.
<span class="lineNum">     300 </span>            :   static int NumCoveredPacketsMissing(const FecPacket* fec_packet);
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :   static void DiscardFECPacket(FecPacket* fec_packet);
<span class="lineNum">     303 </span>            :   static void DiscardOldPackets(RecoveredPacketList* recovered_packet_list);
<span class="lineNum">     304 </span>            :   static uint16_t ParseSequenceNumber(uint8_t* packet);
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :   std::vector&lt;Packet&gt; generated_fec_packets_;
<span class="lineNum">     307 </span>            :   FecPacketList fec_packet_list_;
<span class="lineNum">     308 </span>            :   bool fec_packet_received_;
<span class="lineNum">     309 </span>            : };
<span class="lineNum">     310 </span>            : }  // namespace webrtc
<span class="lineNum">     311 </span>            : #endif  // WEBRTC_MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
