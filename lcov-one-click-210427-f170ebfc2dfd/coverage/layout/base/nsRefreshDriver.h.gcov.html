<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mochitest-e10s.info - layout/base/nsRefreshDriver.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/base</a> - nsRefreshDriver.h<span style="font-size: 80%;"> (source / <a href="nsRefreshDriver.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mochitest-e10s.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /*
<span class="lineNum">       8 </span>            :  * Code to notify things that animate before a refresh, at an appropriate
<span class="lineNum">       9 </span>            :  * refresh rate.  (Perhaps temporary, until replaced by compositor.)
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef nsRefreshDriver_h_
<span class="lineNum">      13 </span>            : #define nsRefreshDriver_h_
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;mozilla/FlushType.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/TimeStamp.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/Vector.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/WeakPtr.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsTObserverArray.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsTHashtable.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsTObserverArray.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsClassHashtable.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsHashKeys.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;GeckoProfiler.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;mozilla/layers/TransactionIdAllocator.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : class nsPresContext;
<span class="lineNum">      31 </span>            : class nsIPresShell;
<span class="lineNum">      32 </span>            : class nsIDocument;
<span class="lineNum">      33 </span>            : class imgIRequest;
<span class="lineNum">      34 </span>            : class nsIDOMEvent;
<span class="lineNum">      35 </span>            : class nsINode;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : namespace mozilla {
<span class="lineNum">      38 </span>            : class RefreshDriverTimer;
<span class="lineNum">      39 </span>            : namespace layout {
<span class="lineNum">      40 </span>            : class VsyncChild;
<span class="lineNum">      41 </span>            : } // namespace layout
<span class="lineNum">      42 </span>            : } // namespace mozilla
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : /**
<span class="lineNum">      45 </span>            :  * An abstract base class to be implemented by callers wanting to be
<span class="lineNum">      46 </span>            :  * notified at refresh times.  When nothing needs to be painted, callers
<span class="lineNum">      47 </span>            :  * may not be notified.
<span class="lineNum">      48 </span>            :  */
<span class="lineNum">      49 </span><span class="lineNoCov">          0 : class nsARefreshObserver {</span>
<span class="lineNum">      50 </span>            : public:
<span class="lineNum">      51 </span>            :   // AddRef and Release signatures that match nsISupports.  Implementors
<span class="lineNum">      52 </span>            :   // must implement reference counting, and those that do implement
<span class="lineNum">      53 </span>            :   // nsISupports will already have methods with the correct signature.
<span class="lineNum">      54 </span>            :   //
<span class="lineNum">      55 </span>            :   // The refresh driver does NOT hold references to refresh observers
<span class="lineNum">      56 </span>            :   // except while it is notifying them.
<span class="lineNum">      57 </span>            :   NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :   virtual void WillRefresh(mozilla::TimeStamp aTime) = 0;
<span class="lineNum">      60 </span>            : };
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : /**
<span class="lineNum">      63 </span>            :  * An abstract base class to be implemented by callers wanting to be notified
<span class="lineNum">      64 </span>            :  * that a refresh has occurred. Callers must ensure an observer is removed
<span class="lineNum">      65 </span>            :  * before it is destroyed.
<span class="lineNum">      66 </span>            :  */
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : class nsAPostRefreshObserver {</span>
<span class="lineNum">      68 </span>            : public:
<span class="lineNum">      69 </span>            :   virtual void DidRefresh() = 0;
<span class="lineNum">      70 </span>            : };
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : class nsRefreshDriver final : public mozilla::layers::TransactionIdAllocator,
<span class="lineNum">      73 </span>            :                               public nsARefreshObserver
<span class="lineNum">      74 </span>            : {
<span class="lineNum">      75 </span>            : public:
<span class="lineNum">      76 </span>            :   explicit nsRefreshDriver(nsPresContext *aPresContext);
<span class="lineNum">      77 </span>            :   ~nsRefreshDriver();
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :   /**
<span class="lineNum">      80 </span>            :    * Methods for testing, exposed via nsIDOMWindowUtils.  See
<span class="lineNum">      81 </span>            :    * nsIDOMWindowUtils.advanceTimeAndRefresh for description.
<span class="lineNum">      82 </span>            :    */
<span class="lineNum">      83 </span>            :   void AdvanceTimeAndRefresh(int64_t aMilliseconds);
<span class="lineNum">      84 </span>            :   void RestoreNormalRefresh();
<span class="lineNum">      85 </span>            :   void DoTick();
<span class="lineNum">      86 </span>            :   bool IsTestControllingRefreshesEnabled() const
<span class="lineNum">      87 </span>            :   {
<span class="lineNum">      88 </span>            :     return mTestControllingRefreshes;
<span class="lineNum">      89 </span>            :   }
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   /**
<span class="lineNum">      92 </span>            :    * Return the time of the most recent refresh.  This is intended to be
<span class="lineNum">      93 </span>            :    * used by callers who want to start an animation now and want to know
<span class="lineNum">      94 </span>            :    * what time to consider the start of the animation.  (This helps
<span class="lineNum">      95 </span>            :    * ensure that multiple animations started during the same event off
<span class="lineNum">      96 </span>            :    * the main event loop have the same start time.)
<span class="lineNum">      97 </span>            :    */
<span class="lineNum">      98 </span>            :   mozilla::TimeStamp MostRecentRefresh() const;
<span class="lineNum">      99 </span>            :   /**
<span class="lineNum">     100 </span>            :    * Same thing, but in microseconds since the epoch.
<span class="lineNum">     101 </span>            :    */
<span class="lineNum">     102 </span>            :   int64_t MostRecentRefreshEpochTime() const;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :   /**
<span class="lineNum">     105 </span>            :    * Add / remove refresh observers.  Returns whether the operation
<span class="lineNum">     106 </span>            :    * succeeded.
<span class="lineNum">     107 </span>            :    *
<span class="lineNum">     108 </span>            :    * The flush type affects:
<span class="lineNum">     109 </span>            :    *   + the order in which the observers are notified (lowest flush
<span class="lineNum">     110 </span>            :    *     type to highest, in order registered)
<span class="lineNum">     111 </span>            :    *   + (in the future) which observers are suppressed when the display
<span class="lineNum">     112 </span>            :    *     doesn't require current position data or isn't currently
<span class="lineNum">     113 </span>            :    *     painting, and, correspondingly, which get notified when there
<span class="lineNum">     114 </span>            :    *     is a flush during such suppression
<span class="lineNum">     115 </span>            :    * and it must be FlushType::Style, FlushType::Layout, or FlushType::Display.
<span class="lineNum">     116 </span>            :    *
<span class="lineNum">     117 </span>            :    * The refresh driver does NOT own a reference to these observers;
<span class="lineNum">     118 </span>            :    * they must remove themselves before they are destroyed.
<span class="lineNum">     119 </span>            :    *
<span class="lineNum">     120 </span>            :    * The observer will be called even if there is no other activity.
<span class="lineNum">     121 </span>            :    */
<span class="lineNum">     122 </span>            :   bool AddRefreshObserver(nsARefreshObserver *aObserver,
<span class="lineNum">     123 </span>            :                           mozilla::FlushType aFlushType);
<span class="lineNum">     124 </span>            :   bool RemoveRefreshObserver(nsARefreshObserver *aObserver,
<span class="lineNum">     125 </span>            :                              mozilla::FlushType aFlushType);
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :   /**
<span class="lineNum">     128 </span>            :    * Add an observer that will be called after each refresh. The caller
<span class="lineNum">     129 </span>            :    * must remove the observer before it is deleted. This does not trigger
<span class="lineNum">     130 </span>            :    * refresh driver ticks.
<span class="lineNum">     131 </span>            :    */
<span class="lineNum">     132 </span>            :   void AddPostRefreshObserver(nsAPostRefreshObserver *aObserver);
<span class="lineNum">     133 </span>            :   void RemovePostRefreshObserver(nsAPostRefreshObserver *aObserver);
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :   /**
<span class="lineNum">     136 </span>            :    * Add/Remove imgIRequest versions of observers.
<span class="lineNum">     137 </span>            :    *
<span class="lineNum">     138 </span>            :    * These are used for hooking into the refresh driver for
<span class="lineNum">     139 </span>            :    * controlling animated images.
<span class="lineNum">     140 </span>            :    *
<span class="lineNum">     141 </span>            :    * @note The refresh driver owns a reference to these listeners.
<span class="lineNum">     142 </span>            :    *
<span class="lineNum">     143 </span>            :    * @note Technically, imgIRequest objects are not nsARefreshObservers, but
<span class="lineNum">     144 </span>            :    * for controlling animated image repaint events, we subscribe the
<span class="lineNum">     145 </span>            :    * imgIRequests to the nsRefreshDriver for notification of paint events.
<span class="lineNum">     146 </span>            :    *
<span class="lineNum">     147 </span>            :    * @returns whether the operation succeeded, or void in the case of removal.
<span class="lineNum">     148 </span>            :    */
<span class="lineNum">     149 </span>            :   bool AddImageRequest(imgIRequest* aRequest);
<span class="lineNum">     150 </span>            :   void RemoveImageRequest(imgIRequest* aRequest);
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   /**
<a name="153"><span class="lineNum">     153 </span>            :    * Add / remove presshells that we should flush style and layout on</a>
<span class="lineNum">     154 </span>            :    */
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   bool AddStyleFlushObserver(nsIPresShell* aShell) {</span>
<span class="lineNum">     156 </span>            :     NS_ASSERTION(!mStyleFlushObservers.Contains(aShell),
<span class="lineNum">     157 </span>            :                  &quot;Double-adding style flush observer&quot;);
<span class="lineNum">     158 </span>            :     // We only get the cause for the first observer each frame because capturing
<span class="lineNum">     159 </span>            :     // a stack is expensive. This is still useful if (1) you're trying to remove
<span class="lineNum">     160 </span>            :     // all flushes for a particial frame or (2) the costly flush is triggered
<span class="lineNum">     161 </span>            :     // near the call site where the first observer is triggered.
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     if (!mStyleCause) {</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       mStyleCause = profiler_get_backtrace();</span>
<span class="lineNum">     164 </span>            :     }
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     bool appended = mStyleFlushObservers.AppendElement(aShell) != nullptr;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     EnsureTimerStarted();</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     return appended;</span>
<span class="lineNum">     169 </span>            :   }
<span class="lineNum">     170 </span>            :   void RemoveStyleFlushObserver(nsIPresShell* aShell) {
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 :     mStyleFlushObservers.RemoveElement(aShell);</span></a>
<span class="lineNum">     172 </span>            :   }
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   bool AddLayoutFlushObserver(nsIPresShell* aShell) {</span>
<span class="lineNum">     174 </span>            :     NS_ASSERTION(!IsLayoutFlushObserver(aShell),
<span class="lineNum">     175 </span>            :                  &quot;Double-adding layout flush observer&quot;);
<span class="lineNum">     176 </span>            :     // We only get the cause for the first observer each frame because capturing
<span class="lineNum">     177 </span>            :     // a stack is expensive. This is still useful if (1) you're trying to remove
<span class="lineNum">     178 </span>            :     // all flushes for a particial frame or (2) the costly flush is triggered
<span class="lineNum">     179 </span>            :     // near the call site where the first observer is triggered.
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     if (!mReflowCause) {</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       mReflowCause = profiler_get_backtrace();</span>
<span class="lineNum">     182 </span>            :     }
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     bool appended = mLayoutFlushObservers.AppendElement(aShell) != nullptr;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     EnsureTimerStarted();</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     return appended;</span>
<span class="lineNum">     186 </span>            :   }
<span class="lineNum">     187 </span>            :   void RemoveLayoutFlushObserver(nsIPresShell* aShell) {
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     mLayoutFlushObservers.RemoveElement(aShell);</span>
<span class="lineNum">     189 </span>            :   }
<span class="lineNum">     190 </span>            :   bool IsLayoutFlushObserver(nsIPresShell* aShell) {
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     return mLayoutFlushObservers.Contains(aShell);</span>
<span class="lineNum">     192 </span>            :   }
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   /**
<span class="lineNum">     195 </span>            :    * Remember whether our presshell's view manager needs a flush
<span class="lineNum">     196 </span>            :    */
<span class="lineNum">     197 </span>            :   void ScheduleViewManagerFlush();
<span class="lineNum">     198 </span>            :   void RevokeViewManagerFlush() {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     mViewManagerFlushIsPending = false;</span>
<span class="lineNum">     200 </span>            :   }
<span class="lineNum">     201 </span>            :   bool ViewManagerFlushIsPending() {
<span class="lineNum">     202 </span>            :     return mViewManagerFlushIsPending;
<span class="lineNum">     203 </span>            :   }
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   /**
<span class="lineNum">     206 </span>            :    * Add a document for which we have FrameRequestCallbacks
<span class="lineNum">     207 </span>            :    */
<span class="lineNum">     208 </span>            :   void ScheduleFrameRequestCallbacks(nsIDocument* aDocument);
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :   /**
<span class="lineNum">     211 </span>            :    * Remove a document for which we have FrameRequestCallbacks
<span class="lineNum">     212 </span>            :    */
<span class="lineNum">     213 </span>            :   void RevokeFrameRequestCallbacks(nsIDocument* aDocument);
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   /**
<span class="lineNum">     216 </span>            :    * Queue a new event to dispatch in next tick before the style flush
<span class="lineNum">     217 </span>            :    */
<span class="lineNum">     218 </span>            :   void ScheduleEventDispatch(nsINode* aTarget, nsIDOMEvent* aEvent);
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :   /**
<span class="lineNum">     221 </span>            :    * Cancel all pending events scheduled by ScheduleEventDispatch which
<span class="lineNum">     222 </span>            :    * targets any node in aDocument.
<span class="lineNum">     223 </span>            :    */
<span class="lineNum">     224 </span>            :   void CancelPendingEvents(nsIDocument* aDocument);
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   /**
<span class="lineNum">     227 </span>            :    * Schedule a frame visibility update &quot;soon&quot;, subject to the heuristics and
<span class="lineNum">     228 </span>            :    * throttling we apply to visibility updates.
<span class="lineNum">     229 </span>            :    */
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   void ScheduleFrameVisibilityUpdate() { mNeedToRecomputeVisibility = true; }</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /**
<span class="lineNum">     233 </span>            :    * Tell the refresh driver that it is done driving refreshes and
<span class="lineNum">     234 </span>            :    * should stop its timer and forget about its pres context.  This may
<span class="lineNum">     235 </span>            :    * be called from within a refresh.
<span class="lineNum">     236 </span>            :    */
<span class="lineNum">     237 </span>            :   void Disconnect();
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   bool IsFrozen() { return mFreezeCount &gt; 0; }
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   /**
<span class="lineNum">     242 </span>            :    * Freeze the refresh driver.  It should stop delivering future
<span class="lineNum">     243 </span>            :    * refreshes until thawed. Note that the number of calls to Freeze() must
<span class="lineNum">     244 </span>            :    * match the number of calls to Thaw() in order for the refresh driver to
<span class="lineNum">     245 </span>            :    * be un-frozen.
<span class="lineNum">     246 </span>            :    */
<span class="lineNum">     247 </span>            :   void Freeze();
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   /**
<span class="lineNum">     250 </span>            :    * Thaw the refresh driver.  If the number of calls to Freeze() matches the
<span class="lineNum">     251 </span>            :    * number of calls to this function, the refresh driver should start
<span class="lineNum">     252 </span>            :    * delivering refreshes again.
<span class="lineNum">     253 </span>            :    */
<span class="lineNum">     254 </span>            :   void Thaw();
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :   /**
<span class="lineNum">     257 </span>            :    * Throttle or unthrottle the refresh driver.  This is done if the
<span class="lineNum">     258 </span>            :    * corresponding presshell is hidden or shown.
<span class="lineNum">     259 </span>            :    */
<span class="lineNum">     260 </span>            :   void SetThrottled(bool aThrottled);
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   /**
<span class="lineNum">     263 </span>            :    * Return the prescontext we were initialized with
<span class="lineNum">     264 </span>            :    */
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   nsPresContext* GetPresContext() const { return mPresContext; }</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   /**
<span class="lineNum">     268 </span>            :    * PBackgroundChild actor is created asynchronously in content process.
<span class="lineNum">     269 </span>            :    * We can't create vsync-based timers during PBackground startup. This
<span class="lineNum">     270 </span>            :    * function will be called when PBackgroundChild actor is created. Then we can
<span class="lineNum">     271 </span>            :    * do the pending vsync-based timer creation.
<span class="lineNum">     272 </span>            :    */
<span class="lineNum">     273 </span>            :   static void PVsyncActorCreated(mozilla::layout::VsyncChild* aVsyncChild);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : #ifdef DEBUG
<span class="lineNum">     276 </span>            :   /**
<span class="lineNum">     277 </span>            :    * Check whether the given observer is an observer for the given flush type
<span class="lineNum">     278 </span>            :    */
<span class="lineNum">     279 </span>            :   bool IsRefreshObserver(nsARefreshObserver *aObserver,
<span class="lineNum">     280 </span>            :                          mozilla::FlushType aFlushType);
<span class="lineNum">     281 </span>            : #endif
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   /**
<span class="lineNum">     284 </span>            :    * Default interval the refresh driver uses, in ms.
<span class="lineNum">     285 </span>            :    */
<span class="lineNum">     286 </span>            :   static int32_t DefaultInterval();
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   bool IsInRefresh() { return mInRefresh; }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   void SetIsResizeSuppressed() { mResizeSuppressed = true; }</span>
<span class="lineNum">     291 </span>            :   bool IsResizeSuppressed() const { return mResizeSuppressed; }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   /**
<span class="lineNum">     294 </span>            :    * The latest value of process-wide jank levels.
<span class="lineNum">     295 </span>            :    *
<span class="lineNum">     296 </span>            :    * For each i, sJankLevels[i] counts the number of times delivery of
<span class="lineNum">     297 </span>            :    * vsync to the main thread has been delayed by at least 2^i
<span class="lineNum">     298 </span>            :    * ms. This data structure has been designed to make it easy to
<span class="lineNum">     299 </span>            :    * determine how much jank has taken place between two instants in
<span class="lineNum">     300 </span>            :    * time.
<span class="lineNum">     301 </span>            :    *
<span class="lineNum">     302 </span>            :    * Return `false` if `aJank` needs to be grown to accomodate the
<span class="lineNum">     303 </span>            :    * data but we didn't have enough memory.
<span class="lineNum">     304 </span>            :    */
<span class="lineNum">     305 </span>            :   static bool GetJankLevels(mozilla::Vector&lt;uint64_t&gt;&amp; aJank);
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   // mozilla::layers::TransactionIdAllocator
<span class="lineNum">     308 </span>            :   uint64_t GetTransactionId() override;
<span class="lineNum">     309 </span>            :   uint64_t LastTransactionId() const override;
<span class="lineNum">     310 </span>            :   void NotifyTransactionCompleted(uint64_t aTransactionId) override;
<span class="lineNum">     311 </span>            :   void RevokeTransactionId(uint64_t aTransactionId) override;
<span class="lineNum">     312 </span>            :   void ClearPendingTransactions() override;
<span class="lineNum">     313 </span>            :   void ResetInitialTransactionId(uint64_t aTransactionId) override;
<span class="lineNum">     314 </span>            :   mozilla::TimeStamp GetTransactionStart() override;
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :   bool IsWaitingForPaint(mozilla::TimeStamp aTime);
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span>            :   // nsARefreshObserver</a>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   NS_IMETHOD_(MozExternalRefCountType) AddRef(void) override { return TransactionIdAllocator::AddRef(); }</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   NS_IMETHOD_(MozExternalRefCountType) Release(void) override { return TransactionIdAllocator::Release(); }</span>
<span class="lineNum">     321 </span>            :   virtual void WillRefresh(mozilla::TimeStamp aTime) override;
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   /**
<span class="lineNum">     324 </span>            :    * Compute the time when the currently active refresh driver timer
<span class="lineNum">     325 </span>            :    * will start its next tick.
<span class="lineNum">     326 </span>            :    *
<span class="lineNum">     327 </span>            :    * Returns 'Nothing' if the refresh driver timer hasn't been
<span class="lineNum">     328 </span>            :    * initialized or if we can't tell when the next tick will happen.
<span class="lineNum">     329 </span>            :    *
<span class="lineNum">     330 </span>            :    * Returns Some(TimeStamp()), i.e. the null time, if the next tick is late.
<span class="lineNum">     331 </span>            :    *
<span class="lineNum">     332 </span>            :    * Otherwise returns Some(TimeStamp(t)), where t is the time of the next tick.
<span class="lineNum">     333 </span>            :    *
<span class="lineNum">     334 </span>            :    * Using these three types of return values it is possible to
<span class="lineNum">     335 </span>            :    * estimate three different things about the idleness of the
<span class="lineNum">     336 </span>            :    * currently active group of refresh drivers. This information is
<span class="lineNum">     337 </span>            :    * used by nsThread to schedule lower priority &quot;idle tasks&quot;.
<span class="lineNum">     338 </span>            :    *
<span class="lineNum">     339 </span>            :    * The 'Nothing' return value indicates to nsThread that the
<span class="lineNum">     340 </span>            :    * currently active refresh drivers will be idle for a time
<span class="lineNum">     341 </span>            :    * significantly longer than the current refresh rate and that it is
<span class="lineNum">     342 </span>            :    * free to schedule longer periods for executing idle tasks. This is the
<span class="lineNum">     343 </span>            :    * expected result when we aren't animating.
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :    * Returning the null time indicates to nsThread that we are very
<span class="lineNum">     346 </span>            :    * busy and that it should definitely not schedule idle tasks at
<span class="lineNum">     347 </span>            :    * all. This is the expected result when we are animating, but
<span class="lineNum">     348 </span>            :    * aren't able to keep up with the animation and hence need to skip
<span class="lineNum">     349 </span>            :    * paints. Since catching up to missed paints will happen as soon as
<span class="lineNum">     350 </span>            :    * possible, this is the expected result if any of the refresh
<span class="lineNum">     351 </span>            :    * drivers attached to the current refresh driver misses a paint.
<span class="lineNum">     352 </span>            :    *
<span class="lineNum">     353 </span>            :    * Returning Some(TimeStamp(t)) indicates to nsThread that we will
<span class="lineNum">     354 </span>            :    * be idle until. This is usually the case when we're animating
<span class="lineNum">     355 </span>            :    * without skipping paints.
<span class="lineNum">     356 </span>            :    */
<span class="lineNum">     357 </span>            :   static mozilla::Maybe&lt;mozilla::TimeStamp&gt; GetIdleDeadlineHint();
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   bool SkippedPaints() const
<span class="lineNum">     360 </span>            :   {
<span class="lineNum">     361 </span>            :     return mSkippedPaints;
<span class="lineNum">     362 </span>            :   }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : private:
<a name="365"><span class="lineNum">     365 </span>            :   typedef nsTObserverArray&lt;nsARefreshObserver*&gt; ObserverArray;</a>
<a name="366"><span class="lineNum">     366 </span>            :   typedef nsTHashtable&lt;nsISupportsHashKey&gt; RequestTable;</a>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   struct ImageStartData {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     ImageStartData()</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     mozilla::Maybe&lt;mozilla::TimeStamp&gt; mStartTime;
<span class="lineNum">     373 </span>            :     RequestTable mEntries;
<span class="lineNum">     374 </span>            :   };
<span class="lineNum">     375 </span>            :   typedef nsClassHashtable&lt;nsUint32HashKey, ImageStartData&gt; ImageStartTable;
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   void DispatchPendingEvents();
<span class="lineNum">     378 </span>            :   void DispatchAnimationEvents();
<span class="lineNum">     379 </span>            :   void RunFrameRequestCallbacks(mozilla::TimeStamp aNowTime);
<span class="lineNum">     380 </span>            :   void Tick(int64_t aNowEpoch, mozilla::TimeStamp aNowTime);
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   enum EnsureTimerStartedFlags {
<span class="lineNum">     383 </span>            :     eNone = 0,
<span class="lineNum">     384 </span>            :     eForceAdjustTimer = 1 &lt;&lt; 0,
<span class="lineNum">     385 </span>            :     eAllowTimeToGoBackwards = 1 &lt;&lt; 1,
<span class="lineNum">     386 </span>            :     eNeverAdjustTimer = 1 &lt;&lt; 2,
<span class="lineNum">     387 </span>            :   };
<span class="lineNum">     388 </span>            :   void EnsureTimerStarted(EnsureTimerStartedFlags aFlags = eNone);
<span class="lineNum">     389 </span>            :   void StopTimer();
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :   uint32_t ObserverCount() const;
<span class="lineNum">     392 </span>            :   uint32_t ImageRequestCount() const;
<span class="lineNum">     393 </span>            :   ObserverArray&amp; ArrayFor(mozilla::FlushType aFlushType);
<span class="lineNum">     394 </span>            :   // Trigger a refresh immediately, if haven't been disconnected or frozen.
<span class="lineNum">     395 </span>            :   void DoRefresh();
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :   double GetRefreshTimerInterval() const;
<span class="lineNum">     398 </span>            :   double GetRegularTimerInterval(bool *outIsDefault = nullptr) const;
<span class="lineNum">     399 </span>            :   static double GetThrottledTimerInterval();
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :   static mozilla::TimeDuration GetMinRecomputeVisibilityInterval();
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :   bool HaveFrameRequestCallbacks() const {
<span class="lineNum">     404 </span>            :     return mFrameRequestCallbackDocs.Length() != 0;
<span class="lineNum">     405 </span>            :   }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :   void FinishedWaitingForTransaction();
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :   mozilla::RefreshDriverTimer* ChooseTimer() const;
<span class="lineNum">     410 </span>            :   mozilla::RefreshDriverTimer* mActiveTimer;
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            :   UniqueProfilerBacktrace mReflowCause;
<span class="lineNum">     413 </span>            :   UniqueProfilerBacktrace mStyleCause;
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :   // nsPresContext passed in constructor and unset in Disconnect.
<span class="lineNum">     416 </span>            :   mozilla::WeakPtr&lt;nsPresContext&gt; mPresContext;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   RefPtr&lt;nsRefreshDriver&gt; mRootRefresh;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :   // The most recently allocated transaction id.
<span class="lineNum">     421 </span>            :   uint64_t mPendingTransaction;
<span class="lineNum">     422 </span>            :   // The most recently completed transaction id.
<span class="lineNum">     423 </span>            :   uint64_t mCompletedTransaction;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   uint32_t mFreezeCount;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   // How long we wait between ticks for throttled (which generally means
<span class="lineNum">     428 </span>            :   // non-visible) documents registered with a non-throttled refresh driver.
<span class="lineNum">     429 </span>            :   const mozilla::TimeDuration mThrottledFrameRequestInterval;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   // How long we wait, at a minimum, before recomputing approximate frame
<span class="lineNum">     432 </span>            :   // visibility information. This is a minimum because, regardless of this
<span class="lineNum">     433 </span>            :   // interval, we only recompute visibility when we've seen a layout or style
<span class="lineNum">     434 </span>            :   // flush since the last time we did it.
<span class="lineNum">     435 </span>            :   const mozilla::TimeDuration mMinRecomputeVisibilityInterval;
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   bool mThrottled;
<span class="lineNum">     438 </span>            :   bool mNeedToRecomputeVisibility;
<span class="lineNum">     439 </span>            :   bool mTestControllingRefreshes;
<span class="lineNum">     440 </span>            :   bool mViewManagerFlushIsPending;
<span class="lineNum">     441 </span>            :   bool mInRefresh;
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :   // True if the refresh driver is suspended waiting for transaction
<span class="lineNum">     444 </span>            :   // id's to be returned and shouldn't do any work during Tick().
<span class="lineNum">     445 </span>            :   bool mWaitingForTransaction;
<span class="lineNum">     446 </span>            :   // True if Tick() was skipped because of mWaitingForTransaction and
<span class="lineNum">     447 </span>            :   // we should schedule a new Tick immediately when resumed instead
<span class="lineNum">     448 </span>            :   // of waiting until the next interval.
<span class="lineNum">     449 </span>            :   bool mSkippedPaints;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :   // True if view managers should delay any resize request until the
<span class="lineNum">     452 </span>            :   // next tick by the refresh driver. This flag will be reset at the
<span class="lineNum">     453 </span>            :   // start of every tick.
<span class="lineNum">     454 </span>            :   bool mResizeSuppressed;
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   int64_t mMostRecentRefreshEpochTime;
<span class="lineNum">     457 </span>            :   // Number of seconds that the refresh driver is blocked waiting for a compositor
<span class="lineNum">     458 </span>            :   // transaction to be completed before we append a note to the gfx critical log.
<span class="lineNum">     459 </span>            :   // The number is doubled every time the threshold is hit.
<span class="lineNum">     460 </span>            :   uint64_t mWarningThreshold;
<span class="lineNum">     461 </span>            :   mozilla::TimeStamp mMostRecentRefresh;
<span class="lineNum">     462 </span>            :   mozilla::TimeStamp mMostRecentTick;
<span class="lineNum">     463 </span>            :   mozilla::TimeStamp mTickStart;
<span class="lineNum">     464 </span>            :   mozilla::TimeStamp mNextThrottledFrameRequestTick;
<span class="lineNum">     465 </span>            :   mozilla::TimeStamp mNextRecomputeVisibilityTick;
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :   // separate arrays for each flush type we support
<span class="lineNum">     468 </span>            :   ObserverArray mObservers[3];
<span class="lineNum">     469 </span>            :   RequestTable mRequests;
<a name="470"><span class="lineNum">     470 </span>            :   ImageStartTable mStartTable;</a>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   struct PendingEvent {</span>
<span class="lineNum">     473 </span>            :     nsCOMPtr&lt;nsINode&gt; mTarget;
<span class="lineNum">     474 </span>            :     nsCOMPtr&lt;nsIDOMEvent&gt; mEvent;
<span class="lineNum">     475 </span>            :   };
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   AutoTArray&lt;nsIPresShell*, 16&gt; mStyleFlushObservers;
<span class="lineNum">     478 </span>            :   AutoTArray&lt;nsIPresShell*, 16&gt; mLayoutFlushObservers;
<span class="lineNum">     479 </span>            :   // nsTArray on purpose, because we want to be able to swap.
<span class="lineNum">     480 </span>            :   nsTArray&lt;nsIDocument*&gt; mFrameRequestCallbackDocs;
<span class="lineNum">     481 </span>            :   nsTArray&lt;nsIDocument*&gt; mThrottledFrameRequestCallbackDocs;
<span class="lineNum">     482 </span>            :   nsTObserverArray&lt;nsAPostRefreshObserver*&gt; mPostRefreshObservers;
<span class="lineNum">     483 </span>            :   nsTArray&lt;PendingEvent&gt; mPendingEvents;
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :   void BeginRefreshingImages(RequestTable&amp; aEntries,
<span class="lineNum">     486 </span>            :                              mozilla::TimeStamp aDesired);
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :   friend class mozilla::RefreshDriverTimer;
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :   static void Shutdown();
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :   // `true` if we are currently in jank-critical mode.
<span class="lineNum">     493 </span>            :   //
<span class="lineNum">     494 </span>            :   // In jank-critical mode, any iteration of the event loop that takes
<span class="lineNum">     495 </span>            :   // more than 16ms to compute will cause an ongoing animation to miss
<span class="lineNum">     496 </span>            :   // frames.
<span class="lineNum">     497 </span>            :   //
<span class="lineNum">     498 </span>            :   // For simplicity, the current implementation assumes that we are
<span class="lineNum">     499 </span>            :   // in jank-critical mode if and only if the vsync driver has at least
<span class="lineNum">     500 </span>            :   // one observer.
<span class="lineNum">     501 </span>            :   static bool IsJankCritical();
<span class="lineNum">     502 </span>            : };
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : #endif /* !defined(nsRefreshDriver_h_) */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
