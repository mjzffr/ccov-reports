<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mochitest-e10s.info - security/nss/lib/freebl/ec.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">security/nss/lib/freebl</a> - ec.c<span style="font-size: 80%;"> (source / <a href="ec.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mochitest-e10s.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">428</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public</a>
<span class="lineNum">       2 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       3 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #ifdef FREEBL_NO_DEPEND
<span class="lineNum">       6 </span>            : #include &quot;stubs.h&quot;
<span class="lineNum">       7 </span>            : #endif
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;blapi.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;prerr.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;secerr.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;secmpi.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;secitem.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mplogic.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;ec.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;ecl.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : static const ECMethod kMethods[] = {
<span class="lineNum">      21 </span>            :     { ECCurve25519,
<span class="lineNum">      22 </span>            :       ec_Curve25519_pt_mul,
<span class="lineNum">      23 </span>            :       ec_Curve25519_pt_validate }
<span class="lineNum">      24 </span>            : };
<a name="25"><span class="lineNum">      25 </span>            : </a>
<span class="lineNum">      26 </span>            : static const ECMethod *
<span class="lineNum">      27 </span><span class="lineNoCov">          0 : ec_get_method_from_name(ECCurveName name)</span>
<span class="lineNum">      28 </span>            : {
<span class="lineNum">      29 </span>            :     int i;
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; sizeof(kMethods) / sizeof(kMethods[0]); ++i) {</span>
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :         if (kMethods[i].name == name) {</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :             return &amp;kMethods[i];</span>
<span class="lineNum">      33 </span>            :         }
<span class="lineNum">      34 </span>            :     }
<span class="lineNum">      35 </span>            :     return NULL;
<span class="lineNum">      36 </span>            : }
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /*
<span class="lineNum">      39 </span>            :  * Returns true if pointP is the point at infinity, false otherwise
<a name="40"><span class="lineNum">      40 </span>            :  */</a>
<span class="lineNum">      41 </span>            : PRBool
<span class="lineNum">      42 </span><span class="lineNoCov">          0 : ec_point_at_infinity(SECItem *pointP)</span>
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span>            :     unsigned int i;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :     for (i = 1; i &lt; pointP-&gt;len; i++) {</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :         if (pointP-&gt;data[i] != 0x00)</span>
<span class="lineNum">      48 </span>            :             return PR_FALSE;
<span class="lineNum">      49 </span>            :     }
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            :     return PR_TRUE;
<span class="lineNum">      52 </span>            : }
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /*
<span class="lineNum">      55 </span>            :  * Computes scalar point multiplication pointQ = k1 * G + k2 * pointP for
<span class="lineNum">      56 </span>            :  * the curve whose parameters are encoded in params with base point G.
<a name="57"><span class="lineNum">      57 </span>            :  */</a>
<span class="lineNum">      58 </span>            : SECStatus
<span class="lineNum">      59 </span><span class="lineNoCov">          0 : ec_points_mul(const ECParams *params, const mp_int *k1, const mp_int *k2,</span>
<span class="lineNum">      60 </span>            :               const SECItem *pointP, SECItem *pointQ)
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span>            :     mp_int Px, Py, Qx, Qy;
<span class="lineNum">      63 </span>            :     mp_int Gx, Gy, order, irreducible, a, b;
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     ECGroup *group = NULL;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">      67 </span>            :     int len;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #if EC_DEBUG
<span class="lineNum">      70 </span>            :     int i;
<span class="lineNum">      71 </span>            :     char mpstr[256];
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :     printf(&quot;ec_points_mul: params [len=%d]:&quot;, params-&gt;DEREncoding.len);
<span class="lineNum">      74 </span>            :     for (i = 0; i &lt; params-&gt;DEREncoding.len; i++)
<span class="lineNum">      75 </span>            :         printf(&quot;%02x:&quot;, params-&gt;DEREncoding.data[i]);
<span class="lineNum">      76 </span>            :     printf(&quot;\n&quot;);
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            :     if (k1 != NULL) {
<span class="lineNum">      79 </span>            :         mp_tohex((mp_int *)k1, mpstr);
<span class="lineNum">      80 </span>            :         printf(&quot;ec_points_mul: scalar k1: %s\n&quot;, mpstr);
<span class="lineNum">      81 </span>            :         mp_todecimal((mp_int *)k1, mpstr);
<span class="lineNum">      82 </span>            :         printf(&quot;ec_points_mul: scalar k1: %s (dec)\n&quot;, mpstr);
<span class="lineNum">      83 </span>            :     }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :     if (k2 != NULL) {
<span class="lineNum">      86 </span>            :         mp_tohex((mp_int *)k2, mpstr);
<span class="lineNum">      87 </span>            :         printf(&quot;ec_points_mul: scalar k2: %s\n&quot;, mpstr);
<span class="lineNum">      88 </span>            :         mp_todecimal((mp_int *)k2, mpstr);
<span class="lineNum">      89 </span>            :         printf(&quot;ec_points_mul: scalar k2: %s (dec)\n&quot;, mpstr);
<span class="lineNum">      90 </span>            :     }
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :     if (pointP != NULL) {
<span class="lineNum">      93 </span>            :         printf(&quot;ec_points_mul: pointP [len=%d]:&quot;, pointP-&gt;len);
<span class="lineNum">      94 </span>            :         for (i = 0; i &lt; pointP-&gt;len; i++)
<span class="lineNum">      95 </span>            :             printf(&quot;%02x:&quot;, pointP-&gt;data[i]);
<span class="lineNum">      96 </span>            :         printf(&quot;\n&quot;);
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span>            : #endif
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :     /* NOTE: We only support uncompressed points for now */
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     len = (params-&gt;fieldID.size + 7) &gt;&gt; 3;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     if (pointP != NULL) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         if ((pointP-&gt;data[0] != EC_POINT_FORM_UNCOMPRESSED) ||</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :             (pointP-&gt;len != (2 * len + 1))) {</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_UNSUPPORTED_EC_POINT_FORM);</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :             return SECFailure;</span>
<span class="lineNum">     107 </span>            :         };
<span class="lineNum">     108 </span>            :     }
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Px) = 0;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Py) = 0;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Qx) = 0;</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Qy) = 0;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Gx) = 0;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Gy) = 0;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;order) = 0;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;irreducible) = 0;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;a) = 0;</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;b) = 0;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Px));</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Py));</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Qx));</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Qy));</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Gx));</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Gy));</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;order));</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;irreducible));</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;a));</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;b));</span>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     if ((k2 != NULL) &amp;&amp; (pointP != NULL)) {</span>
<span class="lineNum">     132 </span>            :         /* Initialize Px and Py */
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_read_unsigned_octets(&amp;Px, pointP-&gt;data + 1, (mp_size)len));</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_read_unsigned_octets(&amp;Py, pointP-&gt;data + 1 + len, (mp_size)len));</span>
<span class="lineNum">     135 </span>            :     }
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     /* construct from named params, if possible */
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     if (params-&gt;name != ECCurve_noName) {</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         group = ECGroup_fromName(params-&gt;name);</span>
<span class="lineNum">     140 </span>            :     }
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     if (group == NULL)</span>
<span class="lineNum">     143 </span>            :         goto cleanup;
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     if ((k2 != NULL) &amp;&amp; (pointP != NULL)) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(ECPoints_mul(group, k1, k2, &amp;Px, &amp;Py, &amp;Qx, &amp;Qy));</span>
<span class="lineNum">     147 </span>            :     } else {
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(ECPoints_mul(group, k1, NULL, NULL, NULL, &amp;Qx, &amp;Qy));</span>
<span class="lineNum">     149 </span>            :     }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :     /* Construct the SECItem representation of point Q */
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     pointQ-&gt;data[0] = EC_POINT_FORM_UNCOMPRESSED;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_to_fixlen_octets(&amp;Qx, pointQ-&gt;data + 1,</span>
<span class="lineNum">     154 </span>            :                                      (mp_size)len));
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_to_fixlen_octets(&amp;Qy, pointQ-&gt;data + 1 + len,</span>
<span class="lineNum">     156 </span>            :                                      (mp_size)len));
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     rv = SECSuccess;</span>
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            : #if EC_DEBUG
<span class="lineNum">     161 </span>            :     printf(&quot;ec_points_mul: pointQ [len=%d]:&quot;, pointQ-&gt;len);
<span class="lineNum">     162 </span>            :     for (i = 0; i &lt; pointQ-&gt;len; i++)
<span class="lineNum">     163 </span>            :         printf(&quot;%02x:&quot;, pointQ-&gt;data[i]);
<span class="lineNum">     164 </span>            :     printf(&quot;\n&quot;);
<span class="lineNum">     165 </span>            : #endif
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : cleanup:
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     ECGroup_free(group);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Px);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Py);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Qx);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Qy);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Gx);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Gy);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     mp_clear(&amp;order);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     mp_clear(&amp;irreducible);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     mp_clear(&amp;a);</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     mp_clear(&amp;b);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     181 </span>            :         rv = SECFailure;
<span class="lineNum">     182 </span>            :     }
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     185 </span>            : }
<span class="lineNum">     186 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : /* Generates a new EC key pair. The private key is a supplied
<span class="lineNum">     189 </span>            :  * value and the public key is the result of performing a scalar
<span class="lineNum">     190 </span>            :  * point multiplication of that value with the curve's base point.
<a name="191"><span class="lineNum">     191 </span>            :  */</a>
<span class="lineNum">     192 </span>            : SECStatus
<span class="lineNum">     193 </span><span class="lineNoCov">          0 : ec_NewKey(ECParams *ecParams, ECPrivateKey **privKey,</span>
<span class="lineNum">     194 </span>            :           const unsigned char *privKeyBytes, int privKeyLen)
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     197 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     198 </span>            :     PLArenaPool *arena;
<span class="lineNum">     199 </span>            :     ECPrivateKey *key;
<span class="lineNum">     200 </span>            :     mp_int k;
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     202 </span>            :     int len;
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : #if EC_DEBUG
<span class="lineNum">     205 </span>            :     printf(&quot;ec_NewKey called\n&quot;);
<span class="lineNum">     206 </span>            : #endif
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;k) = 0;</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     if (!ecParams || !privKey || !privKeyBytes || (privKeyLen &lt; 0) ||</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         !ecParams-&gt;name) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     213 </span>            :     }
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :     /* Initialize an arena for the EC key. */
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     if (!(arena = PORT_NewArena(NSS_FREEBL_DEFAULT_CHUNKSIZE)))</span>
<span class="lineNum">     217 </span>            :         return SECFailure;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     key = (ECPrivateKey *)PORT_ArenaZAlloc(arena, sizeof(ECPrivateKey));</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     if (!key) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         PORT_FreeArena(arena, PR_TRUE);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     /* Set the version number (SEC 1 section C.4 says it should be 1) */
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     SECITEM_AllocItem(arena, &amp;key-&gt;version, 1);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     key-&gt;version.data[0] = 1;</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     /* Copy all of the fields from the ECParams argument to the
<span class="lineNum">     230 </span>            :      * ECParams structure within the private key.
<span class="lineNum">     231 </span>            :      */
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.arena = arena;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.type = ecParams-&gt;type;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.fieldID.size = ecParams-&gt;fieldID.size;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.fieldID.type = ecParams-&gt;fieldID.type;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     if (ecParams-&gt;fieldID.type == ec_field_GFp ||</span>
<span class="lineNum">     237 </span>            :         ecParams-&gt;fieldID.type == ec_field_plain) {
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.fieldID.u.prime,</span>
<span class="lineNum">     239 </span>            :                                       &amp;ecParams-&gt;fieldID.u.prime));
<span class="lineNum">     240 </span>            :     } else {
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.fieldID.u.poly,</span>
<span class="lineNum">     242 </span>            :                                       &amp;ecParams-&gt;fieldID.u.poly));
<span class="lineNum">     243 </span>            :     }
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.fieldID.k1 = ecParams-&gt;fieldID.k1;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.fieldID.k2 = ecParams-&gt;fieldID.k2;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.fieldID.k3 = ecParams-&gt;fieldID.k3;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curve.a,</span>
<span class="lineNum">     248 </span>            :                                   &amp;ecParams-&gt;curve.a));
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curve.b,</span>
<span class="lineNum">     250 </span>            :                                   &amp;ecParams-&gt;curve.b));
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curve.seed,</span>
<span class="lineNum">     252 </span>            :                                   &amp;ecParams-&gt;curve.seed));
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.base,</span>
<span class="lineNum">     254 </span>            :                                   &amp;ecParams-&gt;base));
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.order,</span>
<span class="lineNum">     256 </span>            :                                   &amp;ecParams-&gt;order));
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.cofactor = ecParams-&gt;cofactor;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.DEREncoding,</span>
<span class="lineNum">     259 </span>            :                                   &amp;ecParams-&gt;DEREncoding));
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     key-&gt;ecParams.name = ecParams-&gt;name;</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curveOID,</span>
<span class="lineNum">     262 </span>            :                                   &amp;ecParams-&gt;curveOID));
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     SECITEM_AllocItem(arena, &amp;key-&gt;publicValue, EC_GetPointSize(ecParams));</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     len = ecParams-&gt;order.len;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     SECITEM_AllocItem(arena, &amp;key-&gt;privateValue, len);</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :     /* Copy private key */
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     if (privKeyLen &gt;= len) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         memcpy(key-&gt;privateValue.data, privKeyBytes, len);</span>
<span class="lineNum">     271 </span>            :     } else {
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         memset(key-&gt;privateValue.data, 0, (len - privKeyLen));</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         memcpy(key-&gt;privateValue.data + (len - privKeyLen), privKeyBytes, privKeyLen);</span>
<span class="lineNum">     274 </span>            :     }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     /* Compute corresponding public key */
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     /* Use curve specific code for point multiplication */
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     if (ecParams-&gt;fieldID.type == ec_field_plain) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         const ECMethod *method = ec_get_method_from_name(ecParams-&gt;name);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         if (method == NULL || method-&gt;mul == NULL) {</span>
<span class="lineNum">     282 </span>            :             /* unknown curve */
<span class="lineNum">     283 </span>            :             rv = SECFailure;
<span class="lineNum">     284 </span>            :             goto cleanup;
<span class="lineNum">     285 </span>            :         }
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         rv = method-&gt;mul(&amp;key-&gt;publicValue, &amp;key-&gt;privateValue, NULL);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         goto done;</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;k));</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;k, key-&gt;privateValue.data,</span>
<span class="lineNum">     292 </span>            :                                          (mp_size)len));
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     rv = ec_points_mul(ecParams, &amp;k, NULL, NULL, &amp;(key-&gt;publicValue));</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     if (rv != SECSuccess) {</span>
<span class="lineNum">     296 </span>            :         goto cleanup;
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : done:
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     *privKey = key;</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : cleanup:
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     mp_clear(&amp;k);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     if (rv) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         PORT_FreeArena(arena, PR_TRUE);</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : #if EC_DEBUG
<span class="lineNum">     309 </span>            :     printf(&quot;ec_NewKey returning %s\n&quot;,
<span class="lineNum">     310 </span>            :            (rv == SECSuccess) ? &quot;success&quot; : &quot;failure&quot;);
<span class="lineNum">     311 </span>            : #endif
<span class="lineNum">     312 </span>            : #else
<span class="lineNum">     313 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     314 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     317 </span>            : }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : /* Generates a new EC key pair. The private key is a supplied
<span class="lineNum">     320 </span>            :  * random value (in seed) and the public key is the result of
<span class="lineNum">     321 </span>            :  * performing a scalar point multiplication of that value with
<span class="lineNum">     322 </span>            :  * the curve's base point.
<a name="323"><span class="lineNum">     323 </span>            :  */</a>
<span class="lineNum">     324 </span>            : SECStatus
<span class="lineNum">     325 </span><span class="lineNoCov">          0 : EC_NewKeyFromSeed(ECParams *ecParams, ECPrivateKey **privKey,</span>
<span class="lineNum">     326 </span>            :                   const unsigned char *seed, int seedlen)
<span class="lineNum">     327 </span>            : {
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     329 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     rv = ec_NewKey(ecParams, privKey, seed, seedlen);</span>
<span class="lineNum">     331 </span>            : #else
<span class="lineNum">     332 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     333 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     335 </span>            : }
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     338 </span>            : /* Generate a random private key using the algorithm A.4.1 of ANSI X9.62,
<span class="lineNum">     339 </span>            :  * modified a la FIPS 186-2 Change Notice 1 to eliminate the bias in the
<span class="lineNum">     340 </span>            :  * random number generator.
<span class="lineNum">     341 </span>            :  *
<span class="lineNum">     342 </span>            :  * Parameters
<span class="lineNum">     343 </span>            :  * - order: a buffer that holds the curve's group order
<span class="lineNum">     344 </span>            :  * - len: the length in octets of the order buffer
<span class="lineNum">     345 </span>            :  *
<span class="lineNum">     346 </span>            :  * Return Value
<span class="lineNum">     347 </span>            :  * Returns a buffer of len octets that holds the private key. The caller
<span class="lineNum">     348 </span>            :  * is responsible for freeing the buffer with PORT_ZFree.
<a name="349"><span class="lineNum">     349 </span>            :  */</a>
<span class="lineNum">     350 </span>            : static unsigned char *
<span class="lineNum">     351 </span><span class="lineNoCov">          0 : ec_GenerateRandomPrivateKey(const unsigned char *order, int len)</span>
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     354 </span>            :     mp_err err;
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     unsigned char *privKeyBytes = NULL;</span>
<span class="lineNum">     356 </span>            :     mp_int privKeyVal, order_1, one;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;privKeyVal) = 0;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;order_1) = 0;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;one) = 0;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;privKeyVal));</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;order_1));</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;one));</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :     /* Generates 2*len random bytes using the global random bit generator
<span class="lineNum">     366 </span>            :      * (which implements Algorithm 1 of FIPS 186-2 Change Notice 1) then
<span class="lineNum">     367 </span>            :      * reduces modulo the group order.
<span class="lineNum">     368 </span>            :      */
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     if ((privKeyBytes = PORT_Alloc(2 * len)) == NULL)</span>
<span class="lineNum">     370 </span>            :         goto cleanup;
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(RNG_GenerateGlobalRandomBytes(privKeyBytes, 2 * len));</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;privKeyVal, privKeyBytes, 2 * len));</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;order_1, order, len));</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_set_int(&amp;one, 1));</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub(&amp;order_1, &amp;one, &amp;order_1));</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(&amp;privKeyVal, &amp;order_1, &amp;privKeyVal));</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_add(&amp;privKeyVal, &amp;one, &amp;privKeyVal));</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_to_fixlen_octets(&amp;privKeyVal, privKeyBytes, len));</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     memset(privKeyBytes + len, 0, len);</span>
<span class="lineNum">     380 </span>            : cleanup:
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     mp_clear(&amp;privKeyVal);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     mp_clear(&amp;order_1);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     mp_clear(&amp;one);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     if (err &lt; MP_OKAY) {</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     386 </span>            :         rv = SECFailure;
<span class="lineNum">     387 </span>            :     }
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     if (rv != SECSuccess &amp;&amp; privKeyBytes) {</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         PORT_ZFree(privKeyBytes, 2 * len);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         privKeyBytes = NULL;</span>
<span class="lineNum">     391 </span>            :     }
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     return privKeyBytes;</span>
<span class="lineNum">     393 </span>            : }
<span class="lineNum">     394 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : /* Generates a new EC key pair. The private key is a random value and
<span class="lineNum">     397 </span>            :  * the public key is the result of performing a scalar point multiplication
<span class="lineNum">     398 </span>            :  * of that value with the curve's base point.
<a name="399"><span class="lineNum">     399 </span>            :  */</a>
<span class="lineNum">     400 </span>            : SECStatus
<span class="lineNum">     401 </span><span class="lineNoCov">          0 : EC_NewKey(ECParams *ecParams, ECPrivateKey **privKey)</span>
<span class="lineNum">     402 </span>            : {
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     404 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     405 </span>            :     int len;
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     unsigned char *privKeyBytes = NULL;</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     if (!ecParams) {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     len = ecParams-&gt;order.len;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     privKeyBytes = ec_GenerateRandomPrivateKey(ecParams-&gt;order.data, len);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     if (privKeyBytes == NULL)</span>
<span class="lineNum">     416 </span>            :         goto cleanup;
<span class="lineNum">     417 </span>            :     /* generate public key */
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(ec_NewKey(ecParams, privKey, privKeyBytes, len));</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : cleanup:
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     if (privKeyBytes) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         PORT_ZFree(privKeyBytes, len);</span>
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            : #if EC_DEBUG
<span class="lineNum">     425 </span>            :     printf(&quot;EC_NewKey returning %s\n&quot;,
<span class="lineNum">     426 </span>            :            (rv == SECSuccess) ? &quot;success&quot; : &quot;failure&quot;);
<span class="lineNum">     427 </span>            : #endif
<span class="lineNum">     428 </span>            : #else
<span class="lineNum">     429 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     430 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     433 </span>            : }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : /* Validates an EC public key as described in Section 5.2.2 of
<span class="lineNum">     436 </span>            :  * X9.62. The ECDH primitive when used without the cofactor does
<span class="lineNum">     437 </span>            :  * not address small subgroup attacks, which may occur when the
<span class="lineNum">     438 </span>            :  * public key is not valid. These attacks can be prevented by
<span class="lineNum">     439 </span>            :  * validating the public key before using ECDH.
<a name="440"><span class="lineNum">     440 </span>            :  */</a>
<span class="lineNum">     441 </span>            : SECStatus
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : EC_ValidatePublicKey(ECParams *ecParams, SECItem *publicValue)</span>
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     445 </span>            :     mp_int Px, Py;
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     ECGroup *group = NULL;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     449 </span>            :     int len;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     if (!ecParams || !publicValue || !ecParams-&gt;name) {</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     454 </span>            :     }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :     /* Uses curve specific code for point validation. */
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     if (ecParams-&gt;fieldID.type == ec_field_plain) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         const ECMethod *method = ec_get_method_from_name(ecParams-&gt;name);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         if (method == NULL || method-&gt;validate == NULL) {</span>
<span class="lineNum">     460 </span>            :             /* unknown curve */
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :             return SECFailure;</span>
<span class="lineNum">     463 </span>            :         }
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         return method-&gt;validate(publicValue);</span>
<span class="lineNum">     465 </span>            :     }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :     /* NOTE: We only support uncompressed points for now */
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     len = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     if (publicValue-&gt;data[0] != EC_POINT_FORM_UNCOMPRESSED) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_UNSUPPORTED_EC_POINT_FORM);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     } else if (publicValue-&gt;len != (2 * len + 1)) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_KEY);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     475 </span>            :     }
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Px) = 0;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;Py) = 0;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Px));</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;Py));</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     /* Initialize Px and Py */
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;Px, publicValue-&gt;data + 1, (mp_size)len));</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;Py, publicValue-&gt;data + 1 + len, (mp_size)len));</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :     /* construct from named params */
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     group = ECGroup_fromName(ecParams-&gt;name);</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     if (group == NULL) {</span>
<span class="lineNum">     489 </span>            :         /*
<span class="lineNum">     490 </span>            :          * ECGroup_fromName fails if ecParams-&gt;name is not a valid
<span class="lineNum">     491 </span>            :          * ECCurveName value, or if we run out of memory, or perhaps
<span class="lineNum">     492 </span>            :          * for other reasons.  Unfortunately if ecParams-&gt;name is a
<span class="lineNum">     493 </span>            :          * valid ECCurveName value, we don't know what the right error
<span class="lineNum">     494 </span>            :          * code should be because ECGroup_fromName doesn't return an
<span class="lineNum">     495 </span>            :          * error code to the caller.  Set err to MP_UNDEF because
<span class="lineNum">     496 </span>            :          * that's what ECGroup_fromName uses internally.
<span class="lineNum">     497 </span>            :          */
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         if ((ecParams-&gt;name &lt;= ECCurve_noName) ||</span>
<span class="lineNum">     499 </span>            :             (ecParams-&gt;name &gt;= ECCurve_pastLastCurve)) {
<span class="lineNum">     500 </span>            :             err = MP_BADARG;
<span class="lineNum">     501 </span>            :         } else {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :             err = MP_UNDEF;</span>
<span class="lineNum">     503 </span>            :         }
<span class="lineNum">     504 </span>            :         goto cleanup;
<span class="lineNum">     505 </span>            :     }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :     /* validate public point */
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     if ((err = ECPoint_validate(group, &amp;Px, &amp;Py)) &lt; MP_YES) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         if (err == MP_NO) {</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_BAD_KEY);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             rv = SECFailure;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :             err = MP_OKAY; /* don't change the error code */</span>
<span class="lineNum">     513 </span>            :         }
<span class="lineNum">     514 </span>            :         goto cleanup;
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :     rv = SECSuccess;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : cleanup:
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     ECGroup_free(group);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Px);</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     mp_clear(&amp;Py);</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     525 </span>            :         rv = SECFailure;
<span class="lineNum">     526 </span>            :     }
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     528 </span>            : #else
<span class="lineNum">     529 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     530 </span>            :     return SECFailure;
<span class="lineNum">     531 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     532 </span>            : }
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : /*
<span class="lineNum">     535 </span>            : ** Performs an ECDH key derivation by computing the scalar point
<span class="lineNum">     536 </span>            : ** multiplication of privateValue and publicValue (with or without the
<span class="lineNum">     537 </span>            : ** cofactor) and returns the x-coordinate of the resulting elliptic
<span class="lineNum">     538 </span>            : ** curve point in derived secret.  If successful, derivedSecret-&gt;data
<span class="lineNum">     539 </span>            : ** is set to the address of the newly allocated buffer containing the
<span class="lineNum">     540 </span>            : ** derived secret, and derivedSecret-&gt;len is the size of the secret
<span class="lineNum">     541 </span>            : ** produced. It is the caller's responsibility to free the allocated
<span class="lineNum">     542 </span>            : ** buffer containing the derived secret.
<a name="543"><span class="lineNum">     543 </span>            : */</a>
<span class="lineNum">     544 </span>            : SECStatus
<span class="lineNum">     545 </span><span class="lineNoCov">          0 : ECDH_Derive(SECItem *publicValue,</span>
<span class="lineNum">     546 </span>            :             ECParams *ecParams,
<span class="lineNum">     547 </span>            :             SECItem *privateValue,
<span class="lineNum">     548 </span>            :             PRBool withCofactor,
<span class="lineNum">     549 </span>            :             SECItem *derivedSecret)
<span class="lineNum">     550 </span>            : {
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     552 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     unsigned int len = 0;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     SECItem pointQ = { siBuffer, NULL, 0 };</span>
<span class="lineNum">     555 </span>            :     mp_int k; /* to hold the private value */
<span class="lineNum">     556 </span>            :     mp_int cofactor;
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     558 </span>            : #if EC_DEBUG
<span class="lineNum">     559 </span>            :     int i;
<span class="lineNum">     560 </span>            : #endif
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     if (!publicValue || !ecParams || !privateValue || !derivedSecret ||</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         !ecParams-&gt;name) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :     /*
<span class="lineNum">     569 </span>            :      * Make sure the point is on the requested curve to avoid
<span class="lineNum">     570 </span>            :      * certain small subgroup attacks.
<span class="lineNum">     571 </span>            :      */
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     if (EC_ValidatePublicKey(ecParams, publicValue) != SECSuccess) {</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_KEY);</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     575 </span>            :     }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :     /* Perform curve specific multiplication using ECMethod */
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     if (ecParams-&gt;fieldID.type == ec_field_plain) {</span>
<span class="lineNum">     579 </span>            :         const ECMethod *method;
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         memset(derivedSecret, 0, sizeof(*derivedSecret));</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         derivedSecret = SECITEM_AllocItem(NULL, derivedSecret, EC_GetPointSize(ecParams));</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         if (derivedSecret == NULL) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :             return SECFailure;</span>
<span class="lineNum">     585 </span>            :         }
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         method = ec_get_method_from_name(ecParams-&gt;name);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :         if (method == NULL || method-&gt;validate == NULL ||</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :             method-&gt;mul == NULL) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :             return SECFailure;</span>
<span class="lineNum">     591 </span>            :         }
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :         return method-&gt;mul(derivedSecret, privateValue, publicValue);</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :     /*
<span class="lineNum">     596 </span>            :      * We fail if the public value is the point at infinity, since
<span class="lineNum">     597 </span>            :      * this produces predictable results.
<span class="lineNum">     598 </span>            :      */
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     if (ec_point_at_infinity(publicValue)) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_KEY);</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     602 </span>            :     }
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;k) = 0;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     memset(derivedSecret, 0, sizeof *derivedSecret);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     len = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     pointQ.len = EC_GetPointSize(ecParams);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     if ((pointQ.data = PORT_Alloc(pointQ.len)) == NULL)</span>
<span class="lineNum">     609 </span>            :         goto cleanup;
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;k));</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;k, privateValue-&gt;data,</span>
<span class="lineNum">     613 </span>            :                                          (mp_size)privateValue-&gt;len));
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     if (withCofactor &amp;&amp; (ecParams-&gt;cofactor != 1)) {</span>
<span class="lineNum">     616 </span>            :         /* multiply k with the cofactor */
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         MP_DIGITS(&amp;cofactor) = 0;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_init(&amp;cofactor));</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         mp_set(&amp;cofactor, ecParams-&gt;cofactor);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_mul(&amp;k, &amp;cofactor, &amp;k));</span>
<span class="lineNum">     621 </span>            :     }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :     /* Multiply our private key and peer's public point */
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     if (ec_points_mul(ecParams, NULL, &amp;k, publicValue, &amp;pointQ) != SECSuccess) {</span>
<span class="lineNum">     625 </span>            :         goto cleanup;
<span class="lineNum">     626 </span>            :     }
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     if (ec_point_at_infinity(&amp;pointQ)) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_KEY); /* XXX better error code? */</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     630 </span>            :     }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :     /* Allocate memory for the derived secret and copy
<span class="lineNum">     633 </span>            :      * the x co-ordinate of pointQ into it.
<span class="lineNum">     634 </span>            :      */
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     SECITEM_AllocItem(NULL, derivedSecret, len);</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     memcpy(derivedSecret-&gt;data, pointQ.data + 1, len);</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     rv = SECSuccess;</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            : #if EC_DEBUG
<span class="lineNum">     641 </span>            :     printf(&quot;derived_secret:\n&quot;);
<span class="lineNum">     642 </span>            :     for (i = 0; i &lt; derivedSecret-&gt;len; i++)
<span class="lineNum">     643 </span>            :         printf(&quot;%02x:&quot;, derivedSecret-&gt;data[i]);
<span class="lineNum">     644 </span>            :     printf(&quot;\n&quot;);
<span class="lineNum">     645 </span>            : #endif
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : cleanup:
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     mp_clear(&amp;k);</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     652 </span>            :     }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     if (pointQ.data) {</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         PORT_ZFree(pointQ.data, pointQ.len);</span>
<span class="lineNum">     656 </span>            :     }
<span class="lineNum">     657 </span>            : #else
<span class="lineNum">     658 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     659 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     662 </span>            : }
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : /* Computes the ECDSA signature (a concatenation of two values r and s)
<span class="lineNum">     665 </span>            :  * on the digest using the given key and the random value kb (used in
<span class="lineNum">     666 </span>            :  * computing s).
<a name="667"><span class="lineNum">     667 </span>            :  */</a>
<span class="lineNum">     668 </span>            : SECStatus
<span class="lineNum">     669 </span><span class="lineNoCov">          0 : ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,</span>
<span class="lineNum">     670 </span>            :                          const SECItem *digest, const unsigned char *kb, const int kblen)
<span class="lineNum">     671 </span>            : {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     673 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     674 </span>            :     mp_int x1;
<span class="lineNum">     675 </span>            :     mp_int d, k; /* private key, random integer */
<span class="lineNum">     676 </span>            :     mp_int r, s; /* tuple (r, s) is the signature */
<span class="lineNum">     677 </span>            :     mp_int t;    /* holding tmp values */
<span class="lineNum">     678 </span>            :     mp_int n;
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     ECParams *ecParams = NULL;</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     SECItem kGpoint = { siBuffer, NULL, 0 };</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     int flen = 0;   /* length in bytes of the field size */</span>
<span class="lineNum">     683 </span>            :     unsigned olen;  /* length in bytes of the base point order */
<span class="lineNum">     684 </span>            :     unsigned obits; /* length in bits  of the base point order */
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     unsigned char *t2 = NULL;</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : #if EC_DEBUG
<span class="lineNum">     688 </span>            :     char mpstr[256];
<span class="lineNum">     689 </span>            : #endif
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :     /* Initialize MPI integers. */
<span class="lineNum">     692 </span>            :     /* must happen before the first potential call to cleanup */
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;x1) = 0;</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d) = 0;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;k) = 0;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;r) = 0;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;s) = 0;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;t) = 0;</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :     /* Check args */
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     if (!key || !signature || !digest || !kb || (kblen &lt; 0)) {</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     ecParams = &amp;(key-&gt;ecParams);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     flen = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     olen = ecParams-&gt;order.len;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     if (signature-&gt;data == NULL) {</span>
<span class="lineNum">     711 </span>            :         /* a call to get the signature length only */
<span class="lineNum">     712 </span>            :         goto finish;
<span class="lineNum">     713 </span>            :     }
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     if (signature-&gt;len &lt; 2 * olen) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_OUTPUT_LEN);</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     717 </span>            :     }
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;x1));</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d));</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;k));</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;r));</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;s));</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;t));</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(ecParams-&gt;order, &amp;n);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;privateValue, &amp;d);</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;k, kb, kblen));</span>
<span class="lineNum">     731 </span>            :     /* Make sure k is in the interval [1, n-1] */
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     if ((mp_cmp_z(&amp;k) &lt;= 0) || (mp_cmp(&amp;k, &amp;n) &gt;= 0)) {</span>
<span class="lineNum">     733 </span>            : #if EC_DEBUG
<span class="lineNum">     734 </span>            :         printf(&quot;k is outside [1, n-1]\n&quot;);
<span class="lineNum">     735 </span>            :         mp_tohex(&amp;k, mpstr);
<span class="lineNum">     736 </span>            :         printf(&quot;k : %s \n&quot;, mpstr);
<span class="lineNum">     737 </span>            :         mp_tohex(&amp;n, mpstr);
<span class="lineNum">     738 </span>            :         printf(&quot;n : %s \n&quot;, mpstr);
<span class="lineNum">     739 </span>            : #endif
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     742 </span>            :     }
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :     /*
<span class="lineNum">     745 </span>            :     ** We do not want timing information to leak the length of k,
<span class="lineNum">     746 </span>            :     ** so we compute k*G using an equivalent scalar of fixed
<span class="lineNum">     747 </span>            :     ** bit-length.
<span class="lineNum">     748 </span>            :     ** Fix based on patch for ECDSA timing attack in the paper
<span class="lineNum">     749 </span>            :     ** by Billy Bob Brumley and Nicola Tuveri at
<span class="lineNum">     750 </span>            :     **   http://eprint.iacr.org/2011/232
<span class="lineNum">     751 </span>            :     **
<span class="lineNum">     752 </span>            :     ** How do we convert k to a value of a fixed bit-length?
<span class="lineNum">     753 </span>            :     ** k starts off as an integer satisfying 0 &lt;= k &lt; n.  Hence,
<span class="lineNum">     754 </span>            :     ** n &lt;= k+n &lt; 2n, which means k+n has either the same number
<span class="lineNum">     755 </span>            :     ** of bits as n or one more bit than n.  If k+n has the same
<span class="lineNum">     756 </span>            :     ** number of bits as n, the second addition ensures that the
<span class="lineNum">     757 </span>            :     ** final value has exactly one more bit than n.  Thus, we
<span class="lineNum">     758 </span>            :     ** always end up with a value that exactly one more bit than n.
<span class="lineNum">     759 </span>            :     */
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_add(&amp;k, &amp;n, &amp;k));</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     if (mpl_significant_bits(&amp;k) &lt;= mpl_significant_bits(&amp;n)) {</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_add(&amp;k, &amp;n, &amp;k));</span>
<span class="lineNum">     763 </span>            :     }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     /*
<span class="lineNum">     766 </span>            :     ** ANSI X9.62, Section 5.3.2, Step 2
<span class="lineNum">     767 </span>            :     **
<span class="lineNum">     768 </span>            :     ** Compute kG
<span class="lineNum">     769 </span>            :     */
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :     kGpoint.len = EC_GetPointSize(ecParams);</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     kGpoint.data = PORT_Alloc(kGpoint.len);</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :     if ((kGpoint.data == NULL) ||</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         (ec_points_mul(ecParams, &amp;k, NULL, NULL, &amp;kGpoint) != SECSuccess))</span>
<span class="lineNum">     774 </span>            :         goto cleanup;
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :     /*
<span class="lineNum">     777 </span>            :     ** ANSI X9.62, Section 5.3.3, Step 1
<span class="lineNum">     778 </span>            :     **
<span class="lineNum">     779 </span>            :     ** Extract the x co-ordinate of kG into x1
<span class="lineNum">     780 </span>            :     */
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;x1, kGpoint.data + 1,</span>
<span class="lineNum">     782 </span>            :                                          (mp_size)flen));
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :     /*
<span class="lineNum">     785 </span>            :     ** ANSI X9.62, Section 5.3.3, Step 2
<span class="lineNum">     786 </span>            :     **
<span class="lineNum">     787 </span>            :     ** r = x1 mod n  NOTE: n is the order of the curve
<span class="lineNum">     788 </span>            :     */
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(&amp;x1, &amp;n, &amp;r));</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :     /*
<span class="lineNum">     792 </span>            :     ** ANSI X9.62, Section 5.3.3, Step 3
<span class="lineNum">     793 </span>            :     **
<span class="lineNum">     794 </span>            :     ** verify r != 0
<span class="lineNum">     795 </span>            :     */
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     if (mp_cmp_z(&amp;r) == 0) {</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     799 </span>            :     }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :     /*
<span class="lineNum">     802 </span>            :     ** ANSI X9.62, Section 5.3.3, Step 4
<span class="lineNum">     803 </span>            :     **
<span class="lineNum">     804 </span>            :     ** s = (k**-1 * (HASH(M) + d*r)) mod n
<span class="lineNum">     805 </span>            :     */
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(*digest, &amp;s); /* s = HASH(M)     */</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :     /* In the definition of EC signing, digests are truncated
<span class="lineNum">     809 </span>            :      * to the length of n in bits.
<span class="lineNum">     810 </span>            :      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK((obits = mpl_significant_bits(&amp;n)));</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     if (digest-&gt;len * 8 &gt; obits) {</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         mpl_rsh(&amp;s, &amp;s, digest-&gt;len * 8 - obits);</span>
<span class="lineNum">     814 </span>            :     }
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            : #if EC_DEBUG
<span class="lineNum">     817 </span>            :     mp_todecimal(&amp;n, mpstr);
<span class="lineNum">     818 </span>            :     printf(&quot;n : %s (dec)\n&quot;, mpstr);
<span class="lineNum">     819 </span>            :     mp_todecimal(&amp;d, mpstr);
<span class="lineNum">     820 </span>            :     printf(&quot;d : %s (dec)\n&quot;, mpstr);
<span class="lineNum">     821 </span>            :     mp_tohex(&amp;x1, mpstr);
<span class="lineNum">     822 </span>            :     printf(&quot;x1: %s\n&quot;, mpstr);
<span class="lineNum">     823 </span>            :     mp_todecimal(&amp;s, mpstr);
<span class="lineNum">     824 </span>            :     printf(&quot;digest: %s (decimal)\n&quot;, mpstr);
<span class="lineNum">     825 </span>            :     mp_todecimal(&amp;r, mpstr);
<span class="lineNum">     826 </span>            :     printf(&quot;r : %s (dec)\n&quot;, mpstr);
<span class="lineNum">     827 </span>            :     mp_tohex(&amp;r, mpstr);
<span class="lineNum">     828 </span>            :     printf(&quot;r : %s\n&quot;, mpstr);
<span class="lineNum">     829 </span>            : #endif
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     if ((t2 = PORT_Alloc(2 * ecParams-&gt;order.len)) == NULL) {</span>
<span class="lineNum">     832 </span>            :         rv = SECFailure;
<span class="lineNum">     833 </span>            :         goto cleanup;
<span class="lineNum">     834 </span>            :     }
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     if (RNG_GenerateGlobalRandomBytes(t2, 2 * ecParams-&gt;order.len) != SECSuccess) {</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     839 </span>            :     }
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;t, t2, 2 * ecParams-&gt;order.len)); /* t &lt;-$ Zn */</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;k, &amp;t, &amp;n, &amp;k));                                /* k = k * t mod n */</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_invmod(&amp;k, &amp;n, &amp;k));                                    /* k = k**-1 mod n */</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;k, &amp;t, &amp;n, &amp;k));                                /* k = k * t mod n */</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;d, &amp;r, &amp;n, &amp;d));                                /* d = d * r mod n */</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_addmod(&amp;s, &amp;d, &amp;n, &amp;s));                                /* s = s + d mod n */</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;s, &amp;k, &amp;n, &amp;s));                                /* s = s * k mod n */</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : #if EC_DEBUG
<span class="lineNum">     849 </span>            :     mp_todecimal(&amp;s, mpstr);
<span class="lineNum">     850 </span>            :     printf(&quot;s : %s (dec)\n&quot;, mpstr);
<span class="lineNum">     851 </span>            :     mp_tohex(&amp;s, mpstr);
<span class="lineNum">     852 </span>            :     printf(&quot;s : %s\n&quot;, mpstr);
<span class="lineNum">     853 </span>            : #endif
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :     /*
<span class="lineNum">     856 </span>            :     ** ANSI X9.62, Section 5.3.3, Step 5
<span class="lineNum">     857 </span>            :     **
<span class="lineNum">     858 </span>            :     ** verify s != 0
<span class="lineNum">     859 </span>            :     */
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     if (mp_cmp_z(&amp;s) == 0) {</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     863 </span>            :     }
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :     /*
<span class="lineNum">     866 </span>            :     **
<span class="lineNum">     867 </span>            :     ** Signature is tuple (r, s)
<span class="lineNum">     868 </span>            :     */
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_to_fixlen_octets(&amp;r, signature-&gt;data, olen));</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_to_fixlen_octets(&amp;s, signature-&gt;data + olen, olen));</span>
<span class="lineNum">     871 </span>            : finish:
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     signature-&gt;len = 2 * olen;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     rv = SECSuccess;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     err = MP_OKAY;</span>
<span class="lineNum">     876 </span>            : cleanup:
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     mp_clear(&amp;x1);</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     mp_clear(&amp;k);</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :     mp_clear(&amp;r);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     mp_clear(&amp;s);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     mp_clear(&amp;t);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     if (t2) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         PORT_Free(t2);</span>
<span class="lineNum">     887 </span>            :     }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     if (kGpoint.data) {</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         PORT_ZFree(kGpoint.data, kGpoint.len);</span>
<span class="lineNum">     891 </span>            :     }
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     895 </span>            :         rv = SECFailure;
<span class="lineNum">     896 </span>            :     }
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            : #if EC_DEBUG
<span class="lineNum">     899 </span>            :     printf(&quot;ECDSA signing with seed %s\n&quot;,
<span class="lineNum">     900 </span>            :            (rv == SECSuccess) ? &quot;succeeded&quot; : &quot;failed&quot;);
<span class="lineNum">     901 </span>            : #endif
<span class="lineNum">     902 </span>            : #else
<span class="lineNum">     903 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     904 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     907 </span>            : }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : /*
<span class="lineNum">     910 </span>            : ** Computes the ECDSA signature on the digest using the given key
<span class="lineNum">     911 </span>            : ** and a random seed.
<a name="912"><span class="lineNum">     912 </span>            : */</a>
<span class="lineNum">     913 </span>            : SECStatus
<span class="lineNum">     914 </span><span class="lineNoCov">          0 : ECDSA_SignDigest(ECPrivateKey *key, SECItem *signature, const SECItem *digest)</span>
<span class="lineNum">     915 </span>            : {
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     917 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     918 </span>            :     int len;
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     unsigned char *kBytes = NULL;</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     if (!key) {</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     924 </span>            :     }
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :     /* Generate random value k */
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     len = key-&gt;ecParams.order.len;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     kBytes = ec_GenerateRandomPrivateKey(key-&gt;ecParams.order.data, len);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     if (kBytes == NULL)</span>
<span class="lineNum">     930 </span>            :         goto cleanup;
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            :     /* Generate ECDSA signature with the specified k value */
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     rv = ECDSA_SignDigestWithSeed(key, signature, digest, kBytes, len);</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : cleanup:
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     if (kBytes) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         PORT_ZFree(kBytes, len);</span>
<span class="lineNum">     938 </span>            :     }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            : #if EC_DEBUG
<span class="lineNum">     941 </span>            :     printf(&quot;ECDSA signing %s\n&quot;,
<span class="lineNum">     942 </span>            :            (rv == SECSuccess) ? &quot;succeeded&quot; : &quot;failed&quot;);
<span class="lineNum">     943 </span>            : #endif
<span class="lineNum">     944 </span>            : #else
<span class="lineNum">     945 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">     946 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     949 </span>            : }
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /*
<span class="lineNum">     952 </span>            : ** Checks the signature on the given digest using the key provided.
<span class="lineNum">     953 </span>            : **
<span class="lineNum">     954 </span>            : ** The key argument must represent a valid EC public key (a point on
<span class="lineNum">     955 </span>            : ** the relevant curve).  If it is not a valid point, then the behavior
<span class="lineNum">     956 </span>            : ** of this function is undefined.  In cases where a public key might
<span class="lineNum">     957 </span>            : ** not be valid, use EC_ValidatePublicKey to check.
<a name="958"><span class="lineNum">     958 </span>            : */</a>
<span class="lineNum">     959 </span>            : SECStatus
<span class="lineNum">     960 </span><span class="lineNoCov">          0 : ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,</span>
<span class="lineNum">     961 </span>            :                    const SECItem *digest)
<span class="lineNum">     962 </span>            : {
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     964 </span>            : #ifndef NSS_DISABLE_ECC
<span class="lineNum">     965 </span>            :     mp_int r_, s_;       /* tuple (r', s') is received signature) */
<span class="lineNum">     966 </span>            :     mp_int c, u1, u2, v; /* intermediate values used in verification */
<span class="lineNum">     967 </span>            :     mp_int x1;
<span class="lineNum">     968 </span>            :     mp_int n;
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     ECParams *ecParams = NULL;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     SECItem pointC = { siBuffer, NULL, 0 };</span>
<span class="lineNum">     972 </span>            :     int slen;       /* length in bytes of a half signature (r or s) */
<span class="lineNum">     973 </span>            :     int flen;       /* length in bytes of the field size */
<span class="lineNum">     974 </span>            :     unsigned olen;  /* length in bytes of the base point order */
<span class="lineNum">     975 </span>            :     unsigned obits; /* length in bits  of the base point order */
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : #if EC_DEBUG
<span class="lineNum">     978 </span>            :     char mpstr[256];
<span class="lineNum">     979 </span>            :     printf(&quot;ECDSA verification called\n&quot;);
<span class="lineNum">     980 </span>            : #endif
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :     /* Initialize MPI integers. */
<span class="lineNum">     983 </span>            :     /* must happen before the first potential call to cleanup */
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;r_) = 0;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;s_) = 0;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;c) = 0;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;u1) = 0;</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;u2) = 0;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;x1) = 0;</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;v) = 0;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :     /* Check args */
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     if (!key || !signature || !digest) {</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     997 </span>            :     }
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     ecParams = &amp;(key-&gt;ecParams);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     flen = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     olen = ecParams-&gt;order.len;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     if (signature-&gt;len == 0 || signature-&gt;len % 2 != 0 ||</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         signature-&gt;len &gt; 2 * olen) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INPUT_LEN);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">    1006 </span>            :     }
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     slen = signature-&gt;len / 2;</span>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            :     /*
<span class="lineNum">    1010 </span>            :      * The incoming point has been verified in sftk_handlePublicKeyObject.
<span class="lineNum">    1011 </span>            :      */
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     SECITEM_AllocItem(NULL, &amp;pointC, EC_GetPointSize(ecParams));</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     if (pointC.data == NULL) {</span>
<span class="lineNum">    1015 </span>            :         goto cleanup;
<span class="lineNum">    1016 </span>            :     }
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;r_));</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;s_));</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;c));</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;u1));</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;u2));</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;x1));</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;v));</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :     /*
<span class="lineNum">    1028 </span>            :     ** Convert received signature (r', s') into MPI integers.
<span class="lineNum">    1029 </span>            :     */
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;r_, signature-&gt;data, slen));</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;s_, signature-&gt;data + slen, slen));</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :     /*
<span class="lineNum">    1034 </span>            :     ** ANSI X9.62, Section 5.4.2, Steps 1 and 2
<span class="lineNum">    1035 </span>            :     **
<span class="lineNum">    1036 </span>            :     ** Verify that 0 &lt; r' &lt; n and 0 &lt; s' &lt; n
<span class="lineNum">    1037 </span>            :     */
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(ecParams-&gt;order, &amp;n);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     if (mp_cmp_z(&amp;r_) &lt;= 0 || mp_cmp_z(&amp;s_) &lt;= 0 ||</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         mp_cmp(&amp;r_, &amp;n) &gt;= 0 || mp_cmp(&amp;s_, &amp;n) &gt;= 0) {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         goto cleanup; /* will return rv == SECFailure */</span>
<span class="lineNum">    1043 </span>            :     }
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :     /*
<span class="lineNum">    1046 </span>            :     ** ANSI X9.62, Section 5.4.2, Step 3
<span class="lineNum">    1047 </span>            :     **
<span class="lineNum">    1048 </span>            :     ** c = (s')**-1 mod n
<span class="lineNum">    1049 </span>            :     */
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_invmod(&amp;s_, &amp;n, &amp;c)); /* c = (s')**-1 mod n */</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :     /*
<span class="lineNum">    1053 </span>            :     ** ANSI X9.62, Section 5.4.2, Step 4
<span class="lineNum">    1054 </span>            :     **
<span class="lineNum">    1055 </span>            :     ** u1 = ((HASH(M')) * c) mod n
<span class="lineNum">    1056 </span>            :     */
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(*digest, &amp;u1); /* u1 = HASH(M)     */</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :     /* In the definition of EC signing, digests are truncated
<span class="lineNum">    1060 </span>            :      * to the length of n in bits.
<span class="lineNum">    1061 </span>            :      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK((obits = mpl_significant_bits(&amp;n)));</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     if (digest-&gt;len * 8 &gt; obits) { /* u1 = HASH(M')     */</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         mpl_rsh(&amp;u1, &amp;u1, digest-&gt;len * 8 - obits);</span>
<span class="lineNum">    1065 </span>            :     }
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            : #if EC_DEBUG
<span class="lineNum">    1068 </span>            :     mp_todecimal(&amp;r_, mpstr);
<span class="lineNum">    1069 </span>            :     printf(&quot;r_: %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1070 </span>            :     mp_todecimal(&amp;s_, mpstr);
<span class="lineNum">    1071 </span>            :     printf(&quot;s_: %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1072 </span>            :     mp_todecimal(&amp;c, mpstr);
<span class="lineNum">    1073 </span>            :     printf(&quot;c : %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1074 </span>            :     mp_todecimal(&amp;u1, mpstr);
<span class="lineNum">    1075 </span>            :     printf(&quot;digest: %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1076 </span>            : #endif
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;u1, &amp;c, &amp;n, &amp;u1)); /* u1 = u1 * c mod n */</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :     /*
<span class="lineNum">    1081 </span>            :     ** ANSI X9.62, Section 5.4.2, Step 4
<span class="lineNum">    1082 </span>            :     **
<span class="lineNum">    1083 </span>            :     ** u2 = ((r') * c) mod n
<span class="lineNum">    1084 </span>            :     */
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;r_, &amp;c, &amp;n, &amp;u2));</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :     /*
<span class="lineNum">    1088 </span>            :     ** ANSI X9.62, Section 5.4.3, Step 1
<span class="lineNum">    1089 </span>            :     **
<span class="lineNum">    1090 </span>            :     ** Compute u1*G + u2*Q
<span class="lineNum">    1091 </span>            :     ** Here, A = u1.G     B = u2.Q    and   C = A + B
<span class="lineNum">    1092 </span>            :     ** If the result, C, is the point at infinity, reject the signature
<span class="lineNum">    1093 </span>            :     */
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     if (ec_points_mul(ecParams, &amp;u1, &amp;u2, &amp;key-&gt;publicValue, &amp;pointC) != SECSuccess) {</span>
<span class="lineNum">    1095 </span>            :         rv = SECFailure;
<span class="lineNum">    1096 </span>            :         goto cleanup;
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     if (ec_point_at_infinity(&amp;pointC)) {</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">    1102 </span>            :     }
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;x1, pointC.data + 1, flen));</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            :     /*
<span class="lineNum">    1107 </span>            :     ** ANSI X9.62, Section 5.4.4, Step 2
<span class="lineNum">    1108 </span>            :     **
<span class="lineNum">    1109 </span>            :     ** v = x1 mod n
<span class="lineNum">    1110 </span>            :     */
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(&amp;x1, &amp;n, &amp;v));</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span>            : #if EC_DEBUG
<span class="lineNum">    1114 </span>            :     mp_todecimal(&amp;r_, mpstr);
<span class="lineNum">    1115 </span>            :     printf(&quot;r_: %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1116 </span>            :     mp_todecimal(&amp;v, mpstr);
<span class="lineNum">    1117 </span>            :     printf(&quot;v : %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1118 </span>            : #endif
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :     /*
<span class="lineNum">    1121 </span>            :     ** ANSI X9.62, Section 5.4.4, Step 3
<span class="lineNum">    1122 </span>            :     **
<span class="lineNum">    1123 </span>            :     ** Verification:  v == r'
<span class="lineNum">    1124 </span>            :     */
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     if (mp_cmp(&amp;v, &amp;r_)) {</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :         rv = SECFailure; /* Signature failed to verify. */</span>
<span class="lineNum">    1128 </span>            :     } else {
<span class="lineNum">    1129 </span>            :         rv = SECSuccess; /* Signature verified. */
<span class="lineNum">    1130 </span>            :     }
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            : #if EC_DEBUG
<span class="lineNum">    1133 </span>            :     mp_todecimal(&amp;u1, mpstr);
<span class="lineNum">    1134 </span>            :     printf(&quot;u1: %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1135 </span>            :     mp_todecimal(&amp;u2, mpstr);
<span class="lineNum">    1136 </span>            :     printf(&quot;u2: %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1137 </span>            :     mp_tohex(&amp;x1, mpstr);
<span class="lineNum">    1138 </span>            :     printf(&quot;x1: %s\n&quot;, mpstr);
<span class="lineNum">    1139 </span>            :     mp_todecimal(&amp;v, mpstr);
<span class="lineNum">    1140 </span>            :     printf(&quot;v : %s (dec)\n&quot;, mpstr);
<span class="lineNum">    1141 </span>            : #endif
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : cleanup:
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     mp_clear(&amp;r_);</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     mp_clear(&amp;s_);</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     mp_clear(&amp;c);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     mp_clear(&amp;u1);</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     mp_clear(&amp;u2);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :     mp_clear(&amp;x1);</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     mp_clear(&amp;v);</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     if (pointC.data)</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :         SECITEM_ZfreeItem(&amp;pointC, PR_FALSE);</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1157 </span>            :         rv = SECFailure;
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            : #if EC_DEBUG
<span class="lineNum">    1161 </span>            :     printf(&quot;ECDSA verification %s\n&quot;,
<span class="lineNum">    1162 </span>            :            (rv == SECSuccess) ? &quot;succeeded&quot; : &quot;failed&quot;);
<span class="lineNum">    1163 </span>            : #endif
<span class="lineNum">    1164 </span>            : #else
<span class="lineNum">    1165 </span>            :     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
<span class="lineNum">    1166 </span>            : #endif /* NSS_DISABLE_ECC */
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1169 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
