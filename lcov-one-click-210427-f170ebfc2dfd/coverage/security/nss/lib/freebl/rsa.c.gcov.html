<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mochitest-e10s.info - security/nss/lib/freebl/rsa.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">security/nss/lib/freebl</a> - rsa.c<span style="font-size: 80%;"> (source / <a href="rsa.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mochitest-e10s.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">32</td>
            <td class="headerCovTableEntry">742</td>
            <td class="headerCovTableEntryLo">4.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntryLo">23.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public</a>
<span class="lineNum">       2 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       3 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : /*
<span class="lineNum">       6 </span>            :  * RSA key generation, public key op, private key op.
<span class="lineNum">       7 </span>            :  */
<span class="lineNum">       8 </span>            : #ifdef FREEBL_NO_DEPEND
<span class="lineNum">       9 </span>            : #include &quot;stubs.h&quot;
<span class="lineNum">      10 </span>            : #endif
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;secerr.h&quot;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;prclist.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nssilock.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;prinit.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;blapi.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mpi.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;mpprime.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mplogic.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;secmpi.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;secitem.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;blapii.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /*
<span class="lineNum">      26 </span>            : ** Number of times to attempt to generate a prime (p or q) from a random
<span class="lineNum">      27 </span>            : ** seed (the seed changes for each iteration).
<span class="lineNum">      28 </span>            : */
<span class="lineNum">      29 </span>            : #define MAX_PRIME_GEN_ATTEMPTS 10
<span class="lineNum">      30 </span>            : /*
<span class="lineNum">      31 </span>            : ** Number of times to attempt to generate a key.  The primes p and q change
<span class="lineNum">      32 </span>            : ** for each attempt.
<span class="lineNum">      33 </span>            : */
<span class="lineNum">      34 </span>            : #define MAX_KEY_GEN_ATTEMPTS 10
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : /* Blinding Parameters max cache size  */
<span class="lineNum">      37 </span>            : #define RSA_BLINDING_PARAMS_MAX_CACHE_SIZE 20
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /* exponent should not be greater than modulus */
<span class="lineNum">      40 </span>            : #define BAD_RSA_KEY_SIZE(modLen, expLen)                           \
<span class="lineNum">      41 </span>            :     ((expLen) &gt; (modLen) || (modLen) &gt; RSA_MAX_MODULUS_BITS / 8 || \
<span class="lineNum">      42 </span>            :      (expLen) &gt; RSA_MAX_EXPONENT_BITS / 8)
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : struct blindingParamsStr;
<span class="lineNum">      45 </span>            : typedef struct blindingParamsStr blindingParams;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : struct blindingParamsStr {
<span class="lineNum">      48 </span>            :     blindingParams *next;
<span class="lineNum">      49 </span>            :     mp_int f, g; /* blinding parameter                 */
<span class="lineNum">      50 </span>            :     int counter; /* number of remaining uses of (f, g) */
<span class="lineNum">      51 </span>            : };
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : /*
<span class="lineNum">      54 </span>            : ** RSABlindingParamsStr
<span class="lineNum">      55 </span>            : **
<span class="lineNum">      56 </span>            : ** For discussion of Paul Kocher's timing attack against an RSA private key
<span class="lineNum">      57 </span>            : ** operation, see http://www.cryptography.com/timingattack/paper.html.  The
<span class="lineNum">      58 </span>            : ** countermeasure to this attack, known as blinding, is also discussed in
<span class="lineNum">      59 </span>            : ** the Handbook of Applied Cryptography, 11.118-11.119.
<span class="lineNum">      60 </span>            : */
<span class="lineNum">      61 </span>            : struct RSABlindingParamsStr {
<span class="lineNum">      62 </span>            :     /* Blinding-specific parameters */
<span class="lineNum">      63 </span>            :     PRCList link;              /* link to list of structs            */
<span class="lineNum">      64 </span>            :     SECItem modulus;           /* list element &quot;key&quot;                 */
<span class="lineNum">      65 </span>            :     blindingParams *free, *bp; /* Blinding parameters queue          */
<span class="lineNum">      66 </span>            :     blindingParams array[RSA_BLINDING_PARAMS_MAX_CACHE_SIZE];
<span class="lineNum">      67 </span>            : };
<span class="lineNum">      68 </span>            : typedef struct RSABlindingParamsStr RSABlindingParams;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : /*
<span class="lineNum">      71 </span>            : ** RSABlindingParamsListStr
<span class="lineNum">      72 </span>            : **
<span class="lineNum">      73 </span>            : ** List of key-specific blinding params.  The arena holds the volatile pool
<span class="lineNum">      74 </span>            : ** of memory for each entry and the list itself.  The lock is for list
<span class="lineNum">      75 </span>            : ** operations, in this case insertions and iterations, as well as control
<span class="lineNum">      76 </span>            : ** of the counter for each set of blinding parameters.
<span class="lineNum">      77 </span>            : */
<span class="lineNum">      78 </span>            : struct RSABlindingParamsListStr {
<span class="lineNum">      79 </span>            :     PZLock *lock;    /* Lock for the list   */
<span class="lineNum">      80 </span>            :     PRCondVar *cVar; /* Condidtion Variable */
<span class="lineNum">      81 </span>            :     int waitCount;   /* Number of threads waiting on cVar */
<span class="lineNum">      82 </span>            :     PRCList head;    /* Pointer to the list */
<span class="lineNum">      83 </span>            : };
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : /*
<span class="lineNum">      86 </span>            : ** The master blinding params list.
<span class="lineNum">      87 </span>            : */
<span class="lineNum">      88 </span>            : static struct RSABlindingParamsListStr blindingParamsList = { 0 };
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : /* Number of times to reuse (f, g).  Suggested by Paul Kocher */
<span class="lineNum">      91 </span>            : #define RSA_BLINDING_PARAMS_MAX_REUSE 50
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /* Global, allows optional use of blinding.  On by default. */
<span class="lineNum">      94 </span>            : /* Cannot be changed at the moment, due to thread-safety issues. */
<span class="lineNum">      95 </span>            : static PRBool nssRSAUseBlinding = PR_TRUE;
<a name="96"><span class="lineNum">      96 </span>            : </a>
<span class="lineNum">      97 </span>            : static SECStatus
<span class="lineNum">      98 </span><span class="lineNoCov">          0 : rsa_build_from_primes(const mp_int *p, const mp_int *q,</span>
<span class="lineNum">      99 </span>            :                       mp_int *e, PRBool needPublicExponent,
<span class="lineNum">     100 </span>            :                       mp_int *d, PRBool needPrivateExponent,
<span class="lineNum">     101 </span>            :                       RSAPrivateKey *key, unsigned int keySizeInBits)
<span class="lineNum">     102 </span>            : {
<span class="lineNum">     103 </span>            :     mp_int n, phi;
<span class="lineNum">     104 </span>            :     mp_int psub1, qsub1, tmp;
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;phi) = 0;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;psub1) = 0;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;qsub1) = 0;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;tmp) = 0;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;phi));</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;psub1));</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;qsub1));</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;tmp));</span>
<span class="lineNum">     117 </span>            :     /* p and q must be distinct. */
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     if (mp_cmp(p, q) == 0) {</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     122 </span>            :     }
<span class="lineNum">     123 </span>            :     /* 1.  Compute n = p*q */
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mul(p, q, &amp;n));</span>
<span class="lineNum">     125 </span>            :     /*     verify that the modulus has the desired number of bits */
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     if ((unsigned)mpl_significant_bits(&amp;n) != keySizeInBits) {</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     130 </span>            :     }
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     /* at least one exponent must be given */
<span class="lineNum">     133 </span>            :     PORT_Assert(!(needPublicExponent &amp;&amp; needPrivateExponent));
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :     /* 2.  Compute phi = (p-1)*(q-1) */
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(p, 1, &amp;psub1));</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(q, 1, &amp;qsub1));</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     if (needPublicExponent || needPrivateExponent) {</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_lcm(&amp;psub1, &amp;qsub1, &amp;phi));</span>
<span class="lineNum">     140 </span>            :         /* 3.  Compute d = e**-1 mod(phi) */
<span class="lineNum">     141 </span>            :         /*     or      e = d**-1 mod(phi) as necessary */
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         if (needPublicExponent) {</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :             err = mp_invmod(d, &amp;phi, e);</span>
<span class="lineNum">     144 </span>            :         } else {
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :             err = mp_invmod(e, &amp;phi, d);</span>
<span class="lineNum">     146 </span>            :         }
<span class="lineNum">     147 </span>            :     } else {
<span class="lineNum">     148 </span>            :         err = MP_OKAY;
<span class="lineNum">     149 </span>            :     }
<span class="lineNum">     150 </span>            :     /*     Verify that phi(n) and e have no common divisors */
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     if (err != MP_OKAY) {</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         if (err == MP_UNDEF) {</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_NEED_RANDOM);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             err = MP_OKAY; /* to keep PORT_SetError from being called again */</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             rv = SECFailure;</span>
<span class="lineNum">     156 </span>            :         }
<span class="lineNum">     157 </span>            :         goto cleanup;
<span class="lineNum">     158 </span>            :     }
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :     /* 4.  Compute exponent1 = d mod (p-1) */
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(d, &amp;psub1, &amp;tmp));</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(&amp;tmp, &amp;key-&gt;exponent1, key-&gt;arena);</span>
<span class="lineNum">     163 </span>            :     /* 5.  Compute exponent2 = d mod (q-1) */
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(d, &amp;qsub1, &amp;tmp));</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(&amp;tmp, &amp;key-&gt;exponent2, key-&gt;arena);</span>
<span class="lineNum">     166 </span>            :     /* 6.  Compute coefficient = q**-1 mod p */
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_invmod(q, p, &amp;tmp));</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(&amp;tmp, &amp;key-&gt;coefficient, key-&gt;arena);</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :     /* copy our calculated results, overwrite what is there */
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     key-&gt;modulus.data = NULL;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(&amp;n, &amp;key-&gt;modulus, key-&gt;arena);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     key-&gt;privateExponent.data = NULL;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(d, &amp;key-&gt;privateExponent, key-&gt;arena);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     key-&gt;publicExponent.data = NULL;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(e, &amp;key-&gt;publicExponent, key-&gt;arena);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     key-&gt;prime1.data = NULL;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(p, &amp;key-&gt;prime1, key-&gt;arena);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     key-&gt;prime2.data = NULL;</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     MPINT_TO_SECITEM(q, &amp;key-&gt;prime2, key-&gt;arena);</span>
<span class="lineNum">     181 </span>            : cleanup:
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     mp_clear(&amp;phi);</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     mp_clear(&amp;psub1);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     mp_clear(&amp;qsub1);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     mp_clear(&amp;tmp);</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     189 </span>            :         rv = SECFailure;
<span class="lineNum">     190 </span>            :     }
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     return rv;</span>
<a name="192"><span class="lineNum">     192 </span>            : }</a>
<span class="lineNum">     193 </span>            : static SECStatus
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : generate_prime(mp_int *prime, int primeLen)</span>
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     unsigned long counter = 0;</span>
<span class="lineNum">     199 </span>            :     int piter;
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     unsigned char *pb = NULL;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     pb = PORT_Alloc(primeLen);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     if (!pb) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     205 </span>            :     }
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     for (piter = 0; piter &lt; MAX_PRIME_GEN_ATTEMPTS; piter++) {</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(RNG_GenerateGlobalRandomBytes(pb, primeLen));</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         pb[0] |= 0xC0;            /* set two high-order bits */</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         pb[primeLen - 1] |= 0x01; /* set low-order bit       */</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_read_unsigned_octets(prime, pb, primeLen));</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         err = mpp_make_prime(prime, primeLen * 8, PR_FALSE, &amp;counter);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         if (err != MP_NO)</span>
<span class="lineNum">     213 </span>            :             goto cleanup;
<span class="lineNum">     214 </span>            :         /* keep going while err == MP_NO */
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span>            : cleanup:
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     if (pb)</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         PORT_ZFree(pb, primeLen);</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     221 </span>            :         rv = SECFailure;
<span class="lineNum">     222 </span>            :     }
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     224 </span>            : }
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : /*
<span class="lineNum">     227 </span>            :  *  make sure the key components meet fips186 requirements.
<a name="228"><span class="lineNum">     228 </span>            :  */</a>
<span class="lineNum">     229 </span>            : static PRBool
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : rsa_fips186_verify(mp_int *p, mp_int *q, mp_int *d, int keySizeInBits)</span>
<span class="lineNum">     231 </span>            : {
<span class="lineNum">     232 </span>            :     mp_int pq_diff;
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     PRBool ret = PR_FALSE;</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     if (keySizeInBits &lt; 250) {</span>
<span class="lineNum">     237 </span>            :         /* not a valid FIPS length, no point in our other tests */
<span class="lineNum">     238 </span>            :         /* if you are here, and in FIPS mode, you are outside the security
<span class="lineNum">     239 </span>            :          * policy */
<span class="lineNum">     240 </span>            :         return PR_TRUE;
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     /* p &amp; q are already known to be greater then sqrt(2)*2^(keySize/2-1) */
<span class="lineNum">     244 </span>            :     /* we also know that gcd(p-1,e) = 1 and gcd(q-1,e) = 1 because the
<span class="lineNum">     245 </span>            :      * mp_invmod() function will fail. */
<span class="lineNum">     246 </span>            :     /* now check p-q &gt; 2^(keysize/2-100) */
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;pq_diff) = 0;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;pq_diff));</span>
<span class="lineNum">     249 </span>            :     /* NSS always has p &gt; q, so we know pq_diff is positive */
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub(p, q, &amp;pq_diff));</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     if ((unsigned)mpl_significant_bits(&amp;pq_diff) &lt; (keySizeInBits / 2 - 100)) {</span>
<span class="lineNum">     252 </span>            :         goto cleanup;
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span>            :     /* now verify d is large enough*/
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     if ((unsigned)mpl_significant_bits(d) &lt; (keySizeInBits / 2)) {</span>
<span class="lineNum">     256 </span>            :         goto cleanup;
<span class="lineNum">     257 </span>            :     }
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     ret = PR_TRUE;</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : cleanup:
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     mp_clear(&amp;pq_diff);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">     263 </span>            : }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /*
<span class="lineNum">     266 </span>            : ** Generate and return a new RSA public and private key.
<span class="lineNum">     267 </span>            : **  Both keys are encoded in a single RSAPrivateKey structure.
<span class="lineNum">     268 </span>            : **  &quot;cx&quot; is the random number generator context
<span class="lineNum">     269 </span>            : **  &quot;keySizeInBits&quot; is the size of the key to be generated, in bits.
<span class="lineNum">     270 </span>            : **     512, 1024, etc.
<span class="lineNum">     271 </span>            : **  &quot;publicExponent&quot; when not NULL is a pointer to some data that
<span class="lineNum">     272 </span>            : **     represents the public exponent to use. The data is a byte
<span class="lineNum">     273 </span>            : **     encoded integer, in &quot;big endian&quot; order.
<a name="274"><span class="lineNum">     274 </span>            : */</a>
<span class="lineNum">     275 </span>            : RSAPrivateKey *
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : RSA_NewKey(int keySizeInBits, SECItem *publicExponent)</span>
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span>            :     unsigned int primeLen;
<span class="lineNum">     279 </span>            :     mp_int p, q, e, d;
<span class="lineNum">     280 </span>            :     int kiter;
<span class="lineNum">     281 </span>            :     int max_attempts;
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     int prerr = 0;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     RSAPrivateKey *key = NULL;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     PLArenaPool *arena = NULL;</span>
<span class="lineNum">     287 </span>            :     /* Require key size to be a multiple of 16 bits. */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     if (!publicExponent || keySizeInBits % 16 != 0 ||</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         BAD_RSA_KEY_SIZE((unsigned int)keySizeInBits / 8, publicExponent-&gt;len)) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     292 </span>            :     }
<span class="lineNum">     293 </span>            :     /* 1. Allocate arena &amp; key */
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     arena = PORT_NewArena(NSS_FREEBL_DEFAULT_CHUNKSIZE);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     if (!arena) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     298 </span>            :     }
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     key = PORT_ArenaZNew(arena, RSAPrivateKey);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     if (!key) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         PORT_FreeArena(arena, PR_TRUE);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     key-&gt;arena = arena;</span>
<span class="lineNum">     306 </span>            :     /* length of primes p and q (in bytes) */
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     primeLen = keySizeInBits / (2 * PR_BITS_PER_BYTE);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;p) = 0;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;q) = 0;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;e) = 0;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d) = 0;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;p));</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;q));</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;e));</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d));</span>
<span class="lineNum">     316 </span>            :     /* 2.  Set the version number (PKCS1 v1.5 says it should be zero) */
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     SECITEM_AllocItem(arena, &amp;key-&gt;version, 1);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     key-&gt;version.data[0] = 0;</span>
<span class="lineNum">     319 </span>            :     /* 3.  Set the public exponent */
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(*publicExponent, &amp;e);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     kiter = 0;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     max_attempts = 5 * (keySizeInBits / 2); /* FIPS 186-4 B.3.3 steps 4.7 and 5.8 */</span>
<span class="lineNum">     323 </span>            :     do {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         prerr = 0;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         PORT_SetError(0);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(generate_prime(&amp;p, primeLen));</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(generate_prime(&amp;q, primeLen));</span>
<span class="lineNum">     328 </span>            :         /* Assure p &gt; q */
<span class="lineNum">     329 </span>            :         /* NOTE: PKCS #1 does not require p &gt; q, and NSS doesn't use any
<span class="lineNum">     330 </span>            :          * implementation optimization that requires p &gt; q. We can remove
<span class="lineNum">     331 </span>            :          * this code in the future.
<span class="lineNum">     332 </span>            :          */
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         if (mp_cmp(&amp;p, &amp;q) &lt; 0)</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :             mp_exch(&amp;p, &amp;q);</span>
<span class="lineNum">     335 </span>            :         /* Attempt to use these primes to generate a key */
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         rv = rsa_build_from_primes(&amp;p, &amp;q,</span>
<span class="lineNum">     337 </span>            :                                    &amp;e, PR_FALSE, /* needPublicExponent=false */
<span class="lineNum">     338 </span>            :                                    &amp;d, PR_TRUE,  /* needPrivateExponent=true */
<span class="lineNum">     339 </span>            :                                    key, keySizeInBits);
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :         if (rv == SECSuccess) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :             if (rsa_fips186_verify(&amp;p, &amp;q, &amp;d, keySizeInBits)) {</span>
<span class="lineNum">     342 </span>            :                 break;
<span class="lineNum">     343 </span>            :             }
<span class="lineNum">     344 </span>            :             prerr = SEC_ERROR_NEED_RANDOM; /* retry with different values */
<span class="lineNum">     345 </span>            :         } else {
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             prerr = PORT_GetError();</span>
<span class="lineNum">     347 </span>            :         }
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         kiter++;</span>
<span class="lineNum">     349 </span>            :         /* loop until have primes */
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     } while (prerr == SEC_ERROR_NEED_RANDOM &amp;&amp; kiter &lt; max_attempts);</span>
<span class="lineNum">     351 </span>            :     if (prerr)
<span class="lineNum">     352 </span>            :         goto cleanup;
<span class="lineNum">     353 </span>            : cleanup:
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     mp_clear(&amp;p);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     mp_clear(&amp;q);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     mp_clear(&amp;e);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     360 </span>            :         rv = SECFailure;
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     if (rv &amp;&amp; arena) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         PORT_FreeArena(arena, PR_TRUE);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         key = NULL;</span>
<span class="lineNum">     365 </span>            :     }
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     return key;</span>
<span class="lineNum">     367 </span>            : }
<a name="368"><span class="lineNum">     368 </span>            : </a>
<span class="lineNum">     369 </span>            : mp_err
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : rsa_is_prime(mp_int *p)</span>
<span class="lineNum">     371 </span>            : {
<span class="lineNum">     372 </span>            :     int res;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :     /* run a Fermat test */
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     res = mpp_fermat(p, 2);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     if (res != MP_OKAY) {</span>
<span class="lineNum">     377 </span>            :         return res;
<span class="lineNum">     378 </span>            :     }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :     /* If that passed, run some Miller-Rabin tests */
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     res = mpp_pprime(p, 2);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     return res;</span>
<span class="lineNum">     383 </span>            : }
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : /*
<span class="lineNum">     386 </span>            :  * Factorize a RSA modulus n into p and q by using the exponents e and d.
<span class="lineNum">     387 </span>            :  *
<span class="lineNum">     388 </span>            :  * In: e, d, n
<span class="lineNum">     389 </span>            :  * Out: p, q
<span class="lineNum">     390 </span>            :  *
<span class="lineNum">     391 </span>            :  * See Handbook of Applied Cryptography, 8.2.2(i).
<span class="lineNum">     392 </span>            :  *
<span class="lineNum">     393 </span>            :  * The algorithm is probabilistic, it is run 64 times and each run has a 50%
<span class="lineNum">     394 </span>            :  * chance of succeeding with a runtime of O(log(e*d)).
<span class="lineNum">     395 </span>            :  *
<span class="lineNum">     396 </span>            :  * The returned p might be smaller than q.
<a name="397"><span class="lineNum">     397 </span>            :  */</a>
<span class="lineNum">     398 </span>            : static mp_err
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : rsa_factorize_n_from_exponents(mp_int *e, mp_int *d, mp_int *p, mp_int *q,</span>
<span class="lineNum">     400 </span>            :                                mp_int *n)
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span>            :     /* lambda is the private modulus: e*d = 1 mod lambda */
<span class="lineNum">     403 </span>            :     /* so: e*d - 1 = k*lambda = t*2^s where t is odd */
<span class="lineNum">     404 </span>            :     mp_int klambda;
<span class="lineNum">     405 </span>            :     mp_int t, onetwentyeight;
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     unsigned long s = 0;</span>
<span class="lineNum">     407 </span>            :     unsigned long i;
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :     /* cand = a^(t * 2^i) mod n, next_cand = a^(t * 2^(i+1)) mod n */
<span class="lineNum">     410 </span>            :     mp_int a;
<span class="lineNum">     411 </span>            :     mp_int cand;
<span class="lineNum">     412 </span>            :     mp_int next_cand;
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :     mp_int n_minus_one;
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;klambda) = 0;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;t) = 0;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;a) = 0;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;cand) = 0;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n_minus_one) = 0;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;next_cand) = 0;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;onetwentyeight) = 0;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;klambda));</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;t));</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;a));</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;cand));</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n_minus_one));</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;next_cand));</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;onetwentyeight));</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     mp_set_int(&amp;onetwentyeight, 128);</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :     /* calculate k*lambda = e*d - 1 */
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mul(e, d, &amp;klambda));</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(&amp;klambda, 1, &amp;klambda));</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     /* factorize klambda into t*2^s */
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_copy(&amp;klambda, &amp;t));</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     while (mpp_divis_d(&amp;t, 2) == MP_YES) {</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_div_2(&amp;t, &amp;t));</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         s += 1;</span>
<span class="lineNum">     443 </span>            :     }
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :     /* precompute n_minus_one = n - 1 */
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_copy(n, &amp;n_minus_one));</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(&amp;n_minus_one, 1, &amp;n_minus_one));</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :     /* pick random bases a, each one has a 50% leading to a factorization */
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_set_int(&amp;a, 2));</span>
<span class="lineNum">     451 </span>            :     /* The following is equivalent to for (a=2, a &lt;= 128, a+=2) */
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     while (mp_cmp(&amp;a, &amp;onetwentyeight) &lt;= 0) {</span>
<span class="lineNum">     453 </span>            :         /* compute the base cand = a^(t * 2^0) [i = 0] */
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_exptmod(&amp;a, &amp;t, n, &amp;cand));</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; s; i++) {</span>
<span class="lineNum">     457 </span>            :             /* condition 1: skip the base if we hit a trivial factor of n */
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :             if (mp_cmp(&amp;cand, &amp;n_minus_one) == 0 || mp_cmp_d(&amp;cand, 1) == 0) {</span>
<span class="lineNum">     459 </span>            :                 break;
<span class="lineNum">     460 </span>            :             }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :             /* increase i in a^(t * 2^i) by squaring the number */
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(mp_exptmod_d(&amp;cand, 2, n, &amp;next_cand));</span>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :             /* condition 2: a^(t * 2^(i+1)) = 1 mod n */
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             if (mp_cmp_d(&amp;next_cand, 1) == 0) {</span>
<span class="lineNum">     467 </span>            :                 /* conditions verified, gcd(a^(t * 2^i) - 1, n) is a factor */
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                 CHECK_MPI_OK(mp_sub_d(&amp;cand, 1, &amp;cand));</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                 CHECK_MPI_OK(mp_gcd(&amp;cand, n, p));</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :                 if (mp_cmp_d(p, 1) == 0) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                     CHECK_MPI_OK(mp_add_d(&amp;cand, 1, &amp;cand));</span>
<span class="lineNum">     472 </span>            :                     break;
<span class="lineNum">     473 </span>            :                 }
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                 CHECK_MPI_OK(mp_div(n, p, q, NULL));</span>
<span class="lineNum">     475 </span>            :                 goto cleanup;
<span class="lineNum">     476 </span>            :             }
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(mp_copy(&amp;next_cand, &amp;cand));</span>
<span class="lineNum">     478 </span>            :         }
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_add_d(&amp;a, 2, &amp;a));</span>
<span class="lineNum">     481 </span>            :     }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :     /* if we reach here it's likely (2^64 - 1 / 2^64) that d is wrong */
<span class="lineNum">     484 </span>            :     err = MP_RANGE;
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : cleanup:
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     mp_clear(&amp;klambda);</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     mp_clear(&amp;t);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     mp_clear(&amp;a);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     mp_clear(&amp;cand);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n_minus_one);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     mp_clear(&amp;next_cand);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     mp_clear(&amp;onetwentyeight);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     495 </span>            : }
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            : /*
<span class="lineNum">     498 </span>            :  * Try to find the two primes based on 2 exponents plus a prime.
<span class="lineNum">     499 </span>            :  *
<span class="lineNum">     500 </span>            :  * In: e, d and p.
<span class="lineNum">     501 </span>            :  * Out: p,q.
<span class="lineNum">     502 </span>            :  *
<span class="lineNum">     503 </span>            :  * Step 1, Since d = e**-1 mod phi, we know that d*e == 1 mod phi, or
<span class="lineNum">     504 </span>            :  *  d*e = 1+k*phi, or d*e-1 = k*phi. since d is less than phi and e is
<span class="lineNum">     505 </span>            :  *  usually less than d, then k must be an integer between e-1 and 1
<span class="lineNum">     506 </span>            :  *  (probably on the order of e).
<span class="lineNum">     507 </span>            :  * Step 1a, We can divide k*phi by prime-1 and get k*(q-1). This will reduce
<span class="lineNum">     508 </span>            :  *      the size of our division through the rest of the loop.
<span class="lineNum">     509 </span>            :  * Step 2, Loop through the values k=e-1 to 1 looking for k. k should be on
<span class="lineNum">     510 </span>            :  *  the order or e, and e is typically small. This may take a while for
<span class="lineNum">     511 </span>            :  *  a large random e. We are looking for a k that divides kphi
<span class="lineNum">     512 </span>            :  *  evenly. Once we find a k that divides kphi evenly, we assume it
<span class="lineNum">     513 </span>            :  *  is the true k. It's possible this k is not the 'true' k but has
<span class="lineNum">     514 </span>            :  *  swapped factors of p-1 and/or q-1. Because of this, we
<span class="lineNum">     515 </span>            :  *  tentatively continue Steps 3-6 inside this loop, and may return looking
<span class="lineNum">     516 </span>            :  *  for another k on failure.
<span class="lineNum">     517 </span>            :  * Step 3, Calculate our tentative phi=kphi/k. Note: real phi is (p-1)*(q-1).
<span class="lineNum">     518 </span>            :  * Step 4a, kphi is k*(q-1), so phi is our tenative q-1. q = phi+1.
<span class="lineNum">     519 </span>            :  *      If k is correct, q should be the right length and prime.
<span class="lineNum">     520 </span>            :  * Step 4b, It's possible q-1 and k could have swapped factors. We now have a
<span class="lineNum">     521 </span>            :  *  possible solution that meets our criteria. It may not be the only
<span class="lineNum">     522 </span>            :  *      solution, however, so we keep looking. If we find more than one,
<span class="lineNum">     523 </span>            :  *      we will fail since we cannot determine which is the correct
<span class="lineNum">     524 </span>            :  *      solution, and returning the wrong modulus will compromise both
<span class="lineNum">     525 </span>            :  *      moduli. If no other solution is found, we return the unique solution.
<span class="lineNum">     526 </span>            :  *
<span class="lineNum">     527 </span>            :  * This will return p &amp; q. q may be larger than p in the case that p was given
<span class="lineNum">     528 </span>            :  * and it was the smaller prime.
<a name="529"><span class="lineNum">     529 </span>            :  */</a>
<span class="lineNum">     530 </span>            : static mp_err
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : rsa_get_prime_from_exponents(mp_int *e, mp_int *d, mp_int *p, mp_int *q,</span>
<span class="lineNum">     532 </span>            :                              mp_int *n, unsigned int keySizeInBits)
<span class="lineNum">     533 </span>            : {
<span class="lineNum">     534 </span>            :     mp_int kphi; /* k*phi */
<span class="lineNum">     535 </span>            :     mp_int k;    /* current guess at 'k' */
<span class="lineNum">     536 </span>            :     mp_int phi;  /* (p-1)(q-1) */
<span class="lineNum">     537 </span>            :     mp_int r;    /* remainder */
<span class="lineNum">     538 </span>            :     mp_int tmp;  /* p-1 if p is given */
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     540 </span>            :     unsigned int order_k;
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;kphi) = 0;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;phi) = 0;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;k) = 0;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;r) = 0;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;tmp) = 0;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;kphi));</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;phi));</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;k));</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;r));</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;tmp));</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :     /* our algorithm looks for a factor k whose maximum size is dependent
<span class="lineNum">     554 </span>            :      * on the size of our smallest exponent, which had better be the public
<span class="lineNum">     555 </span>            :      * exponent (if it's the private, the key is vulnerable to a brute force
<span class="lineNum">     556 </span>            :      * attack).
<span class="lineNum">     557 </span>            :      *
<span class="lineNum">     558 </span>            :      * since our factor search is linear, we need to limit the maximum
<span class="lineNum">     559 </span>            :      * size of the public key. this should not be a problem normally, since
<span class="lineNum">     560 </span>            :      * public keys are usually small.
<span class="lineNum">     561 </span>            :      *
<span class="lineNum">     562 </span>            :      * if we want to handle larger public key sizes, we should have
<span class="lineNum">     563 </span>            :      * a version which tries to 'completely' factor k*phi (where completely
<span class="lineNum">     564 </span>            :      * means 'factor into primes, or composites with which are products of
<span class="lineNum">     565 </span>            :      * large primes). Once we have all the factors, we can sort them out and
<span class="lineNum">     566 </span>            :      * try different combinations to form our phi. The risk is if (p-1)/2,
<span class="lineNum">     567 </span>            :      * (q-1)/2, and k are all large primes. In any case if the public key
<span class="lineNum">     568 </span>            :      * is small (order of 20 some bits), then a linear search for k is
<span class="lineNum">     569 </span>            :      * manageable.
<span class="lineNum">     570 </span>            :      */
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     if (mpl_significant_bits(e) &gt; 23) {</span>
<span class="lineNum">     572 </span>            :         err = MP_RANGE;
<span class="lineNum">     573 </span>            :         goto cleanup;
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :     /* calculate k*phi = e*d - 1 */
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mul(e, d, &amp;kphi));</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(&amp;kphi, 1, &amp;kphi));</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :     /* kphi is (e*d)-1, which is the same as k*(p-1)(q-1)
<span class="lineNum">     581 </span>            :      * d &lt; (p-1)(q-1), therefor k must be less than e-1
<span class="lineNum">     582 </span>            :      * We can narrow down k even more, though. Since p and q are odd and both
<span class="lineNum">     583 </span>            :      * have their high bit set, then we know that phi must be on order of
<span class="lineNum">     584 </span>            :      * keySizeBits.
<span class="lineNum">     585 </span>            :      */
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     order_k = (unsigned)mpl_significant_bits(&amp;kphi) - keySizeInBits;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :     /* for (k=kinit; order(k) &gt;= order_k; k--) { */
<span class="lineNum">     589 </span>            :     /* k=kinit: k can't be bigger than  kphi/2^(keySizeInBits -1) */
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_2expt(&amp;k, keySizeInBits - 1));</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_div(&amp;kphi, &amp;k, &amp;k, NULL));</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     if (mp_cmp(&amp;k, e) &gt;= 0) {</span>
<span class="lineNum">     593 </span>            :         /* also can't be bigger then e-1 */
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_sub_d(e, 1, &amp;k));</span>
<span class="lineNum">     595 </span>            :     }
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :     /* calculate our temp value */
<span class="lineNum">     598 </span>            :     /* This saves recalculating this value when the k guess is wrong, which
<span class="lineNum">     599 </span>            :      * is reasonably frequent. */
<span class="lineNum">     600 </span>            :     /* tmp = p-1 (used to calculate q-1= phi/tmp) */
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(p, 1, &amp;tmp));</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_div(&amp;kphi, &amp;tmp, &amp;kphi, &amp;r));</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     if (mp_cmp_z(&amp;r) != 0) {</span>
<span class="lineNum">     604 </span>            :         /* p-1 doesn't divide kphi, some parameter wasn't correct */
<span class="lineNum">     605 </span>            :         err = MP_RANGE;
<span class="lineNum">     606 </span>            :         goto cleanup;
<span class="lineNum">     607 </span>            :     }
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     mp_zero(q);</span>
<span class="lineNum">     609 </span>            :     /* kphi is now k*(q-1) */
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :     /* rest of the for loop */
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     for (; (err == MP_OKAY) &amp;&amp; (mpl_significant_bits(&amp;k) &gt;= order_k);</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :          err = mp_sub_d(&amp;k, 1, &amp;k)) {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(err);</span>
<span class="lineNum">     615 </span>            :         /* looking for k as a factor of kphi */
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_div(&amp;kphi, &amp;k, &amp;phi, &amp;r));</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         if (mp_cmp_z(&amp;r) != 0) {</span>
<span class="lineNum">     618 </span>            :             /* not a factor, try the next one */
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     620 </span>            :         }
<span class="lineNum">     621 </span>            :         /* we have a possible phi, see if it works */
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         if ((unsigned)mpl_significant_bits(&amp;phi) != keySizeInBits / 2) {</span>
<span class="lineNum">     623 </span>            :             /* phi is not the right size */
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     625 </span>            :         }
<span class="lineNum">     626 </span>            :         /* phi should be divisible by 2, since
<span class="lineNum">     627 </span>            :          * q is odd and phi=(q-1). */
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         if (mpp_divis_d(&amp;phi, 2) == MP_NO) {</span>
<span class="lineNum">     629 </span>            :             /* phi is not divisible by 4 */
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     631 </span>            :         }
<span class="lineNum">     632 </span>            :         /* we now have a candidate for the second prime */
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_add_d(&amp;phi, 1, &amp;tmp));</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :         /* check to make sure it is prime */
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         err = rsa_is_prime(&amp;tmp);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         if (err != MP_OKAY) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :             if (err == MP_NO) {</span>
<span class="lineNum">     639 </span>            :                 /* No, then we still have the wrong phi */
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     641 </span>            :             }
<span class="lineNum">     642 </span>            :             goto cleanup;
<span class="lineNum">     643 </span>            :         }
<span class="lineNum">     644 </span>            :         /*
<span class="lineNum">     645 </span>            :          * It is possible that we have the wrong phi if
<span class="lineNum">     646 </span>            :          * k_guess*(q_guess-1) = k*(q-1) (k and q-1 have swapped factors).
<span class="lineNum">     647 </span>            :          * since our q_quess is prime, however. We have found a valid
<span class="lineNum">     648 </span>            :          * rsa key because:
<span class="lineNum">     649 </span>            :          *   q is the correct order of magnitude.
<span class="lineNum">     650 </span>            :          *   phi = (p-1)(q-1) where p and q are both primes.
<span class="lineNum">     651 </span>            :          *   e*d mod phi = 1.
<span class="lineNum">     652 </span>            :          * There is no way to know from the info given if this is the
<span class="lineNum">     653 </span>            :          * original key. We never want to return the wrong key because if
<span class="lineNum">     654 </span>            :          * two moduli with the same factor is known, then euclid's gcd
<span class="lineNum">     655 </span>            :          * algorithm can be used to find that factor. Even though the
<span class="lineNum">     656 </span>            :          * caller didn't pass the original modulus, it doesn't mean the
<span class="lineNum">     657 </span>            :          * modulus wasn't known or isn't available somewhere. So to be safe
<span class="lineNum">     658 </span>            :          * if we can't be sure we have the right q, we don't return any.
<span class="lineNum">     659 </span>            :          *
<span class="lineNum">     660 </span>            :          * So to make sure we continue looking for other valid q's. If none
<span class="lineNum">     661 </span>            :          * are found, then we can safely return this one, otherwise we just
<span class="lineNum">     662 </span>            :          * fail */
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         if (mp_cmp_z(q) != 0) {</span>
<span class="lineNum">     664 </span>            :             /* this is the second valid q, don't return either,
<span class="lineNum">     665 </span>            :              * just fail */
<span class="lineNum">     666 </span>            :             err = MP_RANGE;
<span class="lineNum">     667 </span>            :             break;
<span class="lineNum">     668 </span>            :         }
<span class="lineNum">     669 </span>            :         /* we only have one q so far, save it and if no others are found,
<span class="lineNum">     670 </span>            :          * it's safe to return it */
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_copy(&amp;tmp, q));</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     if ((unsigned)mpl_significant_bits(&amp;k) &lt; order_k) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         if (mp_cmp_z(q) == 0) {</span>
<span class="lineNum">     676 </span>            :             /* If we get here, something was wrong with the parameters we
<span class="lineNum">     677 </span>            :              * were given */
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :             err = MP_RANGE;</span>
<span class="lineNum">     679 </span>            :         }
<span class="lineNum">     680 </span>            :     }
<span class="lineNum">     681 </span>            : cleanup:
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     mp_clear(&amp;kphi);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     mp_clear(&amp;phi);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     mp_clear(&amp;k);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     mp_clear(&amp;r);</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     mp_clear(&amp;tmp);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     688 </span>            : }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : /*
<span class="lineNum">     691 </span>            :  * take a private key with only a few elements and fill out the missing pieces.
<span class="lineNum">     692 </span>            :  *
<span class="lineNum">     693 </span>            :  * All the entries will be overwritten with data allocated out of the arena
<span class="lineNum">     694 </span>            :  * If no arena is supplied, one will be created.
<span class="lineNum">     695 </span>            :  *
<span class="lineNum">     696 </span>            :  * The following fields must be supplied in order for this function
<span class="lineNum">     697 </span>            :  * to succeed:
<span class="lineNum">     698 </span>            :  *   one of either publicExponent or privateExponent
<span class="lineNum">     699 </span>            :  *   two more of the following 5 parameters.
<span class="lineNum">     700 </span>            :  *      modulus (n)
<span class="lineNum">     701 </span>            :  *      prime1  (p)
<span class="lineNum">     702 </span>            :  *      prime2  (q)
<span class="lineNum">     703 </span>            :  *      publicExponent (e)
<span class="lineNum">     704 </span>            :  *      privateExponent (d)
<span class="lineNum">     705 </span>            :  *
<span class="lineNum">     706 </span>            :  * NOTE: if only the publicExponent, privateExponent, and one prime is given,
<span class="lineNum">     707 </span>            :  * then there may be more than one RSA key that matches that combination.
<span class="lineNum">     708 </span>            :  *
<span class="lineNum">     709 </span>            :  * All parameters will be replaced in the key structure with new parameters
<span class="lineNum">     710 </span>            :  * Allocated out of the arena. There is no attempt to free the old structures.
<span class="lineNum">     711 </span>            :  * Prime1 will always be greater than prime2 (even if the caller supplies the
<span class="lineNum">     712 </span>            :  * smaller prime as prime1 or the larger prime as prime2). The parameters are
<span class="lineNum">     713 </span>            :  * not overwritten on failure.
<span class="lineNum">     714 </span>            :  *
<span class="lineNum">     715 </span>            :  *  How it works:
<span class="lineNum">     716 </span>            :  *     We can generate all the parameters from one of the exponents, plus the
<span class="lineNum">     717 </span>            :  *        two primes. (rsa_build_key_from_primes)
<span class="lineNum">     718 </span>            :  *     If we are given one of the exponents and both primes, we are done.
<span class="lineNum">     719 </span>            :  *     If we are given one of the exponents, the modulus and one prime, we
<span class="lineNum">     720 </span>            :  *        caclulate the second prime by dividing the modulus by the given
<span class="lineNum">     721 </span>            :  *        prime, giving us an exponent and 2 primes.
<span class="lineNum">     722 </span>            :  *     If we are given 2 exponents and one of the primes we calculate
<span class="lineNum">     723 </span>            :  *        k*phi = d*e-1, where k is an integer less than d which
<span class="lineNum">     724 </span>            :  *        divides d*e-1. We find factor k so we can isolate phi.
<span class="lineNum">     725 </span>            :  *            phi = (p-1)(q-1)
<span class="lineNum">     726 </span>            :  *        We can use phi to find the other prime as follows:
<span class="lineNum">     727 </span>            :  *        q = (phi/(p-1)) + 1. We now have 2 primes and an exponent.
<span class="lineNum">     728 </span>            :  *        (NOTE: if more then one prime meets this condition, the operation
<span class="lineNum">     729 </span>            :  *        will fail. See comments elsewhere in this file about this).
<span class="lineNum">     730 </span>            :  *        (rsa_get_prime_from_exponents)
<span class="lineNum">     731 </span>            :  *     If we are given 2 exponents and the modulus we factor the modulus to
<span class="lineNum">     732 </span>            :  *        get the 2 missing primes (rsa_factorize_n_from_exponents)
<span class="lineNum">     733 </span>            :  *
<a name="734"><span class="lineNum">     734 </span>            :  */</a>
<span class="lineNum">     735 </span>            : SECStatus
<span class="lineNum">     736 </span><span class="lineNoCov">          0 : RSA_PopulatePrivateKey(RSAPrivateKey *key)</span>
<span class="lineNum">     737 </span>            : {
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     PLArenaPool *arena = NULL;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     PRBool needPublicExponent = PR_TRUE;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     PRBool needPrivateExponent = PR_TRUE;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     PRBool hasModulus = PR_FALSE;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     unsigned int keySizeInBits = 0;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     int prime_count = 0;</span>
<span class="lineNum">     744 </span>            :     /* standard RSA nominclature */
<span class="lineNum">     745 </span>            :     mp_int p, q, e, d, n;
<span class="lineNum">     746 </span>            :     /* remainder */
<span class="lineNum">     747 </span>            :     mp_int r;
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     mp_err err = 0;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     SECStatus rv = SECFailure;</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;p) = 0;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;q) = 0;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;e) = 0;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d) = 0;</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;r) = 0;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;p));</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;q));</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;e));</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d));</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;r));</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     /* if the key didn't already have an arena, create one. */
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     if (key-&gt;arena == NULL) {</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :         arena = PORT_NewArena(NSS_FREEBL_DEFAULT_CHUNKSIZE);</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         if (!arena) {</span>
<span class="lineNum">     768 </span>            :             goto cleanup;
<span class="lineNum">     769 </span>            :         }
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         key-&gt;arena = arena;</span>
<span class="lineNum">     771 </span>            :     }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :     /* load up the known exponents */
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     if (key-&gt;publicExponent.data) {</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         SECITEM_TO_MPINT(key-&gt;publicExponent, &amp;e);</span>
<span class="lineNum">     776 </span>            :         needPublicExponent = PR_FALSE;
<span class="lineNum">     777 </span>            :     }
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     if (key-&gt;privateExponent.data) {</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         SECITEM_TO_MPINT(key-&gt;privateExponent, &amp;d);</span>
<span class="lineNum">     780 </span>            :         needPrivateExponent = PR_FALSE;
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     if (needPrivateExponent &amp;&amp; needPublicExponent) {</span>
<span class="lineNum">     783 </span>            :         /* Not enough information, we need at least one exponent */
<span class="lineNum">     784 </span>            :         err = MP_BADARG;
<span class="lineNum">     785 </span>            :         goto cleanup;
<span class="lineNum">     786 </span>            :     }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :     /* load up the known primes. If only one prime is given, it will be
<span class="lineNum">     789 </span>            :      * assigned 'p'. Once we have both primes, well make sure p is the larger.
<span class="lineNum">     790 </span>            :      * The value prime_count tells us howe many we have acquired.
<span class="lineNum">     791 </span>            :      */
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     if (key-&gt;prime1.data) {</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         int primeLen = key-&gt;prime1.len;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         if (key-&gt;prime1.data[0] == 0) {</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :             primeLen--;</span>
<span class="lineNum">     796 </span>            :         }
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         keySizeInBits = primeLen * 2 * PR_BITS_PER_BYTE;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         SECITEM_TO_MPINT(key-&gt;prime1, &amp;p);</span>
<span class="lineNum">     799 </span>            :         prime_count++;
<span class="lineNum">     800 </span>            :     }
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     if (key-&gt;prime2.data) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         int primeLen = key-&gt;prime2.len;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         if (key-&gt;prime2.data[0] == 0) {</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :             primeLen--;</span>
<span class="lineNum">     805 </span>            :         }
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         keySizeInBits = primeLen * 2 * PR_BITS_PER_BYTE;</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         SECITEM_TO_MPINT(key-&gt;prime2, prime_count ? &amp;q : &amp;p);</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         prime_count++;</span>
<span class="lineNum">     809 </span>            :     }
<span class="lineNum">     810 </span>            :     /* load up the modulus */
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     if (key-&gt;modulus.data) {</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         int modLen = key-&gt;modulus.len;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (key-&gt;modulus.data[0] == 0) {</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :             modLen--;</span>
<span class="lineNum">     815 </span>            :         }
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :         keySizeInBits = modLen * PR_BITS_PER_BYTE;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         SECITEM_TO_MPINT(key-&gt;modulus, &amp;n);</span>
<span class="lineNum">     818 </span>            :         hasModulus = PR_TRUE;
<span class="lineNum">     819 </span>            :     }
<span class="lineNum">     820 </span>            :     /* if we have the modulus and one prime, calculate the second. */
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     if ((prime_count == 1) &amp;&amp; (hasModulus)) {</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         if (mp_div(&amp;n, &amp;p, &amp;q, &amp;r) != MP_OKAY || mp_cmp_z(&amp;r) != 0) {</span>
<span class="lineNum">     823 </span>            :             /* p is not a factor or n, fail */
<span class="lineNum">     824 </span>            :             err = MP_BADARG;
<span class="lineNum">     825 </span>            :             goto cleanup;
<span class="lineNum">     826 </span>            :         }
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :         prime_count++;</span>
<span class="lineNum">     828 </span>            :     }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            :     /* If we didn't have enough primes try to calculate the primes from
<span class="lineNum">     831 </span>            :      * the exponents */
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     if (prime_count &lt; 2) {</span>
<span class="lineNum">     833 </span>            :         /* if we don't have at least 2 primes at this point, then we need both
<span class="lineNum">     834 </span>            :          * exponents and one prime or a modulus*/
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :         if (!needPublicExponent &amp;&amp; !needPrivateExponent &amp;&amp;</span>
<span class="lineNum">     836 </span>            :             (prime_count &gt; 0)) {
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(rsa_get_prime_from_exponents(&amp;e, &amp;d, &amp;p, &amp;q, &amp;n,</span>
<span class="lineNum">     838 </span>            :                                                       keySizeInBits));
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :         } else if (!needPublicExponent &amp;&amp; !needPrivateExponent &amp;&amp; hasModulus) {</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(rsa_factorize_n_from_exponents(&amp;e, &amp;d, &amp;p, &amp;q, &amp;n));</span>
<span class="lineNum">     841 </span>            :         } else {
<span class="lineNum">     842 </span>            :             /* not enough given parameters to get both primes */
<span class="lineNum">     843 </span>            :             err = MP_BADARG;
<span class="lineNum">     844 </span>            :             goto cleanup;
<span class="lineNum">     845 </span>            :         }
<span class="lineNum">     846 </span>            :     }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     /* Assure p &gt; q */
<span class="lineNum">     849 </span>            :     /* NOTE: PKCS #1 does not require p &gt; q, and NSS doesn't use any
<span class="lineNum">     850 </span>            :       * implementation optimization that requires p &gt; q. We can remove
<span class="lineNum">     851 </span>            :       * this code in the future.
<span class="lineNum">     852 </span>            :       */
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     if (mp_cmp(&amp;p, &amp;q) &lt; 0)</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :         mp_exch(&amp;p, &amp;q);</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :     /* we now have our 2 primes and at least one exponent, we can fill
<span class="lineNum">     857 </span>            :       * in the key */
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     rv = rsa_build_from_primes(&amp;p, &amp;q,</span>
<span class="lineNum">     859 </span>            :                                &amp;e, needPublicExponent,
<span class="lineNum">     860 </span>            :                                &amp;d, needPrivateExponent,
<span class="lineNum">     861 </span>            :                                key, keySizeInBits);
<span class="lineNum">     862 </span>            : cleanup:
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     mp_clear(&amp;p);</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     mp_clear(&amp;q);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     mp_clear(&amp;e);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     mp_clear(&amp;r);</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     871 </span>            :         rv = SECFailure;
<span class="lineNum">     872 </span>            :     }
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     if (rv &amp;&amp; arena) {</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         PORT_FreeArena(arena, PR_TRUE);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         key-&gt;arena = NULL;</span>
<span class="lineNum">     876 </span>            :     }
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     878 </span>            : }
<a name="879"><span class="lineNum">     879 </span>            : </a>
<span class="lineNum">     880 </span>            : static unsigned int
<span class="lineNum">     881 </span><span class="lineNoCov">          0 : rsa_modulusLen(SECItem *modulus)</span>
<span class="lineNum">     882 </span>            : {
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     unsigned char byteZero = modulus-&gt;data[0];</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     unsigned int modLen = modulus-&gt;len - !byteZero;</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     return modLen;</span>
<span class="lineNum">     886 </span>            : }
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : /*
<span class="lineNum">     889 </span>            : ** Perform a raw public-key operation
<span class="lineNum">     890 </span>            : **  Length of input and output buffers are equal to key's modulus len.
<a name="891"><span class="lineNum">     891 </span>            : */</a>
<span class="lineNum">     892 </span>            : SECStatus
<span class="lineNum">     893 </span><span class="lineNoCov">          0 : RSA_PublicKeyOp(RSAPublicKey *key,</span>
<span class="lineNum">     894 </span>            :                 unsigned char *output,
<span class="lineNum">     895 </span>            :                 const unsigned char *input)
<span class="lineNum">     896 </span>            : {
<span class="lineNum">     897 </span>            :     unsigned int modLen, expLen, offset;
<span class="lineNum">     898 </span>            :     mp_int n, e, m, c;
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if (!key || !output || !input) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">     904 </span>            :     }
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;e) = 0;</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;m) = 0;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;c) = 0;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;e));</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;m));</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;c));</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     modLen = rsa_modulusLen(&amp;key-&gt;modulus);</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     expLen = rsa_modulusLen(&amp;key-&gt;publicExponent);</span>
<span class="lineNum">     915 </span>            :     /* 1.  Obtain public key (n, e) */
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     if (BAD_RSA_KEY_SIZE(modLen, expLen)) {</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_KEY);</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     920 </span>            :     }
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;modulus, &amp;n);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;publicExponent, &amp;e);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     if (e.used &gt; n.used) {</span>
<span class="lineNum">     924 </span>            :         /* exponent should not be greater than modulus */
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_KEY);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            :     /* 2. check input out of range (needs to be in range [0..n-1]) */
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     offset = (key-&gt;modulus.data[0] == 0) ? 1 : 0; /* may be leading 0 */</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     if (memcmp(input, key-&gt;modulus.data + offset, modLen) &gt;= 0) {</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INPUT_LEN);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">     935 </span>            :     }
<span class="lineNum">     936 </span>            :     /* 2 bis.  Represent message as integer in range [0..n-1] */
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;m, input, modLen));</span>
<span class="lineNum">     938 </span>            : /* 3.  Compute c = m**e mod n */
<span class="lineNum">     939 </span>            : #ifdef USE_MPI_EXPT_D
<span class="lineNum">     940 </span>            :     /* XXX see which is faster */
<span class="lineNum">     941 </span>            :     if (MP_USED(&amp;e) == 1) {
<span class="lineNum">     942 </span>            :         CHECK_MPI_OK(mp_exptmod_d(&amp;m, MP_DIGIT(&amp;e, 0), &amp;n, &amp;c));
<span class="lineNum">     943 </span>            :     } else
<span class="lineNum">     944 </span>            : #endif
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_exptmod(&amp;m, &amp;e, &amp;n, &amp;c));</span>
<span class="lineNum">     946 </span>            :     /* 4.  result c is ciphertext */
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     err = mp_to_fixlen_octets(&amp;c, output, modLen);</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     if (err &gt;= 0)</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :         err = MP_OKAY;</span>
<span class="lineNum">     950 </span>            : cleanup:
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     mp_clear(&amp;e);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     mp_clear(&amp;m);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     mp_clear(&amp;c);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     957 </span>            :         rv = SECFailure;
<span class="lineNum">     958 </span>            :     }
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     960 </span>            : }
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            : /*
<span class="lineNum">     963 </span>            : **  RSA Private key operation (no CRT).
<a name="964"><span class="lineNum">     964 </span>            : */</a>
<span class="lineNum">     965 </span>            : static SECStatus
<span class="lineNum">     966 </span><span class="lineNoCov">          0 : rsa_PrivateKeyOpNoCRT(RSAPrivateKey *key, mp_int *m, mp_int *c, mp_int *n,</span>
<span class="lineNum">     967 </span>            :                       unsigned int modLen)
<span class="lineNum">     968 </span>            : {
<span class="lineNum">     969 </span>            :     mp_int d;
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d) = 0;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d));</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;privateExponent, &amp;d);</span>
<span class="lineNum">     975 </span>            :     /* 1. m = c**d mod n */
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_exptmod(c, &amp;d, n, m));</span>
<span class="lineNum">     977 </span>            : cleanup:
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d);</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">     981 </span>            :         rv = SECFailure;
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     984 </span>            : }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            : /*
<span class="lineNum">     987 </span>            : **  RSA Private key operation using CRT.
<a name="988"><span class="lineNum">     988 </span>            : */</a>
<span class="lineNum">     989 </span>            : static SECStatus
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : rsa_PrivateKeyOpCRTNoCheck(RSAPrivateKey *key, mp_int *m, mp_int *c)</span>
<span class="lineNum">     991 </span>            : {
<span class="lineNum">     992 </span>            :     mp_int p, q, d_p, d_q, qInv;
<span class="lineNum">     993 </span>            :     mp_int m1, m2, h, ctmp;
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;p) = 0;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;q) = 0;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d_p) = 0;</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d_q) = 0;</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;qInv) = 0;</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;m1) = 0;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;m2) = 0;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;h) = 0;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;ctmp) = 0;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;p));</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;q));</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d_p));</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d_q));</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;qInv));</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;m1));</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;m2));</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;h));</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;ctmp));</span>
<span class="lineNum">    1014 </span>            :     /* copy private key parameters into mp integers */
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;prime1, &amp;p);         /* p */</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;prime2, &amp;q);         /* q */</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;exponent1, &amp;d_p);    /* d_p  = d mod (p-1) */</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;exponent2, &amp;d_q);    /* d_q  = d mod (q-1) */</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;coefficient, &amp;qInv); /* qInv = q**-1 mod p */</span>
<span class="lineNum">    1020 </span>            :     /* 1. m1 = c**d_p mod p */
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(c, &amp;p, &amp;ctmp));</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_exptmod(&amp;ctmp, &amp;d_p, &amp;p, &amp;m1));</span>
<span class="lineNum">    1023 </span>            :     /* 2. m2 = c**d_q mod q */
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(c, &amp;q, &amp;ctmp));</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_exptmod(&amp;ctmp, &amp;d_q, &amp;q, &amp;m2));</span>
<span class="lineNum">    1026 </span>            :     /* 3.  h = (m1 - m2) * qInv mod p */
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_submod(&amp;m1, &amp;m2, &amp;p, &amp;h));</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;h, &amp;qInv, &amp;p, &amp;h));</span>
<span class="lineNum">    1029 </span>            :     /* 4.  m = m2 + h * q */
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mul(&amp;h, &amp;q, m));</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_add(m, &amp;m2, m));</span>
<span class="lineNum">    1032 </span>            : cleanup:
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     mp_clear(&amp;p);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     mp_clear(&amp;q);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d_p);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d_q);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     mp_clear(&amp;qInv);</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     mp_clear(&amp;m1);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     mp_clear(&amp;m2);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     mp_clear(&amp;h);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     mp_clear(&amp;ctmp);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1044 </span>            :         rv = SECFailure;
<span class="lineNum">    1045 </span>            :     }
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1047 </span>            : }
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            : /*
<span class="lineNum">    1050 </span>            : ** An attack against RSA CRT was described by Boneh, DeMillo, and Lipton in:
<span class="lineNum">    1051 </span>            : ** &quot;On the Importance of Eliminating Errors in Cryptographic Computations&quot;,
<span class="lineNum">    1052 </span>            : ** http://theory.stanford.edu/~dabo/papers/faults.ps.gz
<span class="lineNum">    1053 </span>            : **
<span class="lineNum">    1054 </span>            : ** As a defense against the attack, carry out the private key operation,
<span class="lineNum">    1055 </span>            : ** followed up with a public key operation to invert the result.
<span class="lineNum">    1056 </span>            : ** Verify that result against the input.
<a name="1057"><span class="lineNum">    1057 </span>            : */</a>
<span class="lineNum">    1058 </span>            : static SECStatus
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 : rsa_PrivateKeyOpCRTCheckedPubKey(RSAPrivateKey *key, mp_int *m, mp_int *c)</span>
<span class="lineNum">    1060 </span>            : {
<span class="lineNum">    1061 </span>            :     mp_int n, e, v;
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;e) = 0;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;v) = 0;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;e));</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;v));</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(rsa_PrivateKeyOpCRTNoCheck(key, m, c));</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;modulus, &amp;n);</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;publicExponent, &amp;e);</span>
<span class="lineNum">    1073 </span>            :     /* Perform a public key operation v = m ** e mod n */
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_exptmod(m, &amp;e, &amp;n, &amp;v));</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :     if (mp_cmp(&amp;v, c) != 0) {</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         rv = SECFailure;</span>
<span class="lineNum">    1077 </span>            :     }
<span class="lineNum">    1078 </span>            : cleanup:
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     mp_clear(&amp;e);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     mp_clear(&amp;v);</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1084 </span>            :         rv = SECFailure;
<span class="lineNum">    1085 </span>            :     }
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1087 </span>            : }
<span class="lineNum">    1088 </span>            : 
<a name="1089"><span class="lineNum">    1089 </span>            : static PRCallOnceType coBPInit = { 0, 0, 0 };</a>
<span class="lineNum">    1090 </span>            : static PRStatus
<span class="lineNum">    1091 </span><span class="lineCov">          3 : init_blinding_params_list(void)</span>
<span class="lineNum">    1092 </span>            : {
<span class="lineNum">    1093 </span><span class="lineCov">          3 :     blindingParamsList.lock = PZ_NewLock(nssILockOther);</span>
<span class="lineNum">    1094 </span><span class="lineCov">          3 :     if (!blindingParamsList.lock) {</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         return PR_FAILURE;</span>
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span><span class="lineCov">          3 :     blindingParamsList.cVar = PR_NewCondVar(blindingParamsList.lock);</span>
<span class="lineNum">    1099 </span><span class="lineCov">          3 :     if (!blindingParamsList.cVar) {</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         return PR_FAILURE;</span>
<span class="lineNum">    1102 </span>            :     }
<span class="lineNum">    1103 </span><span class="lineCov">          3 :     blindingParamsList.waitCount = 0;</span>
<span class="lineNum">    1104 </span><span class="lineCov">          3 :     PR_INIT_CLIST(&amp;blindingParamsList.head);</span>
<span class="lineNum">    1105 </span><span class="lineCov">          3 :     return PR_SUCCESS;</span>
<span class="lineNum">    1106 </span>            : }
<a name="1107"><span class="lineNum">    1107 </span>            : </a>
<span class="lineNum">    1108 </span>            : static SECStatus
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 : generate_blinding_params(RSAPrivateKey *key, mp_int *f, mp_int *g, mp_int *n,</span>
<span class="lineNum">    1110 </span>            :                          unsigned int modLen)
<span class="lineNum">    1111 </span>            : {
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">    1113 </span>            :     mp_int e, k;
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     unsigned char *kb = NULL;</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;e) = 0;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;k) = 0;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;e));</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;k));</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;publicExponent, &amp;e);</span>
<span class="lineNum">    1122 </span>            :     /* generate random k &lt; n */
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     kb = PORT_Alloc(modLen);</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     if (!kb) {</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         goto cleanup;</span>
<span class="lineNum">    1127 </span>            :     }
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     CHECK_SEC_OK(RNG_GenerateGlobalRandomBytes(kb, modLen));</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_read_unsigned_octets(&amp;k, kb, modLen));</span>
<span class="lineNum">    1130 </span>            :     /* k &lt; n */
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(&amp;k, n, &amp;k));</span>
<span class="lineNum">    1132 </span>            :     /* f = k**e mod n */
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_exptmod(&amp;k, &amp;e, n, f));</span>
<span class="lineNum">    1134 </span>            :     /* g = k**-1 mod n */
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_invmod(&amp;k, n, g));</span>
<span class="lineNum">    1136 </span>            : cleanup:
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     if (kb)</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :         PORT_ZFree(kb, modLen);</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     mp_clear(&amp;k);</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     mp_clear(&amp;e);</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1143 </span>            :         rv = SECFailure;
<span class="lineNum">    1144 </span>            :     }
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1146 </span>            : }
<a name="1147"><span class="lineNum">    1147 </span>            : </a>
<span class="lineNum">    1148 </span>            : static SECStatus
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 : init_blinding_params(RSABlindingParams *rsabp, RSAPrivateKey *key,</span>
<span class="lineNum">    1150 </span>            :                      mp_int *n, unsigned int modLen)
<span class="lineNum">    1151 </span>            : {
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     blindingParams *bp = rsabp-&gt;array;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     int i = 0;</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            :     /* Initialize the list pointer for the element */
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     PR_INIT_CLIST(&amp;rsabp-&gt;link);</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; RSA_BLINDING_PARAMS_MAX_CACHE_SIZE; ++i, ++bp) {</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         bp-&gt;next = bp + 1;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         MP_DIGITS(&amp;bp-&gt;f) = 0;</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         MP_DIGITS(&amp;bp-&gt;g) = 0;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :         bp-&gt;counter = 0;</span>
<span class="lineNum">    1162 </span>            :     }
<span class="lineNum">    1163 </span>            :     /* The last bp-&gt;next value was initialized with out
<span class="lineNum">    1164 </span>            :      * of rsabp-&gt;array pointer and must be set to NULL
<span class="lineNum">    1165 </span>            :      */
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :     rsabp-&gt;array[RSA_BLINDING_PARAMS_MAX_CACHE_SIZE - 1].next = NULL;</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     bp = rsabp-&gt;array;</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :     rsabp-&gt;bp = NULL;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     rsabp-&gt;free = bp;</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            :     /* List elements are keyed using the modulus */
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     return SECITEM_CopyItem(NULL, &amp;rsabp-&gt;modulus, &amp;key-&gt;modulus);</span>
<span class="lineNum">    1174 </span>            : }
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<span class="lineNum">    1176 </span>            : static SECStatus
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 : get_blinding_params(RSAPrivateKey *key, mp_int *n, unsigned int modLen,</span>
<span class="lineNum">    1178 </span>            :                     mp_int *f, mp_int *g)
<span class="lineNum">    1179 </span>            : {
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :     RSABlindingParams *rsabp = NULL;</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     blindingParams *bpUnlinked = NULL;</span>
<span class="lineNum">    1182 </span>            :     blindingParams *bp;
<span class="lineNum">    1183 </span>            :     PRCList *el;
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     int cmp = -1;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     PRBool holdingLock = PR_FALSE;</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :     do {
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :         if (blindingParamsList.lock == NULL) {</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :             PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :             return SECFailure;</span>
<span class="lineNum">    1193 </span>            :         }
<span class="lineNum">    1194 </span>            :         /* Acquire the list lock */
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         PZ_Lock(blindingParamsList.lock);</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :         holdingLock = PR_TRUE;</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :         /* Walk the list looking for the private key */
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :         for (el = PR_NEXT_LINK(&amp;blindingParamsList.head);</span>
<span class="lineNum">    1200 </span>            :              el != &amp;blindingParamsList.head;
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :              el = PR_NEXT_LINK(el)) {</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :             rsabp = (RSABlindingParams *)el;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :             cmp = SECITEM_CompareItem(&amp;rsabp-&gt;modulus, &amp;key-&gt;modulus);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :             if (cmp &gt;= 0) {</span>
<span class="lineNum">    1205 </span>            :                 /* The key is found or not in the list. */
<span class="lineNum">    1206 </span>            :                 break;
<span class="lineNum">    1207 </span>            :             }
<span class="lineNum">    1208 </span>            :         }
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         if (cmp) {</span>
<span class="lineNum">    1211 </span>            :             /* At this point, the key is not in the list.  el should point to
<span class="lineNum">    1212 </span>            :             ** the list element before which this key should be inserted.
<span class="lineNum">    1213 </span>            :             */
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :             rsabp = PORT_ZNew(RSABlindingParams);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :             if (!rsabp) {</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                 PORT_SetError(SEC_ERROR_NO_MEMORY);</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                 goto cleanup;</span>
<span class="lineNum">    1218 </span>            :             }
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :             rv = init_blinding_params(rsabp, key, n, modLen);</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :             if (rv != SECSuccess) {</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                 PORT_ZFree(rsabp, sizeof(RSABlindingParams));</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :                 goto cleanup;</span>
<span class="lineNum">    1224 </span>            :             }
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :             /* Insert the new element into the list
<span class="lineNum">    1227 </span>            :             ** If inserting in the middle of the list, el points to the link
<span class="lineNum">    1228 </span>            :             ** to insert before.  Otherwise, the link needs to be appended to
<span class="lineNum">    1229 </span>            :             ** the end of the list, which is the same as inserting before the
<span class="lineNum">    1230 </span>            :             ** head (since el would have looped back to the head).
<span class="lineNum">    1231 </span>            :             */
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :             PR_INSERT_BEFORE(&amp;rsabp-&gt;link, el);</span>
<span class="lineNum">    1233 </span>            :         }
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            :         /* We've found (or created) the RSAblindingParams struct for this key.
<span class="lineNum">    1236 </span>            :          * Now, search its list of ready blinding params for a usable one.
<span class="lineNum">    1237 </span>            :          */
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :         while (0 != (bp = rsabp-&gt;bp)) {</span>
<span class="lineNum">    1239 </span>            : #ifndef UNSAFE_FUZZER_MODE
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :             if (--(bp-&gt;counter) &gt; 0)</span>
<span class="lineNum">    1241 </span>            : #endif
<span class="lineNum">    1242 </span>            :             {
<span class="lineNum">    1243 </span>            :                 /* Found a match and there are still remaining uses left */
<span class="lineNum">    1244 </span>            :                 /* Return the parameters */
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                 CHECK_MPI_OK(mp_copy(&amp;bp-&gt;f, f));</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :                 CHECK_MPI_OK(mp_copy(&amp;bp-&gt;g, g));</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :                 PZ_Unlock(blindingParamsList.lock);</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :                 return SECSuccess;</span>
<span class="lineNum">    1250 </span>            :             }
<span class="lineNum">    1251 </span>            :             /* exhausted this one, give its values to caller, and
<span class="lineNum">    1252 </span>            :              * then retire it.
<span class="lineNum">    1253 </span>            :              */
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :             mp_exch(&amp;bp-&gt;f, f);</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :             mp_exch(&amp;bp-&gt;g, g);</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :             mp_clear(&amp;bp-&gt;f);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :             mp_clear(&amp;bp-&gt;g);</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :             bp-&gt;counter = 0;</span>
<span class="lineNum">    1259 </span>            :             /* Move to free list */
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :             rsabp-&gt;bp = bp-&gt;next;</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :             bp-&gt;next = rsabp-&gt;free;</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :             rsabp-&gt;free = bp;</span>
<span class="lineNum">    1263 </span>            :             /* In case there're threads waiting for new blinding
<span class="lineNum">    1264 </span>            :              * value - notify 1 thread the value is ready
<span class="lineNum">    1265 </span>            :              */
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :             if (blindingParamsList.waitCount &gt; 0) {</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :                 PR_NotifyCondVar(blindingParamsList.cVar);</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :                 blindingParamsList.waitCount--;</span>
<span class="lineNum">    1269 </span>            :             }
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :             PZ_Unlock(blindingParamsList.lock);</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :             return SECSuccess;</span>
<span class="lineNum">    1272 </span>            :         }
<span class="lineNum">    1273 </span>            :         /* We did not find a usable set of blinding params.  Can we make one? */
<span class="lineNum">    1274 </span>            :         /* Find a free bp struct. */
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :         if ((bp = rsabp-&gt;free) != NULL) {</span>
<span class="lineNum">    1276 </span>            :             /* unlink this bp */
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :             rsabp-&gt;free = bp-&gt;next;</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :             bp-&gt;next = NULL;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :             bpUnlinked = bp; /* In case we fail */</span>
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :             PZ_Unlock(blindingParamsList.lock);</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :             holdingLock = PR_FALSE;</span>
<span class="lineNum">    1283 </span>            :             /* generate blinding parameter values for the current thread */
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :             CHECK_SEC_OK(generate_blinding_params(key, f, g, n, modLen));</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            :             /* put the blinding parameter values into cache */
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(mp_init(&amp;bp-&gt;f));</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(mp_init(&amp;bp-&gt;g));</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(mp_copy(f, &amp;bp-&gt;f));</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :             CHECK_MPI_OK(mp_copy(g, &amp;bp-&gt;g));</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span>            :             /* Put this at head of queue of usable params. */
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :             PZ_Lock(blindingParamsList.lock);</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :             holdingLock = PR_TRUE;</span>
<span class="lineNum">    1295 </span>            :             (void)holdingLock;
<span class="lineNum">    1296 </span>            :             /* initialize RSABlindingParamsStr */
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :             bp-&gt;counter = RSA_BLINDING_PARAMS_MAX_REUSE;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :             bp-&gt;next = rsabp-&gt;bp;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :             rsabp-&gt;bp = bp;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :             bpUnlinked = NULL;</span>
<span class="lineNum">    1301 </span>            :             /* In case there're threads waiting for new blinding value
<span class="lineNum">    1302 </span>            :              * just notify them the value is ready
<span class="lineNum">    1303 </span>            :              */
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :             if (blindingParamsList.waitCount &gt; 0) {</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                 PR_NotifyAllCondVar(blindingParamsList.cVar);</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :                 blindingParamsList.waitCount = 0;</span>
<span class="lineNum">    1307 </span>            :             }
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :             PZ_Unlock(blindingParamsList.lock);</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :             return SECSuccess;</span>
<span class="lineNum">    1310 </span>            :         }
<span class="lineNum">    1311 </span>            :         /* Here, there are no usable blinding parameters available,
<span class="lineNum">    1312 </span>            :          * and no free bp blocks, presumably because they're all
<span class="lineNum">    1313 </span>            :          * actively having parameters generated for them.
<span class="lineNum">    1314 </span>            :          * So, we need to wait here and not eat up CPU until some
<span class="lineNum">    1315 </span>            :          * change happens.
<span class="lineNum">    1316 </span>            :          */
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         blindingParamsList.waitCount++;</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :         PR_WaitCondVar(blindingParamsList.cVar, PR_INTERVAL_NO_TIMEOUT);</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :         PZ_Unlock(blindingParamsList.lock);</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :         holdingLock = PR_FALSE;</span>
<span class="lineNum">    1321 </span>            :         (void)holdingLock;
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     } while (1);</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            : cleanup:
<span class="lineNum">    1325 </span>            :     /* It is possible to reach this after the lock is already released.  */
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     if (bpUnlinked) {</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :         if (!holdingLock) {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             PZ_Lock(blindingParamsList.lock);</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :             holdingLock = PR_TRUE;</span>
<span class="lineNum">    1330 </span>            :         }
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :         bp = bpUnlinked;</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         mp_clear(&amp;bp-&gt;f);</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :         mp_clear(&amp;bp-&gt;g);</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :         bp-&gt;counter = 0;</span>
<span class="lineNum">    1335 </span>            :         /* Must put the unlinked bp back on the free list */
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :         bp-&gt;next = rsabp-&gt;free;</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :         rsabp-&gt;free = bp;</span>
<span class="lineNum">    1338 </span>            :     }
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :     if (holdingLock) {</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         PZ_Unlock(blindingParamsList.lock);</span>
<span class="lineNum">    1341 </span>            :     }
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1344 </span>            :     }
<span class="lineNum">    1345 </span>            :     return SECFailure;
<span class="lineNum">    1346 </span>            : }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            : /*
<span class="lineNum">    1349 </span>            : ** Perform a raw private-key operation
<span class="lineNum">    1350 </span>            : **  Length of input and output buffers are equal to key's modulus len.
<a name="1351"><span class="lineNum">    1351 </span>            : */</a>
<span class="lineNum">    1352 </span>            : static SECStatus
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 : rsa_PrivateKeyOp(RSAPrivateKey *key,</span>
<span class="lineNum">    1354 </span>            :                  unsigned char *output,
<span class="lineNum">    1355 </span>            :                  const unsigned char *input,
<span class="lineNum">    1356 </span>            :                  PRBool check)
<span class="lineNum">    1357 </span>            : {
<span class="lineNum">    1358 </span>            :     unsigned int modLen;
<span class="lineNum">    1359 </span>            :     unsigned int offset;
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">    1361 </span>            :     mp_err err;
<span class="lineNum">    1362 </span>            :     mp_int n, c, m;
<span class="lineNum">    1363 </span>            :     mp_int f, g;
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :     if (!key || !output || !input) {</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">    1367 </span>            :     }
<span class="lineNum">    1368 </span>            :     /* check input out of range (needs to be in range [0..n-1]) */
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     modLen = rsa_modulusLen(&amp;key-&gt;modulus);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :     offset = (key-&gt;modulus.data[0] == 0) ? 1 : 0; /* may be leading 0 */</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     if (memcmp(input, key-&gt;modulus.data + offset, modLen) &gt;= 0) {</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_INVALID_ARGS);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">    1374 </span>            :     }
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;c) = 0;</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;m) = 0;</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;f) = 0;</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;g) = 0;</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;c));</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;m));</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;f));</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;g));</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;modulus, &amp;n);</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     OCTETS_TO_MPINT(input, &amp;c, modLen);</span>
<span class="lineNum">    1387 </span>            :     /* If blinding, compute pre-image of ciphertext by multiplying by
<span class="lineNum">    1388 </span>            :     ** blinding factor
<span class="lineNum">    1389 </span>            :     */
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     if (nssRSAUseBlinding) {</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(get_blinding_params(key, &amp;n, modLen, &amp;f, &amp;g));</span>
<span class="lineNum">    1392 </span>            :         /* c' = c*f mod n */
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_mulmod(&amp;c, &amp;f, &amp;n, &amp;c));</span>
<span class="lineNum">    1394 </span>            :     }
<span class="lineNum">    1395 </span>            :     /* Do the private key operation m = c**d mod n */
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     if (key-&gt;prime1.len == 0 ||</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         key-&gt;prime2.len == 0 ||</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         key-&gt;exponent1.len == 0 ||</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         key-&gt;exponent2.len == 0 ||</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         key-&gt;coefficient.len == 0) {</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(rsa_PrivateKeyOpNoCRT(key, &amp;m, &amp;c, &amp;n, modLen));</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :     } else if (check) {</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(rsa_PrivateKeyOpCRTCheckedPubKey(key, &amp;m, &amp;c));</span>
<span class="lineNum">    1404 </span>            :     } else {
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         CHECK_SEC_OK(rsa_PrivateKeyOpCRTNoCheck(key, &amp;m, &amp;c));</span>
<span class="lineNum">    1406 </span>            :     }
<span class="lineNum">    1407 </span>            :     /* If blinding, compute post-image of plaintext by multiplying by
<span class="lineNum">    1408 </span>            :     ** blinding factor
<span class="lineNum">    1409 </span>            :     */
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     if (nssRSAUseBlinding) {</span>
<span class="lineNum">    1411 </span>            :         /* m = m'*g mod n */
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :         CHECK_MPI_OK(mp_mulmod(&amp;m, &amp;g, &amp;n, &amp;m));</span>
<span class="lineNum">    1413 </span>            :     }
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     err = mp_to_fixlen_octets(&amp;m, output, modLen);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     if (err &gt;= 0)</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :         err = MP_OKAY;</span>
<span class="lineNum">    1417 </span>            : cleanup:
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     mp_clear(&amp;c);</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     mp_clear(&amp;m);</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     mp_clear(&amp;f);</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     mp_clear(&amp;g);</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1425 </span>            :         rv = SECFailure;
<span class="lineNum">    1426 </span>            :     }
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1428 </span>            : }
<a name="1429"><span class="lineNum">    1429 </span>            : </a>
<span class="lineNum">    1430 </span>            : SECStatus
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 : RSA_PrivateKeyOp(RSAPrivateKey *key,</span>
<span class="lineNum">    1432 </span>            :                  unsigned char *output,
<span class="lineNum">    1433 </span>            :                  const unsigned char *input)
<span class="lineNum">    1434 </span>            : {
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     return rsa_PrivateKeyOp(key, output, input, PR_FALSE);</span>
<span class="lineNum">    1436 </span>            : }
<a name="1437"><span class="lineNum">    1437 </span>            : </a>
<span class="lineNum">    1438 </span>            : SECStatus
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 : RSA_PrivateKeyOpDoubleChecked(RSAPrivateKey *key,</span>
<span class="lineNum">    1440 </span>            :                               unsigned char *output,
<span class="lineNum">    1441 </span>            :                               const unsigned char *input)
<span class="lineNum">    1442 </span>            : {
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     return rsa_PrivateKeyOp(key, output, input, PR_TRUE);</span>
<span class="lineNum">    1444 </span>            : }
<a name="1445"><span class="lineNum">    1445 </span>            : </a>
<span class="lineNum">    1446 </span>            : SECStatus
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 : RSA_PrivateKeyCheck(const RSAPrivateKey *key)</span>
<span class="lineNum">    1448 </span>            : {
<span class="lineNum">    1449 </span>            :     mp_int p, q, n, psub1, qsub1, e, d, d_p, d_q, qInv, res;
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :     mp_err err = MP_OKAY;</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :     SECStatus rv = SECSuccess;</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;p) = 0;</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;q) = 0;</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;n) = 0;</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;psub1) = 0;</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;qsub1) = 0;</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;e) = 0;</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d) = 0;</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d_p) = 0;</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;d_q) = 0;</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;qInv) = 0;</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :     MP_DIGITS(&amp;res) = 0;</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;p));</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;q));</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;n));</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;psub1));</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;qsub1));</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;e));</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d));</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d_p));</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;d_q));</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;qInv));</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_init(&amp;res));</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     if (!key-&gt;modulus.data || !key-&gt;prime1.data || !key-&gt;prime2.data ||</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :         !key-&gt;publicExponent.data || !key-&gt;privateExponent.data ||</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :         !key-&gt;exponent1.data || !key-&gt;exponent2.data ||</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         !key-&gt;coefficient.data) {</span>
<span class="lineNum">    1479 </span>            :         /* call RSA_PopulatePrivateKey first, if the application wishes to
<span class="lineNum">    1480 </span>            :          * recover these parameters */
<span class="lineNum">    1481 </span>            :         err = MP_BADARG;
<span class="lineNum">    1482 </span>            :         goto cleanup;
<span class="lineNum">    1483 </span>            :     }
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;modulus, &amp;n);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;prime1, &amp;p);</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;prime2, &amp;q);</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;publicExponent, &amp;e);</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;privateExponent, &amp;d);</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;exponent1, &amp;d_p);</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;exponent2, &amp;d_q);</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     SECITEM_TO_MPINT(key-&gt;coefficient, &amp;qInv);</span>
<span class="lineNum">    1493 </span>            :     /* p and q must be distinct. */
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :     if (mp_cmp(&amp;p, &amp;q) == 0) {</span>
<span class="lineNum">    1495 </span>            :         rv = SECFailure;
<span class="lineNum">    1496 </span>            :         goto cleanup;
<span class="lineNum">    1497 </span>            :     }
<span class="lineNum">    1498 </span>            : #define VERIFY_MPI_EQUAL(m1, m2) \
<span class="lineNum">    1499 </span>            :     if (mp_cmp(m1, m2) != 0) {   \
<span class="lineNum">    1500 </span>            :         rv = SECFailure;         \
<span class="lineNum">    1501 </span>            :         goto cleanup;            \
<span class="lineNum">    1502 </span>            :     }
<span class="lineNum">    1503 </span>            : #define VERIFY_MPI_EQUAL_1(m)  \
<span class="lineNum">    1504 </span>            :     if (mp_cmp_d(m, 1) != 0) { \
<span class="lineNum">    1505 </span>            :         rv = SECFailure;       \
<span class="lineNum">    1506 </span>            :         goto cleanup;          \
<span class="lineNum">    1507 </span>            :     }
<span class="lineNum">    1508 </span>            :     /* n == p * q */
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mul(&amp;p, &amp;q, &amp;res));</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL(&amp;res, &amp;n);</span>
<span class="lineNum">    1511 </span>            :     /* gcd(e, p-1) == 1 */
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(&amp;p, 1, &amp;psub1));</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_gcd(&amp;e, &amp;psub1, &amp;res));</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL_1(&amp;res);</span>
<span class="lineNum">    1515 </span>            :     /* gcd(e, q-1) == 1 */
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_sub_d(&amp;q, 1, &amp;qsub1));</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_gcd(&amp;e, &amp;qsub1, &amp;res));</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL_1(&amp;res);</span>
<span class="lineNum">    1519 </span>            :     /* d*e == 1 mod p-1 */
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;d, &amp;e, &amp;psub1, &amp;res));</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL_1(&amp;res);</span>
<span class="lineNum">    1522 </span>            :     /* d*e == 1 mod q-1 */
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;d, &amp;e, &amp;qsub1, &amp;res));</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL_1(&amp;res);</span>
<span class="lineNum">    1525 </span>            :     /* d_p == d mod p-1 */
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(&amp;d, &amp;psub1, &amp;res));</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL(&amp;res, &amp;d_p);</span>
<span class="lineNum">    1528 </span>            :     /* d_q == d mod q-1 */
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mod(&amp;d, &amp;qsub1, &amp;res));</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL(&amp;res, &amp;d_q);</span>
<span class="lineNum">    1531 </span>            :     /* q * q**-1 == 1 mod p */
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     CHECK_MPI_OK(mp_mulmod(&amp;q, &amp;qInv, &amp;p, &amp;res));</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :     VERIFY_MPI_EQUAL_1(&amp;res);</span>
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            : cleanup:
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     mp_clear(&amp;n);</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     mp_clear(&amp;p);</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     mp_clear(&amp;q);</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     mp_clear(&amp;psub1);</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     mp_clear(&amp;qsub1);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     mp_clear(&amp;e);</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d);</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d_p);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :     mp_clear(&amp;d_q);</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :     mp_clear(&amp;qInv);</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     mp_clear(&amp;res);</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :     if (err) {</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :         MP_TO_SEC_ERROR(err);</span>
<span class="lineNum">    1549 </span>            :         rv = SECFailure;
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1552 </span>            : }
<a name="1553"><span class="lineNum">    1553 </span>            : </a>
<span class="lineNum">    1554 </span>            : static SECStatus
<span class="lineNum">    1555 </span><span class="lineCov">          3 : RSA_Init(void)</span>
<span class="lineNum">    1556 </span>            : {
<span class="lineNum">    1557 </span><span class="lineCov">          3 :     if (PR_CallOnce(&amp;coBPInit, init_blinding_params_list) != PR_SUCCESS) {</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :         PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         return SECFailure;</span>
<span class="lineNum">    1560 </span>            :     }
<span class="lineNum">    1561 </span>            :     return SECSuccess;
<span class="lineNum">    1562 </span>            : }
<a name="1563"><span class="lineNum">    1563 </span>            : </a>
<span class="lineNum">    1564 </span>            : SECStatus
<span class="lineNum">    1565 </span><span class="lineCov">          3 : BL_Init(void)</span>
<span class="lineNum">    1566 </span>            : {
<span class="lineNum">    1567 </span><span class="lineCov">          3 :     return RSA_Init();</span>
<span class="lineNum">    1568 </span>            : }
<span class="lineNum">    1569 </span>            : 
<a name="1570"><span class="lineNum">    1570 </span>            : /* cleanup at shutdown */</a>
<span class="lineNum">    1571 </span>            : void
<span class="lineNum">    1572 </span><span class="lineCov">          3 : RSA_Cleanup(void)</span>
<span class="lineNum">    1573 </span>            : {
<span class="lineNum">    1574 </span><span class="lineCov">          3 :     blindingParams *bp = NULL;</span>
<span class="lineNum">    1575 </span><span class="lineCov">          3 :     if (!coBPInit.initialized)</span>
<span class="lineNum">    1576 </span><span class="lineCov">          3 :         return;</span>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineCov">          3 :     while (!PR_CLIST_IS_EMPTY(&amp;blindingParamsList.head)) {</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :         RSABlindingParams *rsabp =</span>
<span class="lineNum">    1580 </span>            :             (RSABlindingParams *)PR_LIST_HEAD(&amp;blindingParamsList.head);
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :         PR_REMOVE_LINK(&amp;rsabp-&gt;link);</span>
<span class="lineNum">    1582 </span>            :         /* clear parameters cache */
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :         while (rsabp-&gt;bp != NULL) {</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :             bp = rsabp-&gt;bp;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :             rsabp-&gt;bp = rsabp-&gt;bp-&gt;next;</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :             mp_clear(&amp;bp-&gt;f);</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :             mp_clear(&amp;bp-&gt;g);</span>
<span class="lineNum">    1588 </span>            :         }
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :         SECITEM_FreeItem(&amp;rsabp-&gt;modulus, PR_FALSE);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :         PORT_Free(rsabp);</span>
<span class="lineNum">    1591 </span>            :     }
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineCov">          3 :     if (blindingParamsList.cVar) {</span>
<span class="lineNum">    1594 </span><span class="lineCov">          3 :         PR_DestroyCondVar(blindingParamsList.cVar);</span>
<span class="lineNum">    1595 </span><span class="lineCov">          3 :         blindingParamsList.cVar = NULL;</span>
<span class="lineNum">    1596 </span>            :     }
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">          3 :     if (blindingParamsList.lock) {</span>
<span class="lineNum">    1599 </span><span class="lineCov">          3 :         SKIP_AFTER_FORK(PZ_DestroyLock(blindingParamsList.lock));</span>
<span class="lineNum">    1600 </span><span class="lineCov">          3 :         blindingParamsList.lock = NULL;</span>
<span class="lineNum">    1601 </span>            :     }
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineCov">          3 :     coBPInit.initialized = 0;</span>
<span class="lineNum">    1604 </span><span class="lineCov">          3 :     coBPInit.inProgress = 0;</span>
<span class="lineNum">    1605 </span><span class="lineCov">          3 :     coBPInit.status = 0;</span>
<span class="lineNum">    1606 </span>            : }
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            : /*
<span class="lineNum">    1609 </span>            :  * need a central place for this function to free up all the memory that
<span class="lineNum">    1610 </span>            :  * free_bl may have allocated along the way. Currently only RSA does this,
<span class="lineNum">    1611 </span>            :  * so I've put it here for now.
<a name="1612"><span class="lineNum">    1612 </span>            :  */</a>
<span class="lineNum">    1613 </span>            : void
<span class="lineNum">    1614 </span><span class="lineCov">          3 : BL_Cleanup(void)</span>
<span class="lineNum">    1615 </span>            : {
<span class="lineNum">    1616 </span><span class="lineCov">          3 :     RSA_Cleanup();</span>
<span class="lineNum">    1617 </span><span class="lineCov">          3 : }</span>
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            : PRBool bl_parentForkedAfterC_Initialize;
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            : /*
<span class="lineNum">    1622 </span>            :  * Set fork flag so it can be tested in SKIP_AFTER_FORK on relevant platforms.
<a name="1623"><span class="lineNum">    1623 </span>            :  */</a>
<span class="lineNum">    1624 </span>            : void
<span class="lineNum">    1625 </span><span class="lineCov">          6 : BL_SetForkState(PRBool forked)</span>
<span class="lineNum">    1626 </span>            : {
<span class="lineNum">    1627 </span><span class="lineCov">          6 :     bl_parentForkedAfterC_Initialize = forked;</span>
<span class="lineNum">    1628 </span><span class="lineCov">          6 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
