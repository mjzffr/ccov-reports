<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mochitest-e10s.info - obj-firefox/dist/include/MediaResource.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">obj-firefox/dist/include</a> - MediaResource.h<span style="font-size: 80%;"> (source / <a href="MediaResource.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mochitest-e10s.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">54</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-04-21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* vim:set ts=2 sw=2 sts=2 et cindent: */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #if !defined(MediaResource_h_)
<span class="lineNum">       7 </span>            : #define MediaResource_h_
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/Mutex.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsIChannel.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsIURI.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsISeekableStream.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsIStreamingProtocolController.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsIStreamListener.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsIChannelEventSink.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsIInterfaceRequestor.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;Intervals.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;MediaCache.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;MediaContainerType.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;MediaData.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;MediaResourceCallback.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;mozilla/Atomics.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mozilla/TimeStamp.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsThreadUtils.h&quot;
<span class="lineNum">      26 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : // For HTTP seeking, if number of bytes needing to be
<span class="lineNum">      29 </span>            : // seeked forward is less than this value then a read is
<span class="lineNum">      30 </span>            : // done rather than a byte range request.
<span class="lineNum">      31 </span>            : //
<span class="lineNum">      32 </span>            : // If we assume a 100Mbit connection, and assume reissuing an HTTP seek causes
<span class="lineNum">      33 </span>            : // a delay of 200ms, then in that 200ms we could have simply read ahead 2MB. So
<span class="lineNum">      34 </span>            : // setting SEEK_VS_READ_THRESHOLD to 1MB sounds reasonable.
<span class="lineNum">      35 </span>            : static const int64_t SEEK_VS_READ_THRESHOLD = 1 * 1024 * 1024;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : static const uint32_t HTTP_REQUESTED_RANGE_NOT_SATISFIABLE_CODE = 416;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // Number of bytes we have accumulated before we assume the connection download
<span class="lineNum">      40 </span>            : // rate can be reliably calculated. 57 Segments at IW=3 allows slow start to
<span class="lineNum">      41 </span>            : // reach a CWND of 30 (See bug 831998)
<span class="lineNum">      42 </span>            : static const int64_t RELIABLE_DATA_THRESHOLD = 57 * 1460;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : class nsIHttpChannel;
<span class="lineNum">      45 </span>            : class nsIPrincipal;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : namespace mozilla {
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : class MediaChannelStatistics;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /**
<span class="lineNum">      52 </span>            :  * This class is useful for estimating rates of data passing through
<span class="lineNum">      53 </span>            :  * some channel. The idea is that activity on the channel &quot;starts&quot;
<span class="lineNum">      54 </span>            :  * and &quot;stops&quot; over time. At certain times data passes through the
<span class="lineNum">      55 </span>            :  * channel (usually while the channel is active; data passing through
<span class="lineNum">      56 </span>            :  * an inactive channel is ignored). The GetRate() function computes
<span class="lineNum">      57 </span>            :  * an estimate of the &quot;current rate&quot; of the channel, which is some
<span class="lineNum">      58 </span>            :  * kind of average of the data passing through over the time the
<span class="lineNum">      59 </span>            :  * channel is active.
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  * All methods take &quot;now&quot; as a parameter so the user of this class can
<span class="lineNum">      62 </span>            :  * control the timeline used.
<span class="lineNum">      63 </span>            :  */
<span class="lineNum">      64 </span>            : class MediaChannelStatistics {
<span class="lineNum">      65 </span>            : public:
<span class="lineNum">      66 </span>            :   MediaChannelStatistics()
<span class="lineNum">      67 </span>            :     : mAccumulatedBytes(0)
<span class="lineNum">      68 </span>            :     , mIsStarted(false)
<span class="lineNum">      69 </span>            :   {
<span class="lineNum">      70 </span>            :     Reset();
<span class="lineNum">      71 </span>            :   }
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :   explicit MediaChannelStatistics(MediaChannelStatistics * aCopyFrom)
<span class="lineNum">      74 </span>            :   {
<span class="lineNum">      75 </span>            :     MOZ_ASSERT(aCopyFrom);
<span class="lineNum">      76 </span>            :     mAccumulatedBytes = aCopyFrom-&gt;mAccumulatedBytes;
<span class="lineNum">      77 </span>            :     mAccumulatedTime = aCopyFrom-&gt;mAccumulatedTime;
<span class="lineNum">      78 </span>            :     mLastStartTime = aCopyFrom-&gt;mLastStartTime;
<span class="lineNum">      79 </span>            :     mIsStarted = aCopyFrom-&gt;mIsStarted;
<span class="lineNum">      80 </span>            :   }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(MediaChannelStatistics)
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :   void Reset() {
<span class="lineNum">      85 </span>            :     mLastStartTime = TimeStamp();
<span class="lineNum">      86 </span>            :     mAccumulatedTime = TimeDuration(0);
<span class="lineNum">      87 </span>            :     mAccumulatedBytes = 0;
<span class="lineNum">      88 </span>            :     mIsStarted = false;
<span class="lineNum">      89 </span>            :   }
<span class="lineNum">      90 </span>            :   void Start() {
<span class="lineNum">      91 </span>            :     if (mIsStarted)
<span class="lineNum">      92 </span>            :       return;
<span class="lineNum">      93 </span>            :     mLastStartTime = TimeStamp::Now();
<span class="lineNum">      94 </span>            :     mIsStarted = true;
<span class="lineNum">      95 </span>            :   }
<span class="lineNum">      96 </span>            :   void Stop() {
<span class="lineNum">      97 </span>            :     if (!mIsStarted)
<span class="lineNum">      98 </span>            :       return;
<span class="lineNum">      99 </span>            :     mAccumulatedTime += TimeStamp::Now() - mLastStartTime;
<span class="lineNum">     100 </span>            :     mIsStarted = false;
<span class="lineNum">     101 </span>            :   }
<span class="lineNum">     102 </span>            :   void AddBytes(int64_t aBytes) {
<span class="lineNum">     103 </span>            :     if (!mIsStarted) {
<span class="lineNum">     104 </span>            :       // ignore this data, it may be related to seeking or some other
<span class="lineNum">     105 </span>            :       // operation we don't care about
<span class="lineNum">     106 </span>            :       return;
<span class="lineNum">     107 </span>            :     }
<span class="lineNum">     108 </span>            :     mAccumulatedBytes += aBytes;
<span class="lineNum">     109 </span>            :   }
<span class="lineNum">     110 </span>            :   double GetRateAtLastStop(bool* aReliable) {
<span class="lineNum">     111 </span>            :     double seconds = mAccumulatedTime.ToSeconds();
<span class="lineNum">     112 </span>            :     *aReliable = (seconds &gt;= 1.0) ||
<span class="lineNum">     113 </span>            :                  (mAccumulatedBytes &gt;= RELIABLE_DATA_THRESHOLD);
<span class="lineNum">     114 </span>            :     if (seconds &lt;= 0.0)
<span class="lineNum">     115 </span>            :       return 0.0;
<span class="lineNum">     116 </span>            :     return static_cast&lt;double&gt;(mAccumulatedBytes)/seconds;
<span class="lineNum">     117 </span>            :   }
<span class="lineNum">     118 </span>            :   double GetRate(bool* aReliable) {
<span class="lineNum">     119 </span>            :     TimeDuration time = mAccumulatedTime;
<span class="lineNum">     120 </span>            :     if (mIsStarted) {
<span class="lineNum">     121 </span>            :       time += TimeStamp::Now() - mLastStartTime;
<span class="lineNum">     122 </span>            :     }
<span class="lineNum">     123 </span>            :     double seconds = time.ToSeconds();
<span class="lineNum">     124 </span>            :     *aReliable = (seconds &gt;= 3.0) ||
<span class="lineNum">     125 </span>            :                  (mAccumulatedBytes &gt;= RELIABLE_DATA_THRESHOLD);
<span class="lineNum">     126 </span>            :     if (seconds &lt;= 0.0)
<span class="lineNum">     127 </span>            :       return 0.0;
<span class="lineNum">     128 </span>            :     return static_cast&lt;double&gt;(mAccumulatedBytes)/seconds;
<span class="lineNum">     129 </span>            :   }
<span class="lineNum">     130 </span>            : private:
<span class="lineNum">     131 </span>            :   ~MediaChannelStatistics() {}
<span class="lineNum">     132 </span>            :   int64_t      mAccumulatedBytes;
<span class="lineNum">     133 </span>            :   TimeDuration mAccumulatedTime;
<span class="lineNum">     134 </span>            :   TimeStamp    mLastStartTime;
<span class="lineNum">     135 </span>            :   bool         mIsStarted;
<span class="lineNum">     136 </span>            : };
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : // Represents a section of contiguous media, with a start and end offset.
<span class="lineNum">     139 </span>            : // Used to denote ranges of data which are cached.
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : typedef media::Interval&lt;int64_t&gt; MediaByteRange;
<span class="lineNum">     142 </span>            : typedef media::IntervalSet&lt;int64_t&gt; MediaByteRangeSet;
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /**
<span class="lineNum">     145 </span>            :  * Provides a thread-safe, seek/read interface to resources
<span class="lineNum">     146 </span>            :  * loaded from a URI. Uses MediaCache to cache data received over
<span class="lineNum">     147 </span>            :  * Necko's async channel API, thus resolving the mismatch between clients
<span class="lineNum">     148 </span>            :  * that need efficient random access to the data and protocols that do not
<span class="lineNum">     149 </span>            :  * support efficient random access, such as HTTP.
<span class="lineNum">     150 </span>            :  *
<span class="lineNum">     151 </span>            :  * Instances of this class must be created on the main thread.
<span class="lineNum">     152 </span>            :  * Most methods must be called on the main thread only. Read, Seek and
<span class="lineNum">     153 </span>            :  * Tell must only be called on non-main threads. In the case of the Ogg
<span class="lineNum">     154 </span>            :  * Decoder they are called on the Decode thread for example. You must
<span class="lineNum">     155 </span>            :  * ensure that no threads are calling these methods once Close is called.
<span class="lineNum">     156 </span>            :  *
<span class="lineNum">     157 </span>            :  * Instances of this class are reference counted. Use nsRefPtr for
<span class="lineNum">     158 </span>            :  * managing the lifetime of instances of this class.
<span class="lineNum">     159 </span>            :  *
<span class="lineNum">     160 </span>            :  * The generic implementation of this class is ChannelMediaResource, which can
<span class="lineNum">     161 </span>            :  * handle any URI for which Necko supports AsyncOpen.
<span class="lineNum">     162 </span>            :  * The 'file:' protocol can be implemented efficiently with direct random
<span class="lineNum">     163 </span>            :  * access, so the FileMediaResource implementation class bypasses the cache.
<span class="lineNum">     164 </span>            :  * MediaResource::Create automatically chooses the best implementation class.
<span class="lineNum">     165 </span>            :  */
<span class="lineNum">     166 </span><span class="lineNoCov">          0 : class MediaResource : public nsISupports</span>
<span class="lineNum">     167 </span>            : {
<span class="lineNum">     168 </span>            : public:
<span class="lineNum">     169 </span>            :   // Our refcounting is threadsafe, and when our refcount drops to zero
<span class="lineNum">     170 </span>            :   // we dispatch an event to the main thread to delete the MediaResource.
<span class="lineNum">     171 </span>            :   // Note that this means it's safe for references to this object to be
<span class="lineNum">     172 </span>            :   // released on a non main thread, but the destructor will always run on
<span class="lineNum">     173 </span>            :   // the main thread.
<span class="lineNum">     174 </span>            :   NS_DECL_THREADSAFE_ISUPPORTS
<span class="lineNum">     175 </span>            : 
<a name="176"><span class="lineNum">     176 </span>            :   // The following can be called on the main thread only:</a>
<span class="lineNum">     177 </span>            :   // Get the URI
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   virtual nsIURI* URI() const { return nullptr; }</span>
<span class="lineNum">     179 </span>            :   // Close the resource, stop any listeners, channels, etc.
<span class="lineNum">     180 </span>            :   // Cancels any currently blocking Read request and forces that request to
<span class="lineNum">     181 </span>            :   // return an error.
<span class="lineNum">     182 </span>            :   virtual nsresult Close() = 0;
<span class="lineNum">     183 </span>            :   // Suspend any downloads that are in progress.
<span class="lineNum">     184 </span>            :   // If aCloseImmediately is set, resources should be released immediately
<span class="lineNum">     185 </span>            :   // since we don't expect to resume again any time soon. Otherwise we
<span class="lineNum">     186 </span>            :   // may resume again soon so resources should be held for a little
<span class="lineNum">     187 </span>            :   // while.
<span class="lineNum">     188 </span>            :   virtual void Suspend(bool aCloseImmediately) = 0;
<span class="lineNum">     189 </span>            :   // Resume any downloads that have been suspended.
<span class="lineNum">     190 </span>            :   virtual void Resume() = 0;
<span class="lineNum">     191 </span>            :   // Get the current principal for the channel
<span class="lineNum">     192 </span>            :   virtual already_AddRefed&lt;nsIPrincipal&gt; GetCurrentPrincipal() = 0;
<span class="lineNum">     193 </span>            :   // If this returns false, then we shouldn't try to clone this MediaResource
<span class="lineNum">     194 </span>            :   // because its underlying resources are not suitable for reuse (e.g.
<span class="lineNum">     195 </span>            :   // because the underlying connection has been lost, or this resource
<a name="196"><span class="lineNum">     196 </span>            :   // just can't be safely cloned). If this returns true, CloneData could</a>
<span class="lineNum">     197 </span>            :   // still fail. If this returns false, CloneData should not be called.
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   virtual bool CanClone() { return false; }</span>
<span class="lineNum">     199 </span>            :   // Create a new stream of the same type that refers to the same URI
<span class="lineNum">     200 </span>            :   // with a new channel. Any cached data associated with the original
<span class="lineNum">     201 </span>            :   // stream should be accessible in the new stream too.
<a name="202"><span class="lineNum">     202 </span>            :   virtual already_AddRefed&lt;MediaResource&gt; CloneData(MediaResourceCallback* aCallback) = 0;</a>
<span class="lineNum">     203 </span>            :   // Set statistics to be recorded to the object passed in.
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   virtual void RecordStatisticsTo(MediaChannelStatistics *aStatistics) { }</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   // These methods are called off the main thread.
<span class="lineNum">     207 </span>            :   // The mode is initially MODE_PLAYBACK.
<span class="lineNum">     208 </span>            :   virtual void SetReadMode(MediaCacheStream::ReadMode aMode) = 0;
<span class="lineNum">     209 </span>            :   // This is the client's estimate of the playback rate assuming
<span class="lineNum">     210 </span>            :   // the media plays continuously. The cache can't guess this itself
<span class="lineNum">     211 </span>            :   // because it doesn't know when the decoder was paused, buffering, etc.
<span class="lineNum">     212 </span>            :   virtual void SetPlaybackRate(uint32_t aBytesPerSecond) = 0;
<span class="lineNum">     213 </span>            :   // Read up to aCount bytes from the stream. The read starts at
<span class="lineNum">     214 </span>            :   // aOffset in the stream, seeking to that location initially if
<span class="lineNum">     215 </span>            :   // it is not the current stream offset. The remaining arguments,
<span class="lineNum">     216 </span>            :   // results and requirements are the same as per the Read method.
<span class="lineNum">     217 </span>            :   virtual nsresult ReadAt(int64_t aOffset, char* aBuffer,
<span class="lineNum">     218 </span>            :                           uint32_t aCount, uint32_t* aBytes) = 0;
<span class="lineNum">     219 </span>            :   // This method returns nullptr if anything fails.
<span class="lineNum">     220 </span>            :   // Otherwise, it returns an owned buffer.
<span class="lineNum">     221 </span>            :   // MediaReadAt may return fewer bytes than requested if end of stream is
<span class="lineNum">     222 </span>            :   // encountered. There is no need to call it again to get more data.
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   virtual already_AddRefed&lt;MediaByteBuffer&gt; MediaReadAt(int64_t aOffset, uint32_t aCount)</span>
<span class="lineNum">     224 </span>            :   {
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     RefPtr&lt;MediaByteBuffer&gt; bytes = new MediaByteBuffer();</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     bool ok = bytes-&gt;SetLength(aCount, fallible);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(ok, nullptr);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     char* curr = reinterpret_cast&lt;char*&gt;(bytes-&gt;Elements());</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     const char* start = curr;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     while (aCount &gt; 0) {</span>
<span class="lineNum">     231 </span>            :       uint32_t bytesRead;
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       nsresult rv = ReadAt(aOffset, curr, aCount, &amp;bytesRead);</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :       NS_ENSURE_SUCCESS(rv, nullptr);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       if (!bytesRead) {</span>
<span class="lineNum">     235 </span>            :         break;
<span class="lineNum">     236 </span>            :       }
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       aOffset += bytesRead;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       aCount -= bytesRead;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :       curr += bytesRead;</span>
<span class="lineNum">     240 </span>            :     }
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     bytes-&gt;SetLength(curr - start);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     return bytes.forget();</span>
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   // Report the current offset in bytes from the start of the stream.
<span class="lineNum">     246 </span>            :   // This is used to approximate where we currently are in the playback of a
<span class="lineNum">     247 </span>            :   // media.
<span class="lineNum">     248 </span>            :   // A call to ReadAt will update this position.
<span class="lineNum">     249 </span>            :   virtual int64_t Tell() = 0;
<span class="lineNum">     250 </span>            :   // Moves any existing channel loads into or out of background. Background
<a name="251"><span class="lineNum">     251 </span>            :   // loads don't block the load event. This also determines whether or not any</a>
<span class="lineNum">     252 </span>            :   // new loads initiated (for example to seek) will be in the background.
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   virtual void SetLoadInBackground(bool aLoadInBackground) {}</span>
<a name="254"><span class="lineNum">     254 </span>            :   // Ensures that the value returned by IsSuspendedByCache below is up to date</a>
<span class="lineNum">     255 </span>            :   // (i.e. the cache has examined this stream at least once).
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   virtual void EnsureCacheUpToDate() {}</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :   // These can be called on any thread.
<span class="lineNum">     259 </span>            :   // Cached blocks associated with this stream will not be evicted
<span class="lineNum">     260 </span>            :   // while the stream is pinned.
<span class="lineNum">     261 </span>            :   virtual void Pin() = 0;
<span class="lineNum">     262 </span>            :   virtual void Unpin() = 0;
<span class="lineNum">     263 </span>            :   // Get the estimated download rate in bytes per second (assuming no
<span class="lineNum">     264 </span>            :   // pausing of the channel is requested by Gecko).
<span class="lineNum">     265 </span>            :   // *aIsReliable is set to true if we think the estimate is useful.
<span class="lineNum">     266 </span>            :   virtual double GetDownloadRate(bool* aIsReliable) = 0;
<span class="lineNum">     267 </span>            :   // Get the length of the stream in bytes. Returns -1 if not known.
<span class="lineNum">     268 </span>            :   // This can change over time; after a seek operation, a misbehaving
<span class="lineNum">     269 </span>            :   // server may give us a resource of a different length to what it had
<span class="lineNum">     270 </span>            :   // reported previously --- or it may just lie in its Content-Length
<span class="lineNum">     271 </span>            :   // header and give us more or less data than it reported. We will adjust
<span class="lineNum">     272 </span>            :   // the result of GetLength to reflect the data that's actually arriving.
<span class="lineNum">     273 </span>            :   virtual int64_t GetLength() = 0;
<span class="lineNum">     274 </span>            :   // Returns the offset of the first byte of cached data at or after aOffset,
<span class="lineNum">     275 </span>            :   // or -1 if there is no such cached data.
<span class="lineNum">     276 </span>            :   virtual int64_t GetNextCachedData(int64_t aOffset) = 0;
<span class="lineNum">     277 </span>            :   // Returns the end of the bytes starting at the given offset
<span class="lineNum">     278 </span>            :   // which are in cache.
<span class="lineNum">     279 </span>            :   virtual int64_t GetCachedDataEnd(int64_t aOffset) = 0;
<span class="lineNum">     280 </span>            :   // Returns true if all the data from aOffset to the end of the stream
<span class="lineNum">     281 </span>            :   // is in cache. If the end of the stream is not known, we return false.
<span class="lineNum">     282 </span>            :   virtual bool IsDataCachedToEndOfResource(int64_t aOffset) = 0;
<span class="lineNum">     283 </span>            :   // Returns true if we are expecting any more data to arrive
<span class="lineNum">     284 </span>            :   // sometime in the not-too-distant future, either from the network or from
<span class="lineNum">     285 </span>            :   // an appendBuffer call on a MediaSource element.
<span class="lineNum">     286 </span>            :   virtual bool IsExpectingMoreData()
<span class="lineNum">     287 </span>            :   {
<span class="lineNum">     288 </span>            :     // MediaDecoder::mDecoderPosition is roughly the same as Tell() which
<span class="lineNum">     289 </span>            :     // returns a position updated by latest Read() or ReadAt().
<span class="lineNum">     290 </span>            :     return !IsDataCachedToEndOfResource(Tell()) &amp;&amp; !IsSuspended();
<span class="lineNum">     291 </span>            :   }
<span class="lineNum">     292 </span>            :   // Returns true if this stream is suspended by the cache because the
<span class="lineNum">     293 </span>            :   // cache is full. If true then the decoder should try to start consuming
<span class="lineNum">     294 </span>            :   // data, otherwise we may not be able to make progress.
<span class="lineNum">     295 </span>            :   // MediaDecoder::NotifySuspendedStatusChanged is called when this
<span class="lineNum">     296 </span>            :   // changes.
<span class="lineNum">     297 </span>            :   // For resources using the media cache, this returns true only when all
<span class="lineNum">     298 </span>            :   // streams for the same resource are all suspended.
<span class="lineNum">     299 </span>            :   virtual bool IsSuspendedByCache() = 0;
<span class="lineNum">     300 </span>            :   // Returns true if this stream has been suspended.
<span class="lineNum">     301 </span>            :   virtual bool IsSuspended() = 0;
<span class="lineNum">     302 </span>            :   // Reads only data which is cached in the media cache. If you try to read
<span class="lineNum">     303 </span>            :   // any data which overlaps uncached data, or if aCount bytes otherwise can't
<span class="lineNum">     304 </span>            :   // be read, this function will return failure. This function be called from
<span class="lineNum">     305 </span>            :   // any thread, and it is the only read operation which is safe to call on
<span class="lineNum">     306 </span>            :   // the main thread, since it's guaranteed to be non blocking.
<span class="lineNum">     307 </span>            :   virtual nsresult ReadFromCache(char* aBuffer,
<span class="lineNum">     308 </span>            :                                  int64_t aOffset,
<span class="lineNum">     309 </span>            :                                  uint32_t aCount) = 0;
<span class="lineNum">     310 </span>            :   // Returns true if the resource can be seeked to unbuffered ranges, i.e.
<span class="lineNum">     311 </span>            :   // for an HTTP network stream this returns true if HTTP1.1 Byte Range
<span class="lineNum">     312 </span>            :   // requests are supported by the connection/server.
<span class="lineNum">     313 </span>            :   virtual bool IsTransportSeekable() = 0;
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :   /**
<span class="lineNum">     316 </span>            :    * Create a resource, reading data from the channel. Call on main thread only.
<span class="lineNum">     317 </span>            :    * The caller must follow up by calling resource-&gt;Open().
<span class="lineNum">     318 </span>            :    */
<span class="lineNum">     319 </span>            :   static already_AddRefed&lt;MediaResource&gt;
<span class="lineNum">     320 </span>            :   Create(MediaResourceCallback* aCallback,
<span class="lineNum">     321 </span>            :          nsIChannel* aChannel, bool aIsPrivateBrowsing);
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   /**
<span class="lineNum">     324 </span>            :    * Open the stream. This creates a stream listener and returns it in
<span class="lineNum">     325 </span>            :    * aStreamListener; this listener needs to be notified of incoming data.
<span class="lineNum">     326 </span>            :    */
<span class="lineNum">     327 </span>            :   virtual nsresult Open(nsIStreamListener** aStreamListener) = 0;
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   /**
<span class="lineNum">     330 </span>            :    * Fills aRanges with MediaByteRanges representing the data which is cached
<span class="lineNum">     331 </span>            :    * in the media cache. Stream should be pinned during call and while
<span class="lineNum">     332 </span>            :    * aRanges is being used.
<span class="lineNum">     333 </span>            :    */
<span class="lineNum">     334 </span>            :   virtual nsresult GetCachedRanges(MediaByteRangeSet&amp; aRanges) = 0;
<span class="lineNum">     335 </span>            : 
<a name="336"><span class="lineNum">     336 </span>            :   // Ensure that the media cache writes any data held in its partial block.</a>
<span class="lineNum">     337 </span>            :   // Called on the main thread only.
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   virtual void FlushCache() { }</span>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<span class="lineNum">     340 </span>            :   // Notify that the last data byte range was loaded.
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   virtual void NotifyLastByteRange() { }</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   // Returns the container content type of the resource. This is copied from the
<span class="lineNum">     344 </span>            :   // nsIChannel when the MediaResource is created. Safe to call from
<span class="lineNum">     345 </span>            :   // any thread.
<span class="lineNum">     346 </span>            :   virtual const MediaContainerType&amp; GetContentType() const = 0;
<a name="347"><span class="lineNum">     347 </span>            : </a>
<span class="lineNum">     348 </span>            :   // Return true if the stream is a live stream
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   virtual bool IsRealTime() {</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     351 </span>            :   }
<a name="352"><span class="lineNum">     352 </span>            : </a>
<span class="lineNum">     353 </span>            :   // Returns true if the resource is a live stream.
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   virtual bool IsLiveStream()</span>
<span class="lineNum">     355 </span>            :   {
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     return GetLength() == -1;</span>
<a name="357"><span class="lineNum">     357 </span>            :   }</a>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   virtual size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     361 </span>            :   }
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :   virtual size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const {
<span class="lineNum">     364 </span>            :     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
<span class="lineNum">     365 </span>            :   }
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   const nsCString&amp; GetContentURL() const { return EmptyCString(); }
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : protected:
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   virtual ~MediaResource() {};</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : private:
<span class="lineNum">     373 </span>            :   void Destroy();
<span class="lineNum">     374 </span>            : };
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : class BaseMediaResource : public MediaResource {
<span class="lineNum">     377 </span>            : public:
<span class="lineNum">     378 </span>            :   nsIURI* URI() const override { return mURI; }
<a name="379"><span class="lineNum">     379 </span>            :   void SetLoadInBackground(bool aLoadInBackground) override;</a>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const override</span>
<span class="lineNum">     382 </span>            :   {
<span class="lineNum">     383 </span>            :     // Might be useful to track in the future:
<span class="lineNum">     384 </span>            :     // - mChannel
<span class="lineNum">     385 </span>            :     // - mURI (possibly owned, looks like just a ref from mChannel)
<a name="386"><span class="lineNum">     386 </span>            :     // Not owned:</a>
<span class="lineNum">     387 </span>            :     // - mCallback
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     size_t size = MediaResource::SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     size += mContainerType.SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     return size;</span>
<span class="lineNum">     392 </span>            :   }
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const override
<span class="lineNum">     395 </span>            :   {
<span class="lineNum">     396 </span>            :     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
<span class="lineNum">     397 </span>            :   }
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   // Returns the url of the resource. Safe to call from any thread?
<span class="lineNum">     400 </span>            :   const nsCString&amp; GetContentURL() const
<span class="lineNum">     401 </span>            :   {
<span class="lineNum">     402 </span>            :     return mContentURL;
<span class="lineNum">     403 </span>            :   }
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : protected:
<span class="lineNum">     406 </span>            :   BaseMediaResource(MediaResourceCallback* aCallback,
<span class="lineNum">     407 </span>            :                     nsIChannel* aChannel,
<span class="lineNum">     408 </span>            :                     nsIURI* aURI,
<span class="lineNum">     409 </span>            :                     const MediaContainerType&amp; aContainerType) :
<span class="lineNum">     410 </span>            :     mCallback(aCallback),
<span class="lineNum">     411 </span>            :     mChannel(aChannel),
<span class="lineNum">     412 </span>            :     mURI(aURI),
<span class="lineNum">     413 </span>            :     mContainerType(aContainerType),
<span class="lineNum">     414 </span>            :     mLoadInBackground(false)
<span class="lineNum">     415 </span>            :   {
<span class="lineNum">     416 </span>            :     mURI-&gt;GetSpec(mContentURL);
<span class="lineNum">     417 </span>            :   }
<span class="lineNum">     418 </span>            :   virtual ~BaseMediaResource()
<span class="lineNum">     419 </span>            :   {
<span class="lineNum">     420 </span>            :   }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   const MediaContainerType&amp; GetContentType() const override
<span class="lineNum">     423 </span>            :   {
<span class="lineNum">     424 </span>            :     return mContainerType;
<span class="lineNum">     425 </span>            :   }
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   // Set the request's load flags to aFlags.  If the request is part of a
<span class="lineNum">     428 </span>            :   // load group, the request is removed from the group, the flags are set, and
<span class="lineNum">     429 </span>            :   // then the request is added back to the load group.
<span class="lineNum">     430 </span>            :   void ModifyLoadFlags(nsLoadFlags aFlags);
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :   // Dispatches an event to call MediaDecoder::NotifyBytesConsumed(aNumBytes, aOffset)
<span class="lineNum">     433 </span>            :   // on the main thread. This is called automatically after every read.
<span class="lineNum">     434 </span>            :   void DispatchBytesConsumed(int64_t aNumBytes, int64_t aOffset);
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   RefPtr&lt;MediaResourceCallback&gt; mCallback;
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :   // Channel used to download the media data. Must be accessed
<span class="lineNum">     439 </span>            :   // from the main thread only.
<span class="lineNum">     440 </span>            :   nsCOMPtr&lt;nsIChannel&gt; mChannel;
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :   // URI in case the stream needs to be re-opened. Access from
<span class="lineNum">     443 </span>            :   // main thread only.
<span class="lineNum">     444 </span>            :   nsCOMPtr&lt;nsIURI&gt; mURI;
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :   // Content-Type of the channel. This is copied from the nsIChannel when the
<span class="lineNum">     447 </span>            :   // MediaResource is created. This is constant, so accessing from any thread
<span class="lineNum">     448 </span>            :   // is safe.
<span class="lineNum">     449 </span>            :   const MediaContainerType mContainerType;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :   // Copy of the url of the channel resource.
<span class="lineNum">     452 </span>            :   nsCString mContentURL;
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   // True if SetLoadInBackground() has been called with
<span class="lineNum">     455 </span>            :   // aLoadInBackground = true, i.e. when the document load event is not
<span class="lineNum">     456 </span>            :   // blocked by this resource, and all channel loads will be in the
<span class="lineNum">     457 </span>            :   // background.
<span class="lineNum">     458 </span>            :   bool mLoadInBackground;
<span class="lineNum">     459 </span>            : };
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : /**
<span class="lineNum">     463 </span>            :  * This class is responsible for managing the suspend count and report suspend
<span class="lineNum">     464 </span>            :  * status of channel.
<span class="lineNum">     465 </span>            :  **/
<span class="lineNum">     466 </span>            : class ChannelSuspendAgent {
<span class="lineNum">     467 </span>            : public:
<span class="lineNum">     468 </span>            :   explicit ChannelSuspendAgent(nsIChannel* aChannel)
<span class="lineNum">     469 </span>            :   : mChannel(aChannel),
<span class="lineNum">     470 </span>            :     mSuspendCount(0),
<span class="lineNum">     471 </span>            :     mIsChannelSuspended(false)
<span class="lineNum">     472 </span>            :   {}
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :   // True when the channel has been suspended or needs to be suspended.
<span class="lineNum">     475 </span>            :   bool IsSuspended();
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   // Return true when the channel is logically suspended, i.e. the suspend
<span class="lineNum">     478 </span>            :   // count goes from 0 to 1.
<span class="lineNum">     479 </span>            :   bool Suspend();
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :   // Return true only when the suspend count is equal to zero.
<span class="lineNum">     482 </span>            :   bool Resume();
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   // Call after opening channel, set channel and check whether the channel
<span class="lineNum">     485 </span>            :   // needs to be suspended.
<span class="lineNum">     486 </span>            :   void NotifyChannelOpened(nsIChannel* aChannel);
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :   // Call before closing channel, reset the channel internal status if needed.
<span class="lineNum">     489 </span>            :   void NotifyChannelClosing();
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // Check whether we need to suspend the channel.
<span class="lineNum">     492 </span>            :   void UpdateSuspendedStatusIfNeeded();
<span class="lineNum">     493 </span>            : private:
<span class="lineNum">     494 </span>            :   // Only suspends channel but not changes the suspend count.
<span class="lineNum">     495 </span>            :   void SuspendInternal();
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   nsIChannel* mChannel;
<span class="lineNum">     498 </span>            :   Atomic&lt;uint32_t&gt; mSuspendCount;
<span class="lineNum">     499 </span>            :   bool mIsChannelSuspended;
<span class="lineNum">     500 </span>            : };
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : /**
<span class="lineNum">     503 </span>            :  * This is the MediaResource implementation that wraps Necko channels.
<span class="lineNum">     504 </span>            :  * Much of its functionality is actually delegated to MediaCache via
<span class="lineNum">     505 </span>            :  * an underlying MediaCacheStream.
<span class="lineNum">     506 </span>            :  *
<span class="lineNum">     507 </span>            :  * All synchronization is performed by MediaCacheStream; all off-main-
<span class="lineNum">     508 </span>            :  * thread operations are delegated directly to that object.
<span class="lineNum">     509 </span>            :  */
<span class="lineNum">     510 </span>            : class ChannelMediaResource : public BaseMediaResource
<span class="lineNum">     511 </span>            : {
<span class="lineNum">     512 </span>            : public:
<span class="lineNum">     513 </span>            :   ChannelMediaResource(MediaResourceCallback* aDecoder,
<span class="lineNum">     514 </span>            :                        nsIChannel* aChannel,
<span class="lineNum">     515 </span>            :                        nsIURI* aURI,
<span class="lineNum">     516 </span>            :                        const MediaContainerType&amp; aContainerType,
<span class="lineNum">     517 </span>            :                        bool aIsPrivateBrowsing = false);
<span class="lineNum">     518 </span>            :   ~ChannelMediaResource();
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :   // These are called on the main thread by MediaCache. These must
<span class="lineNum">     521 </span>            :   // not block or grab locks, because the media cache is holding its lock.
<span class="lineNum">     522 </span>            :   // Notify that data is available from the cache. This can happen even
<span class="lineNum">     523 </span>            :   // if this stream didn't read any data, since another stream might have
<span class="lineNum">     524 </span>            :   // received data for the same resource.
<span class="lineNum">     525 </span>            :   void CacheClientNotifyDataReceived();
<span class="lineNum">     526 </span>            :   // Notify that we reached the end of the stream. This can happen even
<span class="lineNum">     527 </span>            :   // if this stream didn't read any data, since another stream might have
<span class="lineNum">     528 </span>            :   // received data for the same resource.
<span class="lineNum">     529 </span>            :   void CacheClientNotifyDataEnded(nsresult aStatus);
<span class="lineNum">     530 </span>            :   // Notify that the principal for the cached resource changed.
<span class="lineNum">     531 </span>            :   void CacheClientNotifyPrincipalChanged();
<span class="lineNum">     532 </span>            :   // Notify the decoder that the cache suspended status changed.
<span class="lineNum">     533 </span>            :   void CacheClientNotifySuspendedStatusChanged();
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :   // These are called on the main thread by MediaCache. These shouldn't block,
<span class="lineNum">     536 </span>            :   // but they may grab locks --- the media cache is not holding its lock
<span class="lineNum">     537 </span>            :   // when these are called.
<span class="lineNum">     538 </span>            :   // Start a new load at the given aOffset. The old load is cancelled
<span class="lineNum">     539 </span>            :   // and no more data from the old load will be notified via
<span class="lineNum">     540 </span>            :   // MediaCacheStream::NotifyDataReceived/Ended.
<span class="lineNum">     541 </span>            :   // This can fail.
<span class="lineNum">     542 </span>            :   nsresult CacheClientSeek(int64_t aOffset, bool aResume);
<span class="lineNum">     543 </span>            :   // Suspend the current load since data is currently not wanted
<span class="lineNum">     544 </span>            :   nsresult CacheClientSuspend();
<span class="lineNum">     545 </span>            :   // Resume the current load since data is wanted again
<span class="lineNum">     546 </span>            :   nsresult CacheClientResume();
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :   // Ensure that the media cache writes any data held in its partial block.
<span class="lineNum">     549 </span>            :   // Called on the main thread.
<span class="lineNum">     550 </span>            :   void FlushCache() override;
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :   // Notify that the last data byte range was loaded.
<span class="lineNum">     553 </span>            :   void NotifyLastByteRange() override;
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            :   // Main thread
<span class="lineNum">     556 </span>            :   nsresult Open(nsIStreamListener** aStreamListener) override;
<span class="lineNum">     557 </span>            :   nsresult Close() override;
<span class="lineNum">     558 </span>            :   void     Suspend(bool aCloseImmediately) override;
<span class="lineNum">     559 </span>            :   void     Resume() override;
<span class="lineNum">     560 </span>            :   already_AddRefed&lt;nsIPrincipal&gt; GetCurrentPrincipal() override;
<span class="lineNum">     561 </span>            :   // Return true if the stream has been closed.
<span class="lineNum">     562 </span>            :   bool     IsClosed() const { return mCacheStream.IsClosed(); }
<span class="lineNum">     563 </span>            :   bool     CanClone() override;
<span class="lineNum">     564 </span>            :   already_AddRefed&lt;MediaResource&gt; CloneData(MediaResourceCallback* aDecoder) override;
<span class="lineNum">     565 </span>            :   // Set statistics to be recorded to the object passed in. If not called,
<span class="lineNum">     566 </span>            :   // |ChannelMediaResource| will create it's own statistics objects in |Open|.
<span class="lineNum">     567 </span>            :   void RecordStatisticsTo(MediaChannelStatistics *aStatistics) override {
<span class="lineNum">     568 </span>            :     NS_ASSERTION(aStatistics, &quot;Statistics param cannot be null!&quot;);
<span class="lineNum">     569 </span>            :     MutexAutoLock lock(mLock);
<span class="lineNum">     570 </span>            :     if (!mChannelStatistics) {
<span class="lineNum">     571 </span>            :       mChannelStatistics = aStatistics;
<span class="lineNum">     572 </span>            :     }
<span class="lineNum">     573 </span>            :   }
<span class="lineNum">     574 </span>            :   nsresult ReadFromCache(char* aBuffer, int64_t aOffset, uint32_t aCount) override;
<span class="lineNum">     575 </span>            :   void     EnsureCacheUpToDate() override;
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :   // Other thread
<span class="lineNum">     578 </span>            :   void     SetReadMode(MediaCacheStream::ReadMode aMode) override;
<span class="lineNum">     579 </span>            :   void     SetPlaybackRate(uint32_t aBytesPerSecond) override;
<span class="lineNum">     580 </span>            :   nsresult ReadAt(int64_t offset, char* aBuffer,
<span class="lineNum">     581 </span>            :                   uint32_t aCount, uint32_t* aBytes) override;
<span class="lineNum">     582 </span>            :   already_AddRefed&lt;MediaByteBuffer&gt; MediaReadAt(int64_t aOffset, uint32_t aCount) override;
<span class="lineNum">     583 </span>            :   int64_t Tell() override;
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :   // Any thread
<span class="lineNum">     586 </span>            :   void    Pin() override;
<span class="lineNum">     587 </span>            :   void    Unpin() override;
<span class="lineNum">     588 </span>            :   double  GetDownloadRate(bool* aIsReliable) override;
<span class="lineNum">     589 </span>            :   int64_t GetLength() override;
<span class="lineNum">     590 </span>            :   int64_t GetNextCachedData(int64_t aOffset) override;
<span class="lineNum">     591 </span>            :   int64_t GetCachedDataEnd(int64_t aOffset) override;
<span class="lineNum">     592 </span>            :   bool    IsDataCachedToEndOfResource(int64_t aOffset) override;
<span class="lineNum">     593 </span>            :   bool    IsSuspendedByCache() override;
<span class="lineNum">     594 </span>            :   bool    IsSuspended() override;
<span class="lineNum">     595 </span>            :   bool    IsTransportSeekable() override;
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const override {</span>
<span class="lineNum">     598 </span>            :     // Might be useful to track in the future:
<span class="lineNum">     599 </span>            :     //   - mListener (seems minor)
<span class="lineNum">     600 </span>            :     //   - mChannelStatistics (seems minor)
<span class="lineNum">     601 </span>            :     //     owned if RecordStatisticsTo is not called
<span class="lineNum">     602 </span>            :     //   - mDataReceivedEvent (seems minor)
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     size_t size = BaseMediaResource::SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     size += mCacheStream.SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     return size;</span>
<span class="lineNum">     607 </span>            :   }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :   size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const override {
<span class="lineNum">     610 </span>            :     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
<span class="lineNum">     611 </span>            :   }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :   class Listener final : public nsIStreamListener,
<span class="lineNum">     614 </span>            :                          public nsIInterfaceRequestor,
<span class="lineNum">     615 </span>            :                          public nsIChannelEventSink
<span class="lineNum">     616 </span>            :   {
<span class="lineNum">     617 </span>            :     ~Listener() {}
<span class="lineNum">     618 </span>            :   public:
<span class="lineNum">     619 </span>            :     explicit Listener(ChannelMediaResource* aResource) : mResource(aResource) {}
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :     NS_DECL_ISUPPORTS
<span class="lineNum">     622 </span>            :     NS_DECL_NSIREQUESTOBSERVER
<span class="lineNum">     623 </span>            :     NS_DECL_NSISTREAMLISTENER
<span class="lineNum">     624 </span>            :     NS_DECL_NSICHANNELEVENTSINK
<span class="lineNum">     625 </span>            :     NS_DECL_NSIINTERFACEREQUESTOR
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :     void Revoke() { mResource = nullptr; }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :   private:
<span class="lineNum">     630 </span>            :     RefPtr&lt;ChannelMediaResource&gt; mResource;
<span class="lineNum">     631 </span>            :   };
<span class="lineNum">     632 </span>            :   friend class Listener;
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   nsresult GetCachedRanges(MediaByteRangeSet&amp; aRanges) override;
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : protected:
<span class="lineNum">     637 </span>            :   // These are called on the main thread by Listener.
<span class="lineNum">     638 </span>            :   nsresult OnStartRequest(nsIRequest* aRequest);
<span class="lineNum">     639 </span>            :   nsresult OnStopRequest(nsIRequest* aRequest, nsresult aStatus);
<span class="lineNum">     640 </span>            :   nsresult OnDataAvailable(nsIRequest* aRequest,
<span class="lineNum">     641 </span>            :                            nsIInputStream* aStream,
<span class="lineNum">     642 </span>            :                            uint32_t aCount);
<span class="lineNum">     643 </span>            :   nsresult OnChannelRedirect(nsIChannel* aOld, nsIChannel* aNew, uint32_t aFlags);
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :   // Opens the channel, using an HTTP byte range request to start at mOffset
<span class="lineNum">     646 </span>            :   // if possible. Main thread only.
<span class="lineNum">     647 </span>            :   nsresult OpenChannel(nsIStreamListener** aStreamListener);
<span class="lineNum">     648 </span>            :   nsresult RecreateChannel();
<span class="lineNum">     649 </span>            :   // Add headers to HTTP request. Main thread only.
<span class="lineNum">     650 </span>            :   nsresult SetupChannelHeaders();
<span class="lineNum">     651 </span>            :   // Closes the channel. Main thread only.
<span class="lineNum">     652 </span>            :   void CloseChannel();
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :   // Parses 'Content-Range' header and returns results via parameters.
<span class="lineNum">     655 </span>            :   // Returns error if header is not available, values are not parse-able or
<span class="lineNum">     656 </span>            :   // values are out of range.
<span class="lineNum">     657 </span>            :   nsresult ParseContentRangeHeader(nsIHttpChannel * aHttpChan,
<span class="lineNum">     658 </span>            :                                    int64_t&amp; aRangeStart,
<span class="lineNum">     659 </span>            :                                    int64_t&amp; aRangeEnd,
<span class="lineNum">     660 </span>            :                                    int64_t&amp; aRangeTotal);
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   void DoNotifyDataReceived();
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :   static nsresult CopySegmentToCache(nsIInputStream* aInStream,
<span class="lineNum">     665 </span>            :                                      void* aClosure,
<span class="lineNum">     666 </span>            :                                      const char* aFromSegment,
<span class="lineNum">     667 </span>            :                                      uint32_t aToOffset,
<span class="lineNum">     668 </span>            :                                      uint32_t aCount,
<span class="lineNum">     669 </span>            :                                      uint32_t* aWriteCount);
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :   nsresult CopySegmentToCache(nsIPrincipal* aPrincipal,
<span class="lineNum">     672 </span>            :                               const char* aFromSegment,
<span class="lineNum">     673 </span>            :                               uint32_t aCount,
<span class="lineNum">     674 </span>            :                               uint32_t* aWriteCount);
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :   // Main thread access only
<span class="lineNum">     677 </span>            :   int64_t            mOffset;
<span class="lineNum">     678 </span>            :   RefPtr&lt;Listener&gt; mListener;
<span class="lineNum">     679 </span>            :   // A data received event for the decoder that has been dispatched but has
<span class="lineNum">     680 </span>            :   // not yet been processed.
<span class="lineNum">     681 </span>            :   nsRevocableEventPtr&lt;nsRunnableMethod&lt;ChannelMediaResource, void, false&gt; &gt; mDataReceivedEvent;
<span class="lineNum">     682 </span>            :   // When this flag is set, if we get a network error we should silently
<span class="lineNum">     683 </span>            :   // reopen the stream.
<span class="lineNum">     684 </span>            :   bool               mReopenOnError;
<span class="lineNum">     685 </span>            :   // When this flag is set, we should not report the next close of the
<span class="lineNum">     686 </span>            :   // channel.
<span class="lineNum">     687 </span>            :   bool               mIgnoreClose;
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :   // Any thread access
<span class="lineNum">     690 </span>            :   MediaCacheStream mCacheStream;
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :   // This lock protects mChannelStatistics
<span class="lineNum">     693 </span>            :   Mutex               mLock;
<span class="lineNum">     694 </span>            :   RefPtr&lt;MediaChannelStatistics&gt; mChannelStatistics;
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :   // True if we couldn't suspend the stream and we therefore don't want
<span class="lineNum">     697 </span>            :   // to resume later. This is usually due to the channel not being in the
<span class="lineNum">     698 </span>            :   // isPending state at the time of the suspend request.
<span class="lineNum">     699 </span>            :   bool mIgnoreResume;
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :   ChannelSuspendAgent mSuspendAgent;
<span class="lineNum">     702 </span>            : };
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : /**
<span class="lineNum">     705 </span>            :  * RAII class that handles pinning and unpinning for MediaResource and derived.
<span class="lineNum">     706 </span>            :  * This should be used when making calculations that involve potentially-cached
<span class="lineNum">     707 </span>            :  * MediaResource data, so that the state of the world can't change out from under
<span class="lineNum">     708 </span>            :  * us.
<span class="lineNum">     709 </span>            :  */
<span class="lineNum">     710 </span>            : template&lt;class T&gt;
<a name="711"><span class="lineNum">     711 </span>            : class MOZ_RAII AutoPinned {</a>
<span class="lineNum">     712 </span>            :  public:
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   explicit AutoPinned(T* aResource MOZ_GUARD_OBJECT_NOTIFIER_PARAM) : mResource(aResource) {</span>
<span class="lineNum">     714 </span>            :     MOZ_GUARD_OBJECT_NOTIFIER_INIT;
<span class="lineNum">     715 </span>            :     MOZ_ASSERT(mResource);
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     mResource-&gt;Pin();</span>
<a name="717"><span class="lineNum">     717 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   ~AutoPinned() {</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     mResource-&gt;Unpin();</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   operator T*() const { return mResource; }</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   T* operator-&gt;() const MOZ_NO_ADDREF_RELEASE_ON_RETURN { return mResource; }</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : private:
<span class="lineNum">     727 </span>            :   T* mResource;
<span class="lineNum">     728 </span>            :   MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">     729 </span>            : };
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            : /*
<span class="lineNum">     732 </span>            :  * MediaResourceIndex provides a way to access MediaResource objects.
<span class="lineNum">     733 </span>            :  * Read, Seek and Tell must only be called on non-main threads.
<span class="lineNum">     734 </span>            :  * In the case of the Ogg Decoder they are called on the Decode thread for
<span class="lineNum">     735 </span>            :  * example. You must ensure that no threads are calling these methods once
<span class="lineNum">     736 </span>            :  * the MediaResource has been Closed.
<a name="737"><span class="lineNum">     737 </span>            :  */</a>
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineNoCov">          0 : class MediaResourceIndex</span>
<a name="740"><span class="lineNum">     740 </span>            : {</a>
<span class="lineNum">     741 </span>            : public:
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   explicit MediaResourceIndex(MediaResource* aResource)</span>
<span class="lineNum">     743 </span>            :     : mResource(aResource)
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     , mOffset(0)</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   {}</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :   // Read up to aCount bytes from the stream. The buffer must have
<span class="lineNum">     748 </span>            :   // enough room for at least aCount bytes. Stores the number of
<span class="lineNum">     749 </span>            :   // actual bytes read in aBytes (0 on end of file).
<span class="lineNum">     750 </span>            :   // May read less than aCount bytes if the number of
<span class="lineNum">     751 </span>            :   // available bytes is less than aCount. Always check *aBytes after
<span class="lineNum">     752 </span>            :   // read, and call again if necessary.
<span class="lineNum">     753 </span>            :   nsresult Read(char* aBuffer, uint32_t aCount, uint32_t* aBytes);
<span class="lineNum">     754 </span>            :   // Seek to the given bytes offset in the stream. aWhence can be
<span class="lineNum">     755 </span>            :   // one of:
<span class="lineNum">     756 </span>            :   //   NS_SEEK_SET
<span class="lineNum">     757 </span>            :   //   NS_SEEK_CUR
<span class="lineNum">     758 </span>            :   //   NS_SEEK_END
<span class="lineNum">     759 </span>            :   //
<span class="lineNum">     760 </span>            :   // In the Http strategy case the cancel will cause the http
<span class="lineNum">     761 </span>            :   // channel's listener to close the pipe, forcing an i/o error on any
<span class="lineNum">     762 </span>            :   // blocked read. This will allow the decode thread to complete the
<span class="lineNum">     763 </span>            :   // event.
<span class="lineNum">     764 </span>            :   //
<span class="lineNum">     765 </span>            :   // In the case of a seek in progress, the byte range request creates
<span class="lineNum">     766 </span>            :   // a new listener. This is done on the main thread via seek
<span class="lineNum">     767 </span>            :   // synchronously dispatching an event. This avoids the issue of us
<span class="lineNum">     768 </span>            :   // closing the listener but an outstanding byte range request
<span class="lineNum">     769 </span>            :   // creating a new one. They run on the same thread so no explicit
<span class="lineNum">     770 </span>            :   // synchronisation is required. The byte range request checks for
<span class="lineNum">     771 </span>            :   // the cancel flag and does not create a new channel or listener if
<span class="lineNum">     772 </span>            :   // we are cancelling.
<span class="lineNum">     773 </span>            :   //
<span class="lineNum">     774 </span>            :   // The default strategy does not do any seeking - the only issue is
<span class="lineNum">     775 </span>            :   // a blocked read which it handles by causing the listener to close
<span class="lineNum">     776 </span>            :   // the pipe, as per the http case.
<span class="lineNum">     777 </span>            :   //
<span class="lineNum">     778 </span>            :   // The file strategy doesn't block for any great length of time so
<span class="lineNum">     779 </span>            :   // is fine for a no-op cancel.
<span class="lineNum">     780 </span>            :   nsresult Seek(int32_t aWhence, int64_t aOffset);
<span class="lineNum">     781 </span>            :   // Report the current offset in bytes from the start of the stream.
<span class="lineNum">     782 </span>            :   int64_t Tell() const { return mOffset; }
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :   // Return the underlying MediaResource.
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   MediaResource* GetResource() const { return mResource; }</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :   // Read up to aCount bytes from the stream. The read starts at
<span class="lineNum">     788 </span>            :   // aOffset in the stream, seeking to that location initially if
<span class="lineNum">     789 </span>            :   // it is not the current stream offset.
<span class="lineNum">     790 </span>            :   // Unlike MediaResource::ReadAt, ReadAt only returns fewer bytes than
<span class="lineNum">     791 </span>            :   // requested if end of stream or an error is encountered. There is no need to
<span class="lineNum">     792 </span>            :   // call it again to get more data.
<span class="lineNum">     793 </span>            :   // *aBytes will contain the number of bytes copied, even if an error occurred.
<span class="lineNum">     794 </span>            :   // ReadAt doesn't have an impact on the offset returned by Tell().
<span class="lineNum">     795 </span>            :   nsresult ReadAt(int64_t aOffset, char* aBuffer,
<span class="lineNum">     796 </span>            :                   uint32_t aCount, uint32_t* aBytes) const;
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :   // Convenience methods, directly calling the MediaResource method of the same
<span class="lineNum">     799 </span>            :   // name.
<span class="lineNum">     800 </span>            :   // Those functions do not update the MediaResource offset as returned
<span class="lineNum">     801 </span>            :   // by Tell().
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :   // This method returns nullptr if anything fails.
<span class="lineNum">     804 </span>            :   // Otherwise, it returns an owned buffer.
<a name="805"><span class="lineNum">     805 </span>            :   // MediaReadAt may return fewer bytes than requested if end of stream is</a>
<span class="lineNum">     806 </span>            :   // encountered. There is no need to call it again to get more data.
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   already_AddRefed&lt;MediaByteBuffer&gt; MediaReadAt(int64_t aOffset, uint32_t aCount) const</span>
<span class="lineNum">     808 </span>            :   {
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     return mResource-&gt;MediaReadAt(aOffset, aCount);</span>
<span class="lineNum">     810 </span>            :   }
<span class="lineNum">     811 </span>            :   // Get the length of the stream in bytes. Returns -1 if not known.
<span class="lineNum">     812 </span>            :   // This can change over time; after a seek operation, a misbehaving
<span class="lineNum">     813 </span>            :   // server may give us a resource of a different length to what it had
<span class="lineNum">     814 </span>            :   // reported previously --- or it may just lie in its Content-Length
<a name="815"><span class="lineNum">     815 </span>            :   // header and give us more or less data than it reported. We will adjust</a>
<span class="lineNum">     816 </span>            :   // the result of GetLength to reflect the data that's actually arriving.
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   int64_t GetLength() const { return mResource-&gt;GetLength(); }</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            : private:
<span class="lineNum">     820 </span>            :   RefPtr&lt;MediaResource&gt; mResource;
<span class="lineNum">     821 </span>            :   int64_t mOffset;
<span class="lineNum">     822 </span>            : };
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : } // namespace mozilla
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
